/*
 * GoJS v2.1.37 JavaScript Library for HTML Diagrams, https://gojs.net
 * GoJS and Northwoods Software are registered trademarks of Northwoods Software Corporation, https://www.nwoods.com.
 * Copyright (C) 1998-2021 by Northwoods Software Corporation.  All Rights Reserved.
 * THIS SOFTWARE IS LICENSED.  THE LICENSE AGREEMENT IS AT: https://gojs.net/2.1.37/license.html.
 * DO NOT MODIFY THIS FILE.  DO NOT DISTRIBUTE A MODIFIED COPY OF THE CONTENTS OF THIS FILE.
 */
(function () {
    var t;

    function aa(a) {
        var b = 0;
        return function () {
            return b < a.length ? {done: !1, value: a[b++]} : {done: !0}
        }
    }

    function ba(a) {
        var b = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
        return b ? b.call(a) : {next: aa(a)}
    }

    function ca(a) {
        for (var b, c = []; !(b = a.next()).done;) c.push(b.value);
        return c
    }

    var da = "function" == typeof Object.create ? Object.create : function (a) {
        function b() {
        }

        b.prototype = a;
        return new b
    }, ea;
    if ("function" == typeof Object.setPrototypeOf) ea = Object.setPrototypeOf; else {
        var ha;
        a:{
            var ia = {a: !0}, ja = {};
            try {
                ja.__proto__ = ia;
                ha = ja.a;
                break a
            } catch (a) {
            }
            ha = !1
        }
        ea = ha ? function (a, b) {
            a.__proto__ = b;
            if (a.__proto__ !== b) throw new TypeError(a + " is not extensible");
            return a
        } : null
    }
    var la = ea;

    function ma(a, b) {
        a.prototype = da(b.prototype);
        a.prototype.constructor = a;
        if (la) la(a, b); else for (var c in b) if ("prototype" != c) if (Object.defineProperties) {
            var d = Object.getOwnPropertyDescriptor(b, c);
            d && Object.defineProperty(a, c, d)
        } else a[c] = b[c];
        a.MB = b.prototype
    }

    var na = "undefined" != typeof window && window === self ? self : "undefined" != typeof global && null != global ? global : self,
        oa = "function" == typeof Object.defineProperties ? Object.defineProperty : function (a, b, c) {
            a != Array.prototype && a != Object.prototype && (a[b] = c.value)
        };

    function pa(a) {
        if (a) {
            for (var b = na, c = ["Array", "prototype", "fill"], d = 0; d < c.length - 1; d++) {
                var e = c[d];
                e in b || (b[e] = {});
                b = b[e]
            }
            c = c[c.length - 1];
            d = b[c];
            a = a(d);
            a != d && null != a && oa(b, c, {configurable: !0, writable: !0, value: a})
        }
    }

    pa(function (a) {
        return a ? a : function (a, c, d) {
            var b = this.length || 0;
            0 > c && (c = Math.max(0, b + c));
            if (null == d || d > b) d = b;
            d = Number(d);
            0 > d && (d = Math.max(0, b + d));
            for (c = Number(c || 0); c < d; c++) this[c] = a;
            return this
        }
    });
    var qa = "object" === typeof self && self.self === self && self || "object" === typeof global && global.global === global && global || "object" === typeof window && window.window === window && window || {};
    void 0 === qa.requestAnimationFrame && (void 0 === qa.setImmediate ? qa.requestAnimationFrame = function (a) {
        qa.setTimeout(a, 0)
    } : qa.requestAnimationFrame = qa.setImmediate);

    function ra() {
    }

    function sa(a, b) {
        var c = -1;
        return function () {
            var d = this, e = arguments;
            -1 !== c && qa.clearTimeout(c);
            c = ta(function () {
                c = -1;
                a.apply(d, e)
            }, b)
        }
    }

    function ta(a, b) {
        return qa.setTimeout(a, b)
    }

    function ua(a) {
        return qa.document.createElement(a)
    }

    function v(a) {
        throw Error(a);
    }

    function va(a, b) {
        a = "The object is frozen, so its properties cannot be set: " + a.toString();
        void 0 !== b && (a += "  to value: " + b);
        v(a)
    }

    function w(a, b, c, d) {
        a instanceof b || (c = wa(c), void 0 !== d && (c += "." + d), xa(a, b, c))
    }

    function A(a, b, c, d) {
        typeof a !== b && (c = wa(c), void 0 !== d && (c += "." + d), xa(a, b, c))
    }

    function C(a, b, c) {
        "number" === typeof a && isFinite(a) || (b = wa(b), void 0 !== c && (b += "." + c), v(b + " must be a real number type, and not NaN or Infinity: " + a))
    }

    function xa(a, b, c, d) {
        b = wa(b);
        c = wa(c);
        void 0 !== d && (c += "." + d);
        "string" === typeof a ? v(c + " value is not an instance of " + b + ': "' + a + '"') : v(c + " value is not an instance of " + b + ": " + a)
    }

    function za(a, b, c, d) {
        c = wa(c);
        void 0 !== d && (c += "." + d);
        v(c + " is not in the range " + b + ": " + a)
    }

    function Ba(a) {
        v(("string" === typeof a.className ? a.className : "") + " constructor cannot take any arguments.")
    }

    function Ca(a) {
        v("Collection was modified during iteration: " + a.toString() + "\n  Perhaps you should iterate over a copy of the collection,\n  or you could collect items to be removed from the collection after the iteration.")
    }

    function Da(a, b) {
        v("No property to set for this enum value: " + b + " on " + a.toString())
    }

    function Ea(a) {
        qa.console && qa.console.log(a)
    }

    function Fa() {
        qa.console && qa.console.log("Warning: List/Map/Set constructors no longer take an argument that enforces type.Instead they take an optional collection of Values to add to the collection. See 2.0 changelog for details.")
    }

    function Ga(a) {
        return "object" === typeof a && null !== a
    }

    function Ha(a) {
        return Array.isArray(a) || qa.NodeList && a instanceof qa.NodeList || qa.HTMLCollection && a instanceof qa.HTMLCollection
    }

    function Ia(a, b, c) {
        Ha(a) || xa(a, "Array or NodeList or HTMLCollection", b, c)
    }

    function Ja(a) {
        return Array.prototype.slice.call(a)
    }

    function Ka(a, b, c) {
        Array.isArray(a) ? b >= a.length ? a.push(c) : a.splice(b, 0, c) : v("Cannot insert an object into an HTMLCollection or NodeList: " + c + " at " + b)
    }

    function La(a, b) {
        Array.isArray(a) ? b >= a.length ? a.pop() : a.splice(b, 1) : v("Cannot remove an object from an HTMLCollection or NodeList at " + b)
    }

    function Ma() {
        var a = Na.pop();
        return void 0 === a ? [] : a
    }

    function Oa(a) {
        a.length = 0;
        Na.push(a)
    }

    function wa(a) {
        return null === a ? "*" : "string" === typeof a ? a : "function" === typeof a && "string" === typeof a.className ? a.className : ""
    }

    function Pa(a) {
        if ("function" === typeof a) {
            if (a.className) return a.className;
            if (a.name) return a.name;
            var b = a.toString();
            b = b.substring(9, b.indexOf("(")).trim();
            if ("" !== b) return a._className = b
        } else if (Ga(a) && a.constructor) return Pa(a.constructor);
        return typeof a
    }

    function Qa(a) {
        var b = a;
        Ga(a) && (a.text ? b = a.text : a.name ? b = a.name : void 0 !== a.key ? b = a.key : void 0 !== a.id ? b = a.id : a.constructor === Object && (a.Text ? b = a.Text : a.Name ? b = a.Name : void 0 !== a.Key ? b = a.Key : void 0 !== a.Id ? b = a.Id : void 0 !== a.ID && (b = a.ID)));
        return void 0 === b ? "undefined" : null === b ? "null" : b.toString()
    }

    function Ra(a, b) {
        if (a.hasOwnProperty(b)) return !0;
        for (a = Object.getPrototypeOf(a); a && a !== Function;) {
            if (a.hasOwnProperty(b)) return !0;
            var c = a.CB;
            if (c && c[b]) return !0;
            a = Object.getPrototypeOf(a)
        }
        return !1
    }

    function Sa(a, b, c) {
        Object.defineProperty(Ua.prototype, a, {get: b, set: c})
    }

    function Va() {
        var a = Wa;
        if (void 0 === qa.document) return a;
        if (0 === a.length) for (var b = qa.document.getElementsByTagName("canvas"), c = b.length, d = 0; d < c; d++) {
            var e = b[d];
            e.parentElement && e.parentElement.B && a.push(e.parentElement.B)
        }
        return a
    }

    function Ya(a) {
        for (var b = [], c = 0; 256 > c; c++) b["0123456789abcdef".charAt(c >> 4) + "0123456789abcdef".charAt(c & 15)] = String.fromCharCode(c);
        a.length % 2 && (a = "0" + a);
        c = [];
        for (var d = 0, e = 0; e < a.length; e += 2) c[d++] = b[a.substr(e, 2)];
        a = c.join("");
        a = "" === a ? "0" : a;
        b = [];
        for (c = 0; 256 > c; c++) b[c] = c;
        for (c = d = 0; 256 > c; c++) d = (d + b[c] + 119) % 256, e = b[c], b[c] = b[d], b[d] = e;
        d = c = 0;
        for (var f = "", g = 0; g < a.length; g++) c = (c + 1) % 256, d = (d + b[c]) % 256, e = b[c], b[c] = b[d], b[d] = e, f += String.fromCharCode(a.charCodeAt(g) ^ b[(b[c] + b[d]) % 256]);
        return f
    }

    var Za = void 0 !== qa.navigator && 0 < qa.navigator.userAgent.indexOf("MSIE 9.0"),
        $a = void 0 !== qa.navigator && 0 < qa.navigator.userAgent.indexOf("MSIE 10.0"),
        cb = void 0 !== qa.navigator && 0 < qa.navigator.userAgent.indexOf("Trident/7"),
        db = void 0 !== qa.navigator && 0 < qa.navigator.userAgent.indexOf("Edge/"),
        eb = void 0 !== qa.navigator && void 0 !== qa.navigator.platform && 0 <= qa.navigator.platform.toUpperCase().indexOf("MAC"),
        fb = void 0 !== qa.navigator && void 0 !== qa.navigator.platform && null !== qa.navigator.platform.match(/(iPhone|iPod|iPad)/i),
        Na = [];
    Object.freeze([]);
    var Wa = [];
    ra.className = "Util";
    ra.Dx = "32ab5ff3b26f42dc0ed90f21452913b5";
    ra.adym = "gojs.net";
    ra.vfo = "28e647fdb061";
    ra.className = "Util";

    function E(a, b, c) {
        gb(this);
        this.l = a;
        this.Wa = b;
        this.w = c
    }

    E.prototype.toString = function () {
        return "EnumValue." + this.Wa
    };

    function hb(a, b) {
        return void 0 === b || null === b || "" === b ? null : a[b]
    }

    function ib(a, b, c, d) {
        a.classType !== b && (c = wa(c), void 0 !== d && (c += "." + d), xa(a, "function" === "a constant of class " + typeof b.className ? b.className : "", c))
    }

    na.Object.defineProperties(E.prototype, {
        classType: {
            configurable: !0, get: function () {
                return this.l
            }
        }, name: {
            configurable: !0, get: function () {
                return this.Wa
            }
        }, value: {
            configurable: !0, get: function () {
                return this.w
            }
        }
    });
    E.className = "EnumValue";

    function jb() {
        this.Ex = []
    }

    jb.prototype.toString = function () {
        return this.Ex.join("")
    };
    jb.prototype.add = function (a) {
        "" !== a && this.Ex.push(a)
    };
    jb.className = "StringBuilder";

    function kb() {
    }

    kb.className = "PropertyCollection";
    var F = {
        Gm: !1, By: !1, gA: !1, FB: !1, JB: !1, Ry: !1, Ay: !1, DB: null, trace: function (a) {
            qa.console && qa.console.log(a)
        }, EB: function (a, b, c, d) {
            a.strokeStyle = "red";
            a.fillStyle = "red";
            a.font = "8px sans-serif";
            a.beginPath();
            a.moveTo(-10, 0);
            a.lineTo(10, 0);
            a.moveTo(0, -10);
            a.lineTo(0, 10);
            a.stroke();
            a.setTransform(1, 0, 0, 1, 0, 0);
            a.scale(c, c);
            a.transform(b.m11, b.m12, b.m21, b.m22, b.dx, b.dy);
            a.lineWidth = 2;
            a.beginPath();
            a.moveTo(d.left, d.top + 20);
            a.lineTo(d.left, d.top);
            a.lineTo(d.left + 20, d.top);
            a.moveTo(d.right, d.bottom - 20);
            a.lineTo(d.right,
                d.bottom);
            a.lineTo(d.right - 20, d.bottom);
            a.stroke();
            a.fillText("DB: " + Math.round(d.x) + ", " + Math.round(d.y) + ", " + Math.round(d.width) + ", " + Math.round(d.height), d.left, d.top - 5)
        }, Lz: function (a) {
            var b = {}, c;
            for (c in a) {
                b.x = c;
                if ("licenseKey" !== b.x) {
                    var d = a[b.x];
                    if (void 0 !== d.prototype) {
                        b.Vm = Object.getOwnPropertyNames(d.prototype);
                        for (var e = {Jk: 0}; e.Jk < b.Vm.length; e = {Jk: e.Jk}, e.Jk++) {
                            var f = Object.getOwnPropertyDescriptor(d.prototype, b.Vm[e.Jk]);
                            void 0 !== f.get && void 0 === f.set && Object.defineProperty(d.prototype,
                                b.Vm[e.Jk], {
                                    set: function (a, b) {
                                        return function () {
                                            throw Error("Property " + a.Vm[b.Jk] + " of " + a.x + " is read-only.");
                                        }
                                    }(b, e)
                                })
                        }
                    }
                }
                b = {Vm: b.Vm, x: b.x}
            }
        }
    };

    function lb() {
    }

    lb.prototype.reset = function () {
    };
    lb.prototype.next = function () {
        return !1
    };
    lb.prototype.vd = function () {
        return !1
    };
    lb.prototype.first = function () {
        return null
    };
    lb.prototype.any = function () {
        return !1
    };
    lb.prototype.all = function () {
        return !0
    };
    lb.prototype.each = function () {
        return this
    };
    lb.prototype.map = function () {
        return this
    };
    lb.prototype.filter = function () {
        return this
    };
    lb.prototype.Sd = function () {
    };
    lb.prototype.toString = function () {
        return "EmptyIterator"
    };
    na.Object.defineProperties(lb.prototype, {
        iterator: {
            configurable: !0, get: function () {
                return this
            }
        }, count: {
            configurable: !0, get: function () {
                return 0
            }
        }
    });
    lb.prototype.first = lb.prototype.first;
    lb.prototype.hasNext = lb.prototype.vd;
    lb.prototype.next = lb.prototype.next;
    lb.prototype.reset = lb.prototype.reset;
    var mb = null;
    lb.className = "EmptyIterator";
    mb = new lb;

    function nb(a) {
        this.key = -1;
        this.value = a
    }

    nb.prototype.reset = function () {
        this.key = -1
    };
    nb.prototype.next = function () {
        return -1 === this.key ? (this.key = 0, !0) : !1
    };
    nb.prototype.vd = function () {
        return this.next()
    };
    nb.prototype.first = function () {
        this.key = 0;
        return this.value
    };
    nb.prototype.any = function (a) {
        this.key = -1;
        return a(this.value)
    };
    nb.prototype.all = function (a) {
        this.key = -1;
        return a(this.value)
    };
    nb.prototype.each = function (a) {
        this.key = -1;
        a(this.value);
        return this
    };
    nb.prototype.map = function (a) {
        return new nb(a(this.value))
    };
    nb.prototype.filter = function (a) {
        return a(this.value) ? new nb(this.value) : mb
    };
    nb.prototype.Sd = function () {
        this.value = null
    };
    nb.prototype.toString = function () {
        return "SingletonIterator(" + this.value + ")"
    };
    na.Object.defineProperties(nb.prototype, {
        iterator: {
            configurable: !0, get: function () {
                return this
            }
        }, count: {
            configurable: !0, get: function () {
                return 1
            }
        }
    });
    nb.prototype.first = nb.prototype.first;
    nb.prototype.hasNext = nb.prototype.vd;
    nb.prototype.next = nb.prototype.next;
    nb.prototype.reset = nb.prototype.reset;
    nb.className = "SingletonIterator";

    function pb(a) {
        this.yb = a;
        this.sf = null;
        a.Ma = null;
        this.oa = a.u;
        this.Va = -1
    }

    pb.prototype.reset = function () {
        var a = this.yb;
        a.Ma = null;
        this.oa = a.u;
        this.Va = -1
    };
    pb.prototype.next = function () {
        var a = this.yb;
        if (a.u !== this.oa) {
            if (0 > this.key) return !1;
            Ca(a)
        }
        a = a.j;
        var b = a.length, c = ++this.Va, d = this.sf;
        if (null !== d) for (; c < b;) {
            var e = a[c];
            if (d(e)) return this.key = this.Va = c, this.value = e, !0;
            c++
        } else {
            if (c < b) return this.key = c, this.value = a[c], !0;
            this.Sd()
        }
        return !1
    };
    pb.prototype.vd = function () {
        return this.next()
    };
    pb.prototype.first = function () {
        var a = this.yb;
        this.oa = a.u;
        this.Va = 0;
        a = a.j;
        var b = a.length, c = this.sf;
        if (null !== c) {
            for (var d = 0; d < b;) {
                var e = a[d];
                if (c(e)) return this.key = this.Va = d, this.value = e;
                d++
            }
            return null
        }
        return 0 < b ? (a = a[0], this.key = 0, this.value = a) : null
    };
    pb.prototype.any = function (a) {
        var b = this.yb;
        b.Ma = null;
        var c = b.u;
        this.Va = -1;
        for (var d = b.j, e = d.length, f = this.sf, g = 0; g < e; g++) {
            var h = d[g];
            if (null === f || f(h)) {
                if (a(h)) return !0;
                b.u !== c && Ca(b)
            }
        }
        return !1
    };
    pb.prototype.all = function (a) {
        var b = this.yb;
        b.Ma = null;
        var c = b.u;
        this.Va = -1;
        for (var d = b.j, e = d.length, f = this.sf, g = 0; g < e; g++) {
            var h = d[g];
            if (null === f || f(h)) {
                if (!a(h)) return !1;
                b.u !== c && Ca(b)
            }
        }
        return !0
    };
    pb.prototype.each = function (a) {
        var b = this.yb;
        b.Ma = null;
        var c = b.u;
        this.Va = -1;
        for (var d = b.j, e = d.length, f = this.sf, g = 0; g < e; g++) {
            var h = d[g];
            if (null === f || f(h)) a(h), b.u !== c && Ca(b)
        }
        return this
    };
    pb.prototype.map = function (a) {
        var b = this.yb;
        b.Ma = null;
        var c = b.u;
        this.Va = -1;
        for (var d = [], e = b.j, f = e.length, g = this.sf, h = 0; h < f; h++) {
            var k = e[h];
            if (null === g || g(k)) d.push(a(k)), b.u !== c && Ca(b)
        }
        a = new H;
        a.j = d;
        a.tb();
        return a.iterator
    };
    pb.prototype.filter = function (a) {
        var b = this.yb;
        b.Ma = null;
        var c = b.u;
        this.Va = -1;
        for (var d = [], e = b.j, f = e.length, g = this.sf, h = 0; h < f; h++) {
            var k = e[h];
            if (null === g || g(k)) a(k) && d.push(k), b.u !== c && Ca(b)
        }
        a = new H;
        a.j = d;
        a.tb();
        return a.iterator
    };
    pb.prototype.Sd = function () {
        this.key = -1;
        this.value = null;
        this.oa = -1;
        this.sf = null;
        this.yb.Ma = this
    };
    pb.prototype.toString = function () {
        return "ListIterator@" + this.Va + "/" + this.yb.count
    };
    na.Object.defineProperties(pb.prototype, {
        iterator: {
            configurable: !0, get: function () {
                return this
            }
        }, predicate: {
            configurable: !0, get: function () {
                return this.sf
            }, set: function (a) {
                this.sf = a
            }
        }, count: {
            configurable: !0, get: function () {
                var a = this.sf;
                if (null !== a) {
                    for (var b = 0, c = this.yb.j, d = c.length, e = 0; e < d; e++) a(c[e]) && b++;
                    return b
                }
                return this.yb.j.length
            }
        }
    });
    pb.prototype.first = pb.prototype.first;
    pb.prototype.hasNext = pb.prototype.vd;
    pb.prototype.next = pb.prototype.next;
    pb.prototype.reset = pb.prototype.reset;
    pb.className = "ListIterator";

    function qb(a) {
        this.yb = a;
        a.sh = null;
        this.oa = a.u;
        this.Va = a.j.length
    }

    qb.prototype.reset = function () {
        var a = this.yb;
        a.sh = null;
        this.oa = a.u;
        this.Va = a.j.length
    };
    qb.prototype.next = function () {
        var a = this.yb;
        if (a.u !== this.oa) {
            if (0 > this.key) return !1;
            Ca(a)
        }
        var b = --this.Va;
        if (0 <= b) return this.key = b, this.value = a.j[b], !0;
        this.Sd();
        return !1
    };
    qb.prototype.vd = function () {
        return this.next()
    };
    qb.prototype.first = function () {
        var a = this.yb;
        this.oa = a.u;
        var b = a.j;
        this.Va = a = b.length - 1;
        return 0 <= a ? (b = b[a], this.key = a, this.value = b) : null
    };
    qb.prototype.any = function (a) {
        var b = this.yb;
        b.sh = null;
        var c = b.u, d = b.j, e = d.length;
        this.Va = e;
        for (--e; 0 <= e; e--) {
            if (a(d[e])) return !0;
            b.u !== c && Ca(b)
        }
        return !1
    };
    qb.prototype.all = function (a) {
        var b = this.yb;
        b.sh = null;
        var c = b.u, d = b.j, e = d.length;
        this.Va = e;
        for (--e; 0 <= e; e--) {
            if (!a(d[e])) return !1;
            b.u !== c && Ca(b)
        }
        return !0
    };
    qb.prototype.each = function (a) {
        var b = this.yb;
        b.sh = null;
        var c = b.u, d = b.j, e = d.length;
        this.Va = e;
        for (--e; 0 <= e; e--) a(d[e]), b.u !== c && Ca(b);
        return this
    };
    qb.prototype.map = function (a) {
        var b = this.yb;
        b.sh = null;
        var c = b.u, d = [], e = b.j, f = e.length;
        this.Va = f;
        for (--f; 0 <= f; f--) d.push(a(e[f])), b.u !== c && Ca(b);
        a = new H;
        a.j = d;
        a.tb();
        return a.iterator
    };
    qb.prototype.filter = function (a) {
        var b = this.yb;
        b.sh = null;
        var c = b.u, d = [], e = b.j, f = e.length;
        this.Va = f;
        for (--f; 0 <= f; f--) {
            var g = e[f];
            a(g) && d.push(g);
            b.u !== c && Ca(b)
        }
        a = new H;
        a.j = d;
        a.tb();
        return a.iterator
    };
    qb.prototype.Sd = function () {
        this.key = -1;
        this.value = null;
        this.oa = -1;
        this.yb.sh = this
    };
    qb.prototype.toString = function () {
        return "ListIteratorBackwards(" + this.Va + "/" + this.yb.count + ")"
    };
    na.Object.defineProperties(qb.prototype, {
        iterator: {
            configurable: !0, get: function () {
                return this
            }
        }, count: {
            configurable: !0, get: function () {
                return this.yb.j.length
            }
        }
    });
    qb.prototype.first = qb.prototype.first;
    qb.prototype.hasNext = qb.prototype.vd;
    qb.prototype.next = qb.prototype.next;
    qb.prototype.reset = qb.prototype.reset;
    qb.className = "ListIteratorBackwards";

    function H(a) {
        gb(this);
        this.s = !1;
        this.j = [];
        this.u = 0;
        this.sh = this.Ma = null;
        void 0 !== a && ("function" === typeof a || "string" === typeof a ? Fa() : this.addAll(a))
    }

    t = H.prototype;
    t.tb = function () {
        var a = this.u;
        a++;
        999999999 < a && (a = 0);
        this.u = a
    };
    t.freeze = function () {
        this.s = !0;
        return this
    };
    t.ka = function () {
        this.s = !1;
        return this
    };
    t.toString = function () {
        return "List()#" + rb(this)
    };
    t.add = function (a) {
        if (null === a) return this;
        this.s && va(this, a);
        this.j.push(a);
        this.tb();
        return this
    };
    t.push = function (a) {
        this.add(a)
    };
    t.addAll = function (a) {
        if (null === a) return this;
        this.s && va(this);
        var b = this.j;
        if (Ha(a)) for (var c = a.length, d = 0; d < c; d++) b.push(a[d]); else for (a = a.iterator; a.next();) b.push(a.value);
        this.tb();
        return this
    };
    t.clear = function () {
        this.s && va(this);
        this.j.length = 0;
        this.tb()
    };
    t.contains = function (a) {
        return null === a ? !1 : -1 !== this.j.indexOf(a)
    };
    t.has = function (a) {
        return this.contains(a)
    };
    t.indexOf = function (a) {
        return null === a ? -1 : this.j.indexOf(a)
    };
    t.M = function (a) {
        F && C(a, H, "elt:i");
        var b = this.j;
        (0 > a || a >= b.length) && za(a, "0 <= i < length", H, "elt:i");
        return b[a]
    };
    t.get = function (a) {
        return this.M(a)
    };
    t.Vc = function (a, b) {
        F && C(a, H, "setElt:i");
        var c = this.j;
        (0 > a || a >= c.length) && za(a, "0 <= i < length", H, "setElt:i");
        this.s && va(this, a);
        c[a] = b
    };
    t.set = function (a, b) {
        this.Vc(a, b)
    };
    t.first = function () {
        var a = this.j;
        return 0 === a.length ? null : a[0]
    };
    t.cc = function () {
        var a = this.j, b = a.length;
        return 0 < b ? a[b - 1] : null
    };
    t.pop = function () {
        this.s && va(this);
        var a = this.j;
        return 0 < a.length ? a.pop() : null
    };
    H.prototype.any = function (a) {
        for (var b = this.j, c = this.u, d = b.length, e = 0; e < d; e++) {
            if (a(b[e])) return !0;
            this.u !== c && Ca(this)
        }
        return !1
    };
    H.prototype.all = function (a) {
        for (var b = this.j, c = this.u, d = b.length, e = 0; e < d; e++) {
            if (!a(b[e])) return !1;
            this.u !== c && Ca(this)
        }
        return !0
    };
    H.prototype.each = function (a) {
        for (var b = this.j, c = this.u, d = b.length, e = 0; e < d; e++) a(b[e]), this.u !== c && Ca(this);
        return this
    };
    H.prototype.map = function (a) {
        for (var b = new H, c = [], d = this.j, e = this.u, f = d.length, g = 0; g < f; g++) c.push(a(d[g])), this.u !== e && Ca(this);
        b.j = c;
        b.tb();
        return b
    };
    H.prototype.filter = function (a) {
        for (var b = new H, c = [], d = this.j, e = this.u, f = d.length, g = 0; g < f; g++) {
            var h = d[g];
            a(h) && c.push(h);
            this.u !== e && Ca(this)
        }
        b.j = c;
        b.tb();
        return b
    };
    t = H.prototype;
    t.Bb = function (a, b) {
        F && C(a, H, "insertAt:i");
        0 > a && za(a, ">= 0", H, "insertAt:i");
        this.s && va(this, a);
        var c = this.j;
        a >= c.length ? c.push(b) : c.splice(a, 0, b);
        this.tb()
    };
    t.remove = function (a) {
        if (null === a) return !1;
        this.s && va(this, a);
        var b = this.j;
        a = b.indexOf(a);
        if (-1 === a) return !1;
        a === b.length - 1 ? b.pop() : b.splice(a, 1);
        this.tb();
        return !0
    };
    t.delete = function (a) {
        return this.remove(a)
    };
    t.jb = function (a) {
        F && C(a, H, "removeAt:i");
        var b = this.j;
        (0 > a || a >= b.length) && za(a, "0 <= i < length", H, "removeAt:i");
        this.s && va(this, a);
        a === b.length - 1 ? b.pop() : b.splice(a, 1);
        this.tb()
    };
    t.removeRange = function (a, b) {
        F && (C(a, H, "removeRange:from"), C(b, H, "removeRange:to"));
        var c = this.j, d = c.length;
        if (0 > a) a = 0; else if (a >= d) return this;
        if (0 > b) return this;
        b >= d && (b = d - 1);
        if (a > b) return this;
        this.s && va(this);
        for (var e = a, f = b + 1; f < d;) c[e++] = c[f++];
        c.length = d - (b - a + 1);
        this.tb();
        return this
    };
    H.prototype.copy = function () {
        var a = new H, b = this.j;
        0 < b.length && (a.j = Array.prototype.slice.call(b));
        return a
    };
    t = H.prototype;
    t.ta = function () {
        for (var a = this.j, b = this.count, c = Array(b), d = 0; d < b; d++) c[d] = a[d];
        return c
    };
    t.Xw = function () {
        for (var a = new I, b = this.j, c = this.count, d = 0; d < c; d++) a.add(b[d]);
        return a
    };
    t.sort = function (a) {
        F && A(a, "function", H, "sort:sortfunc");
        this.s && va(this);
        this.j.sort(a);
        this.tb();
        return this
    };
    t.Fj = function (a, b, c) {
        var d = this.j, e = d.length;
        void 0 === b && (b = 0);
        void 0 === c && (c = e);
        F && (A(a, "function", H, "sortRange:sortfunc"), C(b, H, "sortRange:from"), C(c, H, "sortRange:to"));
        this.s && va(this);
        var f = c - b;
        if (1 >= f) return this;
        (0 > b || b >= e - 1) && za(b, "0 <= from < length", H, "sortRange:from");
        if (2 === f) return c = d[b], e = d[b + 1], 0 < a(c, e) && (d[b] = e, d[b + 1] = c, this.tb()), this;
        if (0 === b) if (c >= e) d.sort(a); else for (b = d.slice(0, c), b.sort(a), a = 0; a < c; a++) d[a] = b[a]; else if (c >= e) for (c = d.slice(b), c.sort(a), a = b; a < e; a++) d[a] = c[a - b];
        else for (e = d.slice(b, c), e.sort(a), a = b; a < c; a++) d[a] = e[a - b];
        this.tb();
        return this
    };
    t.reverse = function () {
        this.s && va(this);
        this.j.reverse();
        this.tb();
        return this
    };
    na.Object.defineProperties(H.prototype, {
        _dataArray: {
            configurable: !0, get: function () {
                return this.j
            }
        }, count: {
            configurable: !0, get: function () {
                return this.j.length
            }
        }, size: {
            configurable: !0, get: function () {
                return this.j.length
            }
        }, length: {
            configurable: !0, get: function () {
                return this.j.length
            }
        }, iterator: {
            configurable: !0, get: function () {
                if (0 >= this.j.length) return mb;
                var a = this.Ma;
                return null !== a ? (a.reset(), a) : new pb(this)
            }
        }, iteratorBackwards: {
            configurable: !0,
            enumerable: !0, get: function () {
                if (0 >= this.j.length) return mb;
                var a = this.sh;
                return null !== a ? (a.reset(), a) : new qb(this)
            }
        }
    });
    H.prototype.reverse = H.prototype.reverse;
    H.prototype.sortRange = H.prototype.Fj;
    H.prototype.sort = H.prototype.sort;
    H.prototype.toSet = H.prototype.Xw;
    H.prototype.toArray = H.prototype.ta;
    H.prototype.removeRange = H.prototype.removeRange;
    H.prototype.removeAt = H.prototype.jb;
    H.prototype["delete"] = H.prototype.delete;
    H.prototype.remove = H.prototype.remove;
    H.prototype.insertAt = H.prototype.Bb;
    H.prototype.pop = H.prototype.pop;
    H.prototype.last = H.prototype.cc;
    H.prototype.first = H.prototype.first;
    H.prototype.set = H.prototype.set;
    H.prototype.setElt = H.prototype.Vc;
    H.prototype.get = H.prototype.get;
    H.prototype.elt = H.prototype.M;
    H.prototype.indexOf = H.prototype.indexOf;
    H.prototype.has = H.prototype.has;
    H.prototype.contains = H.prototype.contains;
    H.prototype.clear = H.prototype.clear;
    H.prototype.addAll = H.prototype.addAll;
    H.prototype.push = H.prototype.push;
    H.prototype.add = H.prototype.add;
    H.prototype.thaw = H.prototype.ka;
    H.prototype.freeze = H.prototype.freeze;
    H.className = "List";

    function vb(a) {
        this.Gg = a;
        a.Ma = null;
        this.oa = a.u;
        this.qa = null
    }

    vb.prototype.reset = function () {
        var a = this.Gg;
        a.Ma = null;
        this.oa = a.u;
        this.qa = null
    };
    vb.prototype.next = function () {
        var a = this.Gg;
        if (a.u !== this.oa) {
            if (null === this.key) return !1;
            Ca(a)
        }
        var b = this.qa;
        b = null === b ? a.ga : b.va;
        if (null !== b) return this.qa = b, this.value = b.value, this.key = b.key, !0;
        this.Sd();
        return !1
    };
    vb.prototype.vd = function () {
        return this.next()
    };
    vb.prototype.first = function () {
        var a = this.Gg;
        this.oa = a.u;
        a = a.ga;
        if (null !== a) {
            this.qa = a;
            var b = a.value;
            this.key = a.key;
            return this.value = b
        }
        return null
    };
    vb.prototype.any = function (a) {
        var b = this.Gg;
        b.Ma = null;
        var c = b.u;
        this.qa = null;
        for (var d = b.ga; null !== d;) {
            if (a(d.value)) return !0;
            b.u !== c && Ca(b);
            d = d.va
        }
        return !1
    };
    vb.prototype.all = function (a) {
        var b = this.Gg;
        b.Ma = null;
        var c = b.u;
        this.qa = null;
        for (var d = b.ga; null !== d;) {
            if (!a(d.value)) return !1;
            b.u !== c && Ca(b);
            d = d.va
        }
        return !0
    };
    vb.prototype.each = function (a) {
        var b = this.Gg;
        b.Ma = null;
        var c = b.u;
        this.qa = null;
        for (var d = b.ga; null !== d;) a(d.value), b.u !== c && Ca(b), d = d.va;
        return this
    };
    vb.prototype.map = function (a) {
        var b = this.Gg;
        b.Ma = null;
        for (var c = new H, d = b.u, e = b.ga; null !== e;) c.add(a(e.value)), b.u !== d && Ca(b), e = e.va;
        return c.iterator
    };
    vb.prototype.filter = function (a) {
        var b = this.Gg;
        b.Ma = null;
        for (var c = new H, d = b.u, e = b.ga; null !== e;) {
            var f = e.value;
            a(f) && c.add(f);
            b.u !== d && Ca(b);
            e = e.va
        }
        return c.iterator
    };
    vb.prototype.Sd = function () {
        this.value = this.key = null;
        this.oa = -1;
        this.Gg.Ma = this
    };
    vb.prototype.toString = function () {
        return null !== this.qa ? "SetIterator@" + this.qa.value : "SetIterator"
    };
    na.Object.defineProperties(vb.prototype, {
        iterator: {
            configurable: !0, get: function () {
                return this
            }
        }, count: {
            configurable: !0, get: function () {
                return this.Gg.Mb
            }
        }
    });
    vb.prototype.first = vb.prototype.first;
    vb.prototype.hasNext = vb.prototype.vd;
    vb.prototype.next = vb.prototype.next;
    vb.prototype.reset = vb.prototype.reset;
    vb.className = "SetIterator";

    function I(a) {
        gb(this);
        this.s = !1;
        this.Ob = {};
        this.Mb = 0;
        this.Ma = null;
        this.u = 0;
        this.lf = this.ga = null;
        void 0 !== a && ("function" === typeof a || "string" === typeof a ? Fa() : this.addAll(a))
    }

    t = I.prototype;
    t.tb = function () {
        var a = this.u;
        a++;
        999999999 < a && (a = 0);
        this.u = a
    };
    t.freeze = function () {
        this.s = !0;
        return this
    };
    t.ka = function () {
        this.s = !1;
        return this
    };
    t.toString = function () {
        return "Set()#" + rb(this)
    };
    t.add = function (a) {
        if (null === a) return this;
        this.s && va(this, a);
        var b = a;
        Ga(a) && (b = wb(a));
        void 0 === this.Ob[b] && (this.Mb++, a = new xb(a, a), this.Ob[b] = a, b = this.lf, null === b ? this.ga = a : (a.hm = b, b.va = a), this.lf = a, this.tb());
        return this
    };
    t.addAll = function (a) {
        if (null === a) return this;
        this.s && va(this);
        if (Ha(a)) for (var b = a.length, c = 0; c < b; c++) this.add(a[c]); else for (a = a.iterator; a.next();) this.add(a.value);
        return this
    };
    t.contains = function (a) {
        if (null === a) return !1;
        var b = a;
        return Ga(a) && (b = rb(a), void 0 === b) ? !1 : void 0 !== this.Ob[b]
    };
    t.has = function (a) {
        return this.contains(a)
    };
    t.Tz = function (a) {
        if (null === a) return !0;
        for (a = a.iterator; a.next();) if (!this.contains(a.value)) return !1;
        return !0
    };
    t.Uz = function (a) {
        if (null === a) return !0;
        for (a = a.iterator; a.next();) if (this.contains(a.value)) return !0;
        return !1
    };
    t.first = function () {
        var a = this.ga;
        return null === a ? null : a.value
    };
    I.prototype.any = function (a) {
        for (var b = this.u, c = this.ga; null !== c;) {
            if (a(c.value)) return !0;
            this.u !== b && Ca(this);
            c = c.va
        }
        return !1
    };
    I.prototype.all = function (a) {
        for (var b = this.u, c = this.ga; null !== c;) {
            if (!a(c.value)) return !1;
            this.u !== b && Ca(this);
            c = c.va
        }
        return !0
    };
    I.prototype.each = function (a) {
        for (var b = this.u, c = this.ga; null !== c;) a(c.value), this.u !== b && Ca(this), c = c.va;
        return this
    };
    I.prototype.map = function (a) {
        for (var b = new I, c = this.u, d = this.ga; null !== d;) b.add(a(d.value)), this.u !== c && Ca(this), d = d.va;
        return b
    };
    I.prototype.filter = function (a) {
        for (var b = new I, c = this.u, d = this.ga; null !== d;) {
            var e = d.value;
            a(e) && b.add(e);
            this.u !== c && Ca(this);
            d = d.va
        }
        return b
    };
    t = I.prototype;
    t.remove = function (a) {
        if (null === a) return !1;
        this.s && va(this, a);
        var b = a;
        if (Ga(a) && (b = rb(a), void 0 === b)) return !1;
        a = this.Ob[b];
        if (void 0 === a) return !1;
        var c = a.va, d = a.hm;
        null !== c && (c.hm = d);
        null !== d && (d.va = c);
        this.ga === a && (this.ga = c);
        this.lf === a && (this.lf = d);
        delete this.Ob[b];
        this.Mb--;
        this.tb();
        return !0
    };
    t.delete = function (a) {
        return this.remove(a)
    };
    t.lr = function (a) {
        if (null === a) return this;
        this.s && va(this);
        if (Ha(a)) for (var b = a.length, c = 0; c < b; c++) this.remove(a[c]); else for (a = a.iterator; a.next();) this.remove(a.value);
        return this
    };
    t.mB = function (a) {
        if (null === a || 0 === this.count) return this;
        this.s && va(this);
        var b = new I;
        b.addAll(a);
        a = [];
        for (var c = this.iterator; c.next();) {
            var d = c.value;
            b.contains(d) || a.push(d)
        }
        this.lr(a);
        return this
    };
    t.clear = function () {
        this.s && va(this);
        this.Ob = {};
        this.Mb = 0;
        null !== this.Ma && this.Ma.reset();
        this.lf = this.ga = null;
        this.tb()
    };
    I.prototype.copy = function () {
        var a = new I, b = this.Ob, c;
        for (c in b) a.add(b[c].value);
        return a
    };
    I.prototype.ta = function () {
        var a = Array(this.Mb), b = this.Ob, c = 0, d;
        for (d in b) a[c] = b[d].value, c++;
        return a
    };
    I.prototype.Ww = function () {
        var a = new H, b = this.Ob, c;
        for (c in b) a.add(b[c].value);
        return a
    };

    function gb(a) {
        a.__gohashid = yb++
    }

    function wb(a) {
        var b = a.__gohashid;
        void 0 === b && (b = yb++, a.__gohashid = b);
        return b
    }

    function rb(a) {
        return a.__gohashid
    }

    na.Object.defineProperties(I.prototype, {
        count: {
            configurable: !0, get: function () {
                return this.Mb
            }
        }, size: {
            configurable: !0, get: function () {
                return this.Mb
            }
        }, iterator: {
            configurable: !0, get: function () {
                if (0 >= this.Mb) return mb;
                var a = this.Ma;
                return null !== a ? (a.reset(), a) : new vb(this)
            }
        }
    });
    I.prototype.toList = I.prototype.Ww;
    I.prototype.toArray = I.prototype.ta;
    I.prototype.clear = I.prototype.clear;
    I.prototype.retainAll = I.prototype.mB;
    I.prototype.removeAll = I.prototype.lr;
    I.prototype["delete"] = I.prototype.delete;
    I.prototype.remove = I.prototype.remove;
    I.prototype.first = I.prototype.first;
    I.prototype.containsAny = I.prototype.Uz;
    I.prototype.containsAll = I.prototype.Tz;
    I.prototype.has = I.prototype.has;
    I.prototype.contains = I.prototype.contains;
    I.prototype.addAll = I.prototype.addAll;
    I.prototype.add = I.prototype.add;
    I.prototype.thaw = I.prototype.ka;
    I.prototype.freeze = I.prototype.freeze;
    var yb = 1;
    I.className = "Set";
    I.uniqueHash = gb;
    I.hashIdUnique = wb;
    I.hashId = rb;

    function zb(a) {
        this.ma = a;
        this.oa = a.u;
        this.qa = null
    }

    zb.prototype.reset = function () {
        this.oa = this.ma.u;
        this.qa = null
    };
    zb.prototype.next = function () {
        var a = this.ma;
        if (a.u !== this.oa) {
            if (null === this.key) return !1;
            Ca(a)
        }
        var b = this.qa;
        b = null === b ? a.ga : b.va;
        if (null !== b) return this.qa = b, this.value = this.key = a = b.key, !0;
        this.Sd();
        return !1
    };
    zb.prototype.vd = function () {
        return this.next()
    };
    zb.prototype.first = function () {
        var a = this.ma;
        this.oa = a.u;
        a = a.ga;
        return null !== a ? (this.qa = a, this.value = this.key = a = a.key) : null
    };
    zb.prototype.any = function (a) {
        var b = this.ma, c = b.u;
        this.qa = null;
        for (var d = b.ga; null !== d;) {
            if (a(d.key)) return !0;
            b.u !== c && Ca(b);
            d = d.va
        }
        return !1
    };
    zb.prototype.all = function (a) {
        var b = this.ma, c = b.u;
        this.qa = null;
        for (var d = b.ga; null !== d;) {
            if (!a(d.key)) return !1;
            b.u !== c && Ca(b);
            d = d.va
        }
        return !0
    };
    zb.prototype.each = function (a) {
        var b = this.ma, c = b.u;
        this.qa = null;
        for (var d = b.ga; null !== d;) a(d.key), b.u !== c && Ca(b), d = d.va;
        return this
    };
    zb.prototype.map = function (a) {
        var b = this.ma, c = b.u;
        this.qa = null;
        for (var d = new H, e = b.ga; null !== e;) d.add(a(e.key)), b.u !== c && Ca(b), e = e.va;
        return d.iterator
    };
    zb.prototype.filter = function (a) {
        var b = this.ma, c = b.u;
        this.qa = null;
        for (var d = new H, e = b.ga; null !== e;) {
            var f = e.key;
            a(f) && d.add(f);
            b.u !== c && Ca(b);
            e = e.va
        }
        return d.iterator
    };
    zb.prototype.Sd = function () {
        this.value = this.key = null;
        this.oa = -1
    };
    zb.prototype.toString = function () {
        return null !== this.qa ? "MapKeySetIterator@" + this.qa.value : "MapKeySetIterator"
    };
    na.Object.defineProperties(zb.prototype, {
        iterator: {
            configurable: !0, get: function () {
                return this
            }
        }, count: {
            configurable: !0, get: function () {
                return this.ma.Mb
            }
        }
    });
    zb.prototype.first = zb.prototype.first;
    zb.prototype.hasNext = zb.prototype.vd;
    zb.prototype.next = zb.prototype.next;
    zb.prototype.reset = zb.prototype.reset;
    zb.className = "MapKeySetIterator";

    function Ab(a) {
        I.call(this);
        gb(this);
        this.s = !0;
        this.ma = a
    }

    ma(Ab, I);
    t = Ab.prototype;
    t.freeze = function () {
        return this
    };
    t.ka = function () {
        return this
    };
    t.toString = function () {
        return "MapKeySet(" + this.ma.toString() + ")"
    };
    t.add = function () {
        v("This Set is read-only: " + this.toString());
        return this
    };
    t.contains = function (a) {
        return this.ma.contains(a)
    };
    t.has = function (a) {
        return this.contains(a)
    };
    t.remove = function () {
        v("This Set is read-only: " + this.toString());
        return !1
    };
    t.delete = function (a) {
        return this.remove(a)
    };
    t.clear = function () {
        v("This Set is read-only: " + this.toString())
    };
    t.first = function () {
        var a = this.ma.ga;
        return null !== a ? a.key : null
    };
    Ab.prototype.any = function (a) {
        for (var b = this.ma.ga; null !== b;) {
            if (a(b.key)) return !0;
            b = b.va
        }
        return !1
    };
    Ab.prototype.all = function (a) {
        for (var b = this.ma.ga; null !== b;) {
            if (!a(b.key)) return !1;
            b = b.va
        }
        return !0
    };
    Ab.prototype.each = function (a) {
        for (var b = this.ma.ga; null !== b;) a(b.key), b = b.va;
        return this
    };
    Ab.prototype.map = function (a) {
        for (var b = new I, c = this.ma.ga; null !== c;) b.add(a(c.key)), c = c.va;
        return b
    };
    Ab.prototype.filter = function (a) {
        for (var b = new I, c = this.ma.ga; null !== c;) {
            var d = c.key;
            a(d) && b.add(d);
            c = c.va
        }
        return b
    };
    Ab.prototype.copy = function () {
        return new Ab(this.ma)
    };
    Ab.prototype.Xw = function () {
        var a = new I, b = this.ma.Ob, c;
        for (c in b) a.add(b[c].key);
        return a
    };
    Ab.prototype.ta = function () {
        var a = this.ma.Ob, b = Array(this.ma.Mb), c = 0, d;
        for (d in a) b[c] = a[d].key, c++;
        return b
    };
    Ab.prototype.Ww = function () {
        var a = new H, b = this.ma.Ob, c;
        for (c in b) a.add(b[c].key);
        return a
    };
    na.Object.defineProperties(Ab.prototype, {
        count: {
            configurable: !0, get: function () {
                return this.ma.Mb
            }
        }, size: {
            configurable: !0, get: function () {
                return this.ma.Mb
            }
        }, iterator: {
            configurable: !0, get: function () {
                return 0 >= this.ma.Mb ? mb : new zb(this.ma)
            }
        }
    });
    Ab.prototype.toList = Ab.prototype.Ww;
    Ab.prototype.toArray = Ab.prototype.ta;
    Ab.prototype.toSet = Ab.prototype.Xw;
    Ab.prototype.first = Ab.prototype.first;
    Ab.prototype.clear = Ab.prototype.clear;
    Ab.prototype["delete"] = Ab.prototype.delete;
    Ab.prototype.remove = Ab.prototype.remove;
    Ab.prototype.has = Ab.prototype.has;
    Ab.prototype.contains = Ab.prototype.contains;
    Ab.prototype.add = Ab.prototype.add;
    Ab.prototype.thaw = Ab.prototype.ka;
    Ab.prototype.freeze = Ab.prototype.freeze;
    Ab.className = "MapKeySet";

    function Bb(a) {
        this.ma = a;
        a.kf = null;
        this.oa = a.u;
        this.qa = null
    }

    Bb.prototype.reset = function () {
        var a = this.ma;
        a.kf = null;
        this.oa = a.u;
        this.qa = null
    };
    Bb.prototype.next = function () {
        var a = this.ma;
        if (a.u !== this.oa) {
            if (null === this.key) return !1;
            Ca(a)
        }
        var b = this.qa;
        b = null === b ? a.ga : b.va;
        if (null !== b) return this.qa = b, this.value = b.value, this.key = b.key, !0;
        this.Sd();
        return !1
    };
    Bb.prototype.vd = function () {
        return this.next()
    };
    Bb.prototype.first = function () {
        var a = this.ma;
        this.oa = a.u;
        a = a.ga;
        if (null !== a) {
            this.qa = a;
            var b = a.value;
            this.key = a.key;
            return this.value = b
        }
        return null
    };
    Bb.prototype.any = function (a) {
        var b = this.ma;
        b.kf = null;
        var c = b.u;
        this.qa = null;
        for (var d = b.ga; null !== d;) {
            if (a(d.value)) return !0;
            b.u !== c && Ca(b);
            d = d.va
        }
        return !1
    };
    Bb.prototype.all = function (a) {
        var b = this.ma;
        b.kf = null;
        var c = b.u;
        this.qa = null;
        for (var d = b.ga; null !== d;) {
            if (!a(d.value)) return !1;
            b.u !== c && Ca(b);
            d = d.va
        }
        return !0
    };
    Bb.prototype.each = function (a) {
        var b = this.ma;
        b.kf = null;
        var c = b.u;
        this.qa = null;
        for (var d = b.ga; null !== d;) a(d.value), b.u !== c && Ca(b), d = d.va;
        return this
    };
    Bb.prototype.map = function (a) {
        var b = this.ma;
        b.kf = null;
        var c = b.u;
        this.qa = null;
        for (var d = new H, e = b.ga; null !== e;) d.add(a(e.value)), b.u !== c && Ca(b), e = e.va;
        return d.iterator
    };
    Bb.prototype.filter = function (a) {
        var b = this.ma;
        b.kf = null;
        var c = b.u;
        this.qa = null;
        for (var d = new H, e = b.ga; null !== e;) {
            var f = e.value;
            a(f) && d.add(f);
            b.u !== c && Ca(b);
            e = e.va
        }
        return d.iterator
    };
    Bb.prototype.Sd = function () {
        this.value = this.key = null;
        this.oa = -1;
        this.ma.kf = this
    };
    Bb.prototype.toString = function () {
        return null !== this.qa ? "MapValueSetIterator@" + this.qa.value : "MapValueSetIterator"
    };
    na.Object.defineProperties(Bb.prototype, {
        iterator: {
            configurable: !0, get: function () {
                return this
            }
        }, count: {
            configurable: !0, get: function () {
                return this.ma.Mb
            }
        }
    });
    Bb.prototype.first = Bb.prototype.first;
    Bb.prototype.hasNext = Bb.prototype.vd;
    Bb.prototype.next = Bb.prototype.next;
    Bb.prototype.reset = Bb.prototype.reset;
    Bb.className = "MapValueSetIterator";

    function xb(a, b) {
        this.key = a;
        this.value = b;
        this.hm = this.va = null
    }

    xb.prototype.toString = function () {
        return "{" + this.key + ":" + this.value + "}"
    };
    xb.className = "KeyValuePair";

    function Cb(a) {
        this.ma = a;
        a.Ma = null;
        this.oa = a.u;
        this.qa = null
    }

    Cb.prototype.reset = function () {
        var a = this.ma;
        a.Ma = null;
        this.oa = a.u;
        this.qa = null
    };
    Cb.prototype.next = function () {
        var a = this.ma;
        if (a.u !== this.oa) {
            if (null === this.key) return !1;
            Ca(a)
        }
        var b = this.qa;
        b = null === b ? a.ga : b.va;
        if (null !== b) return this.qa = b, this.key = b.key, this.value = b.value, !0;
        this.Sd();
        return !1
    };
    Cb.prototype.vd = function () {
        return this.next()
    };
    Cb.prototype.first = function () {
        var a = this.ma;
        this.oa = a.u;
        a = a.ga;
        return null !== a ? (this.qa = a, this.key = a.key, this.value = a.value, a) : null
    };
    Cb.prototype.any = function (a) {
        var b = this.ma;
        b.Ma = null;
        var c = b.u;
        this.qa = null;
        for (var d = b.ga; null !== d;) {
            if (a(d)) return !0;
            b.u !== c && Ca(b);
            d = d.va
        }
        return !1
    };
    Cb.prototype.all = function (a) {
        var b = this.ma;
        b.Ma = null;
        var c = b.u;
        this.qa = null;
        for (var d = b.ga; null !== d;) {
            if (!a(d)) return !1;
            b.u !== c && Ca(b);
            d = d.va
        }
        return !0
    };
    Cb.prototype.each = function (a) {
        var b = this.ma;
        b.Ma = null;
        var c = b.u;
        this.qa = null;
        for (var d = b.ga; null !== d;) a(d), b.u !== c && Ca(b), d = d.va;
        return this
    };
    Cb.prototype.map = function (a) {
        var b = this.ma;
        b.Ma = null;
        var c = b.u;
        this.qa = null;
        for (var d = new H, e = b.ga; null !== e;) d.add(a(e)), b.u !== c && Ca(b), e = e.va;
        return d.iterator
    };
    Cb.prototype.filter = function (a) {
        var b = this.ma;
        b.Ma = null;
        var c = b.u;
        this.qa = null;
        for (var d = new H, e = b.ga; null !== e;) a(e) && d.add(e), b.u !== c && Ca(b), e = e.va;
        return d.iterator
    };
    Cb.prototype.Sd = function () {
        this.value = this.key = null;
        this.oa = -1;
        this.ma.Ma = this
    };
    Cb.prototype.toString = function () {
        return null !== this.qa ? "MapIterator@" + this.qa : "MapIterator"
    };
    na.Object.defineProperties(Cb.prototype, {
        iterator: {
            configurable: !0, get: function () {
                return this
            }
        }, count: {
            configurable: !0, get: function () {
                return this.ma.Mb
            }
        }
    });
    Cb.prototype.first = Cb.prototype.first;
    Cb.prototype.hasNext = Cb.prototype.vd;
    Cb.prototype.next = Cb.prototype.next;
    Cb.prototype.reset = Cb.prototype.reset;
    Cb.className = "MapIterator";

    function Db(a) {
        gb(this);
        this.s = !1;
        this.Ob = {};
        this.Mb = 0;
        this.kf = this.Ma = null;
        this.u = 0;
        this.lf = this.ga = null;
        void 0 !== a && ("function" === typeof a || "string" === typeof a ? Fa() : this.addAll(a))
    }

    t = Db.prototype;
    t.tb = function () {
        var a = this.u;
        a++;
        999999999 < a && (a = 0);
        this.u = a
    };
    t.freeze = function () {
        this.s = !0;
        return this
    };
    t.ka = function () {
        this.s = !1;
        return this
    };
    t.toString = function () {
        return "Map()#" + rb(this)
    };
    t.add = function (a, b) {
        this.s && va(this, a);
        var c = a;
        Ga(a) && (c = wb(a));
        var d = this.Ob[c];
        void 0 === d ? (this.Mb++, a = new xb(a, b), this.Ob[c] = a, c = this.lf, null === c ? this.ga = a : (a.hm = c, c.va = a), this.lf = a, this.tb()) : d.value = b;
        return this
    };
    t.set = function (a, b) {
        return this.add(a, b)
    };
    t.addAll = function (a) {
        if (null === a) return this;
        if (Ha(a)) for (var b = a.length, c = 0; c < b; c++) {
            var d = a[c];
            this.add(d.key, d.value)
        } else if (a instanceof Db) for (a = a.iterator; a.next();) this.add(a.key, a.value); else for (a = a.iterator; a.next();) b = a.value, this.add(b.key, b.value);
        return this
    };
    t.first = function () {
        return this.ga
    };
    Db.prototype.any = function (a) {
        for (var b = this.u, c = this.ga; null !== c;) {
            if (a(c)) return !0;
            this.u !== b && Ca(this);
            c = c.va
        }
        return !1
    };
    Db.prototype.all = function (a) {
        for (var b = this.u, c = this.ga; null !== c;) {
            if (!a(c)) return !1;
            this.u !== b && Ca(this);
            c = c.va
        }
        return !0
    };
    Db.prototype.each = function (a) {
        for (var b = this.u, c = this.ga; null !== c;) a(c), this.u !== b && Ca(this), c = c.va;
        return this
    };
    Db.prototype.map = function (a) {
        for (var b = new Db, c = this.u, d = this.ga; null !== d;) b.add(d.key, a(d)), this.u !== c && Ca(this), d = d.va;
        return b
    };
    Db.prototype.filter = function (a) {
        for (var b = new Db, c = this.u, d = this.ga; null !== d;) a(d) && b.add(d.key, d.value), this.u !== c && Ca(this), d = d.va;
        return b
    };
    t = Db.prototype;
    t.contains = function (a) {
        var b = a;
        return Ga(a) && (b = rb(a), void 0 === b) ? !1 : void 0 !== this.Ob[b]
    };
    t.has = function (a) {
        return this.contains(a)
    };
    t.K = function (a) {
        var b = a;
        if (Ga(a) && (b = rb(a), void 0 === b)) return null;
        a = this.Ob[b];
        return void 0 === a ? null : a.value
    };
    t.get = function (a) {
        return this.K(a)
    };
    t.remove = function (a) {
        if (null === a) return !1;
        this.s && va(this, a);
        var b = a;
        if (Ga(a) && (b = rb(a), void 0 === b)) return !1;
        a = this.Ob[b];
        if (void 0 === a) return !1;
        var c = a.va, d = a.hm;
        null !== c && (c.hm = d);
        null !== d && (d.va = c);
        this.ga === a && (this.ga = c);
        this.lf === a && (this.lf = d);
        delete this.Ob[b];
        this.Mb--;
        this.tb();
        return !0
    };
    t.delete = function (a) {
        return this.remove(a)
    };
    t.clear = function () {
        this.s && va(this);
        this.Ob = {};
        this.Mb = 0;
        null !== this.Ma && this.Ma.reset();
        null !== this.kf && this.kf.reset();
        this.lf = this.ga = null;
        this.tb()
    };
    Db.prototype.copy = function () {
        var a = new Db, b = this.Ob, c;
        for (c in b) {
            var d = b[c];
            a.add(d.key, d.value)
        }
        return a
    };
    Db.prototype.ta = function () {
        var a = this.Ob, b = Array(this.Mb), c = 0, d;
        for (d in a) {
            var e = a[d];
            b[c] = new xb(e.key, e.value);
            c++
        }
        return b
    };
    Db.prototype.Wf = function () {
        return new Ab(this)
    };
    na.Object.defineProperties(Db.prototype, {
        count: {
            configurable: !0, get: function () {
                return this.Mb
            }
        }, size: {
            configurable: !0, get: function () {
                return this.Mb
            }
        }, iterator: {
            configurable: !0, get: function () {
                if (0 >= this.count) return mb;
                var a = this.Ma;
                return null !== a ? (a.reset(), a) : new Cb(this)
            }
        }, iteratorKeys: {
            configurable: !0, get: function () {
                return 0 >= this.count ? mb : new zb(this)
            }
        }, iteratorValues: {
            configurable: !0, get: function () {
                if (0 >= this.count) return mb;
                var a = this.kf;
                return null !== a ? (a.reset(), a) : new Bb(this)
            }
        }
    });
    Db.prototype.toKeySet = Db.prototype.Wf;
    Db.prototype.toArray = Db.prototype.ta;
    Db.prototype.clear = Db.prototype.clear;
    Db.prototype["delete"] = Db.prototype.delete;
    Db.prototype.remove = Db.prototype.remove;
    Db.prototype.get = Db.prototype.get;
    Db.prototype.getValue = Db.prototype.K;
    Db.prototype.has = Db.prototype.has;
    Db.prototype.contains = Db.prototype.contains;
    Db.prototype.first = Db.prototype.first;
    Db.prototype.addAll = Db.prototype.addAll;
    Db.prototype.set = Db.prototype.set;
    Db.prototype.add = Db.prototype.add;
    Db.prototype.thaw = Db.prototype.ka;
    Db.prototype.freeze = Db.prototype.freeze;
    Db.className = "Map";

    function J(a, b) {
        void 0 === a ? this.H = this.G = 0 : "number" === typeof a && "number" === typeof b ? (this.G = a, this.H = b) : v("Invalid arguments to Point constructor: " + a + ", " + b);
        this.s = !1
    }

    J.prototype.assign = function (a) {
        this.G = a.G;
        this.H = a.H;
        return this
    };
    J.prototype.h = function (a, b) {
        this.G = a;
        this.H = b;
        return this
    };
    J.prototype.Vg = function (a, b) {
        F && (A(a, "number", J, "setTo:x"), A(b, "number", J, "setTo:y"), this.ha());
        this.G = a;
        this.H = b;
        return this
    };
    J.prototype.set = function (a) {
        F && (w(a, J, J, "set:p"), this.ha());
        this.G = a.G;
        this.H = a.H;
        return this
    };
    J.prototype.copy = function () {
        var a = new J;
        a.G = this.G;
        a.H = this.H;
        return a
    };
    t = J.prototype;
    t.ia = function () {
        this.s = !0;
        Object.freeze(this);
        return this
    };
    t.J = function () {
        return this.s || Object.isFrozen(this) ? this : this.copy().freeze()
    };
    t.freeze = function () {
        this.s = !0;
        return this
    };
    t.ka = function () {
        Object.isFrozen(this) && v("cannot thaw constant: " + this);
        this.s = !1;
        return this
    };
    t.ha = function (a) {
        if (F && this.s) {
            var b = "The Point is frozen, so its properties cannot be set: " + this.toString();
            void 0 !== a && (b += "  to value: " + a);
            v(b)
        }
    };

    function Eb(a) {
        if ("string" === typeof a) {
            a = a.split(" ");
            for (var b = 0, c = 0; "" === a[b];) b++;
            var d = a[b++];
            d && (c = parseFloat(d));
            for (var e = 0; "" === a[b];) b++;
            (d = a[b++]) && (e = parseFloat(d));
            return new J(c, e)
        }
        return new J
    }

    function Fb(a) {
        F && w(a, J);
        return a.x.toString() + " " + a.y.toString()
    }

    t.toString = function () {
        return "Point(" + this.x + "," + this.y + ")"
    };
    t.A = function (a) {
        return a instanceof J ? this.G === a.x && this.H === a.y : !1
    };
    t.pj = function (a, b) {
        return this.G === a && this.H === b
    };
    t.Ta = function (a) {
        return K.C(this.G, a.x) && K.C(this.H, a.y)
    };
    t.add = function (a) {
        F && (w(a, J, J, "add:p"), this.ha());
        this.G += a.x;
        this.H += a.y;
        return this
    };
    t.ke = function (a) {
        F && (w(a, J, J, "subtract:p"), this.ha());
        this.G -= a.x;
        this.H -= a.y;
        return this
    };
    t.offset = function (a, b) {
        F && (C(a, J, "offset:dx"), C(b, J, "offset:dy"), this.ha());
        this.G += a;
        this.H += b;
        return this
    };
    J.prototype.rotate = function (a) {
        F && (C(a, J, "rotate:angle"), this.ha());
        if (0 === a) return this;
        var b = this.G, c = this.H;
        if (0 === b && 0 === c) return this;
        360 <= a ? a -= 360 : 0 > a && (a += 360);
        if (90 === a) {
            a = 0;
            var d = 1
        } else 180 === a ? (a = -1, d = 0) : 270 === a ? (a = 0, d = -1) : (d = a * Math.PI / 180, a = Math.cos(d), d = Math.sin(d));
        this.G = a * b - d * c;
        this.H = d * b + a * c;
        return this
    };
    t = J.prototype;
    t.scale = function (a, b) {
        F && (C(a, J, "scale:sx"), C(b, J, "scale:sy"), this.ha());
        this.G *= a;
        this.H *= b;
        return this
    };
    t.Re = function (a) {
        F && w(a, J, J, "distanceSquaredPoint:p");
        var b = a.x - this.G;
        a = a.y - this.H;
        return b * b + a * a
    };
    t.ud = function (a, b) {
        F && (C(a, J, "distanceSquared:px"), C(b, J, "distanceSquared:py"));
        a -= this.G;
        b -= this.H;
        return a * a + b * b
    };
    t.normalize = function () {
        F && this.ha();
        var a = this.G, b = this.H, c = Math.sqrt(a * a + b * b);
        0 < c && (this.G = a / c, this.H = b / c);
        return this
    };
    t.Xa = function (a) {
        F && w(a, J, J, "directionPoint:p");
        return Gb(a.x - this.G, a.y - this.H)
    };
    t.direction = function (a, b) {
        F && (C(a, J, "direction:px"), C(b, J, "direction:py"));
        return Gb(a - this.G, b - this.H)
    };

    function Gb(a, b) {
        if (0 === a) return 0 < b ? 90 : 0 > b ? 270 : 0;
        if (0 === b) return 0 < a ? 0 : 180;
        if (isNaN(a) || isNaN(b)) return 0;
        var c = 180 * Math.atan(Math.abs(b / a)) / Math.PI;
        0 > a ? c = 0 > b ? c + 180 : 180 - c : 0 > b && (c = 360 - c);
        return c
    }

    t.fB = function (a, b, c, d) {
        F && (C(a, J, "projectOntoLineSegment:px"), C(b, J, "projectOntoLineSegment:py"), C(c, J, "projectOntoLineSegment:qx"), C(d, J, "projectOntoLineSegment:qy"));
        K.$h(a, b, c, d, this.G, this.H, this);
        return this
    };
    t.gB = function (a, b) {
        F && (w(a, J, J, "projectOntoLineSegmentPoint:p"), w(b, J, J, "projectOntoLineSegmentPoint:q"));
        K.$h(a.x, a.y, b.x, b.y, this.G, this.H, this);
        return this
    };
    t.rB = function (a, b, c, d) {
        F && (C(a, J, "snapToGrid:originx"), C(b, J, "snapToGrid:originy"), C(c, J, "snapToGrid:cellwidth"), C(d, J, "snapToGrid:cellheight"));
        K.Pq(this.G, this.H, a, b, c, d, this);
        return this
    };
    t.sB = function (a, b) {
        F && (w(a, J, J, "snapToGridPoint:p"), w(b, Hb, J, "snapToGridPoint:q"));
        K.Pq(this.G, this.H, a.x, a.y, b.width, b.height, this);
        return this
    };
    t.Ej = function (a, b) {
        F && (w(a, L, J, "setRectSpot:r"), w(b, M, J, "setRectSpot:spot"), this.ha());
        this.G = a.x + b.x * a.width + b.offsetX;
        this.H = a.y + b.y * a.height + b.offsetY;
        return this
    };
    t.al = function (a, b, c, d, e) {
        F && (C(a, J, "setSpot:x"), C(b, J, "setSpot:y"), C(c, J, "setSpot:w"), C(d, J, "setSpot:h"), (0 > c || 0 > d) && v("Point.setSpot:Width and height cannot be negative"), w(e, M, J, "setSpot:spot"), this.ha());
        this.G = a + e.x * c + e.offsetX;
        this.H = b + e.y * d + e.offsetY;
        return this
    };
    t.transform = function (a) {
        F && w(a, Ib, J, "transform:t");
        a.ya(this);
        return this
    };

    function Jb(a, b) {
        F && w(b, Ib, J, "transformInverted:t");
        b.Kd(a);
        return a
    }

    function Kb(a, b, c, d, e, f) {
        F && (C(a, J, "distanceLineSegmentSquared:px"), C(b, J, "distanceLineSegmentSquared:py"), C(c, J, "distanceLineSegmentSquared:ax"), C(d, J, "distanceLineSegmentSquared:ay"), C(e, J, "distanceLineSegmentSquared:bx"), C(f, J, "distanceLineSegmentSquared:by"));
        var g = e - c, h = f - d, k = g * g + h * h;
        c -= a;
        d -= b;
        var l = -c * g - d * h;
        if (0 >= l || l >= k) return g = e - a, h = f - b, Math.min(c * c + d * d, g * g + h * h);
        a = g * d - h * c;
        return a * a / k
    }

    function Lb(a, b, c, d) {
        F && (C(a, J, "distanceSquared:px"), C(b, J, "distanceSquared:py"), C(c, J, "distanceSquared:qx"), C(d, J, "distanceSquared:qy"));
        a = c - a;
        b = d - b;
        return a * a + b * b
    }

    function Mb(a, b, c, d) {
        F && (C(a, J, "direction:px"), C(b, J, "direction:py"), C(c, J, "direction:qx"), C(d, J, "direction:qy"));
        a = c - a;
        b = d - b;
        if (0 === a) return 0 < b ? 90 : 0 > b ? 270 : 0;
        if (0 === b) return 0 < a ? 0 : 180;
        if (isNaN(a) || isNaN(b)) return 0;
        d = 180 * Math.atan(Math.abs(b / a)) / Math.PI;
        0 > a ? d = 0 > b ? d + 180 : 180 - d : 0 > b && (d = 360 - d);
        return d
    }

    t.o = function () {
        return isFinite(this.x) && isFinite(this.y)
    };
    J.alloc = function () {
        var a = Nb.pop();
        return void 0 === a ? new J : a
    };
    J.allocAt = function (a, b) {
        var c = Nb.pop();
        if (void 0 === c) return new J(a, b);
        c.x = a;
        c.y = b;
        return c
    };
    J.free = function (a) {
        Nb.push(a)
    };
    na.Object.defineProperties(J.prototype, {
        x: {
            configurable: !0, get: function () {
                return this.G
            }, set: function (a) {
                F && (A(a, "number", J, "x"), this.ha(a));
                this.G = a
            }
        }, y: {
            configurable: !0, get: function () {
                return this.H
            }, set: function (a) {
                F && (A(a, "number", J, "y"), this.ha(a));
                this.H = a
            }
        }
    });
    J.prototype.isReal = J.prototype.o;
    J.prototype.setSpot = J.prototype.al;
    J.prototype.setRectSpot = J.prototype.Ej;
    J.prototype.snapToGridPoint = J.prototype.sB;
    J.prototype.snapToGrid = J.prototype.rB;
    J.prototype.projectOntoLineSegmentPoint = J.prototype.gB;
    J.prototype.projectOntoLineSegment = J.prototype.fB;
    J.intersectingLineSegments = function (a, b, c, d, e, f, g, h) {
        F && (C(a, L, "intersectingLineSegments:a1x"), C(b, L, "intersectingLineSegments:a1y"), C(c, L, "intersectingLineSegments:a2x"), C(d, L, "intersectingLineSegments:a2y"), C(e, L, "intersectingLineSegments:b1x"), C(f, L, "intersectingLineSegments:b1y"), C(g, L, "intersectingLineSegments:b2x"), C(h, L, "intersectingLineSegments:b2y"));
        return K.Xq(a, b, c, d, e, f, g, h)
    };
    J.prototype.direction = J.prototype.direction;
    J.prototype.directionPoint = J.prototype.Xa;
    J.prototype.normalize = J.prototype.normalize;
    J.prototype.distanceSquared = J.prototype.ud;
    J.prototype.distanceSquaredPoint = J.prototype.Re;
    J.prototype.scale = J.prototype.scale;
    J.prototype.rotate = J.prototype.rotate;
    J.prototype.offset = J.prototype.offset;
    J.prototype.subtract = J.prototype.ke;
    J.prototype.add = J.prototype.add;
    J.prototype.equalsApprox = J.prototype.Ta;
    J.prototype.equalTo = J.prototype.pj;
    J.prototype.equals = J.prototype.A;
    J.prototype.set = J.prototype.set;
    J.prototype.setTo = J.prototype.Vg;
    var Ob = null, Pb = null, Qb = null, Rb = null, Sb = null, Nb = [];
    J.className = "Point";
    J.parse = Eb;
    J.stringify = Fb;
    J.distanceLineSegmentSquared = Kb;
    J.distanceSquared = Lb;
    J.direction = Mb;
    J.Origin = Ob = (new J(0, 0)).ia();
    J.InfiniteTopLeft = Pb = (new J(-Infinity, -Infinity)).ia();
    J.InfiniteBottomRight = Qb = (new J(Infinity, Infinity)).ia();
    J.SixPoint = Rb = (new J(6, 6)).ia();
    J.NoPoint = Sb = (new J(NaN, NaN)).ia();
    J.parse = Eb;
    J.stringify = Fb;
    J.distanceLineSegmentSquared = Kb;
    J.distanceSquared = Lb;
    J.direction = Mb;

    function Hb(a, b) {
        void 0 === a ? this.ea = this.fa = 0 : "number" === typeof a && (0 <= a || isNaN(a)) && "number" === typeof b && (0 <= b || isNaN(b)) ? (this.fa = a, this.ea = b) : v("Invalid arguments to Size constructor: " + a + ", " + b);
        this.s = !1
    }

    var Tb, Ub, Vb, Wb, Zb, $b, ac;
    Hb.prototype.assign = function (a) {
        this.fa = a.fa;
        this.ea = a.ea;
        return this
    };
    Hb.prototype.h = function (a, b) {
        this.fa = a;
        this.ea = b;
        return this
    };
    Hb.prototype.Vg = function (a, b) {
        F && (A(a, "number", Hb, "setTo:w"), A(b, "number", Hb, "setTo:h"), 0 > a && za(a, ">= 0", Hb, "setTo:w"), 0 > b && za(b, ">= 0", Hb, "setTo:h"), this.ha());
        this.fa = a;
        this.ea = b;
        return this
    };
    Hb.prototype.set = function (a) {
        F && (w(a, Hb, Hb, "set:s"), this.ha());
        this.fa = a.fa;
        this.ea = a.ea;
        return this
    };
    Hb.prototype.copy = function () {
        var a = new Hb;
        a.fa = this.fa;
        a.ea = this.ea;
        return a
    };
    t = Hb.prototype;
    t.ia = function () {
        this.s = !0;
        Object.freeze(this);
        return this
    };
    t.J = function () {
        return this.s || Object.isFrozen(this) ? this : this.copy().freeze()
    };
    t.freeze = function () {
        this.s = !0;
        return this
    };
    t.ka = function () {
        Object.isFrozen(this) && v("cannot thaw constant: " + this);
        this.s = !1;
        return this
    };
    t.ha = function (a) {
        if (F && this.s) {
            var b = "The Size is frozen, so its properties cannot be set: " + this.toString();
            void 0 !== a && (b += "  to value: " + a);
            v(b)
        }
    };

    function bc(a) {
        if ("string" === typeof a) {
            a = a.split(" ");
            for (var b = 0, c = 0; "" === a[b];) b++;
            var d = a[b++];
            d && (c = parseFloat(d));
            for (var e = 0; "" === a[b];) b++;
            (d = a[b++]) && (e = parseFloat(d));
            return new Hb(c, e)
        }
        return new Hb
    }

    function cc(a) {
        F && w(a, Hb);
        return a.width.toString() + " " + a.height.toString()
    }

    t.toString = function () {
        return "Size(" + this.width + "," + this.height + ")"
    };
    t.A = function (a) {
        return a instanceof Hb ? this.fa === a.width && this.ea === a.height : !1
    };
    t.pj = function (a, b) {
        return this.fa === a && this.ea === b
    };
    t.Ta = function (a) {
        return K.C(this.fa, a.width) && K.C(this.ea, a.height)
    };
    t.o = function () {
        return isFinite(this.width) && isFinite(this.height)
    };
    Hb.alloc = function () {
        var a = dc.pop();
        return void 0 === a ? new Hb : a
    };
    Hb.free = function (a) {
        dc.push(a)
    };
    na.Object.defineProperties(Hb.prototype, {
        width: {
            configurable: !0, get: function () {
                return this.fa
            }, set: function (a) {
                F && (A(a, "number", Hb, "width"), this.ha(a));
                0 > a && za(a, ">= 0", Hb, "width");
                this.fa = a
            }
        }, height: {
            configurable: !0, get: function () {
                return this.ea
            }, set: function (a) {
                F && (A(a, "number", Hb, "height"), this.ha(a));
                0 > a && za(a, ">= 0", Hb, "height");
                this.ea = a
            }
        }
    });
    Hb.prototype.isReal = Hb.prototype.o;
    Hb.prototype.equalsApprox = Hb.prototype.Ta;
    Hb.prototype.equalTo = Hb.prototype.pj;
    Hb.prototype.equals = Hb.prototype.A;
    Hb.prototype.set = Hb.prototype.set;
    Hb.prototype.setTo = Hb.prototype.Vg;
    var dc = [];
    Hb.className = "Size";
    Hb.parse = bc;
    Hb.stringify = cc;
    Hb.ZeroSize = Tb = (new Hb(0, 0)).ia();
    Hb.OneSize = Ub = (new Hb(1, 1)).ia();
    Hb.SixSize = Vb = (new Hb(6, 6)).ia();
    Hb.EightSize = Wb = (new Hb(8, 8)).ia();
    Hb.TenSize = Zb = (new Hb(10, 10)).ia();
    Hb.InfiniteSize = $b = (new Hb(Infinity, Infinity)).ia();
    Hb.NoSize = ac = (new Hb(NaN, NaN)).ia();
    Hb.parse = bc;
    Hb.stringify = cc;

    function L(a, b, c, d) {
        void 0 === a ? this.ea = this.fa = this.H = this.G = 0 : a instanceof J ? (c = a.x, a = a.y, b instanceof J ? (d = b.x, b = b.y, this.G = Math.min(c, d), this.H = Math.min(a, b), this.fa = Math.abs(c - d), this.ea = Math.abs(a - b)) : b instanceof Hb ? (this.G = c, this.H = a, this.fa = b.width, this.ea = b.height) : v("Incorrect arguments supplied to Rect constructor")) : "number" === typeof a && "number" === typeof b && "number" === typeof c && (0 <= c || isNaN(c)) && "number" === typeof d && (0 <= d || isNaN(d)) ? (this.G = a, this.H = b, this.fa = c, this.ea = d) : v("Invalid arguments to Rect constructor: " +
            a + ", " + b + ", " + c + ", " + d);
        this.s = !1
    }

    t = L.prototype;
    t.assign = function (a) {
        this.G = a.G;
        this.H = a.H;
        this.fa = a.fa;
        this.ea = a.ea;
        return this
    };
    t.h = function (a, b, c, d) {
        this.G = a;
        this.H = b;
        this.fa = c;
        this.ea = d;
        return this
    };

    function ec(a, b, c) {
        a.fa = b;
        a.ea = c
    }

    t.Vg = function (a, b, c, d) {
        F && (A(a, "number", L, "setTo:x"), A(b, "number", L, "setTo:y"), A(c, "number", L, "setTo:w"), A(d, "number", L, "setTo:h"), 0 > c && za(c, ">= 0", L, "setTo:w"), 0 > d && za(d, ">= 0", L, "setTo:h"), this.ha());
        this.G = a;
        this.H = b;
        this.fa = c;
        this.ea = d;
        return this
    };
    t.set = function (a) {
        F && (w(a, L, L, "set:r"), this.ha());
        this.G = a.G;
        this.H = a.H;
        this.fa = a.fa;
        this.ea = a.ea;
        return this
    };
    t.Wc = function (a) {
        F && (w(a, J, L, "setPoint:p"), this.ha());
        this.G = a.x;
        this.H = a.y;
        return this
    };
    t.qB = function (a) {
        F && (w(a, Hb, L, "setSize:s"), this.ha());
        this.fa = a.width;
        this.ea = a.height;
        return this
    };
    L.prototype.copy = function () {
        var a = new L;
        a.G = this.G;
        a.H = this.H;
        a.fa = this.fa;
        a.ea = this.ea;
        return a
    };
    t = L.prototype;
    t.ia = function () {
        this.s = !0;
        Object.freeze(this);
        return this
    };
    t.J = function () {
        return this.s || Object.isFrozen(this) ? this : this.copy().freeze()
    };
    t.freeze = function () {
        this.s = !0;
        return this
    };
    t.ka = function () {
        Object.isFrozen(this) && v("cannot thaw constant: " + this);
        this.s = !1;
        return this
    };
    t.ha = function (a) {
        if (F && this.s) {
            var b = "The Rect is frozen, so its properties cannot be set: " + this.toString();
            void 0 !== a && (b += "  to value: " + a);
            v(b)
        }
    };

    function fc(a) {
        if ("string" === typeof a) {
            a = a.split(" ");
            for (var b = 0, c = 0; "" === a[b];) b++;
            var d = a[b++];
            d && (c = parseFloat(d));
            for (var e = 0; "" === a[b];) b++;
            (d = a[b++]) && (e = parseFloat(d));
            for (var f = 0; "" === a[b];) b++;
            (d = a[b++]) && (f = parseFloat(d));
            for (var g = 0; "" === a[b];) b++;
            (d = a[b++]) && (g = parseFloat(d));
            return new L(c, e, f, g)
        }
        return new L
    }

    function gc(a) {
        F && w(a, L);
        return a.x.toString() + " " + a.y.toString() + " " + a.width.toString() + " " + a.height.toString()
    }

    t.toString = function () {
        return "Rect(" + this.x + "," + this.y + "," + this.width + "," + this.height + ")"
    };
    t.A = function (a) {
        return a instanceof L ? this.G === a.x && this.H === a.y && this.fa === a.width && this.ea === a.height : !1
    };
    t.pj = function (a, b, c, d) {
        return this.G === a && this.H === b && this.fa === c && this.ea === d
    };
    t.Ta = function (a) {
        return K.C(this.G, a.x) && K.C(this.H, a.y) && K.C(this.fa, a.width) && K.C(this.ea, a.height)
    };

    function hc(a, b) {
        return K.da(a.G, b.x) && K.da(a.H, b.y) && K.da(a.fa, b.width) && K.da(a.ea, b.height)
    }

    t.ca = function (a) {
        F && w(a, J, L, "containsPoint:p");
        return this.G <= a.x && this.G + this.fa >= a.x && this.H <= a.y && this.H + this.ea >= a.y
    };
    t.Pe = function (a) {
        F && w(a, L, L, "containsRect:r");
        return this.G <= a.x && a.x + a.width <= this.G + this.fa && this.H <= a.y && a.y + a.height <= this.H + this.ea
    };
    t.contains = function (a, b, c, d) {
        F ? (C(a, L, "contains:x"), C(b, L, "contains:y"), void 0 === c ? c = 0 : C(c, L, "contains:w"), void 0 === d ? d = 0 : C(d, L, "contains:h"), (0 > c || 0 > d) && v("Rect.contains:Width and height cannot be negative")) : (void 0 === c && (c = 0), void 0 === d && (d = 0));
        return this.G <= a && a + c <= this.G + this.fa && this.H <= b && b + d <= this.H + this.ea
    };
    t.offset = function (a, b) {
        F && (C(a, L, "offset:dx"), C(b, L, "offset:dy"), this.ha());
        this.G += a;
        this.H += b;
        return this
    };
    t.Pc = function (a, b) {
        F && (C(a, L, "inflate:w"), C(b, L, "inflate:h"));
        return ic(this, b, a, b, a)
    };
    t.Dq = function (a) {
        F && w(a, jc, L, "addMargin:m");
        return ic(this, a.top, a.right, a.bottom, a.left)
    };
    t.Vw = function (a) {
        F && w(a, jc, L, "subtractMargin:m");
        return ic(this, -a.top, -a.right, -a.bottom, -a.left)
    };
    t.KA = function (a, b, c, d) {
        F && (C(a, L, "grow:t"), C(b, L, "grow:r"), C(c, L, "grow:b"), C(d, L, "grow:l"));
        return ic(this, a, b, c, d)
    };

    function ic(a, b, c, d, e) {
        F && a.ha();
        var f = a.fa;
        c + e <= -f ? (a.G += f / 2, a.fa = 0) : (a.G -= e, a.fa += c + e);
        c = a.ea;
        b + d <= -c ? (a.H += c / 2, a.ea = 0) : (a.H -= b, a.ea += b + d);
        return a
    }

    t.Sy = function (a) {
        F && w(a, L, L, "intersectRect:r");
        return kc(this, a.x, a.y, a.width, a.height)
    };
    t.nw = function (a, b, c, d) {
        F && (C(a, L, "intersect:x"), C(b, L, "intersect:y"), C(c, L, "intersect:w"), C(d, L, "intersect:h"), (0 > c || 0 > d) && v("Rect.intersect:Width and height cannot be negative"));
        return kc(this, a, b, c, d)
    };

    function kc(a, b, c, d, e) {
        F && a.ha();
        var f = Math.max(a.G, b), g = Math.max(a.H, c);
        b = Math.min(a.G + a.fa, b + d);
        c = Math.min(a.H + a.ea, c + e);
        a.G = f;
        a.H = g;
        a.fa = Math.max(0, b - f);
        a.ea = Math.max(0, c - g);
        return a
    }

    t.Sc = function (a) {
        F && w(a, L, L, "intersectsRect:r");
        return this.ow(a.x, a.y, a.width, a.height)
    };
    t.ow = function (a, b, c, d) {
        F && (C(a, L, "intersects:x"), C(b, L, "intersects:y"), C(a, L, "intersects:w"), C(b, L, "intersects:h"), (0 > c || 0 > d) && v("Rect.intersects:Width and height cannot be negative"));
        var e = this.fa, f = this.G;
        if (Infinity !== e && Infinity !== c && (e += f, c += a, isNaN(c) || isNaN(e) || f > c || a > e)) return !1;
        a = this.ea;
        c = this.H;
        return Infinity !== a && Infinity !== d && (a += c, d += b, isNaN(d) || isNaN(a) || c > d || b > a) ? !1 : !0
    };

    function lc(a, b) {
        var c = a.fa, d = a.G, e = b.x - 10;
        if (d > b.width + 10 + 10 + e || e > c + d) return !1;
        c = a.ea;
        a = a.H;
        d = b.y - 10;
        return a > b.height + 10 + 10 + d || d > c + a ? !1 : !0
    }

    t.Ze = function (a) {
        F && w(a, J, L, "unionPoint:p");
        return oc(this, a.x, a.y, 0, 0)
    };
    t.Yc = function (a) {
        F && w(a, L, L, "unionRect:r");
        return oc(this, a.G, a.H, a.fa, a.ea)
    };
    t.ex = function (a, b, c, d) {
        F ? (C(a, L, "union:x"), C(b, L, "union:y"), void 0 === c ? c = 0 : C(c, L, "union:w"), void 0 === d ? d = 0 : C(d, L, "union:h"), (0 > c || 0 > d) && v("Rect.union:Width and height cannot be negative"), this.ha()) : (void 0 === c && (c = 0), void 0 === d && (d = 0));
        return oc(this, a, b, c, d)
    };

    function oc(a, b, c, d, e) {
        var f = Math.min(a.G, b), g = Math.min(a.H, c);
        b = Math.max(a.G + a.fa, b + d);
        c = Math.max(a.H + a.ea, c + e);
        a.G = f;
        a.H = g;
        a.fa = b - f;
        a.ea = c - g;
        return a
    }

    t.al = function (a, b, c) {
        F && (C(a, L, "setSpot:x"), C(b, L, "setSpot:y"), w(c, M, L, "setSpot:spot"), this.ha());
        this.G = a - c.offsetX - c.x * this.fa;
        this.H = b - c.offsetY - c.y * this.ea;
        return this
    };

    function pc(a, b, c, d, e, f, g, h) {
        F ? (C(a, L, "contains:rx"), C(b, L, "contains:ry"), C(c, L, "contains:rw"), C(d, L, "contains:rh"), C(e, L, "contains:x"), C(f, L, "contains:y"), void 0 === g ? g = 0 : C(g, L, "contains:w"), void 0 === h ? h = 0 : C(h, L, "contains:h"), (0 > c || 0 > d || 0 > g || 0 > h) && v("Rect.contains:Width and height cannot be negative")) : (void 0 === g && (g = 0), void 0 === h && (h = 0));
        return a <= e && e + g <= a + c && b <= f && f + h <= b + d
    }

    function qc(a, b, c, d, e, f, g, h) {
        F && (C(a, L, "intersects:rx"), C(b, L, "intersects:ry"), C(c, L, "intersects:rw"), C(d, L, "intersects:rh"), C(e, L, "intersects:x"), C(f, L, "intersects:y"), C(g, L, "intersects:w"), C(h, L, "intersects:h"), (0 > c || 0 > d || 0 > g || 0 > h) && v("Rect.intersects:Width and height cannot be negative"));
        return a > g + e || e > c + a ? !1 : b > h + f || f > d + b ? !1 : !0
    }

    t.o = function () {
        return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height)
    };
    t.QA = function () {
        return 0 === this.width && 0 === this.height
    };
    L.alloc = function () {
        var a = tc.pop();
        return void 0 === a ? new L : a
    };
    L.allocAt = function (a, b, c, d) {
        var e = tc.pop();
        return void 0 === e ? new L(a, b, c, d) : e.h(a, b, c, d)
    };
    L.free = function (a) {
        tc.push(a)
    };
    na.Object.defineProperties(L.prototype, {
        x: {
            configurable: !0, get: function () {
                return this.G
            }, set: function (a) {
                F && (A(a, "number", L, "x"), this.ha(a));
                this.G = a
            }
        }, y: {
            configurable: !0, get: function () {
                return this.H
            }, set: function (a) {
                F && (A(a, "number", L, "y"), this.ha(a));
                this.H = a
            }
        }, width: {
            configurable: !0, get: function () {
                return this.fa
            }, set: function (a) {
                F && (A(a, "number", L, "width"), this.ha(a));
                0 > a && za(a, ">= 0", L, "width");
                this.fa = a
            }
        }, height: {
            configurable: !0, get: function () {
                return this.ea
            },
            set: function (a) {
                F && (A(a, "number", L, "height"), this.ha(a));
                0 > a && za(a, ">= 0", L, "height");
                this.ea = a
            }
        }, left: {
            configurable: !0, get: function () {
                return this.G
            }, set: function (a) {
                F && (A(a, "number", L, "left"), this.ha(a));
                this.G = a
            }
        }, top: {
            configurable: !0, get: function () {
                return this.H
            }, set: function (a) {
                F && (A(a, "number", L, "top"), this.ha(a));
                this.H = a
            }
        }, right: {
            configurable: !0, get: function () {
                return this.G + this.fa
            }, set: function (a) {
                F && (C(a, L, "right"), this.ha(a));
                this.G += a - (this.G + this.fa)
            }
        },
        bottom: {
            configurable: !0, get: function () {
                return this.H + this.ea
            }, set: function (a) {
                F && (C(a, L, "top"), this.ha(a));
                this.H += a - (this.H + this.ea)
            }
        }, position: {
            configurable: !0, get: function () {
                return new J(this.G, this.H)
            }, set: function (a) {
                F && (w(a, J, L, "position"), this.ha(a));
                this.G = a.x;
                this.H = a.y
            }
        }, size: {
            configurable: !0, get: function () {
                return new Hb(this.fa, this.ea)
            }, set: function (a) {
                F && (w(a, Hb, L, "size"), this.ha(a));
                this.fa = a.width;
                this.ea = a.height
            }
        }, center: {
            configurable: !0,
            enumerable: !0, get: function () {
                return new J(this.G + this.fa / 2, this.H + this.ea / 2)
            }, set: function (a) {
                F && (w(a, J, L, "center"), this.ha(a));
                this.G = a.x - this.fa / 2;
                this.H = a.y - this.ea / 2
            }
        }, centerX: {
            configurable: !0, get: function () {
                return this.G + this.fa / 2
            }, set: function (a) {
                F && (C(a, L, "centerX"), this.ha(a));
                this.G = a - this.fa / 2
            }
        }, centerY: {
            configurable: !0, get: function () {
                return this.H + this.ea / 2
            }, set: function (a) {
                F && (C(a, L, "centerY"), this.ha(a));
                this.H = a - this.ea / 2
            }
        }
    });
    L.prototype.isEmpty = L.prototype.QA;
    L.prototype.isReal = L.prototype.o;
    L.intersectsLineSegment = function (a, b, c, d, e, f, g, h) {
        F && (C(a, L, "intersectsLineSegment:x"), C(b, L, "intersectsLineSegment:y"), C(c, L, "intersectsLineSegment:w"), C(d, L, "intersectsLineSegment:h"), C(e, L, "intersectsLineSegment:p1x"), C(f, L, "intersectsLineSegment:p1y"), C(g, L, "intersectsLineSegment:p2x"), C(h, L, "intersectsLineSegment:p2y"), (0 > c || 0 > d) && v("Rect.intersectsLineSegment: width and height cannot be negative"));
        return K.Ty(a, b, c, d, e, f, g, h)
    };
    L.prototype.setSpot = L.prototype.al;
    L.prototype.union = L.prototype.ex;
    L.prototype.unionRect = L.prototype.Yc;
    L.prototype.unionPoint = L.prototype.Ze;
    L.prototype.intersects = L.prototype.ow;
    L.prototype.intersectsRect = L.prototype.Sc;
    L.prototype.intersect = L.prototype.nw;
    L.prototype.intersectRect = L.prototype.Sy;
    L.prototype.grow = L.prototype.KA;
    L.prototype.subtractMargin = L.prototype.Vw;
    L.prototype.addMargin = L.prototype.Dq;
    L.prototype.inflate = L.prototype.Pc;
    L.prototype.offset = L.prototype.offset;
    L.prototype.contains = L.prototype.contains;
    L.prototype.containsRect = L.prototype.Pe;
    L.prototype.containsPoint = L.prototype.ca;
    L.prototype.equalsApprox = L.prototype.Ta;
    L.prototype.equalTo = L.prototype.pj;
    L.prototype.equals = L.prototype.A;
    L.prototype.setSize = L.prototype.qB;
    L.prototype.setPoint = L.prototype.Wc;
    L.prototype.set = L.prototype.set;
    L.prototype.setTo = L.prototype.Vg;
    var uc = null, vc = null, tc = [];
    L.className = "Rect";
    L.parse = fc;
    L.stringify = gc;
    L.contains = pc;
    L.intersects = qc;
    L.ZeroRect = uc = (new L(0, 0, 0, 0)).ia();
    L.NoRect = vc = (new L(NaN, NaN, NaN, NaN)).ia();
    L.parse = fc;
    L.stringify = gc;
    L.contains = pc;
    L.intersects = qc;

    function jc(a, b, c, d) {
        void 0 === a ? this.Be = this.oe = this.Ke = this.Me = 0 : void 0 === b ? this.left = this.bottom = this.right = this.top = a : void 0 === c ? (this.top = a, this.right = b, this.bottom = a, this.left = b) : void 0 !== d ? (this.top = a, this.right = b, this.bottom = c, this.left = d) : v("Invalid arguments to Margin constructor: " + a + ", " + b + ", " + c + ", " + d);
        this.s = !1
    }

    jc.prototype.assign = function (a) {
        this.Me = a.Me;
        this.Ke = a.Ke;
        this.oe = a.oe;
        this.Be = a.Be;
        return this
    };
    jc.prototype.Vg = function (a, b, c, d) {
        F && (A(a, "number", jc, "setTo:t"), A(b, "number", jc, "setTo:r"), A(c, "number", jc, "setTo:b"), A(d, "number", jc, "setTo:l"), this.ha());
        this.Me = a;
        this.Ke = b;
        this.oe = c;
        this.Be = d;
        return this
    };
    jc.prototype.set = function (a) {
        F && (w(a, jc, jc, "assign:m"), this.ha());
        this.Me = a.Me;
        this.Ke = a.Ke;
        this.oe = a.oe;
        this.Be = a.Be;
        return this
    };
    jc.prototype.copy = function () {
        var a = new jc;
        a.Me = this.Me;
        a.Ke = this.Ke;
        a.oe = this.oe;
        a.Be = this.Be;
        return a
    };
    t = jc.prototype;
    t.ia = function () {
        this.s = !0;
        Object.freeze(this);
        return this
    };
    t.J = function () {
        return this.s || Object.isFrozen(this) ? this : this.copy().freeze()
    };
    t.freeze = function () {
        this.s = !0;
        return this
    };
    t.ka = function () {
        Object.isFrozen(this) && v("cannot thaw constant: " + this);
        this.s = !1;
        return this
    };
    t.ha = function (a) {
        if (F && this.s) {
            var b = "The Margin is frozen, so its properties cannot be set: " + this.toString();
            void 0 !== a && (b += "  to value: " + a);
            v(b)
        }
    };

    function wc(a) {
        if ("string" === typeof a) {
            a = a.split(" ");
            for (var b = 0, c = NaN; "" === a[b];) b++;
            var d = a[b++];
            d && (c = parseFloat(d));
            if (isNaN(c)) return new jc;
            for (var e = NaN; "" === a[b];) b++;
            (d = a[b++]) && (e = parseFloat(d));
            if (isNaN(e)) return new jc(c);
            for (var f = NaN; "" === a[b];) b++;
            (d = a[b++]) && (f = parseFloat(d));
            if (isNaN(f)) return new jc(c, e);
            for (var g = NaN; "" === a[b];) b++;
            (d = a[b++]) && (g = parseFloat(d));
            return isNaN(g) ? new jc(c, e) : new jc(c, e, f, g)
        }
        return new jc
    }

    function xc(a) {
        F && w(a, jc);
        return a.top.toString() + " " + a.right.toString() + " " + a.bottom.toString() + " " + a.left.toString()
    }

    t.toString = function () {
        return "Margin(" + this.top + "," + this.right + "," + this.bottom + "," + this.left + ")"
    };
    t.A = function (a) {
        return a instanceof jc ? this.Me === a.top && this.Ke === a.right && this.oe === a.bottom && this.Be === a.left : !1
    };
    t.pj = function (a, b, c, d) {
        return this.Me === a && this.Ke === b && this.oe === c && this.Be === d
    };
    t.Ta = function (a) {
        return K.C(this.Me, a.top) && K.C(this.Ke, a.right) && K.C(this.oe, a.bottom) && K.C(this.Be, a.left)
    };
    t.o = function () {
        return isFinite(this.top) && isFinite(this.right) && isFinite(this.bottom) && isFinite(this.left)
    };
    jc.alloc = function () {
        var a = yc.pop();
        return void 0 === a ? new jc : a
    };
    jc.free = function (a) {
        yc.push(a)
    };
    na.Object.defineProperties(jc.prototype, {
        top: {
            configurable: !0, get: function () {
                return this.Me
            }, set: function (a) {
                F && (C(a, jc, "top"), this.ha(a));
                this.Me = a
            }
        }, right: {
            configurable: !0, get: function () {
                return this.Ke
            }, set: function (a) {
                F && (C(a, jc, "right"), this.ha(a));
                this.Ke = a
            }
        }, bottom: {
            configurable: !0, get: function () {
                return this.oe
            }, set: function (a) {
                F && (C(a, jc, "bottom"), this.ha(a));
                this.oe = a
            }
        }, left: {
            configurable: !0, get: function () {
                return this.Be
            }, set: function (a) {
                F &&
                (C(a, jc, "left"), this.ha(a));
                this.Be = a
            }
        }
    });
    jc.prototype.isReal = jc.prototype.o;
    jc.prototype.equalsApprox = jc.prototype.Ta;
    jc.prototype.equalTo = jc.prototype.pj;
    jc.prototype.equals = jc.prototype.A;
    jc.prototype.set = jc.prototype.set;
    jc.prototype.setTo = jc.prototype.Vg;
    var zc = null, Dc = null, yc = [];
    jc.className = "Margin";
    jc.parse = wc;
    jc.stringify = xc;
    jc.ZeroMargin = zc = (new jc(0, 0, 0, 0)).ia();
    jc.TwoMargin = Dc = (new jc(2, 2, 2, 2)).ia();
    jc.parse = wc;
    jc.stringify = xc;

    function M(a, b, c, d) {
        void 0 === a ? this.ce = this.be = this.H = this.G = 0 : (void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = 0), this.x = a, this.y = b, this.offsetX = c, this.offsetY = d);
        this.s = !1
    }

    var Ec, Fc, Gc, Hc, Lc, Mc, Nc, Oc, Pc, Rc, Sc, Tc, Uc, Vc, Wc, Xc, Yc, Zc, ad, bd, cd, dd, ed, fd, gd, jd, kd, ld,
        md, nd, od, pd, qd, rd, sd, td;
    M.prototype.assign = function (a) {
        this.G = a.G;
        this.H = a.H;
        this.be = a.be;
        this.ce = a.ce;
        return this
    };
    M.prototype.Vg = function (a, b, c, d) {
        F && (ud(a, "setTo:x"), ud(b, "setTo:y"), vd(c, "setTo:offx"), vd(d, "setTo:offy"), this.ha());
        this.G = a;
        this.H = b;
        this.be = c;
        this.ce = d;
        return this
    };
    M.prototype.set = function (a) {
        F && (w(a, M, M, "set:s"), this.ha());
        this.G = a.G;
        this.H = a.H;
        this.be = a.be;
        this.ce = a.ce;
        return this
    };
    M.prototype.copy = function () {
        var a = new M;
        a.G = this.G;
        a.H = this.H;
        a.be = this.be;
        a.ce = this.ce;
        return a
    };
    t = M.prototype;
    t.ia = function () {
        this.s = !0;
        Object.freeze(this);
        return this
    };
    t.J = function () {
        return this.s || Object.isFrozen(this) ? this : this.copy().freeze()
    };
    t.freeze = function () {
        this.s = !0;
        return this
    };
    t.ka = function () {
        Object.isFrozen(this) && v("cannot thaw constant: " + this);
        this.s = !1;
        return this
    };
    t.ha = function (a) {
        if (F && this.s) {
            var b = "The Spot is frozen, so its properties cannot be set: " + this.toString();
            void 0 !== a && (b += "  to value: " + a);
            v(b)
        }
    };

    function wd(a, b) {
        a.G = NaN;
        a.H = NaN;
        a.be = b;
        return a
    }

    function ud(a, b) {
        (isNaN(a) || 1 < a || 0 > a) && za(a, "0 <= " + b + " <= 1", M, b)
    }

    function vd(a, b) {
        (isNaN(a) || Infinity === a || -Infinity === a) && za(a, "real number, not NaN or Infinity", M, b)
    }

    function xd(a) {
        if ("string" === typeof a) {
            a = a.trim();
            if ("None" === a) return Ec;
            if ("TopLeft" === a) return Fc;
            if ("Top" === a || "TopCenter" === a || "MiddleTop" === a) return Gc;
            if ("TopRight" === a) return Hc;
            if ("Left" === a || "LeftCenter" === a || "MiddleLeft" === a) return Lc;
            if ("Center" === a) return Mc;
            if ("Right" === a || "RightCenter" === a || "MiddleRight" === a) return Nc;
            if ("BottomLeft" === a) return Oc;
            if ("Bottom" === a || "BottomCenter" === a || "MiddleBottom" === a) return Pc;
            if ("BottomRight" === a) return Rc;
            if ("TopSide" === a) return Sc;
            if ("LeftSide" ===
                a) return Tc;
            if ("RightSide" === a) return Uc;
            if ("BottomSide" === a) return Vc;
            if ("TopBottomSides" === a) return Wc;
            if ("LeftRightSides" === a) return Xc;
            if ("TopLeftSides" === a) return Yc;
            if ("TopRightSides" === a) return Zc;
            if ("BottomLeftSides" === a) return ad;
            if ("BottomRightSides" === a) return bd;
            if ("NotTopSide" === a) return cd;
            if ("NotLeftSide" === a) return dd;
            if ("NotRightSide" === a) return ed;
            if ("NotBottomSide" === a) return fd;
            if ("AllSides" === a) return gd;
            if ("Default" === a) return jd;
            a = a.split(" ");
            for (var b = 0, c = 0; "" === a[b];) b++;
            var d = a[b++];
            void 0 !== d && 0 < d.length && (c = parseFloat(d));
            for (var e = 0; "" === a[b];) b++;
            d = a[b++];
            void 0 !== d && 0 < d.length && (e = parseFloat(d));
            for (var f = 0; "" === a[b];) b++;
            d = a[b++];
            void 0 !== d && 0 < d.length && (f = parseFloat(d));
            for (var g = 0; "" === a[b];) b++;
            d = a[b++];
            void 0 !== d && 0 < d.length && (g = parseFloat(d));
            return new M(c, e, f, g)
        }
        return new M
    }

    function yd(a) {
        F && w(a, M);
        return a.cb() ? a.x.toString() + " " + a.y.toString() + " " + a.offsetX.toString() + " " + a.offsetY.toString() : a.toString()
    }

    t.toString = function () {
        return this.cb() ? 0 === this.be && 0 === this.ce ? "Spot(" + this.x + "," + this.y + ")" : "Spot(" + this.x + "," + this.y + "," + this.offsetX + "," + this.offsetY + ")" : this.A(Ec) ? "None" : this.A(Fc) ? "TopLeft" : this.A(Gc) ? "Top" : this.A(Hc) ? "TopRight" : this.A(Lc) ? "Left" : this.A(Mc) ? "Center" : this.A(Nc) ? "Right" : this.A(Oc) ? "BottomLeft" : this.A(Pc) ? "Bottom" : this.A(Rc) ? "BottomRight" : this.A(Sc) ? "TopSide" : this.A(Tc) ? "LeftSide" : this.A(Uc) ? "RightSide" : this.A(Vc) ? "BottomSide" : this.A(Wc) ? "TopBottomSides" : this.A(Xc) ? "LeftRightSides" :
            this.A(Yc) ? "TopLeftSides" : this.A(Zc) ? "TopRightSides" : this.A(ad) ? "BottomLeftSides" : this.A(bd) ? "BottomRightSides" : this.A(cd) ? "NotTopSide" : this.A(dd) ? "NotLeftSide" : this.A(ed) ? "NotRightSide" : this.A(fd) ? "NotBottomSide" : this.A(gd) ? "AllSides" : this.A(jd) ? "Default" : "None"
    };
    t.A = function (a) {
        return a instanceof M ? (this.G === a.x || isNaN(this.G) && isNaN(a.x)) && (this.H === a.y || isNaN(this.H) && isNaN(a.y)) && this.be === a.offsetX && this.ce === a.offsetY : !1
    };
    t.ww = function () {
        return new M(.5 - (this.G - .5), .5 - (this.H - .5), -this.be, -this.ce)
    };
    t.Qf = function (a) {
        if (!this.Uc()) return !1;
        if (!a.Uc()) if (a.A(kd)) a = Tc; else if (a.A(ld)) a = Uc; else if (a.A(md)) a = Sc; else if (a.A(nd)) a = Vc; else return !1;
        a = a.offsetY;
        return (this.ce & a) === a
    };
    t.cb = function () {
        return !isNaN(this.x) && !isNaN(this.y)
    };
    t.Tb = function () {
        return isNaN(this.x) || isNaN(this.y)
    };
    t.Uc = function () {
        return isNaN(this.x) && isNaN(this.y) && 1 === this.offsetX && 0 !== this.offsetY
    };
    t.Zq = function () {
        return isNaN(this.x) && isNaN(this.y) && 0 === this.offsetX && 0 === this.offsetY
    };
    t.Jb = function () {
        return isNaN(this.x) && isNaN(this.y) && -1 === this.offsetX && 0 === this.offsetY
    };
    M.alloc = function () {
        var a = zd.pop();
        return void 0 === a ? new M : a
    };
    M.free = function (a) {
        zd.push(a)
    };
    na.Object.defineProperties(M.prototype, {
        x: {
            configurable: !0, get: function () {
                return this.G
            }, set: function (a) {
                F && (ud(a, "x"), this.ha(a));
                this.G = a
            }
        }, y: {
            configurable: !0, get: function () {
                return this.H
            }, set: function (a) {
                F && (ud(a, "y"), this.ha(a));
                this.H = a
            }
        }, offsetX: {
            configurable: !0, get: function () {
                return this.be
            }, set: function (a) {
                F && (vd(a, "offsetX"), this.ha(a));
                this.be = a
            }
        }, offsetY: {
            configurable: !0, get: function () {
                return this.ce
            }, set: function (a) {
                F && (vd(a, "offsetY"),
                    this.ha(a));
                this.ce = a
            }
        }
    });
    M.prototype.isDefault = M.prototype.Jb;
    M.prototype.isNone = M.prototype.Zq;
    M.prototype.isSide = M.prototype.Uc;
    M.prototype.isNoSpot = M.prototype.Tb;
    M.prototype.isSpot = M.prototype.cb;
    M.prototype.includesSide = M.prototype.Qf;
    M.prototype.opposite = M.prototype.ww;
    M.prototype.equals = M.prototype.A;
    M.prototype.set = M.prototype.set;
    M.prototype.setTo = M.prototype.Vg;
    var zd = [];
    M.className = "Spot";
    M.parse = xd;
    M.stringify = yd;
    M.None = Ec = wd(new M(0, 0, 0, 0), 0).ia();
    M.Default = jd = wd(new M(0, 0, -1, 0), -1).ia();
    M.TopLeft = Fc = (new M(0, 0, 0, 0)).ia();
    M.TopCenter = Gc = (new M(.5, 0, 0, 0)).ia();
    M.TopRight = Hc = (new M(1, 0, 0, 0)).ia();
    M.LeftCenter = Lc = (new M(0, .5, 0, 0)).ia();
    M.Center = Mc = (new M(.5, .5, 0, 0)).ia();
    M.RightCenter = Nc = (new M(1, .5, 0, 0)).ia();
    M.BottomLeft = Oc = (new M(0, 1, 0, 0)).ia();
    M.BottomCenter = Pc = (new M(.5, 1, 0, 0)).ia();
    M.BottomRight = Rc = (new M(1, 1, 0, 0)).ia();
    M.MiddleTop = od = Gc;
    M.MiddleLeft = pd = Lc;
    M.MiddleRight = qd = Nc;
    M.MiddleBottom = rd = Pc;
    M.Top = md = Gc;
    M.Left = kd = Lc;
    M.Right = ld = Nc;
    M.Bottom = nd = Pc;
    M.TopSide = Sc = wd(new M(0, 0, 1, 1), 1).ia();
    M.LeftSide = Tc = wd(new M(0, 0, 1, 2), 1).ia();
    M.RightSide = Uc = wd(new M(0, 0, 1, 4), 1).ia();
    M.BottomSide = Vc = wd(new M(0, 0, 1, 8), 1).ia();
    M.TopBottomSides = Wc = wd(new M(0, 0, 1, 9), 1).ia();
    M.LeftRightSides = Xc = wd(new M(0, 0, 1, 6), 1).ia();
    M.TopLeftSides = Yc = wd(new M(0, 0, 1, 3), 1).ia();
    M.TopRightSides = Zc = wd(new M(0, 0, 1, 5), 1).ia();
    M.BottomLeftSides = ad = wd(new M(0, 0, 1, 10), 1).ia();
    M.BottomRightSides = bd = wd(new M(0, 0, 1, 12), 1).ia();
    M.NotTopSide = cd = wd(new M(0, 0, 1, 14), 1).ia();
    M.NotLeftSide = dd = wd(new M(0, 0, 1, 13), 1).ia();
    M.NotRightSide = ed = wd(new M(0, 0, 1, 11), 1).ia();
    M.NotBottomSide = fd = wd(new M(0, 0, 1, 7), 1).ia();
    M.AllSides = gd = wd(new M(0, 0, 1, 15), 1).ia();
    sd = (new M(.156, .156)).ia();
    td = (new M(.844, .844)).ia();
    M.parse = xd;
    M.stringify = yd;

    function Ib() {
        this.m11 = 1;
        this.m21 = this.m12 = 0;
        this.m22 = 1;
        this.dy = this.dx = 0
    }

    Ib.prototype.set = function (a) {
        this.m11 = a.m11;
        this.m12 = a.m12;
        this.m21 = a.m21;
        this.m22 = a.m22;
        this.dx = a.dx;
        this.dy = a.dy;
        return this
    };
    Ib.prototype.copy = function () {
        var a = new Ib;
        a.m11 = this.m11;
        a.m12 = this.m12;
        a.m21 = this.m21;
        a.m22 = this.m22;
        a.dx = this.dx;
        a.dy = this.dy;
        return a
    };
    t = Ib.prototype;
    t.toString = function () {
        return "Transform(" + this.m11 + "," + this.m12 + "," + this.m21 + "," + this.m22 + "," + this.dx + "," + this.dy + ")"
    };
    t.A = function (a) {
        return this.m11 === a.m11 && this.m12 === a.m12 && this.m21 === a.m21 && this.m22 === a.m22 && this.dx === a.dx && this.dy === a.dy
    };
    t.fu = function () {
        return 0 === this.dx && 0 === this.dy && 1 === this.m11 && 0 === this.m12 && 0 === this.m21 && 1 === this.m22
    };
    t.reset = function () {
        this.m11 = 1;
        this.m21 = this.m12 = 0;
        this.m22 = 1;
        this.dy = this.dx = 0;
        return this
    };
    t.multiply = function (a) {
        var b = this.m11 * a.m11 + this.m21 * a.m12, c = this.m12 * a.m11 + this.m22 * a.m12,
            d = this.m11 * a.m21 + this.m21 * a.m22, e = this.m12 * a.m21 + this.m22 * a.m22;
        this.dx = this.m11 * a.dx + this.m21 * a.dy + this.dx;
        this.dy = this.m12 * a.dx + this.m22 * a.dy + this.dy;
        this.m11 = b;
        this.m12 = c;
        this.m21 = d;
        this.m22 = e;
        return this
    };
    t.uw = function (a) {
        var b = 1 / (a.m11 * a.m22 - a.m12 * a.m21), c = a.m22 * b, d = -a.m12 * b, e = -a.m21 * b, f = a.m11 * b,
            g = b * (a.m21 * a.dy - a.m22 * a.dx);
        a = b * (a.m12 * a.dx - a.m11 * a.dy);
        b = this.m11 * c + this.m21 * d;
        c = this.m12 * c + this.m22 * d;
        d = this.m11 * e + this.m21 * f;
        e = this.m12 * e + this.m22 * f;
        this.dx = this.m11 * g + this.m21 * a + this.dx;
        this.dy = this.m12 * g + this.m22 * a + this.dy;
        this.m11 = b;
        this.m12 = c;
        this.m21 = d;
        this.m22 = e;
        return this
    };
    t.du = function () {
        var a = 1 / (this.m11 * this.m22 - this.m12 * this.m21), b = -this.m12 * a, c = -this.m21 * a, d = this.m11 * a,
            e = a * (this.m21 * this.dy - this.m22 * this.dx), f = a * (this.m12 * this.dx - this.m11 * this.dy);
        this.m11 = this.m22 * a;
        this.m12 = b;
        this.m21 = c;
        this.m22 = d;
        this.dx = e;
        this.dy = f;
        return this
    };
    Ib.prototype.rotate = function (a, b, c) {
        F && (C(a, Ib, "rotate:angle"), C(b, Ib, "rotate:rx"), C(c, Ib, "rotate:ry"));
        360 <= a ? a -= 360 : 0 > a && (a += 360);
        if (0 === a) return this;
        this.translate(b, c);
        if (90 === a) {
            a = 0;
            var d = 1
        } else 180 === a ? (a = -1, d = 0) : 270 === a ? (a = 0, d = -1) : (d = a * Math.PI / 180, a = Math.cos(d), d = Math.sin(d));
        var e = this.m12 * a + this.m22 * d, f = this.m11 * -d + this.m21 * a, g = this.m12 * -d + this.m22 * a;
        this.m11 = this.m11 * a + this.m21 * d;
        this.m12 = e;
        this.m21 = f;
        this.m22 = g;
        this.translate(-b, -c);
        return this
    };
    t = Ib.prototype;
    t.translate = function (a, b) {
        F && (C(a, Ib, "translate:x"), C(b, Ib, "translate:y"));
        this.dx += this.m11 * a + this.m21 * b;
        this.dy += this.m12 * a + this.m22 * b;
        return this
    };
    t.scale = function (a, b) {
        void 0 === b && (b = a);
        F && (C(a, Ib, "translate:sx"), C(b, Ib, "translate:sy"));
        this.m11 *= a;
        this.m12 *= a;
        this.m21 *= b;
        this.m22 *= b;
        return this
    };
    t.ya = function (a) {
        var b = a.x, c = a.y;
        return a.h(b * this.m11 + c * this.m21 + this.dx, b * this.m12 + c * this.m22 + this.dy)
    };
    t.Kd = function (a) {
        var b = 1 / (this.m11 * this.m22 - this.m12 * this.m21), c = a.x, d = a.y;
        return a.h(c * this.m22 * b + d * -this.m21 * b + b * (this.m21 * this.dy - this.m22 * this.dx), c * -this.m12 * b + d * this.m11 * b + b * (this.m12 * this.dx - this.m11 * this.dy))
    };
    t.py = function (a) {
        var b = 1 / (this.m11 * this.m22 - this.m12 * this.m21), c = 1.25 * a.x, d = 1.2 * a.y;
        return a.h(c * this.m22 * b + d * -this.m21 * b + b * (this.m21 * this.dy - this.m22 * this.dx), c * -this.m12 * b + d * this.m11 * b + b * (this.m12 * this.dx - this.m11 * this.dy))
    };
    t.ax = function (a) {
        var b = a.x, c = a.y, d = b + a.width, e = c + a.height, f = this.m11, g = this.m12, h = this.m21, k = this.m22,
            l = this.dx, m = this.dy, n = b * f + c * h + l, p = b * g + c * k + m, r = d * f + c * h + l,
            q = d * g + c * k + m;
        c = b * f + e * h + l;
        b = b * g + e * k + m;
        f = d * f + e * h + l;
        d = d * g + e * k + m;
        e = Math.min(n, r);
        n = Math.max(n, r);
        r = Math.min(p, q);
        p = Math.max(p, q);
        e = Math.min(e, c);
        n = Math.max(n, c);
        r = Math.min(r, b);
        p = Math.max(p, b);
        e = Math.min(e, f);
        n = Math.max(n, f);
        r = Math.min(r, d);
        p = Math.max(p, d);
        a.h(e, r, n - e, p - r);
        return a
    };
    Ib.alloc = function () {
        var a = Gd.pop();
        return void 0 === a ? new Ib : a
    };
    Ib.free = function (a) {
        Gd.push(a)
    };
    Ib.prototype.transformRect = Ib.prototype.ax;
    Ib.prototype.transformPoint = Ib.prototype.ya;
    Ib.prototype.scale = Ib.prototype.scale;
    Ib.prototype.translate = Ib.prototype.translate;
    Ib.prototype.rotate = Ib.prototype.rotate;
    Ib.prototype.invert = Ib.prototype.du;
    Ib.prototype.multiplyInverted = Ib.prototype.uw;
    Ib.prototype.multiply = Ib.prototype.multiply;
    Ib.prototype.reset = Ib.prototype.reset;
    Ib.prototype.isIdentity = Ib.prototype.fu;
    Ib.prototype.equals = Ib.prototype.A;
    Ib.prototype.set = Ib.prototype.set;
    var Gd = [];
    Ib.className = "Transform";
    Ib.xF = "54a702f3e53909c447824c6706603faf4c";
    var K = {
        AB: "7da71ca0ad381e90", Xg: (Math.sqrt(2) - 1) / 3 * 4, wx: null, sqrt: function (a) {
            if (0 >= a) return 0;
            var b = K.wx;
            if (null === b) {
                b = [];
                for (var c = 0; 2E3 >= c; c++) b[c] = Math.sqrt(c);
                K.wx = b
            }
            return 1 > a ? (c = 1 / a, 2E3 >= c ? 1 / b[c | 0] : Math.sqrt(a)) : 2E3 >= a ? b[a | 0] : Math.sqrt(a)
        }, C: function (a, b) {
            a -= b;
            return .5 > a && -.5 < a
        }, da: function (a, b) {
            a -= b;
            return 5E-8 > a && -5E-8 < a
        }, Ub: function (a, b, c, d, e, f, g) {
            0 >= e && (e = 1E-6);
            if (a < c) {
                var h = a;
                var k = c
            } else h = c, k = a;
            if (b < d) {
                var l = b;
                var m = d
            } else l = d, m = b;
            if (a === c) return l <= g && g <= m && a - e <= f && f <= a + e;
            if (b === d) return h <=
                f && f <= k && b - e <= g && g <= b + e;
            k += e;
            h -= e;
            if (h <= f && f <= k && (m += e, l -= e, l <= g && g <= m)) if (k - h > m - l) if (a - c > e || c - a > e) {
                if (f = (d - b) / (c - a) * (f - a) + b, f - e <= g && g <= f + e) return !0
            } else return !0; else if (b - d > e || d - b > e) {
                if (g = (c - a) / (d - b) * (g - b) + a, g - e <= f && f <= g + e) return !0
            } else return !0;
            return !1
        }, Jt: function (a, b, c, d, e, f, g, h, k, l, m, n) {
            if (K.Ub(a, b, g, h, n, c, d) && K.Ub(a, b, g, h, n, e, f)) return K.Ub(a, b, g, h, n, l, m);
            var p = (a + c) / 2, r = (b + d) / 2, q = (c + e) / 2, u = (d + f) / 2;
            e = (e + g) / 2;
            f = (f + h) / 2;
            d = (p + q) / 2;
            c = (r + u) / 2;
            q = (q + e) / 2;
            u = (u + f) / 2;
            var x = (d + q) / 2, y = (c + u) / 2;
            return K.Jt(a,
                b, p, r, d, c, x, y, k, l, m, n) || K.Jt(x, y, q, u, e, f, g, h, k, l, m, n)
        }, Nz: function (a, b, c, d, e, f, g, h, k) {
            var l = (c + e) / 2, m = (d + f) / 2;
            k.h((((a + c) / 2 + l) / 2 + (l + (e + g) / 2) / 2) / 2, (((b + d) / 2 + m) / 2 + (m + (f + h) / 2) / 2) / 2);
            return k
        }, Mz: function (a, b, c, d, e, f, g, h) {
            var k = (c + e) / 2, l = (d + f) / 2;
            return Mb(((a + c) / 2 + k) / 2, ((b + d) / 2 + l) / 2, (k + (e + g) / 2) / 2, (l + (f + h) / 2) / 2)
        }, Fm: function (a, b, c, d, e, f, g, h, k, l) {
            if (K.Ub(a, b, g, h, k, c, d) && K.Ub(a, b, g, h, k, e, f)) oc(l, a, b, 0, 0), oc(l, g, h, 0, 0); else {
                var m = (a + c) / 2, n = (b + d) / 2, p = (c + e) / 2, r = (d + f) / 2;
                e = (e + g) / 2;
                f = (f + h) / 2;
                d = (m + p) / 2;
                c = (n + r) /
                    2;
                p = (p + e) / 2;
                r = (r + f) / 2;
                var q = (d + p) / 2, u = (c + r) / 2;
                K.Fm(a, b, m, n, d, c, q, u, k, l);
                K.Fm(q, u, p, r, e, f, g, h, k, l)
            }
            return l
        }, Oe: function (a, b, c, d, e, f, g, h, k, l) {
            if (K.Ub(a, b, g, h, k, c, d) && K.Ub(a, b, g, h, k, e, f)) 0 === l.length && (l.push(a), l.push(b)), l.push(g), l.push(h); else {
                var m = (a + c) / 2, n = (b + d) / 2, p = (c + e) / 2, r = (d + f) / 2;
                e = (e + g) / 2;
                f = (f + h) / 2;
                d = (m + p) / 2;
                c = (n + r) / 2;
                p = (p + e) / 2;
                r = (r + f) / 2;
                var q = (d + p) / 2, u = (c + r) / 2;
                K.Oe(a, b, m, n, d, c, q, u, k, l);
                K.Oe(q, u, p, r, e, f, g, h, k, l)
            }
            return l
        }, Aw: function (a, b, c, d, e, f, g, h, k, l) {
            if (K.Ub(a, b, e, f, l, c, d)) return K.Ub(a,
                b, e, f, l, h, k);
            var m = (a + c) / 2, n = (b + d) / 2;
            c = (c + e) / 2;
            d = (d + f) / 2;
            var p = (m + c) / 2, r = (n + d) / 2;
            return K.Aw(a, b, m, n, p, r, g, h, k, l) || K.Aw(p, r, c, d, e, f, g, h, k, l)
        }, KB: function (a, b, c, d, e, f, g) {
            g.h(((a + c) / 2 + (c + e) / 2) / 2, ((b + d) / 2 + (d + f) / 2) / 2);
            return g
        }, zw: function (a, b, c, d, e, f, g, h) {
            if (K.Ub(a, b, e, f, g, c, d)) oc(h, a, b, 0, 0), oc(h, e, f, 0, 0); else {
                var k = (a + c) / 2, l = (b + d) / 2;
                c = (c + e) / 2;
                d = (d + f) / 2;
                var m = (k + c) / 2, n = (l + d) / 2;
                K.zw(a, b, k, l, m, n, g, h);
                K.zw(m, n, c, d, e, f, g, h)
            }
            return h
        }, hr: function (a, b, c, d, e, f, g, h) {
            if (K.Ub(a, b, e, f, g, c, d)) 0 === h.length && (h.push(a),
                h.push(b)), h.push(e), h.push(f); else {
                var k = (a + c) / 2, l = (b + d) / 2;
                c = (c + e) / 2;
                d = (d + f) / 2;
                var m = (k + c) / 2, n = (l + d) / 2;
                K.hr(a, b, k, l, m, n, g, h);
                K.hr(m, n, c, d, e, f, g, h)
            }
            return h
        }, Fq: function (a, b, c, d, e, f, g, h, k, l, m, n, p, r) {
            if (K.Ub(a, b, g, h, p, c, d) && K.Ub(a, b, g, h, p, e, f)) {
                if (a < k && g < k && a < m && g < m || a > k && g > k && a > m && g > m || b < l && h < l && b < n && h < n || b > l && h > l && b > n && h > n) return !1;
                var q = (a - g) * (l - n) - (b - h) * (k - m);
                if (0 === q) return !1;
                p = ((a * h - b * g) * (k - m) - (a - g) * (k * n - l * m)) / q;
                q = ((a * h - b * g) * (l - n) - (b - h) * (k * n - l * m)) / q;
                if ((k > m ? k - m : m - k) < (l > n ? l - n : n - l)) {
                    if (b < h ? g = b :
                        (g = h, h = b), 1E-5 + q < g || q > h + 1E-5) return !1
                } else if (a < g ? h = a : (h = g, g = a), 1E-5 + p < h || p > g + 1E-5) return !1;
                r.h(p, q);
                return !0
            }
            q = (a + c) / 2;
            var u = (b + d) / 2, x = (c + e) / 2, y = (d + f) / 2;
            e = (e + g) / 2;
            f = (f + h) / 2;
            d = (q + x) / 2;
            c = (u + y) / 2;
            x = (x + e) / 2;
            y = (y + f) / 2;
            var z = (d + x) / 2, B = (c + y) / 2, D = Infinity, G = !1, O = 0, U = 0;
            K.Fq(a, b, q, u, d, c, z, B, k, l, m, n, p, r) && (a = (r.x - k) * (r.x - k) + (r.y - l) * (r.y - l), a < D && (D = a, G = !0, O = r.x, U = r.y));
            K.Fq(z, B, x, y, e, f, g, h, k, l, m, n, p, r) && (r.x - k) * (r.x - k) + (r.y - l) * (r.y - l) < D && (G = !0, O = r.x, U = r.y);
            G && (r.x = O, r.y = U);
            return G
        }, Gq: function (a, b, c, d, e, f,
                         g, h, k, l, m, n, p) {
            var r = 0;
            if (K.Ub(a, b, g, h, p, c, d) && K.Ub(a, b, g, h, p, e, f)) {
                p = (a - g) * (l - n) - (b - h) * (k - m);
                if (0 === p) return r;
                var q = ((a * h - b * g) * (k - m) - (a - g) * (k * n - l * m)) / p,
                    u = ((a * h - b * g) * (l - n) - (b - h) * (k * n - l * m)) / p;
                if (q >= m) return r;
                if ((k > m ? k - m : m - k) < (l > n ? l - n : n - l)) {
                    if (b < h ? (a = b, b = h) : a = h, u < a || u > b) return r
                } else if (a < g ? (b = a, a = g) : b = g, q < b || q > a) return r;
                0 < p ? r++ : 0 > p && r--
            } else {
                q = (a + c) / 2;
                u = (b + d) / 2;
                var x = (c + e) / 2, y = (d + f) / 2;
                e = (e + g) / 2;
                f = (f + h) / 2;
                d = (q + x) / 2;
                c = (u + y) / 2;
                x = (x + e) / 2;
                y = (y + f) / 2;
                var z = (d + x) / 2, B = (c + y) / 2;
                r += K.Gq(a, b, q, u, d, c, z, B, k, l,
                    m, n, p);
                r += K.Gq(z, B, x, y, e, f, g, h, k, l, m, n, p)
            }
            return r
        }, $h: function (a, b, c, d, e, f, g) {
            if (K.da(a, c)) {
                b < d ? (c = b, b = d) : c = d;
                if (f < c) return g.h(a, c), !1;
                if (f > b) return g.h(a, b), !1;
                g.h(a, f);
                return !0
            }
            if (K.da(b, d)) {
                a < c ? (d = a, a = c) : d = c;
                if (e < d) return g.h(d, b), !1;
                if (e > a) return g.h(a, b), !1;
                g.h(e, b);
                return !0
            }
            e = ((a - e) * (a - c) + (b - f) * (b - d)) / ((c - a) * (c - a) + (d - b) * (d - b));
            if (-5E-6 > e) return g.h(a, b), !1;
            if (1.000005 < e) return g.h(c, d), !1;
            g.h(a + e * (c - a), b + e * (d - b));
            return !0
        }, Ve: function (a, b, c, d, e, f, g, h, k) {
            if (K.C(a, c) && K.C(b, d)) return k.h(a,
                b), !1;
            if (K.da(e, g)) return K.da(a, c) ? (K.$h(a, b, c, d, e, f, k), !1) : K.$h(a, b, c, d, e, (d - b) / (c - a) * (e - a) + b, k);
            h = (h - f) / (g - e);
            if (K.da(a, c)) {
                c = h * (a - e) + f;
                b < d ? (e = b, b = d) : e = d;
                if (c < e) return k.h(a, e), !1;
                if (c > b) return k.h(a, b), !1;
                k.h(a, c);
                return !0
            }
            g = (d - b) / (c - a);
            if (K.da(h, g)) return K.$h(a, b, c, d, e, f, k), !1;
            e = (g * a - h * e + f - b) / (g - h);
            if (K.da(g, 0)) {
                a < c ? (d = a, a = c) : d = c;
                if (e < d) return k.h(d, b), !1;
                if (e > a) return k.h(a, b), !1;
                k.h(e, b);
                return !0
            }
            return K.$h(a, b, c, d, e, g * (e - a) + b, k)
        }, IB: function (a, b, c, d, e) {
            return K.Ve(c.x, c.y, d.x, d.y, a.x, a.y,
                b.x, b.y, e)
        }, HB: function (a, b, c, d, e, f, g, h, k, l) {
            function m(c, d) {
                var e = (c - a) * (c - a) + (d - b) * (d - b);
                e < n && (n = e, k.h(c, d))
            }

            var n = Infinity;
            m(k.x, k.y);
            var p = 0, r = 0, q = 0, u = 0;
            e < g ? (p = e, r = g) : (p = g, r = e);
            f < h ? (q = e, u = g) : (q = g, u = e);
            p = (r - p) / 2 + l;
            l = (u - q) / 2 + l;
            e = (e + g) / 2;
            f = (f + h) / 2;
            if (0 === p || 0 === l) return k;
            if (.5 > (c > a ? c - a : a - c)) {
                p = 1 - (c - e) * (c - e) / (p * p);
                if (0 > p) return k;
                p = Math.sqrt(p);
                d = -l * p + f;
                m(c, l * p + f);
                m(c, d)
            } else {
                c = (d - b) / (c - a);
                d = 1 / (p * p) + c * c / (l * l);
                h = 2 * c * (b - c * a) / (l * l) - 2 * c * f / (l * l) - 2 * e / (p * p);
                p = h * h - 4 * d * (2 * c * a * f / (l * l) - 2 * b * f / (l * l) + f * f / (l * l) +
                    e * e / (p * p) - 1 + (b - c * a) * (b - c * a) / (l * l));
                if (0 > p) return k;
                p = Math.sqrt(p);
                l = (-h + p) / (2 * d);
                m(l, c * l - c * a + b);
                p = (-h - p) / (2 * d);
                m(p, c * p - c * a + b)
            }
            return k
        }, Of: function (a, b, c, d, e, f, g, h, k) {
            var l = 1E21, m = a, n = b;
            if (K.Ve(a, b, a, d, e, f, g, h, k)) {
                var p = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f);
                p < l && (l = p, m = k.x, n = k.y)
            }
            K.Ve(c, b, c, d, e, f, g, h, k) && (p = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f), p < l && (l = p, m = k.x, n = k.y));
            K.Ve(a, b, c, b, e, f, g, h, k) && (b = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f), b < l && (l = b, m = k.x, n = k.y));
            K.Ve(a, d, c, d, e, f, g, h, k) && (a = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f),
            a < l && (l = a, m = k.x, n = k.y));
            k.h(m, n);
            return 1E21 > l
        }, GB: function (a, b, c, d, e, f, g, h, k) {
            c = a - c;
            g = e - g;
            0 === c || 0 === g ? 0 === c ? (b = (f - h) / g, h = a, e = b * h + (f - b * e)) : (f = (b - d) / c, h = e, e = f * h + (b - f * a)) : (d = (b - d) / c, h = (f - h) / g, a = b - d * a, h = (f - h * e - a) / (d - h), e = d * h + a);
            k.h(h, e);
            return k
        }, bu: function (a, b, c) {
            return K.Ty(a.x, a.y, a.width, a.height, b.x, b.y, c.x, c.y)
        }, Ty: function (a, b, c, d, e, f, g, h) {
            var k = a + c, l = b + d;
            return e === g ? (f < h ? (g = f, f = h) : g = h, a <= e && e <= k && g <= l && f >= b) : f === h ? (e < g ? (h = e, e = g) : h = g, b <= f && f <= l && h <= k && e >= a) : pc(a, b, c, d, e, f) || pc(a, b, c, d, g, h) ||
            K.Xq(a, b, k, b, e, f, g, h) || K.Xq(k, b, k, l, e, f, g, h) || K.Xq(k, l, a, l, e, f, g, h) || K.Xq(a, l, a, b, e, f, g, h) ? !0 : !1
        }, Xq: function (a, b, c, d, e, f, g, h) {
            return 0 >= K.Mt(a, b, c, d, e, f) * K.Mt(a, b, c, d, g, h) && 0 >= K.Mt(e, f, g, h, a, b) * K.Mt(e, f, g, h, c, d)
        }, Mt: function (a, b, c, d, e, f) {
            c -= a;
            d -= b;
            a = e - a;
            b = f - b;
            f = a * d - b * c;
            0 === f && (f = a * c + b * d, 0 < f && (f = (a - c) * c + (b - d) * d, 0 > f && (f = 0)));
            return 0 > f ? -1 : 0 < f ? 1 : 0
        }, er: function (a) {
            0 > a && (a += 360);
            360 <= a && (a -= 360);
            return a
        }, vy: function (a, b, c, d, e, f) {
            var g = Math.PI;
            f || (d *= g / 180, e *= g / 180);
            var h = d > e ? -1 : 1;
            f = [];
            var k = g / 2, l = d;
            d = Math.min(2 * g, Math.abs(e - d));
            if (1E-5 > d) return k = l + h * Math.min(d, k), h = a + c * Math.cos(l), l = b + c * Math.sin(l), a += c * Math.cos(k), b += c * Math.sin(k), c = (h + a) / 2, k = (l + b) / 2, f.push([h, l, c, k, c, k, a, b]), f;
            for (; 1E-5 < d;) e = l + h * Math.min(d, k), f.push(K.Wz(c, l, e, a, b)), d -= Math.abs(e - l), l = e;
            return f
        }, Wz: function (a, b, c, d, e) {
            var f = (c - b) / 2, g = a * Math.cos(f), h = a * Math.sin(f), k = -h, l = g * g + k * k,
                m = l + g * g + k * h;
            l = 4 / 3 * (Math.sqrt(2 * l * m) - m) / (g * h - k * g);
            h = g - l * k;
            g = k + l * g;
            k = -g;
            l = f + b;
            f = Math.cos(l);
            l = Math.sin(l);
            return [d + a * Math.cos(b), e + a * Math.sin(b), d +
            h * f - g * l, e + h * l + g * f, d + h * f - k * l, e + h * l + k * f, d + a * Math.cos(c), e + a * Math.sin(c)]
        }, Pq: function (a, b, c, d, e, f, g) {
            c = Math.floor((a - c) / e) * e + c;
            d = Math.floor((b - d) / f) * f + d;
            var h = c;
            c + e - a < e / 2 && (h = c + e);
            a = d;
            d + f - b < f / 2 && (a = d + f);
            g.h(h, a);
            return g
        }, Iy: function (a, b) {
            var c = Math.max(a, b);
            a = Math.min(a, b);
            var d;
            do b = c % a, c = d = a, a = b; while (0 < b);
            return d
        }, aA: function (a, b, c, d) {
            var e = 0 > c, f = 0 > d;
            if (a < b) {
                var g = 1;
                var h = 0
            } else g = 0, h = 1;
            var k = 0 === g ? a : b;
            var l = 0 === g ? c : d;
            if (0 === g ? e : f) l = -l;
            g = h;
            c = 0 === g ? c : d;
            if (0 === g ? e : f) c = -c;
            return K.bA(k, 0 === g ? a : b,
                l, c, 0, 0)
        }, bA: function (a, b, c, d, e, f) {
            if (0 < d) if (0 < c) {
                e = a * a;
                f = b * b;
                a *= c;
                var g = b * d, h = -f + g, k = -f + Math.sqrt(a * a + g * g);
                b = h;
                for (var l = 0; 9999999999 > l; ++l) {
                    b = .5 * (h + k);
                    if (b === h || b === k) break;
                    var m = a / (b + e), n = g / (b + f);
                    m = m * m + n * n - 1;
                    if (0 < m) h = b; else if (0 > m) k = b; else break
                }
                c = e * c / (b + e) - c;
                d = f * d / (b + f) - d;
                c = Math.sqrt(c * c + d * d)
            } else c = Math.abs(d - b); else d = a * a - b * b, f = a * c, f < d ? (d = f / d, f = b * Math.sqrt(Math.abs(1 - d * d)), c = a * d - c, c = Math.sqrt(c * c + f * f)) : c = Math.abs(c - a);
            return c
        }, me: new kb, on: new kb, di: new kb, ei: 0
    };
    K.za = K.AB;

    function Hd(a) {
        F && 1 < arguments.length && v("Geometry constructor can take at most one optional argument, the Geometry type.");
        gb(this);
        this.s = !1;
        void 0 === a ? a = Id : F && ib(a, Hd, Hd, "constructor:type");
        this.sa = a;
        this.tc = this.nc = this.kd = this.jd = 0;
        this.Tj = new H;
        this.ms = this.Tj.u;
        this.Tr = (new L).freeze();
        this.wa = !0;
        this.vn = this.kl = null;
        this.wn = NaN;
        this.Af = Fc;
        this.Bf = Rc;
        this.Ol = this.Pl = NaN;
        this.dg = Jd
    }

    Hd.prototype.copy = function () {
        var a = new Hd;
        a.sa = this.sa;
        a.jd = this.jd;
        a.kd = this.kd;
        a.nc = this.nc;
        a.tc = this.tc;
        for (var b = this.Tj.j, c = b.length, d = a.Tj, e = 0; e < c; e++) {
            var f = b[e].copy();
            d.add(f)
        }
        a.ms = this.ms;
        a.Tr.assign(this.Tr);
        a.wa = this.wa;
        a.kl = this.kl;
        a.vn = this.vn;
        a.wn = this.wn;
        a.Af = this.Af.J();
        a.Bf = this.Bf.J();
        a.Pl = this.Pl;
        a.Ol = this.Ol;
        a.dg = this.dg;
        return a
    };
    t = Hd.prototype;
    t.ia = function () {
        this.freeze();
        Object.freeze(this);
        return this
    };
    t.freeze = function () {
        this.s = !0;
        var a = this.figures;
        a.freeze();
        a = a.j;
        for (var b = a.length, c = 0; c < b; c++) a[c].freeze();
        return this
    };
    t.ka = function () {
        Object.isFrozen(this) && v("cannot thaw constant: " + this);
        this.s = !1;
        var a = this.figures;
        a.ka();
        a = a.j;
        for (var b = a.length, c = 0; c < b; c++) a[c].ka();
        return this
    };
    t.Ta = function (a) {
        if (!(a instanceof Hd)) return !1;
        if (this.type !== a.type) return this.type === Kd && a.type === Id ? Ld(this, a) : a.type === Kd && this.type === Id ? Ld(a, this) : !1;
        if (this.type === Id) {
            var b = this.figures.j;
            a = a.figures.j;
            var c = b.length;
            if (c !== a.length) return !1;
            for (var d = 0; d < c; d++) if (!b[d].Ta(a[d])) return !1;
            return !0
        }
        return K.C(this.startX, a.startX) && K.C(this.startY, a.startY) && K.C(this.endX, a.endX) && K.C(this.endY, a.endY)
    };

    function Ld(a, b) {
        return a.type !== Kd || b.type !== Id ? !1 : 1 === b.figures.count && (b = b.figures.M(0), 1 === b.segments.count && K.C(a.startX, b.startX) && K.C(a.startY, b.startY) && (b = b.segments.M(0), b.type === Md && K.C(a.endX, b.endX) && K.C(a.endY, b.endY))) ? !0 : !1
    }

    function Nd(a) {
        return a.toString()
    }

    t.pb = function (a) {
        a.classType === Hd ? this.type = a : Da(this, a)
    };
    t.toString = function (a) {
        void 0 === a && (a = -1);
        switch (this.type) {
            case Kd:
                return 0 > a ? "M" + this.startX.toString() + " " + this.startY.toString() + "L" + this.endX.toString() + " " + this.endY.toString() : "M" + this.startX.toFixed(a) + " " + this.startY.toFixed(a) + "L" + this.endX.toFixed(a) + " " + this.endY.toFixed(a);
            case Od:
                var b = new L(this.startX, this.startY, 0, 0);
                b.ex(this.endX, this.endY, 0, 0);
                return 0 > a ? "M" + b.x.toString() + " " + b.y.toString() + "H" + b.right.toString() + "V" + b.bottom.toString() + "H" + b.left.toString() + "z" : "M" + b.x.toFixed(a) +
                    " " + b.y.toFixed(a) + "H" + b.right.toFixed(a) + "V" + b.bottom.toFixed(a) + "H" + b.left.toFixed(a) + "z";
            case Pd:
                b = new L(this.startX, this.startY, 0, 0);
                b.ex(this.endX, this.endY, 0, 0);
                if (0 > a) return a = b.left.toString() + " " + (b.y + b.height / 2).toString(), "M" + a + "A" + (b.width / 2).toString() + " " + (b.height / 2).toString() + " 0 0 1 " + (b.right.toString() + " " + (b.y + b.height / 2).toString()) + "A" + (b.width / 2).toString() + " " + (b.height / 2).toString() + " 0 0 1 " + a;
                var c = b.left.toFixed(a) + " " + (b.y + b.height / 2).toFixed(a);
                return "M" + c + "A" + (b.width /
                    2).toFixed(a) + " " + (b.height / 2).toFixed(a) + " 0 0 1 " + (b.right.toFixed(a) + " " + (b.y + b.height / 2).toFixed(a)) + "A" + (b.width / 2).toFixed(a) + " " + (b.height / 2).toFixed(a) + " 0 0 1 " + c;
            case Id:
                b = "";
                c = this.figures.j;
                for (var d = c.length, e = 0; e < d; e++) {
                    var f = c[e];
                    0 < e && (b += " x ");
                    f.isFilled && (b += "F ");
                    b += f.toString(a)
                }
                return b;
            default:
                return this.type.toString()
        }
    };

    function Qd(a, b) {
        function c() {
            return u >= D - 1 ? !0 : null !== n[u + 1].match(G)
        }

        function d() {
            u++;
            return n[u]
        }

        function e() {
            var a = new J(parseFloat(d()), parseFloat(d()));
            x === x.toLowerCase() && (a.x = B.x + a.x, a.y = B.y + a.y);
            return a
        }

        function f() {
            return B = e()
        }

        function g() {
            return z = e()
        }

        function h() {
            var a = y.toLowerCase();
            return "c" !== a && "s" !== a && "q" !== a && "t" !== a ? B : new J(2 * B.x - z.x, 2 * B.y - z.y)
        }

        void 0 === b && (b = !1);
        "string" !== typeof a && xa(a, "string", Hd, "parse:str");
        var k = new RegExp("([" + Ud + "])([" + Ud + "])", "gm"), l = new RegExp("([" +
            Ud + "])([^s])", "gm"), m = new RegExp("([^s])([" + Ud + "])", "gm");
        a = a.replace(/,/gm, " ");
        a = a.replace(k, "$1 $2");
        a = a.replace(k, "$1 $2");
        a = a.replace(l, "$1 $2");
        a = a.replace(m, "$1 $2");
        a = a.replace(/([0-9])([+\-])/gm, "$1 $2");
        a = a.replace(/[\s\r\t\n]+/gm, " ");
        a = a.replace(/^\s+|\s+$/g, "");
        var n = a.split(" ");
        for (a = 0; a < n.length; a++) if (l = n[a], null !== l.match(/(\.[0-9]*)(\.)/gm)) {
            k = Ma();
            m = "";
            for (var p = !1, r = 0; r < l.length; r++) {
                var q = l[r];
                "." !== q || p ? "." === q ? (k.push(m), m = ".") : m += q : (p = !0, m += q)
            }
            k.push(m);
            n.splice(a, 1);
            for (l =
                     0; l < k.length; l++) n.splice(a + l, 0, k[l]);
            a += k.length - 1;
            Oa(k)
        }
        var u = -1, x = "", y = "";
        k = new J(0, 0);
        var z = new J(0, 0), B = new J(0, 0), D = n.length;
        a = Vd(null);
        m = l = !1;
        p = !0;
        r = null;
        for (var G = new RegExp("[" + Ud + "]"); !(u >= D - 1);) if (y = x, x = d(), "" !== x) switch (x.toUpperCase()) {
            case "X":
                p = !0;
                m = l = !1;
                break;
            case "M":
                r = f();
                null === a.oc || !0 === p ? (Wd(a, r.x, r.y, l, !m), p = !1) : a.moveTo(r.x, r.y);
                for (k = B; !c();) r = f(), a.lineTo(r.x, r.y);
                break;
            case "L":
                for (; !c();) r = f(), a.lineTo(r.x, r.y);
                break;
            case "H":
                for (; !c();) B = new J((x === x.toLowerCase() ? B.x :
                    0) + parseFloat(d()), B.y), a.lineTo(B.x, B.y);
                break;
            case "V":
                for (; !c();) B = new J(B.x, (x === x.toLowerCase() ? B.y : 0) + parseFloat(d())), a.lineTo(B.x, B.y);
                break;
            case "C":
                for (; !c();) {
                    r = e();
                    q = g();
                    var O = f();
                    Xd(a, r.x, r.y, q.x, q.y, O.x, O.y)
                }
                break;
            case "S":
                for (; !c();) r = h(), q = g(), O = f(), Xd(a, r.x, r.y, q.x, q.y, O.x, O.y);
                break;
            case "Q":
                for (; !c();) r = g(), q = f(), Yd(a, r.x, r.y, q.x, q.y);
                break;
            case "T":
                for (; !c();) z = r = h(), q = f(), Yd(a, r.x, r.y, q.x, q.y);
                break;
            case "B":
                for (; !c();) {
                    r = parseFloat(d());
                    q = parseFloat(d());
                    O = parseFloat(d());
                    var U =
                        parseFloat(d()), R = parseFloat(d()), fa = R, Y = !1;
                    c() || (fa = parseFloat(d()), c() || (Y = 0 !== parseFloat(d())));
                    x === x.toLowerCase() && (O += B.x, U += B.y);
                    a.arcTo(r, q, O, U, R, fa, Y)
                }
                break;
            case "A":
                for (; !c();) r = Math.abs(parseFloat(d())), q = Math.abs(parseFloat(d())), O = parseFloat(d()), R = U = !1, Y = fa = 0, fa = d(), 1 === fa.length ? (U = !!parseFloat(fa), R = !!parseFloat(d()), fa = parseFloat(d())) : 2 === fa.length ? (U = !!parseFloat(fa[0]), R = !!parseFloat(fa[1]), fa = parseFloat(d())) : (U = !!parseFloat(fa[0]), R = !!parseFloat(fa[1]), fa = parseFloat(fa.slice(2))),
                    Y = parseFloat(d()), x === x.toLowerCase() && (fa = B.x + fa, Y = B.y + Y), B.h(fa, Y), Zd(a, r, q, O, U, R, fa, Y);
                break;
            case "Z":
                ie(a);
                B = k;
                break;
            case "F":
                r = "";
                for (q = 1; n[u + q];) if (null !== n[u + q].match(/[Uu]/)) q++; else if (null === n[u + q].match(G)) q++; else {
                    r = n[u + q];
                    break
                }
                r.match(/[Mm]/) ? l = !0 : 0 < a.oc.segments.length && (a.oc.isFilled = !0);
                break;
            case "U":
                r = "";
                for (q = 1; n[u + q];) if (null !== n[u + q].match(/[Ff]/)) q++; else if (null === n[u + q].match(G)) q++; else {
                    r = n[u + q];
                    break
                }
                r.match(/[Mm]/) ? m = !0 : a.tr(!1)
        }
        k = a.Wt;
        je = a;
        if (b) for (b = k.figures.iterator; b.next();) b.value.isFilled =
            !0;
        return k
    }

    function ke(a, b) {
        for (var c = a.length, d = J.alloc(), e = 0; e < c; e++) {
            var f = a[e];
            d.x = f[0];
            d.y = f[1];
            b.ya(d);
            f[0] = d.x;
            f[1] = d.y;
            d.x = f[2];
            d.y = f[3];
            b.ya(d);
            f[2] = d.x;
            f[3] = d.y;
            d.x = f[4];
            d.y = f[5];
            b.ya(d);
            f[4] = d.x;
            f[5] = d.y;
            d.x = f[6];
            d.y = f[7];
            b.ya(d);
            f[6] = d.x;
            f[7] = d.y
        }
        J.free(d)
    }

    t.rw = function () {
        if (this.wa || this.ms !== this.figures.u) return !0;
        for (var a = this.figures.j, b = a.length, c = 0; c < b; c++) if (a[c].rw()) return !0;
        return !1
    };
    Hd.prototype.computeBounds = function () {
        this.wa = !1;
        this.vn = this.kl = null;
        this.wn = NaN;
        this.ms = this.figures.u;
        for (var a = this.figures.j, b = a.length, c = 0; c < b; c++) {
            var d = a[c];
            d.wa = !1;
            var e = d.segments;
            d.ot = e.u;
            d = e.j;
            e = d.length;
            for (var f = 0; f < e; f++) {
                var g = d[f];
                g.wa = !1;
                g.bf = null
            }
        }
        a = this.Tr;
        a.ka();
        isNaN(this.Pl) || isNaN(this.Ol) ? a.h(0, 0, 0, 0) : a.h(0, 0, this.Pl, this.Ol);
        le(this, a, !1);
        oc(a, 0, 0, 0, 0);
        a.freeze()
    };
    Hd.prototype.uy = function () {
        var a = new L;
        le(this, a, !0);
        return a
    };

    function le(a, b, c) {
        switch (a.type) {
            case Kd:
            case Od:
            case Pd:
                c ? b.h(a.jd, a.kd, 0, 0) : oc(b, a.jd, a.kd, 0, 0);
                oc(b, a.nc, a.tc, 0, 0);
                break;
            case Id:
                var d = a.figures;
                a = d.j;
                d = d.length;
                for (var e = 0; e < d; e++) {
                    var f = a[e];
                    c && 0 === e ? b.h(f.startX, f.startY, 0, 0) : oc(b, f.startX, f.startY, 0, 0);
                    for (var g = f.segments.j, h = g.length, k = f.startX, l = f.startY, m = 0; m < h; m++) {
                        var n = g[m];
                        switch (n.type) {
                            case Md:
                            case me:
                                k = n.endX;
                                l = n.endY;
                                oc(b, k, l, 0, 0);
                                break;
                            case ne:
                                K.Fm(k, l, n.point1X, n.point1Y, n.point2X, n.point2Y, n.endX, n.endY, .5, b);
                                k = n.endX;
                                l = n.endY;
                                break;
                            case oe:
                                K.zw(k, l, n.point1X, n.point1Y, n.endX, n.endY, .5, b);
                                k = n.endX;
                                l = n.endY;
                                break;
                            case pe:
                            case qe:
                                var p = n.type === pe ? re(n, f) : se(n, f, k, l), r = p.length;
                                if (0 === r) {
                                    k = n.centerX;
                                    l = n.centerY;
                                    oc(b, k, l, 0, 0);
                                    break
                                }
                                n = null;
                                for (var q = 0; q < r; q++) n = p[q], K.Fm(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], .5, b);
                                null !== n && (k = n[6], l = n[7]);
                                break;
                            default:
                                v("Unknown Segment type: " + n.type)
                        }
                    }
                }
                break;
            default:
                v("Unknown Geometry type: " + a.type)
        }
    }

    Hd.prototype.normalize = function () {
        this.s && va(this);
        var a = this.uy();
        this.offset(-a.x, -a.y);
        return new J(-a.x, -a.y)
    };
    Hd.prototype.offset = function (a, b) {
        this.s && va(this);
        F && (C(a, Hd, "offset"), C(b, Hd, "offset"));
        this.transform(1, 0, 0, 1, a, b);
        return this
    };
    Hd.prototype.scale = function (a, b) {
        this.s && va(this);
        F && (C(a, Hd, "scale:x"), C(b, Hd, "scale:y"), 0 === a && za(a, "scale must be non-zero", Hd, "scale:x"), 0 === b && za(b, "scale must be non-zero", Hd, "scale:y"));
        this.transform(a, 0, 0, b, 0, 0);
        return this
    };
    Hd.prototype.rotate = function (a, b, c) {
        this.s && va(this);
        void 0 === b && (b = 0);
        void 0 === c && (c = 0);
        F && (C(a, Hd, "rotate:angle"), C(b, Hd, "rotate:x"), C(c, Hd, "rotate:y"));
        var d = Ib.alloc();
        d.reset();
        d.rotate(a, b, c);
        this.transform(d.m11, d.m12, d.m21, d.m22, d.dx, d.dy);
        Ib.free(d);
        return this
    };
    t = Hd.prototype;
    t.transform = function (a, b, c, d, e, f) {
        switch (this.type) {
            case Kd:
            case Od:
            case Pd:
                var g = this.jd;
                var h = this.kd;
                this.jd = g * a + h * c + e;
                this.kd = g * b + h * d + f;
                g = this.nc;
                h = this.tc;
                this.nc = g * a + h * c + e;
                this.tc = g * b + h * d + f;
                break;
            case Id:
                for (var k = this.figures.j, l = k.length, m = 0; m < l; m++) {
                    var n = k[m];
                    g = n.startX;
                    h = n.startY;
                    n.startX = g * a + h * c + e;
                    n.startY = g * b + h * d + f;
                    n = n.segments.j;
                    for (var p = n.length, r = 0; r < p; r++) {
                        var q = n[r];
                        switch (q.type) {
                            case Md:
                            case me:
                                g = q.endX;
                                h = q.endY;
                                q.endX = g * a + h * c + e;
                                q.endY = g * b + h * d + f;
                                break;
                            case ne:
                                g = q.point1X;
                                h = q.point1Y;
                                q.point1X = g * a + h * c + e;
                                q.point1Y = g * b + h * d + f;
                                g = q.point2X;
                                h = q.point2Y;
                                q.point2X = g * a + h * c + e;
                                q.point2Y = g * b + h * d + f;
                                g = q.endX;
                                h = q.endY;
                                q.endX = g * a + h * c + e;
                                q.endY = g * b + h * d + f;
                                break;
                            case oe:
                                g = q.point1X;
                                h = q.point1Y;
                                q.point1X = g * a + h * c + e;
                                q.point1Y = g * b + h * d + f;
                                g = q.endX;
                                h = q.endY;
                                q.endX = g * a + h * c + e;
                                q.endY = g * b + h * d + f;
                                break;
                            case pe:
                                g = q.centerX;
                                h = q.centerY;
                                q.centerX = g * a + h * c + e;
                                q.centerY = g * b + h * d + f;
                                0 !== b && (g = 180 * Math.atan2(b, a) / Math.PI, 0 > g && (g += 360), q.startAngle += g);
                                0 > a && (q.startAngle = 180 - q.startAngle, q.sweepAngle = -q.sweepAngle);
                                0 > d &&
                                (q.startAngle = -q.startAngle, q.sweepAngle = -q.sweepAngle);
                                q.radiusX *= Math.sqrt(a * a + c * c);
                                void 0 !== q.radiusY && (q.radiusY *= Math.sqrt(b * b + d * d));
                                break;
                            case qe:
                                g = q.endX;
                                h = q.endY;
                                q.endX = g * a + h * c + e;
                                q.endY = g * b + h * d + f;
                                0 !== b && (g = 180 * Math.atan2(b, a) / Math.PI, 0 > g && (g += 360), q.xAxisRotation += g);
                                0 > a && (q.xAxisRotation = 180 - q.xAxisRotation, q.isClockwiseArc = !q.isClockwiseArc);
                                0 > d && (q.xAxisRotation = -q.xAxisRotation, q.isClockwiseArc = !q.isClockwiseArc);
                                q.radiusX *= Math.sqrt(a * a + c * c);
                                q.radiusY *= Math.sqrt(b * b + d * d);
                                break;
                            default:
                                v("Unknown Segment type: " +
                                    q.type)
                        }
                    }
                }
        }
        this.wa = !0;
        return this
    };
    t.ca = function (a, b) {
        void 0 === b && (b = 0);
        var c = this.jd, d = this.kd, e = this.nc, f = this.tc;
        switch (this.type) {
            case Kd:
                return K.Ub(c, d, e, f, b, a.x, a.y);
            case Od:
                var g = L.allocAt(Math.min(c, e) - b, Math.min(d, f) - b, Math.abs(e - c) + 2 * b, Math.abs(f - d) + 2 * b);
                a = g.ca(a);
                L.free(g);
                return a;
            case Pd:
                g = Math.min(c, e) - b;
                var h = Math.min(d, f) - b;
                c = (Math.abs(e - c) + 2 * b) / 2;
                b = (Math.abs(f - d) + 2 * b) / 2;
                if (0 >= c || 0 >= b) return !1;
                g = a.x - (g + c);
                h = a.y - (h + b);
                return 1 >= g * g / (c * c) + h * h / (b * b);
            case Id:
                return te(this, a, b, !0, !1);
            default:
                return !1
        }
    };

    function te(a, b, c, d, e) {
        var f = b.x;
        b = b.y;
        for (var g = a.bounds.x - 20, h = 0, k, l, m, n, p = a.figures.j, r = p.length, q = 0; q < r; q++) {
            var u = p[q];
            if (u.isFilled) {
                if (d && u.ca(f, b, c)) return !0;
                var x = u.segments;
                k = u.startX;
                l = u.startY;
                for (var y = k, z = l, B = x.j, D = 0; D <= x.length; D++) {
                    var G = void 0;
                    if (D !== x.length) {
                        G = B[D];
                        var O = G.type;
                        a = G.endX;
                        n = G.endY
                    } else O = Md, a = y, n = z;
                    switch (O) {
                        case me:
                            y = ue(f, b, g, b, k, l, y, z);
                            if (isNaN(y)) return !0;
                            h += y;
                            y = a;
                            z = n;
                            break;
                        case Md:
                            k = ue(f, b, g, b, k, l, a, n);
                            if (isNaN(k)) return !0;
                            h += k;
                            break;
                        case ne:
                            m = K.Gq(k, l, G.point1X,
                                G.point1Y, G.point2X, G.point2Y, a, n, g, b, f, b, .5);
                            h += m;
                            break;
                        case oe:
                            m = K.Gq(k, l, (k + 2 * G.point1X) / 3, (l + 2 * G.point1Y) / 3, (2 * G.point1X + a) / 3, (2 * G.point1Y + n) / 3, a, n, g, b, f, b, .5);
                            h += m;
                            break;
                        case pe:
                        case qe:
                            O = G.type === pe ? re(G, u) : se(G, u, k, l);
                            var U = O.length;
                            if (0 === U) {
                                k = ue(f, b, g, b, k, l, G.centerX, G.centerY);
                                if (isNaN(k)) return !0;
                                h += k;
                                break
                            }
                            G = null;
                            for (var R = 0; R < U; R++) {
                                G = O[R];
                                if (0 === R) {
                                    m = ue(f, b, g, b, k, l, G[0], G[1]);
                                    if (isNaN(m)) return !0;
                                    h += m
                                }
                                m = K.Gq(G[0], G[1], G[2], G[3], G[4], G[5], G[6], G[7], g, b, f, b, .5);
                                h += m
                            }
                            null !== G && (a = G[6],
                                n = G[7]);
                            break;
                        default:
                            v("Unknown Segment type: " + G.type)
                    }
                    k = a;
                    l = n
                }
                if (0 !== h) return !0;
                h = 0
            } else if (u.ca(f, b, e ? c : c + 2)) return !0
        }
        return 0 !== h
    }

    function ue(a, b, c, d, e, f, g, h) {
        if (K.Ub(e, f, g, h, .05, a, b)) return NaN;
        var k = (a - c) * (f - h);
        if (0 === k) return 0;
        var l = ((a * d - b * c) * (e - g) - (a - c) * (e * h - f * g)) / k;
        b = (a * d - b * c) * (f - h) / k;
        if (l >= a) return 0;
        if ((e > g ? e - g : g - e) < (f > h ? f - h : h - f)) if (f < h) {
            if (b < f || b > h) return 0
        } else {
            if (b < h || b > f) return 0
        } else if (e < g) {
            if (l < e || l > g) return 0
        } else if (l < g || l > e) return 0;
        return 0 < k ? 1 : -1
    }

    function ve(a, b, c, d) {
        a = a.figures.j;
        for (var e = a.length, f = 0; f < e; f++) if (a[f].ca(b, c, d)) return !0;
        return !1
    }

    t.iw = function (a, b) {
        0 > a ? a = 0 : 1 < a && (a = 1);
        void 0 === b && (b = new J);
        if (this.type === Kd) return b.h(this.startX + a * (this.endX - this.startX), this.startY + a * (this.endY - this.startY)), b;
        for (var c = this.flattenedSegments, d = this.flattenedLengths, e = c.length, f = this.flattenedTotalLength * a, g = 0, h = 0; h < e; h++) {
            var k = d[h], l = k.length;
            for (a = 0; a < l; a++) {
                var m = k[a];
                if (g + m >= f) return d = f - g, d = 0 === m ? 0 : d / m, c = c[h], h = c[2 * a], e = c[2 * a + 1], b.h(h + (c[2 * a + 2] - h) * d, e + (c[2 * a + 3] - e) * d), b;
                g += m
            }
        }
        return b
    };
    t.Jy = function (a) {
        0 > a ? a = 0 : 1 < a && (a = 1);
        if (this.type === Kd) return 180 * Math.atan2(this.endY - this.startY, this.endX - this.startX) / Math.PI;
        for (var b = this.flattenedSegments, c = this.flattenedLengths, d = b.length, e = this.flattenedTotalLength * a, f = 0, g = 0; g < d; g++) {
            var h = c[g], k = h.length;
            for (a = 0; a < k; a++) {
                var l = h[a];
                if (f + l >= e) return e = b[g], b = e[2 * a], c = e[2 * a + 1], d = e[2 * a + 2], a = e[2 * a + 3], 1 > Math.abs(d - b) && 1 > Math.abs(a - c) ? 0 : 1 > Math.abs(d - b) ? 0 <= a - c ? 90 : 270 : 1 > Math.abs(a - c) ? 0 <= d - b ? 0 : 180 : 180 * Math.atan2(a - c, d - b) / Math.PI;
                f += l
            }
        }
        return NaN
    };
    t.jw = function (a, b) {
        0 > a ? a = 0 : 1 < a && (a = 1);
        void 0 === b && (b = []);
        b.length = 3;
        if (this.type === Kd) return b[0] = this.startX + a * (this.endX - this.startX), b[1] = this.startY + a * (this.endY - this.startY), b[2] = 180 * Math.atan2(this.endY - this.startY, this.endX - this.startX) / Math.PI, b;
        for (var c = this.flattenedSegments, d = this.flattenedLengths, e = c.length, f = this.flattenedTotalLength * a, g = 0, h = 0; h < e; h++) {
            var k = d[h], l = k.length;
            for (a = 0; a < l; a++) {
                var m = k[a];
                if (g + m >= f) return d = f - g, d = 0 === m ? 0 : d / m, m = c[h], c = m[2 * a], h = m[2 * a + 1], e = m[2 * a + 2], a = m[2 * a +
                3], b[0] = c + (e - c) * d, b[1] = h + (a - h) * d, b[2] = 1 > Math.abs(e - c) && 1 > Math.abs(a - h) ? 0 : 1 > Math.abs(e - c) ? 0 <= a - h ? 90 : 270 : 1 > Math.abs(a - h) ? 0 <= e - c ? 0 : 180 : 180 * Math.atan2(a - h, e - c) / Math.PI, b;
                g += m
            }
        }
        return b
    };
    t.Ky = function (a) {
        if (this.type === Kd) {
            var b = this.startX, c = this.startY, d = this.endX, e = this.endY;
            if (b !== d || c !== e) {
                var f = a.x;
                a = a.y;
                if (b === d) {
                    if (c < e) {
                        var g = c;
                        d = e
                    } else g = e, d = c;
                    return a <= g ? g === c ? 0 : 1 : a >= d ? d === c ? 0 : 1 : Math.abs(a - c) / (d - g)
                }
                if (c === e) return b < d ? g = b : (g = d, d = b), f <= g ? g === b ? 0 : 1 : f >= d ? d === b ? 0 : 1 : Math.abs(f - b) / (d - g);
                g = (d - b) * (d - b) + (e - c) * (e - c);
                var h = J.alloc();
                K.$h(b, c, d, e, f, a, h);
                a = h.x;
                f = h.y;
                J.free(h);
                return Math.sqrt(((a - b) * (a - b) + (f - c) * (f - c)) / g)
            }
        } else if (this.type === Od) {
            g = this.startX;
            h = this.startY;
            var k = this.endX;
            e = this.endY;
            if (g !== k || h !== e) {
                b = k - g;
                c = e - h;
                f = 2 * b + 2 * c;
                d = a.x;
                a = a.y;
                d = Math.min(Math.max(d, g), k);
                a = Math.min(Math.max(a, h), e);
                g = Math.abs(d - g);
                k = Math.abs(d - k);
                h = Math.abs(a - h);
                e = Math.abs(a - e);
                var l = Math.min(g, k, h, e);
                if (l === h) return d / f;
                if (l === k) return (b + a) / f;
                if (l === e) return (2 * b + c - d) / f;
                if (l === g) return (2 * b + 2 * c - a) / f
            }
        } else {
            b = this.flattenedSegments;
            c = this.flattenedLengths;
            f = this.flattenedTotalLength;
            d = J.alloc();
            e = Infinity;
            h = g = 0;
            k = b.length;
            for (var m = l = 0, n = 0; n < k; n++) for (var p = b[n], r = c[n], q = p.length, u = 0; u < q; u += 2) {
                var x =
                    p[u], y = p[u + 1];
                if (0 !== u) {
                    K.$h(l, m, x, y, a.x, a.y, d);
                    var z = (d.x - a.x) * (d.x - a.x) + (d.y - a.y) * (d.y - a.y);
                    z < e && (e = z, g = h, g += Math.sqrt((d.x - l) * (d.x - l) + (d.y - m) * (d.y - m)));
                    h += r[(u - 2) / 2]
                }
                l = x;
                m = y
            }
            J.free(d);
            a = g / f;
            return 0 > a ? 0 : 1 < a ? 1 : a
        }
        return 0
    };

    function we(a) {
        if (null === a.kl) {
            var b = a.kl = [], c = a.vn = [], d = [], e = [];
            if (a.type === Kd) d.push(a.startX), d.push(a.startY), d.push(a.endX), d.push(a.endY), b.push(d), e.push(Math.sqrt((a.startX - a.endX) * (a.startX - a.endX) + (a.startY - a.endY) * (a.startY - a.endY))), c.push(e); else if (a.type === Od) d.push(a.startX), d.push(a.startY), d.push(a.endX), d.push(a.startY), d.push(a.endX), d.push(a.endY), d.push(a.startX), d.push(a.endY), d.push(a.startX), d.push(a.startY), b.push(d), e.push(Math.abs(a.startX - a.endX)), e.push(Math.abs(a.startY -
                a.endY)), e.push(Math.abs(a.startX - a.endX)), e.push(Math.abs(a.startY - a.endY)), c.push(e); else if (a.type === Pd) {
                var f = new xe;
                f.startX = a.endX;
                f.startY = (a.startY + a.endY) / 2;
                var g = new ye(pe);
                g.startAngle = 0;
                g.sweepAngle = 360;
                g.centerX = (a.startX + a.endX) / 2;
                g.centerY = (a.startY + a.endY) / 2;
                g.radiusX = Math.abs(a.startX - a.endX) / 2;
                g.radiusY = Math.abs(a.startY - a.endY) / 2;
                f.add(g);
                a = re(g, f);
                e = a.length;
                if (0 === e) d.push(g.centerX), d.push(g.centerY); else {
                    g = f.startX;
                    f = f.startY;
                    for (var h = 0; h < e; h++) {
                        var k = a[h];
                        K.Oe(g, f, k[2], k[3],
                            k[4], k[5], k[6], k[7], .5, d);
                        g = k[6];
                        f = k[7]
                    }
                }
                b.push(d);
                c.push(ze(d))
            } else for (a = a.figures.iterator; a.next();) {
                e = a.value;
                d = [];
                d.push(e.startX);
                d.push(e.startY);
                g = e.startX;
                f = e.startY;
                h = g;
                k = f;
                for (var l = e.segments.j, m = l.length, n = 0; n < m; n++) {
                    var p = l[n];
                    switch (p.type) {
                        case me:
                            4 <= d.length && (b.push(d), c.push(ze(d)));
                            d = [];
                            d.push(p.endX);
                            d.push(p.endY);
                            g = p.endX;
                            f = p.endY;
                            h = g;
                            k = f;
                            break;
                        case Md:
                            d.push(p.endX);
                            d.push(p.endY);
                            g = p.endX;
                            f = p.endY;
                            break;
                        case ne:
                            K.Oe(g, f, p.point1X, p.point1Y, p.point2X, p.point2Y, p.endX, p.endY,
                                .5, d);
                            g = p.endX;
                            f = p.endY;
                            break;
                        case oe:
                            K.hr(g, f, p.point1X, p.point1Y, p.endX, p.endY, .5, d);
                            g = p.endX;
                            f = p.endY;
                            break;
                        case pe:
                            var r = re(p, e), q = r.length;
                            if (0 === q) {
                                d.push(p.centerX);
                                d.push(p.centerY);
                                g = p.centerX;
                                f = p.centerY;
                                break
                            }
                            for (var u = 0; u < q; u++) {
                                var x = r[u];
                                K.Oe(g, f, x[2], x[3], x[4], x[5], x[6], x[7], .5, d);
                                g = x[6];
                                f = x[7]
                            }
                            break;
                        case qe:
                            r = se(p, e, g, f);
                            q = r.length;
                            if (0 === q) {
                                d.push(p.centerX);
                                d.push(p.centerY);
                                g = p.centerX;
                                f = p.centerY;
                                break
                            }
                            for (u = 0; u < q; u++) x = r[u], K.Oe(g, f, x[2], x[3], x[4], x[5], x[6], x[7], .5, d), g = x[6],
                                f = x[7];
                            break;
                        default:
                            v("Segment not of valid type: " + p.type)
                    }
                    p.isClosed && (d.push(h), d.push(k))
                }
                4 <= d.length && (b.push(d), c.push(ze(d)))
            }
        }
    }

    function ze(a) {
        for (var b = [], c = 0, d = 0, e = a.length, f = 0; f < e; f += 2) {
            var g = a[f], h = a[f + 1];
            0 !== f && (c = Math.sqrt(Lb(c, d, g, h)), b.push(c));
            c = g;
            d = h
        }
        return b
    }

    t.add = function (a) {
        this.Tj.add(a);
        return this
    };
    t.kn = function (a, b, c, d, e, f, g, h) {
        this.s && va(this);
        this.Af = (new M(a, b, e, f)).freeze();
        this.Bf = (new M(c, d, g, h)).freeze();
        return this
    };
    na.Object.defineProperties(Hd.prototype, {
        flattenedSegments: {
            configurable: !0, get: function () {
                we(this);
                return this.kl
            }
        }, flattenedLengths: {
            configurable: !0, get: function () {
                we(this);
                return this.vn
            }
        }, flattenedTotalLength: {
            configurable: !0, get: function () {
                var a = this.wn;
                if (isNaN(a)) {
                    if (this.type === Kd) {
                        a = Math.abs(this.endX - this.startX);
                        var b = Math.abs(this.endY - this.startY);
                        a = Math.sqrt(a * a + b * b)
                    } else if (this.type === Od) a = 2 * Math.abs(this.endX - this.startX) + 2 * Math.abs(this.endY -
                        this.startY); else {
                        b = this.flattenedLengths;
                        for (var c = b.length, d = a = 0; d < c; d++) for (var e = b[d], f = e.length, g = 0; g < f; g++) a += e[g]
                    }
                    this.wn = a
                }
                return a
            }
        }, type: {
            configurable: !0, get: function () {
                return this.sa
            }, set: function (a) {
                this.sa !== a && (F && ib(a, Hd, Hd, "type"), this.s && va(this, a), this.sa = a, this.wa = !0)
            }
        }, startX: {
            configurable: !0, get: function () {
                return this.jd
            }, set: function (a) {
                this.jd !== a && (F && C(a, Hd, "startX"), this.s && va(this, a), this.jd = a, this.wa = !0)
            }
        }, startY: {
            configurable: !0,
            get: function () {
                return this.kd
            }, set: function (a) {
                this.kd !== a && (F && C(a, Hd, "startY"), this.s && va(this, a), this.kd = a, this.wa = !0)
            }
        }, endX: {
            configurable: !0, get: function () {
                return this.nc
            }, set: function (a) {
                this.nc !== a && (F && C(a, Hd, "endX"), this.s && va(this, a), this.nc = a, this.wa = !0)
            }
        }, endY: {
            configurable: !0, get: function () {
                return this.tc
            }, set: function (a) {
                this.tc !== a && (F && C(a, Hd, "endY"), this.s && va(this, a), this.tc = a, this.wa = !0)
            }
        }, figures: {
            configurable: !0, get: function () {
                return this.Tj
            },
            set: function (a) {
                this.Tj !== a && (F && w(a, H, Hd, "figures"), this.s && va(this, a), this.Tj = a, this.wa = !0)
            }
        }, spot1: {
            configurable: !0, get: function () {
                return this.Af
            }, set: function (a) {
                F && w(a, M, Hd, "spot1");
                this.s && va(this, a);
                this.Af = a.J()
            }
        }, spot2: {
            configurable: !0, get: function () {
                return this.Bf
            }, set: function (a) {
                F && w(a, M, Hd, "spot2");
                this.s && va(this, a);
                this.Bf = a.J()
            }
        }, defaultStretch: {
            configurable: !0, get: function () {
                return this.dg
            }, set: function (a) {
                F && ib(a, N, Hd, "stretch");
                this.s &&
                va(this, a);
                this.dg = a
            }
        }, bounds: {
            configurable: !0, get: function () {
                this.rw() && this.computeBounds();
                return this.Tr
            }
        }
    });
    Hd.prototype.setSpots = Hd.prototype.kn;
    Hd.prototype.add = Hd.prototype.add;
    Hd.prototype.getFractionForPoint = Hd.prototype.Ky;
    Hd.prototype.getPointAndAngleAlongPath = Hd.prototype.jw;
    Hd.prototype.getAngleAlongPath = Hd.prototype.Jy;
    Hd.prototype.getPointAlongPath = Hd.prototype.iw;
    Hd.prototype.containsPoint = Hd.prototype.ca;
    Hd.prototype.transform = Hd.prototype.transform;
    Hd.prototype.rotate = Hd.prototype.rotate;
    Hd.prototype.scale = Hd.prototype.scale;
    Hd.prototype.offset = Hd.prototype.offset;
    Hd.prototype.normalize = Hd.prototype.normalize;
    Hd.prototype.computeBoundsWithoutOrigin = Hd.prototype.uy;
    Hd.prototype.equalsApprox = Hd.prototype.Ta;
    var Kd = new E(Hd, "Line", 0), Od = new E(Hd, "Rectangle", 1), Pd = new E(Hd, "Ellipse", 2),
        Id = new E(Hd, "Path", 3), Ud = "UuBbMmZzLlHhVvCcSsQqTtAaFfXx";
    Hd.className = "Geometry";
    Hd.stringify = Nd;
    Hd.fillPath = function (a) {
        "string" !== typeof a && xa(a, "string", Hd, "fillPath:str");
        a = a.split(/[Xx]/);
        for (var b = a.length, c = "", d = 0; d < b; d++) {
            var e = a[d];
            c = null !== e.match(/[Ff]/) ? 0 === d ? c + e : c + ("X" + (" " === e[0] ? "" : " ") + e) : c + ((0 === d ? "" : "X ") + "F" + (" " === e[0] ? "" : " ") + e)
        }
        return c
    };
    Hd.parse = Qd;
    Hd.Line = Kd;
    Hd.Rectangle = Od;
    Hd.Ellipse = Pd;
    Hd.Path = Id;

    function xe(a, b, c, d) {
        gb(this);
        this.Fx = null;
        this.s = !1;
        void 0 === c && (c = !0);
        this.ws = c;
        void 0 === d && (d = !0);
        this.Bs = d;
        void 0 !== a ? (F && C(a, xe, "sx"), this.jd = a) : this.jd = 0;
        void 0 !== b ? (F && C(b, xe, "sy"), this.kd = b) : this.kd = 0;
        this.nm = new H;
        this.ot = this.nm.u;
        this.wa = !0
    }

    xe.prototype.copy = function () {
        var a = new xe;
        a.ws = this.ws;
        a.Bs = this.Bs;
        a.jd = this.jd;
        a.kd = this.kd;
        for (var b = this.nm.j, c = b.length, d = a.nm, e = 0; e < c; e++) {
            var f = b[e].copy();
            d.add(f)
        }
        a.ot = this.ot;
        a.wa = this.wa;
        a.Fx = this.Fx;
        return a
    };
    t = xe.prototype;
    t.Ta = function (a) {
        if (!(a instanceof xe && K.C(this.startX, a.startX) && K.C(this.startY, a.startY))) return !1;
        var b = this.segments.j;
        a = a.segments.j;
        var c = b.length;
        if (c !== a.length) return !1;
        for (var d = 0; d < c; d++) if (!b[d].Ta(a[d])) return !1;
        return !0
    };
    t.toString = function (a) {
        void 0 === a && (a = -1);
        var b = 0 > a ? "M" + this.startX.toString() + " " + this.startY.toString() : "M" + this.startX.toFixed(a) + " " + this.startY.toFixed(a);
        for (var c = this.segments.j, d = c.length, e = 0; e < d; e++) b += " " + c[e].toString(a);
        return b
    };
    t.freeze = function () {
        this.s = !0;
        var a = this.segments;
        a.freeze();
        var b = a.j;
        a = a.length;
        for (var c = 0; c < a; c++) b[c].freeze();
        return this
    };
    t.ka = function () {
        this.s = !1;
        var a = this.segments;
        a.ka();
        a = a.j;
        for (var b = a.length, c = 0; c < b; c++) a[c].ka();
        return this
    };
    t.rw = function () {
        if (this.wa) return !0;
        var a = this.segments;
        if (this.ot !== a.u) return !0;
        a = a.j;
        for (var b = a.length, c = 0; c < b; c++) if (a[c].wa) return !0;
        return !1
    };
    t.add = function (a) {
        this.nm.add(a);
        return this
    };
    t.ca = function (a, b, c) {
        for (var d = this.startX, e = this.startY, f = d, g = e, h = this.segments.j, k = h.length, l = 0; l < k; l++) {
            var m = h[l];
            switch (m.type) {
                case me:
                    f = m.endX;
                    g = m.endY;
                    d = m.endX;
                    e = m.endY;
                    break;
                case Md:
                    if (K.Ub(d, e, m.endX, m.endY, c, a, b)) return !0;
                    d = m.endX;
                    e = m.endY;
                    break;
                case ne:
                    if (K.Jt(d, e, m.point1X, m.point1Y, m.point2X, m.point2Y, m.endX, m.endY, .5, a, b, c)) return !0;
                    d = m.endX;
                    e = m.endY;
                    break;
                case oe:
                    if (K.Aw(d, e, m.point1X, m.point1Y, m.endX, m.endY, .5, a, b, c)) return !0;
                    d = m.endX;
                    e = m.endY;
                    break;
                case pe:
                case qe:
                    var n = m.type ===
                    pe ? re(m, this) : se(m, this, d, e), p = n.length;
                    if (0 === p) {
                        if (K.Ub(d, e, m.centerX, m.centerY, c, a, b)) return !0;
                        d = m.centerX;
                        e = m.centerY;
                        break
                    }
                    for (var r = null, q = 0; q < p; q++) if (r = n[q], 0 === q && K.Ub(d, e, r[0], r[1], c, a, b) || K.Jt(r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], .5, a, b, c)) return !0;
                    null !== r && (d = r[6], e = r[7]);
                    break;
                default:
                    v("Unknown Segment type: " + m.type)
            }
            if (m.isClosed && (d !== f || e !== g) && K.Ub(d, e, f, g, c, a, b)) return !0
        }
        return !1
    };
    na.Object.defineProperties(xe.prototype, {
        isFilled: {
            configurable: !0, get: function () {
                return this.ws
            }, set: function (a) {
                F && A(a, "boolean", xe, "isFilled");
                this.s && va(this, a);
                this.ws = a
            }
        }, isShadowed: {
            configurable: !0, get: function () {
                return this.Bs
            }, set: function (a) {
                F && A(a, "boolean", xe, "isShadowed");
                this.s && va(this, a);
                this.Bs = a
            }
        }, startX: {
            configurable: !0, get: function () {
                return this.jd
            }, set: function (a) {
                F && C(a, xe, "startX");
                this.s && va(this, a);
                this.jd = a;
                this.wa = !0
            }
        }, startY: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.kd
            }, set: function (a) {
                F && C(a, xe, "startY");
                this.s && va(this, a);
                this.kd = a;
                this.wa = !0
            }
        }, segments: {
            configurable: !0, get: function () {
                return this.nm
            }, set: function (a) {
                F && w(a, H, xe, "segments");
                this.s && va(this, a);
                this.nm = a;
                this.wa = !0
            }
        }
    });
    xe.prototype.add = xe.prototype.add;
    xe.prototype.equalsApprox = xe.prototype.Ta;
    xe.className = "PathFigure";

    function ye(a, b, c, d, e, f, g, h) {
        gb(this);
        this.s = !1;
        void 0 === a ? a = Md : F && ib(a, ye, ye, "constructor:type");
        this.sa = a;
        void 0 !== b ? (F && C(b, ye, "ex"), this.nc = b) : this.nc = 0;
        void 0 !== c ? (F && C(c, ye, "ey"), this.tc = c) : this.tc = 0;
        void 0 === d && (d = 0);
        void 0 === e && (e = 0);
        void 0 === f && (f = 0);
        void 0 === g && (g = 0);
        a === qe ? (a = f % 360, 0 > a && (a += 360), this.Je = a, this.$i = 0, F && C(d, ye, "x1"), this.aj = Math.max(d, 0), F && C(e, ye, "y1"), this.Bh = Math.max(e, 0), this.Xl = "boolean" === typeof g ? g : "number" === typeof g ? !!g : !1, this.ol = !!h) : (F && C(d, ye, "x1"), this.Je = d,
        F && C(e, ye, "y1"), this.$i = e, F && C(f, ye, "x2"), a === pe && (f = Math.max(f, 0)), this.aj = f, "number" === typeof g ? (a === pe && (g = Math.max(g, 0)), this.Bh = g) : this.Bh = 0, this.ol = this.Xl = !1);
        this.Yj = !1;
        this.wa = !0;
        this.bf = null
    }

    ye.prototype.copy = function () {
        var a = new ye;
        a.sa = this.sa;
        a.nc = this.nc;
        a.tc = this.tc;
        a.Je = this.Je;
        a.$i = this.$i;
        a.aj = this.aj;
        a.Bh = this.Bh;
        a.Xl = this.Xl;
        a.ol = this.ol;
        a.Yj = this.Yj;
        a.wa = this.wa;
        return a
    };
    t = ye.prototype;
    t.Ta = function (a) {
        if (!(a instanceof ye) || this.type !== a.type || this.isClosed !== a.isClosed) return !1;
        switch (this.type) {
            case me:
            case Md:
                return K.C(this.endX, a.endX) && K.C(this.endY, a.endY);
            case ne:
                return K.C(this.endX, a.endX) && K.C(this.endY, a.endY) && K.C(this.point1X, a.point1X) && K.C(this.point1Y, a.point1Y) && K.C(this.point2X, a.point2X) && K.C(this.point2Y, a.point2Y);
            case oe:
                return K.C(this.endX, a.endX) && K.C(this.endY, a.endY) && K.C(this.point1X, a.point1X) && K.C(this.point1Y, a.point1Y);
            case pe:
                return K.C(this.startAngle,
                    a.startAngle) && K.C(this.sweepAngle, a.sweepAngle) && K.C(this.centerX, a.centerX) && K.C(this.centerY, a.centerY) && K.C(this.radiusX, a.radiusX) && K.C(this.radiusY, a.radiusY);
            case qe:
                return this.isClockwiseArc === a.isClockwiseArc && this.isLargeArc === a.isLargeArc && K.C(this.xAxisRotation, a.xAxisRotation) && K.C(this.endX, a.endX) && K.C(this.endY, a.endY) && K.C(this.radiusX, a.radiusX) && K.C(this.radiusY, a.radiusY);
            default:
                return !1
        }
    };
    t.pb = function (a) {
        a.classType === ye ? this.type = a : Da(this, a)
    };
    t.toString = function (a) {
        void 0 === a && (a = -1);
        switch (this.type) {
            case me:
                a = 0 > a ? "M" + this.endX.toString() + " " + this.endY.toString() : "M" + this.endX.toFixed(a) + " " + this.endY.toFixed(a);
                break;
            case Md:
                a = 0 > a ? "L" + this.endX.toString() + " " + this.endY.toString() : "L" + this.endX.toFixed(a) + " " + this.endY.toFixed(a);
                break;
            case ne:
                a = 0 > a ? "C" + this.point1X.toString() + " " + this.point1Y.toString() + " " + this.point2X.toString() + " " + this.point2Y.toString() + " " + this.endX.toString() + " " + this.endY.toString() : "C" + this.point1X.toFixed(a) +
                    " " + this.point1Y.toFixed(a) + " " + this.point2X.toFixed(a) + " " + this.point2Y.toFixed(a) + " " + this.endX.toFixed(a) + " " + this.endY.toFixed(a);
                break;
            case oe:
                a = 0 > a ? "Q" + this.point1X.toString() + " " + this.point1Y.toString() + " " + this.endX.toString() + " " + this.endY.toString() : "Q" + this.point1X.toFixed(a) + " " + this.point1Y.toFixed(a) + " " + this.endX.toFixed(a) + " " + this.endY.toFixed(a);
                break;
            case pe:
                a = 0 > a ? "B" + this.startAngle.toString() + " " + this.sweepAngle.toString() + " " + this.centerX.toString() + " " + this.centerY.toString() +
                    " " + this.radiusX.toString() + " " + this.radiusY.toString() : "B" + this.startAngle.toFixed(a) + " " + this.sweepAngle.toFixed(a) + " " + this.centerX.toFixed(a) + " " + this.centerY.toFixed(a) + " " + this.radiusX.toFixed(a) + " " + this.radiusY.toFixed(a);
                break;
            case qe:
                a = 0 > a ? "A" + this.radiusX.toString() + " " + this.radiusY.toString() + " " + this.xAxisRotation.toString() + " " + (this.isLargeArc ? 1 : 0) + " " + (this.isClockwiseArc ? 1 : 0) + " " + this.endX.toString() + " " + this.endY.toString() : "A" + this.radiusX.toFixed(a) + " " + this.radiusY.toFixed(a) +
                    " " + this.xAxisRotation.toFixed(a) + " " + (this.isLargeArc ? 1 : 0) + " " + (this.isClockwiseArc ? 1 : 0) + " " + this.endX.toFixed(a) + " " + this.endY.toFixed(a);
                break;
            default:
                a = this.type.toString()
        }
        return a + (this.Yj ? "z" : "")
    };
    t.freeze = function () {
        this.s = !0;
        return this
    };
    t.ka = function () {
        this.s = !1;
        return this
    };
    t.close = function () {
        this.Yj = !0;
        return this
    };

    function re(a, b) {
        if (null !== a.bf && !1 === b.wa) return a.bf;
        var c = a.radiusX, d = a.radiusY;
        void 0 === d && (d = c);
        if (0 === c || 0 === d) return a.bf = [], a.bf;
        b = a.Je;
        var e = a.$i, f = K.vy(0, 0, c < d ? c : d, a.startAngle, a.startAngle + a.sweepAngle, !1);
        if (c !== d) {
            var g = Ib.alloc();
            g.reset();
            c < d ? g.scale(1, d / c) : g.scale(c / d, 1);
            ke(f, g);
            Ib.free(g)
        }
        c = f.length;
        for (d = 0; d < c; d++) g = f[d], g[0] += b, g[1] += e, g[2] += b, g[3] += e, g[4] += b, g[5] += e, g[6] += b, g[7] += e;
        a.bf = f;
        return a.bf
    }

    function se(a, b, c, d) {
        function e(a, b, c, d) {
            return (a * d < b * c ? -1 : 1) * Math.acos((a * c + b * d) / (Math.sqrt(a * a + b * b) * Math.sqrt(c * c + d * d)))
        }

        if (null !== a.bf && !1 === b.wa) return a.bf;
        b = a.aj;
        var f = a.Bh;
        0 === b && (b = 1E-4);
        0 === f && (f = 1E-4);
        var g = Math.PI / 180 * a.Je, h = a.Xl, k = a.ol, l = a.nc, m = a.tc, n = Math.cos(g), p = Math.sin(g),
            r = n * (c - l) / 2 + p * (d - m) / 2;
        g = -p * (c - l) / 2 + n * (d - m) / 2;
        var q = r * r / (b * b) + g * g / (f * f);
        1 < q && (b *= Math.sqrt(q), f *= Math.sqrt(q));
        q = (h === k ? -1 : 1) * Math.sqrt((b * b * f * f - b * b * g * g - f * f * r * r) / (b * b * g * g + f * f * r * r));
        isNaN(q) && (q = 0);
        h = q * b * g / f;
        q = q * -f *
            r / b;
        isNaN(h) && (h = 0);
        isNaN(q) && (q = 0);
        c = (c + l) / 2 + n * h - p * q;
        d = (d + m) / 2 + p * h + n * q;
        m = e(1, 0, (r - h) / b, (g - q) / f);
        n = (r - h) / b;
        l = (g - q) / f;
        r = (-r - h) / b;
        h = (-g - q) / f;
        g = e(n, l, r, h);
        r = (n * r + l * h) / (Math.sqrt(n * n + l * l) * Math.sqrt(r * r + h * h));
        -1 >= r ? g = Math.PI : 1 <= r && (g = 0);
        !k && 0 < g && (g -= 2 * Math.PI);
        k && 0 > g && (g += 2 * Math.PI);
        k = b > f ? 1 : b / f;
        r = b > f ? f / b : 1;
        b = K.vy(0, 0, b > f ? b : f, m, m + g, !0);
        f = Ib.alloc();
        f.reset();
        f.translate(c, d);
        f.rotate(a.Je, 0, 0);
        f.scale(k, r);
        ke(b, f);
        Ib.free(f);
        a.bf = b;
        return a.bf
    }

    na.Object.defineProperties(ye.prototype, {
        isClosed: {
            configurable: !0, get: function () {
                return this.Yj
            }, set: function (a) {
                this.Yj !== a && (this.Yj = a, this.wa = !0)
            }
        }, type: {
            configurable: !0, get: function () {
                return this.sa
            }, set: function (a) {
                F && ib(a, ye, ye, "type");
                this.s && va(this, a);
                this.sa = a;
                this.wa = !0
            }
        }, endX: {
            configurable: !0, get: function () {
                return this.nc
            }, set: function (a) {
                F && C(a, ye, "endX");
                this.s && va(this, a);
                this.nc = a;
                this.wa = !0
            }
        }, endY: {
            configurable: !0, get: function () {
                return this.tc
            },
            set: function (a) {
                F && C(a, ye, "endY");
                this.s && va(this, a);
                this.tc = a;
                this.wa = !0
            }
        }, point1X: {
            configurable: !0, get: function () {
                return this.Je
            }, set: function (a) {
                F && C(a, ye, "point1X");
                this.s && va(this, a);
                this.Je = a;
                this.wa = !0
            }
        }, point1Y: {
            configurable: !0, get: function () {
                return this.$i
            }, set: function (a) {
                F && C(a, ye, "point1Y");
                this.s && va(this, a);
                this.$i = a;
                this.wa = !0
            }
        }, point2X: {
            configurable: !0, get: function () {
                return this.aj
            }, set: function (a) {
                F && C(a, ye, "point2X");
                this.s && va(this, a);
                this.aj =
                    a;
                this.wa = !0
            }
        }, point2Y: {
            configurable: !0, get: function () {
                return this.Bh
            }, set: function (a) {
                F && C(a, ye, "point2Y");
                this.s && va(this, a);
                this.Bh = a;
                this.wa = !0
            }
        }, centerX: {
            configurable: !0, get: function () {
                return this.Je
            }, set: function (a) {
                F && C(a, ye, "centerX");
                this.s && va(this, a);
                this.Je = a;
                this.wa = !0
            }
        }, centerY: {
            configurable: !0, get: function () {
                return this.$i
            }, set: function (a) {
                F && C(a, ye, "centerY");
                this.s && va(this, a);
                this.$i = a;
                this.wa = !0
            }
        }, radiusX: {
            configurable: !0,
            get: function () {
                return this.aj
            }, set: function (a) {
                F && C(a, ye, "radiusX");
                0 > a && za(a, ">= zero", ye, "radiusX");
                this.s && va(this, a);
                this.aj = a;
                this.wa = !0
            }
        }, radiusY: {
            configurable: !0, get: function () {
                return this.Bh
            }, set: function (a) {
                F && C(a, ye, "radiusY");
                0 > a && za(a, ">= zero", ye, "radiusY");
                this.s && va(this, a);
                this.Bh = a;
                this.wa = !0
            }
        }, startAngle: {
            configurable: !0, get: function () {
                return this.nc
            }, set: function (a) {
                this.nc !== a && (this.s && va(this, a), F && C(a, ye, "startAngle"), a %= 360, 0 > a && (a += 360), this.nc =
                    a, this.wa = !0)
            }
        }, sweepAngle: {
            configurable: !0, get: function () {
                return this.tc
            }, set: function (a) {
                F && C(a, ye, "sweepAngle");
                this.s && va(this, a);
                360 < a && (a = 360);
                -360 > a && (a = -360);
                this.tc = a;
                this.wa = !0
            }
        }, isClockwiseArc: {
            configurable: !0, get: function () {
                return this.ol
            }, set: function (a) {
                this.s && va(this, a);
                this.ol = a;
                this.wa = !0
            }
        }, isLargeArc: {
            configurable: !0, get: function () {
                return this.Xl
            }, set: function (a) {
                this.s && va(this, a);
                this.Xl = a;
                this.wa = !0
            }
        }, xAxisRotation: {
            configurable: !0,
            get: function () {
                return this.Je
            }, set: function (a) {
                F && C(a, ye, "xAxisRotation");
                a %= 360;
                0 > a && (a += 360);
                this.s && va(this, a);
                this.Je = a;
                this.wa = !0
            }
        }
    });
    ye.prototype.equalsApprox = ye.prototype.Ta;
    var me = new E(ye, "Move", 0), Md = new E(ye, "Line", 1), ne = new E(ye, "Bezier", 2),
        oe = new E(ye, "QuadraticBezier", 3), pe = new E(ye, "Arc", 4), qe = new E(ye, "SvgArc", 4);
    ye.className = "PathSegment";
    ye.Move = me;
    ye.Line = Md;
    ye.Bezier = ne;
    ye.QuadraticBezier = oe;
    ye.Arc = pe;
    ye.SvgArc = qe;

    function Ae() {
        this.B = null;
        this.Jv = (new J(0, 0)).freeze();
        this.Su = (new J(0, 0)).freeze();
        this.Lr = this.Ms = 0;
        this.Mr = 1;
        this.Mi = "";
        this.Dt = this.fs = !1;
        this.cs = this.Or = 0;
        this.bh = this.ps = this.zs = !1;
        this.ls = null;
        this.yt = 0;
        this.td = this.xt = null
    }

    Ae.prototype.copy = function () {
        var a = new Ae;
        return this.clone(a)
    };
    Ae.prototype.clone = function (a) {
        a.B = this.B;
        a.Jv.assign(this.viewPoint);
        a.Su.assign(this.documentPoint);
        a.Ms = this.Ms;
        a.Lr = this.Lr;
        a.Mr = this.Mr;
        a.Mi = this.Mi;
        a.fs = this.fs;
        a.Dt = this.Dt;
        a.Or = this.Or;
        a.cs = this.cs;
        a.zs = this.zs;
        a.ps = this.ps;
        a.bh = this.bh;
        a.ls = this.ls;
        a.yt = this.yt;
        a.xt = this.xt;
        a.td = this.td;
        return a
    };
    Ae.prototype.toString = function () {
        var a = "^";
        0 !== this.modifiers && (a += "M:" + this.modifiers);
        0 !== this.button && (a += "B:" + this.button);
        "" !== this.key && (a += "K:" + this.key);
        0 !== this.clickCount && (a += "C:" + this.clickCount);
        0 !== this.delta && (a += "D:" + this.delta);
        this.handled && (a += "h");
        this.bubbles && (a += "b");
        null !== this.documentPoint && (a += "@" + this.documentPoint.toString());
        return a
    };
    Ae.prototype.Sq = function (a, b) {
        var c = this.diagram;
        if (null === c) return b;
        Be(c, this.event, a, b);
        return b
    };
    Ae.prototype.EA = function (a, b) {
        var c = this.diagram;
        if (null === c) return b;
        Be(c, this.event, a, b);
        b.assign(c.yu(b));
        return b
    };
    na.Object.defineProperties(Ae.prototype, {
        diagram: {
            configurable: !0, get: function () {
                return this.B
            }, set: function (a) {
                this.B = a
            }
        }, viewPoint: {
            configurable: !0, get: function () {
                return this.Jv
            }, set: function (a) {
                w(a, J, Ae, "viewPoint");
                this.Jv.assign(a)
            }
        }, documentPoint: {
            configurable: !0, get: function () {
                return this.Su
            }, set: function (a) {
                w(a, J, Ae, "documentPoint");
                this.Su.assign(a)
            }
        }, modifiers: {
            configurable: !0, get: function () {
                return this.Ms
            }, set: function (a) {
                this.Ms =
                    a
            }
        }, button: {
            configurable: !0, get: function () {
                return this.Lr
            }, set: function (a) {
                this.Lr = a;
                if (null === this.event) switch (a) {
                    case 0:
                        this.buttons = 1;
                        break;
                    case 1:
                        this.buttons = 4;
                        break;
                    case 2:
                        this.buttons = 2
                }
            }
        }, buttons: {
            configurable: !0, get: function () {
                return this.Mr
            }, set: function (a) {
                this.Mr = a
            }
        }, key: {
            configurable: !0, get: function () {
                return this.Mi
            }, set: function (a) {
                this.Mi = a
            }
        }, down: {
            configurable: !0, get: function () {
                return this.fs
            }, set: function (a) {
                this.fs = a
            }
        }, up: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Dt
            }, set: function (a) {
                this.Dt = a
            }
        }, clickCount: {
            configurable: !0, get: function () {
                return this.Or
            }, set: function (a) {
                this.Or = a
            }
        }, delta: {
            configurable: !0, get: function () {
                return this.cs
            }, set: function (a) {
                this.cs = a
            }
        }, isMultiTouch: {
            configurable: !0, get: function () {
                return this.zs
            }, set: function (a) {
                this.zs = a
            }
        }, handled: {
            configurable: !0, get: function () {
                return this.ps
            }, set: function (a) {
                this.ps = a
            }
        }, bubbles: {
            configurable: !0,
            get: function () {
                return this.bh
            }, set: function (a) {
                this.bh = a
            }
        }, event: {
            configurable: !0, get: function () {
                return this.ls
            }, set: function (a) {
                this.ls = a
            }
        }, isTouchEvent: {
            configurable: !0, get: function () {
                var a = qa.TouchEvent, b = this.event;
                return a && b instanceof a ? !0 : (a = qa.PointerEvent) && b instanceof a && ("touch" === b.pointerType || "pen" === b.pointerType)
            }
        }, timestamp: {
            configurable: !0, get: function () {
                return this.yt
            }, set: function (a) {
                this.yt = a
            }
        }, targetDiagram: {
            configurable: !0,
            get: function () {
                return this.xt
            }, set: function (a) {
                this.xt = a
            }
        }, targetObject: {
            configurable: !0, get: function () {
                return this.td
            }, set: function (a) {
                this.td = a
            }
        }, control: {
            configurable: !0, get: function () {
                return 0 !== (this.modifiers & 1)
            }, set: function (a) {
                this.modifiers = a ? this.modifiers | 1 : this.modifiers & -2
            }
        }, shift: {
            configurable: !0, get: function () {
                return 0 !== (this.modifiers & 4)
            }, set: function (a) {
                this.modifiers = a ? this.modifiers | 4 : this.modifiers & -5
            }
        }, alt: {
            configurable: !0,
            get: function () {
                return 0 !== (this.modifiers & 2)
            }, set: function (a) {
                this.modifiers = a ? this.modifiers | 2 : this.modifiers & -3
            }
        }, meta: {
            configurable: !0, get: function () {
                return 0 !== (this.modifiers & 8)
            }, set: function (a) {
                this.modifiers = a ? this.modifiers | 8 : this.modifiers & -9
            }
        }, left: {
            configurable: !0, get: function () {
                var a = this.event;
                return null === a || "mousedown" !== a.type && "mouseup" !== a.type && "pointerdown" !== a.type && "pointerup" !== a.type ? 0 !== (this.buttons & 1) : 0 === this.button
            }, set: function (a) {
                this.buttons =
                    a ? this.buttons | 1 : this.buttons & -2
            }
        }, right: {
            configurable: !0, get: function () {
                var a = this.event;
                return null === a || "mousedown" !== a.type && "mouseup" !== a.type && "pointerdown" !== a.type && "pointerup" !== a.type ? 0 !== (this.buttons & 2) : 2 === this.button
            }, set: function (a) {
                this.buttons = a ? this.buttons | 2 : this.buttons & -3
            }
        }, middle: {
            configurable: !0, get: function () {
                var a = this.event;
                return null === a || "mousedown" !== a.type && "mouseup" !== a.type && "pointerdown" !== a.type && "pointerup" !== a.type ? 0 !== (this.buttons &
                    4) : 1 === this.button
            }, set: function (a) {
                this.buttons = a ? this.buttons | 4 : this.buttons & -5
            }
        }
    });
    Ae.prototype.getMultiTouchDocumentPoint = Ae.prototype.EA;
    Ae.prototype.getMultiTouchViewPoint = Ae.prototype.Sq;
    Ae.className = "InputEvent";

    function Ce() {
        this.B = null;
        this.Wa = "";
        this.Ws = this.vt = null
    }

    Ce.prototype.copy = function () {
        var a = new Ce;
        a.B = this.B;
        a.Wa = this.Wa;
        a.vt = this.vt;
        a.Ws = this.Ws;
        return a
    };
    Ce.prototype.toString = function () {
        var a = "*" + this.name;
        null !== this.subject && (a += ":" + this.subject.toString());
        null !== this.parameter && (a += "(" + this.parameter.toString() + ")");
        return a
    };
    na.Object.defineProperties(Ce.prototype, {
        diagram: {
            configurable: !0, get: function () {
                return this.B
            }, set: function (a) {
                this.B = a
            }
        }, name: {
            configurable: !0, get: function () {
                return this.Wa
            }, set: function (a) {
                this.Wa = a
            }
        }, subject: {
            configurable: !0, get: function () {
                return this.vt
            }, set: function (a) {
                this.vt = a
            }
        }, parameter: {
            configurable: !0, get: function () {
                return this.Ws
            }, set: function (a) {
                this.Ws = a
            }
        }
    });
    Ce.className = "DiagramEvent";

    function Ke() {
        this.Gn = Le;
        this.tf = this.Ls = "";
        this.op = this.pp = this.wp = this.xp = this.vp = this.B = this.hc = null
    }

    Ke.prototype.clear = function () {
        this.op = this.pp = this.wp = this.xp = this.vp = this.B = this.hc = null
    };
    Ke.prototype.copy = function () {
        var a = new Ke;
        a.Gn = this.Gn;
        a.Ls = this.Ls;
        a.tf = this.tf;
        a.hc = this.hc;
        a.B = this.B;
        a.vp = this.vp;
        var b = this.xp;
        a.xp = Ga(b) && "function" === typeof b.J ? b.J() : b;
        b = this.wp;
        a.wp = Ga(b) && "function" === typeof b.J ? b.J() : b;
        b = this.pp;
        a.pp = Ga(b) && "function" === typeof b.J ? b.J() : b;
        b = this.op;
        a.op = Ga(b) && "function" === typeof b.J ? b.J() : b;
        return a
    };
    Ke.prototype.pb = function (a) {
        a.classType === Ke ? this.change = a : Da(this, a)
    };
    Ke.prototype.toString = function () {
        var a = "";
        a = this.change === Me ? a + "* " : this.change === Le ? a + (null !== this.model ? "!m" : "!d") : a + ((null !== this.model ? "!m" : "!d") + this.change);
        this.propertyName && "string" === typeof this.propertyName && (a += " " + this.propertyName);
        this.modelChange && this.modelChange !== this.propertyName && (a += " " + this.modelChange);
        a += ": ";
        this.change === Me ? null !== this.oldValue && (a += " " + this.oldValue) : (null !== this.object && (a += Qa(this.object)), null !== this.oldValue && (a += "  old: " + Qa(this.oldValue)), null !==
        this.oldParam && (a += " " + this.oldParam), null !== this.newValue && (a += "  new: " + Qa(this.newValue)), null !== this.newParam && (a += " " + this.newParam));
        return a
    };
    Ke.prototype.K = function (a) {
        return a ? this.oldValue : this.newValue
    };
    Ke.prototype.GA = function (a) {
        return a ? this.oldParam : this.newParam
    };
    Ke.prototype.canUndo = function () {
        return null !== this.model || null !== this.diagram ? !0 : !1
    };
    Ke.prototype.undo = function () {
        this.canUndo() && (null !== this.model ? this.model.changeState(this, !0) : null !== this.diagram && this.diagram.changeState(this, !0))
    };
    Ke.prototype.canRedo = function () {
        return null !== this.model || null !== this.diagram ? !0 : !1
    };
    Ke.prototype.redo = function () {
        this.canRedo() && (null !== this.model ? this.model.changeState(this, !1) : null !== this.diagram && this.diagram.changeState(this, !1))
    };
    na.Object.defineProperties(Ke.prototype, {
        model: {
            configurable: !0, get: function () {
                return this.hc
            }, set: function (a) {
                this.hc = a
            }
        }, diagram: {
            configurable: !0, get: function () {
                return this.B
            }, set: function (a) {
                this.B = a
            }
        }, change: {
            configurable: !0, get: function () {
                return this.Gn
            }, set: function (a) {
                F && ib(a, Ke, Ke, "change");
                this.Gn = a
            }
        }, modelChange: {
            configurable: !0, get: function () {
                return this.Ls
            }, set: function (a) {
                F && A(a, "string", Ke, "modelChange");
                this.Ls = a
            }
        }, propertyName: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.tf
            }, set: function (a) {
                F && "string" !== typeof a && A(a, "function", Ke, "propertyName");
                this.tf = a
            }
        }, isTransactionFinished: {
            configurable: !0, get: function () {
                return this.Gn === Me && ("CommittedTransaction" === this.tf || "FinishedUndo" === this.tf || "FinishedRedo" === this.tf)
            }
        }, object: {
            configurable: !0, get: function () {
                return this.vp
            }, set: function (a) {
                this.vp = a
            }
        }, oldValue: {
            configurable: !0, get: function () {
                return this.xp
            }, set: function (a) {
                this.xp =
                    a
            }
        }, oldParam: {
            configurable: !0, get: function () {
                return this.wp
            }, set: function (a) {
                this.wp = a
            }
        }, newValue: {
            configurable: !0, get: function () {
                return this.pp
            }, set: function (a) {
                this.pp = a
            }
        }, newParam: {
            configurable: !0, get: function () {
                return this.op
            }, set: function (a) {
                this.op = a
            }
        }
    });
    Ke.prototype.redo = Ke.prototype.redo;
    Ke.prototype.canRedo = Ke.prototype.canRedo;
    Ke.prototype.undo = Ke.prototype.undo;
    Ke.prototype.canUndo = Ke.prototype.canUndo;
    Ke.prototype.getParam = Ke.prototype.GA;
    Ke.prototype.getValue = Ke.prototype.K;
    Ke.prototype.clear = Ke.prototype.clear;
    var Me = new E(Ke, "Transaction", -1), Le = new E(Ke, "Property", 0), Ne = new E(Ke, "Insert", 1),
        Oe = new E(Ke, "Remove", 2);
    Ke.className = "ChangedEvent";
    Ke.Transaction = Me;
    Ke.Property = Le;
    Ke.Insert = Ne;
    Ke.Remove = Oe;

    function Pe() {
        this.w = (new H).freeze();
        this.Wa = "";
        this.l = !1
    }

    Pe.prototype.toString = function (a) {
        var b = "Transaction: " + this.name + " " + this.changes.count.toString() + (this.isComplete ? "" : ", incomplete");
        if (void 0 !== a && 0 < a) {
            a = this.changes.count;
            for (var c = 0; c < a; c++) {
                var d = this.changes.M(c);
                null !== d && (b += "\n  " + d.toString())
            }
        }
        return b
    };
    Pe.prototype.clear = function () {
        var a = this.changes;
        a.ka();
        for (var b = a.count - 1; 0 <= b; b--) {
            var c = a.M(b);
            null !== c && c.clear()
        }
        a.clear();
        a.freeze()
    };
    Pe.prototype.canUndo = function () {
        return this.isComplete
    };
    Pe.prototype.undo = function () {
        if (this.canUndo()) for (var a = this.changes.count - 1; 0 <= a; a--) {
            var b = this.changes.M(a);
            null !== b && b.undo()
        }
    };
    Pe.prototype.canRedo = function () {
        return this.isComplete
    };
    Pe.prototype.redo = function () {
        if (this.canRedo()) for (var a = this.changes.count, b = 0; b < a; b++) {
            var c = this.changes.M(b);
            null !== c && c.redo()
        }
    };
    Pe.prototype.xw = function () {
        if (this.isComplete) {
            var a = this.changes;
            a.ka();
            for (var b = new Db, c = 0; c < a.count; c++) {
                var d = a.M(c);
                if (null !== d && d.change === Le && d.object) {
                    var e = b.get(d.object);
                    e || (e = new Db, b.set(d.object, e));
                    var f = e.get(d.propertyName);
                    null === f ? e.set(d.propertyName, -1) : (0 < f && a.Vc(f, null), e.set(d.propertyName, c))
                }
            }
            for (c = b = 0; c < a.count; c++) d = a.M(c), null !== d && (c > b && a.Vc(b, d), b++);
            for (; a.length > b;) a.pop();
            a.freeze()
        }
    };
    na.Object.defineProperties(Pe.prototype, {
        changes: {
            configurable: !0, get: function () {
                return this.w
            }
        }, name: {
            configurable: !0, get: function () {
                return this.Wa
            }, set: function (a) {
                this.Wa = a
            }
        }, isComplete: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                this.l = a
            }
        }
    });
    Pe.prototype.optimize = Pe.prototype.xw;
    Pe.prototype.redo = Pe.prototype.redo;
    Pe.prototype.canRedo = Pe.prototype.canRedo;
    Pe.prototype.undo = Pe.prototype.undo;
    Pe.prototype.canUndo = Pe.prototype.canUndo;
    Pe.prototype.clear = Pe.prototype.clear;
    Pe.className = "Transaction";

    function Qe() {
        this.qv = new I;
        this.qd = !1;
        this.L = (new H).freeze();
        this.Xd = -1;
        this.w = 999;
        this.ye = !1;
        this.Zr = null;
        this.hj = 0;
        this.l = !1;
        F && (this.l = !0);
        this.Fe = (new H).freeze();
        this.em = new H;
        this.Zu = !0;
        this.fv = this.xs = this.jv = this.iv = !1
    }

    Qe.prototype.toString = function (a) {
        var b = "UndoManager " + this.historyIndex + "<" + this.history.count + "<=" + this.maxHistoryLength;
        b += "[";
        for (var c = this.nestedTransactionNames.count, d = 0; d < c; d++) 0 < d && (b += " "), b += this.nestedTransactionNames.M(d);
        b += "]";
        if (void 0 !== a && 0 < a) for (c = this.history.count, d = 0; d < c; d++) b += "\n " + this.history.M(d).toString(a - 1);
        return b
    };
    Qe.prototype.clear = function () {
        var a = this.history;
        a.ka();
        for (var b = a.count - 1; 0 <= b; b--) {
            var c = a.M(b);
            null !== c && c.clear()
        }
        a.clear();
        this.Xd = -1;
        a.freeze();
        this.ye = !1;
        this.Zr = null;
        this.hj = 0;
        this.Fe.ka();
        this.Fe.clear();
        this.Fe.freeze();
        this.em.clear();
        this.fv = this.xs = this.jv = this.iv = !1
    };
    Qe.prototype.copyProperties = function (a) {
        this.isEnabled = a.isEnabled;
        this.maxHistoryLength = a.maxHistoryLength;
        this.checksTransactionLevel = a.checksTransactionLevel
    };
    t = Qe.prototype;
    t.ly = function (a) {
        this.qv.add(a)
    };
    t.ez = function (a) {
        this.qv.remove(a)
    };
    t.Ca = function (a) {
        void 0 === a && (a = "");
        null === a && (a = "");
        if (this.isUndoingRedoing) return !1;
        !0 === this.Zu && (this.Zu = !1, this.hj++, this.isInternalTransaction || this.Hb("StartingFirstTransaction", a, this.currentTransaction), 0 < this.hj && this.hj--);
        this.isEnabled && (this.Fe.ka(), this.Fe.add(a), this.Fe.freeze(), null === this.currentTransaction ? this.em.add(0) : this.em.add(this.currentTransaction.changes.count));
        this.hj++;
        var b = 1 === this.transactionLevel;
        b && (this.isInternalTransaction || this.Hb("StartedTransaction", a, this.currentTransaction));
        return b
    };
    t.bb = function (a) {
        void 0 === a && (a = "");
        return Re(this, !0, a)
    };
    t.Uf = function () {
        return Re(this, !1, "")
    };

    function Re(a, b, c) {
        if (a.isUndoingRedoing) return !1;
        a.checksTransactionLevel && 1 > a.transactionLevel && Ea("Ending transaction without having started a transaction: " + c);
        var d = 1 === a.transactionLevel, e = a.currentTransaction;
        d && b && (a.isInternalTransaction || a.Hb("CommittingTransaction", c, e));
        var f = 0;
        if (0 < a.transactionLevel && (a.hj--, a.isEnabled)) {
            var g = a.Fe.count;
            0 < g && ("" === c && (c = a.Fe.M(0)), a.Fe.ka(), a.Fe.jb(g - 1), a.Fe.freeze());
            g = a.em.count;
            0 < g && (f = a.em.M(g - 1), a.em.jb(g - 1))
        }
        if (d) {
            if (b) {
                a.xs = !1;
                null === e && "" !==
                c && (e = a.currentTransaction);
                if (a.isEnabled && null !== e) {
                    e.isComplete || (e.isComplete = !0, e.name = c);
                    b = a.history;
                    b.ka();
                    for (d = b.count - 1; d > a.historyIndex; d--) f = b.M(d), null !== f && f.clear(), b.jb(d), a.xs = !0;
                    d = a.maxHistoryLength;
                    0 <= d && (0 === d ? b.clear() : b.count >= d && (f = b.M(0), null !== f && f.clear(), b.jb(0), a.Xd--));
                    0 === d || 0 !== b.count && b.get(b.count - 1) === e || (b.add(e), a.Xd++);
                    b.freeze()
                }
                a.isInternalTransaction || a.Hb("CommittedTransaction", c, e)
            } else {
                a.ye = !0;
                try {
                    a.isEnabled && null !== e && (e.isComplete = !0, e.undo())
                } finally {
                    a.isInternalTransaction ||
                    a.Hb("RolledBackTransaction", c, e), a.ye = !1
                }
                null !== e && e.clear()
            }
            a.Zr = null;
            a.isPendingClear && a.clear();
            a.isPendingClear = !1;
            a.isPendingUnmodified = !1;
            return !0
        }
        if (a.isEnabled && !b && null !== e) {
            a = f;
            c = e.changes;
            for (e = c.count - 1; e >= a; e--) b = c.M(e), null !== b && b.undo(), c.ka(), c.jb(e);
            c.freeze()
        }
        return !1
    }

    Qe.prototype.canUndo = function () {
        if (!this.isEnabled || 0 < this.transactionLevel) return !1;
        var a = this.transactionToUndo;
        return null !== a && a.canUndo() ? !0 : !1
    };
    Qe.prototype.undo = function () {
        if (this.canUndo()) {
            var a = this.transactionToUndo;
            try {
                this.ye = !0, this.Hb("StartingUndo", "Undo", a), this.Xd--, a.undo()
            } catch (b) {
                Ea("undo error: " + b.toString())
            } finally {
                this.Hb("FinishedUndo", "Undo", a), this.ye = !1
            }
        }
    };
    Qe.prototype.canRedo = function () {
        if (!this.isEnabled || 0 < this.transactionLevel) return !1;
        var a = this.transactionToRedo;
        return null !== a && a.canRedo() ? !0 : !1
    };
    Qe.prototype.redo = function () {
        if (this.canRedo()) {
            var a = this.transactionToRedo;
            try {
                this.ye = !0, this.Hb("StartingRedo", "Redo", a), this.Xd++, a.redo()
            } catch (b) {
                Ea("redo error: " + b.toString())
            } finally {
                this.Hb("FinishedRedo", "Redo", a), this.ye = !1
            }
        }
    };
    Qe.prototype.Hb = function (a, b, c) {
        void 0 === c && (c = null);
        var d = new Ke;
        d.change = Me;
        d.propertyName = a;
        d.object = c;
        d.oldValue = b;
        for (a = this.models; a.next();) b = a.value, d.model = b, b.Kt(d)
    };
    Qe.prototype.mw = function (a) {
        if (this.isEnabled && !this.isUndoingRedoing && !this.skipsEvent(a)) {
            var b = this.currentTransaction;
            null === b && (this.Zr = b = new Pe);
            var c = a.copy();
            b = b.changes;
            b.ka();
            b.add(c);
            b.freeze();
            this.checksTransactionLevel && 0 >= this.transactionLevel && !this.Zu && (a = a.diagram, null !== a && !1 === a.Aj || Ea("Change not within a transaction: " + c.toString()))
        }
    };
    Qe.prototype.skipsEvent = function (a) {
        if (null === a || 0 > a.change.value) return !0;
        a = a.object;
        if (null === a) return !1;
        if (void 0 !== a.layer) {
            if (a = a.layer, null !== a && a.isTemporary) return !0
        } else if (a.isTemporary) return !0;
        return !1
    };
    na.Object.defineProperties(Qe.prototype, {
        models: {
            configurable: !0, get: function () {
                return this.qv.iterator
            }
        }, isEnabled: {
            configurable: !0, get: function () {
                return this.qd
            }, set: function (a) {
                this.qd = a
            }
        }, transactionToUndo: {
            configurable: !0, get: function () {
                return 0 <= this.historyIndex && this.historyIndex <= this.history.count - 1 ? this.history.M(this.historyIndex) : null
            }
        }, transactionToRedo: {
            configurable: !0, get: function () {
                return this.historyIndex < this.history.count -
                1 ? this.history.M(this.historyIndex + 1) : null
            }
        }, isUndoingRedoing: {
            configurable: !0, get: function () {
                return this.ye
            }
        }, history: {
            configurable: !0, get: function () {
                return this.L
            }
        }, maxHistoryLength: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                this.w = a
            }
        }, historyIndex: {
            configurable: !0, get: function () {
                return this.Xd
            }
        }, currentTransaction: {
            configurable: !0, get: function () {
                return this.Zr
            }
        }, transactionLevel: {
            configurable: !0,
            get: function () {
                return this.hj
            }
        }, isInTransaction: {
            configurable: !0, get: function () {
                return 0 < this.hj
            }
        }, checksTransactionLevel: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                this.l = a
            }
        }, nestedTransactionNames: {
            configurable: !0, get: function () {
                return this.Fe
            }
        }, isPendingClear: {
            configurable: !0, get: function () {
                return this.iv
            }, set: function (a) {
                this.iv = a
            }
        }, isPendingUnmodified: {
            configurable: !0, get: function () {
                return this.jv
            }, set: function (a) {
                this.jv =
                    a
            }
        }, isInternalTransaction: {
            configurable: !0, get: function () {
                return this.fv
            }, set: function (a) {
                this.fv = a
            }
        }, isJustDiscarded: {
            configurable: !0, get: function () {
                return this.xs
            }
        }
    });
    Qe.prototype.handleChanged = Qe.prototype.mw;
    Qe.prototype.redo = Qe.prototype.redo;
    Qe.prototype.undo = Qe.prototype.undo;
    Qe.prototype.canUndo = Qe.prototype.canUndo;
    Qe.prototype.rollbackTransaction = Qe.prototype.Uf;
    Qe.prototype.commitTransaction = Qe.prototype.bb;
    Qe.prototype.startTransaction = Qe.prototype.Ca;
    Qe.prototype.removeModel = Qe.prototype.ez;
    Qe.prototype.addModel = Qe.prototype.ly;
    Qe.prototype.clear = Qe.prototype.clear;
    Qe.className = "UndoManager";

    function Se() {
        0 < arguments.length && Ba(Se);
        gb(this);
        this.B = Te;
        this.Wa = "";
        this.qd = !0;
        this.Zc = !1;
        this.vx = null;
        this.Bz = new Ae;
        this.Gt = -1
    }

    Se.prototype.toString = function () {
        return "" !== this.name ? this.name + " Tool" : Pa(this.constructor)
    };
    Se.prototype.updateAdornments = function () {
    };
    Se.prototype.canStart = function () {
        return this.isEnabled
    };
    Se.prototype.doStart = function () {
    };
    Se.prototype.doActivate = function () {
        this.isActive = !0
    };
    Se.prototype.doDeactivate = function () {
        this.isActive = !1
    };
    Se.prototype.doStop = function () {
    };
    Se.prototype.doCancel = function () {
        this.transactionResult = null;
        this.stopTool()
    };
    Se.prototype.stopTool = function () {
        var a = this.diagram;
        a.currentTool === this && (a.currentTool = null, a.currentCursor = "")
    };
    Se.prototype.doMouseDown = function () {
        !this.isActive && this.canStart() && this.doActivate()
    };
    Se.prototype.doMouseMove = function () {
    };
    Se.prototype.doMouseUp = function () {
        this.stopTool()
    };
    Se.prototype.doMouseWheel = function () {
    };
    Se.prototype.canStartMultiTouch = function () {
        return !0
    };
    Se.prototype.standardPinchZoomStart = function () {
        var a = this.diagram, b = a.lastInput, c = b.Sq(0, J.allocAt(NaN, NaN)), d = b.Sq(1, J.allocAt(NaN, NaN));
        if (c.o() && d.o() && (this.doCancel(), a.Nm("hasGestureZoom"))) {
            a.gm = a.scale;
            var e = d.x - c.x, f = d.y - c.y;
            a.Dv = Math.sqrt(e * e + f * f);
            b.bubbles = !1
        }
        J.free(c);
        J.free(d)
    };
    Se.prototype.standardPinchZoomMove = function () {
        var a = this.diagram, b = a.lastInput, c = b.Sq(0, J.allocAt(NaN, NaN)), d = b.Sq(1, J.allocAt(NaN, NaN));
        if (c.o() && d.o() && (this.doCancel(), a.Nm("hasGestureZoom"))) {
            var e = d.x - c.x, f = d.y - c.y;
            f = Math.sqrt(e * e + f * f) / a.Dv;
            e = new J((Math.min(d.x, c.x) + Math.max(d.x, c.x)) / 2, (Math.min(d.y, c.y) + Math.max(d.y, c.y)) / 2);
            f *= a.gm;
            var g = a.commandHandler;
            if (f !== a.scale && g.canResetZoom(f)) {
                var h = a.zoomPoint;
                a.zoomPoint = e;
                g.resetZoom(f);
                a.zoomPoint = h
            }
            b.bubbles = !1
        }
        J.free(c);
        J.free(d)
    };
    Se.prototype.doKeyDown = function () {
        "Esc" === this.diagram.lastInput.key && this.doCancel()
    };
    Se.prototype.doKeyUp = function () {
    };
    Se.prototype.Ca = function (a) {
        void 0 === a && (a = this.name);
        this.transactionResult = null;
        return this.diagram.Ca(a)
    };
    Se.prototype.Wg = function () {
        var a = this.diagram;
        return null === this.transactionResult ? a.Uf() : a.bb(this.transactionResult)
    };
    Se.prototype.standardMouseSelect = function () {
        var a = this.diagram;
        if (a.allowSelect) {
            var b = a.lastInput, c = a.Lm(b.documentPoint, !1);
            if (null !== c) if (eb ? b.meta : b.control) {
                a.U("ChangingSelection", a.selection);
                for (b = c; null !== b && !b.canSelect();) b = b.containingGroup;
                null !== b && (b.isSelected = !b.isSelected);
                a.U("ChangedSelection", a.selection)
            } else if (b.shift) {
                if (!c.isSelected) {
                    a.U("ChangingSelection", a.selection);
                    for (b = c; null !== b && !b.canSelect();) b = b.containingGroup;
                    null !== b && (b.isSelected = !0);
                    a.U("ChangedSelection",
                        a.selection)
                }
            } else {
                if (!c.isSelected) {
                    for (b = c; null !== b && !b.canSelect();) b = b.containingGroup;
                    null !== b && a.select(b)
                }
            } else !b.left || (eb ? b.meta : b.control) || b.shift || a.clearSelection()
        }
    };
    Se.prototype.standardMouseClick = function (a, b) {
        void 0 === a && (a = null);
        void 0 === b && (b = function (a) {
            return !a.layer.isTemporary
        });
        var c = this.diagram, d = c.lastInput;
        a = c.ac(d.documentPoint, a, b);
        d.targetObject = a;
        Ue(a, d, c);
        return d.handled
    };

    function Ue(a, b, c) {
        b.handled = !1;
        if (null === a || a.Ug()) {
            var d = 0;
            b.left ? d = 1 === b.clickCount ? 1 : 2 === b.clickCount ? 2 : 1 : b.right && 1 === b.clickCount && (d = 3);
            var e = "ObjectSingleClicked";
            if (null !== a) {
                switch (d) {
                    case 1:
                        e = "ObjectSingleClicked";
                        break;
                    case 2:
                        e = "ObjectDoubleClicked";
                        break;
                    case 3:
                        e = "ObjectContextClicked"
                }
                0 !== d && c.U(e, a)
            } else {
                switch (d) {
                    case 1:
                        e = "BackgroundSingleClicked";
                        break;
                    case 2:
                        e = "BackgroundDoubleClicked";
                        break;
                    case 3:
                        e = "BackgroundContextClicked"
                }
                0 !== d && c.U(e)
            }
            if (null !== a) for (; null !== a;) {
                c = null;
                switch (d) {
                    case 1:
                        c =
                            a.click;
                        break;
                    case 2:
                        c = a.doubleClick ? a.doubleClick : a.click;
                        break;
                    case 3:
                        c = a.contextClick
                }
                if (null !== c && (c(b, a), b.handled)) break;
                a = a.panel
            } else {
                a = null;
                switch (d) {
                    case 1:
                        a = c.click;
                        break;
                    case 2:
                        a = c.doubleClick ? c.doubleClick : c.click;
                        break;
                    case 3:
                        a = c.contextClick
                }
                null !== a && a(b)
            }
        }
    }

    Se.prototype.standardMouseOver = function () {
        var a = this.diagram, b = a.lastInput;
        if (!0 !== a.animationManager.yc) {
            var c = a.skipsUndoManager;
            a.skipsUndoManager = !0;
            var d = a.viewportBounds.ca(b.documentPoint) ? a.ac(b.documentPoint, null, null) : null;
            b.targetObject = d;
            var e = !1;
            if (d !== a.Oj) {
                var f = a.Oj, g = f;
                a.Oj = d;
                this.doCurrentObjectChanged(f, d);
                for (b.handled = !1; null !== f;) {
                    var h = f.mouseLeave;
                    if (null !== h) {
                        if (d === f) break;
                        if (null !== d && d.Tg(f)) break;
                        h(b, f, d);
                        e = !0;
                        if (b.handled) break
                    }
                    f = f.panel
                }
                f = g;
                for (b.handled = !1; null !== d;) {
                    g =
                        d.mouseEnter;
                    if (null !== g) {
                        if (f === d) break;
                        if (null !== f && f.Tg(d)) break;
                        g(b, d, f);
                        e = !0;
                        if (b.handled) break
                    }
                    d = d.panel
                }
                d = a.Oj
            }
            if (null !== d) {
                f = d;
                for (g = ""; null !== f;) {
                    g = f.cursor;
                    if ("" !== g) break;
                    f = f.panel
                }
                a.currentCursor = g;
                b.handled = !1;
                for (f = d; null !== f;) {
                    d = f.mouseOver;
                    if (null !== d && (d(b, f), e = !0, b.handled)) break;
                    f = f.panel
                }
            } else a.currentCursor = "", d = a.mouseOver, null !== d && (d(b), e = !0);
            e && a.Kb();
            a.skipsUndoManager = c
        }
    };
    Se.prototype.doCurrentObjectChanged = function () {
    };
    Se.prototype.standardMouseWheel = function () {
        var a = this.diagram, b = a.lastInput, c = b.delta;
        if (0 !== c && a.documentBounds.o()) {
            var d = a.commandHandler, e = a.toolManager.mouseWheelBehavior;
            if (null !== d && (e === Ve && !b.shift || e === We && b.control)) {
                if (0 < c ? d.canIncreaseZoom() : d.canDecreaseZoom()) e = a.zoomPoint, a.zoomPoint = b.viewPoint, 0 < c ? d.increaseZoom() : d.decreaseZoom(), a.zoomPoint = e;
                b.bubbles = !1
            } else if (e === Ve && b.shift || e === We && !b.control) {
                d = a.position.copy();
                var f = 0 < c ? c : -c, g = b.event, h = g.deltaMode;
                e = g.deltaX;
                g = g.deltaY;
                if ($a || cb || db) h = 1, 0 < e && (e = 3), 0 > e && (e = -3), 0 < g && (g = 3), 0 > g && (g = -3);
                if (void 0 === h || void 0 === e || void 0 === g || 0 === e && 0 === g || b.shift) !b.shift && a.allowVerticalScroll ? (f = 3 * f * a.scrollVerticalLineChange, 0 < c ? a.scroll("pixel", "up", f) : a.scroll("pixel", "down", f)) : b.shift && a.allowHorizontalScroll && (f = 3 * f * a.scrollHorizontalLineChange, 0 < c ? a.scroll("pixel", "left", f) : a.scroll("pixel", "right", f)); else {
                    switch (h) {
                        case 0:
                            c = "pixel";
                            break;
                        case 1:
                            c = "line";
                            break;
                        case 2:
                            c = "page";
                            break;
                        default:
                            c = "pixel"
                    }
                    0 !== e && a.allowHorizontalScroll &&
                    (e *= a.scrollHorizontalLineChange / 16, 0 < e ? a.scroll(c, "left", -e) : a.scroll(c, "right", e));
                    0 !== g && a.allowVerticalScroll && (g *= a.scrollVerticalLineChange / 16, 0 < g ? a.scroll(c, "up", -g) : a.scroll(c, "down", g))
                }
                a.position.A(d) || (b.bubbles = !1)
            }
        }
    };
    Se.prototype.standardWaitAfter = function (a, b) {
        F && A(a, "number", Se, "standardWaitAfter:delay");
        void 0 === b && (b = this.diagram.lastInput);
        this.cancelWaitAfter();
        var c = this, d = b.clone(this.Bz);
        this.Gt = ta(function () {
            c.doWaitAfter(d)
        }, a)
    };
    Se.prototype.cancelWaitAfter = function () {
        -1 !== this.Gt && qa.clearTimeout(this.Gt);
        this.Gt = -1
    };
    Se.prototype.doWaitAfter = function () {
    };
    Se.prototype.findToolHandleAt = function (a, b) {
        a = this.diagram.ac(a, function (a) {
            for (; null !== a && !(a.panel instanceof Xe);) a = a.panel;
            return a
        });
        return null === a ? null : a.part.category === b ? a : null
    };
    Se.prototype.isBeyondDragSize = function (a, b) {
        var c = this.diagram;
        void 0 === a && (a = c.firstInput.viewPoint);
        void 0 === b && (b = c.lastInput.viewPoint);
        var d = c.toolManager.dragSize, e = d.width;
        d = d.height;
        c.firstInput.isTouchEvent && (e += 6, d += 6);
        return Math.abs(b.x - a.x) > e || Math.abs(b.y - a.y) > d
    };
    na.Object.defineProperties(Se.prototype, {
        diagram: {
            configurable: !0, get: function () {
                return this.B
            }, set: function (a) {
                a instanceof Q && (this.B = a)
            }
        }, name: {
            configurable: !0, get: function () {
                return this.Wa
            }, set: function (a) {
                A(a, "string", Se, "name");
                this.Wa = a
            }
        }, isEnabled: {
            configurable: !0, get: function () {
                return this.qd
            }, set: function (a) {
                A(a, "boolean", Se, "isEnabled");
                this.qd = a
            }
        }, isActive: {
            configurable: !0, get: function () {
                return this.Zc
            }, set: function (a) {
                A(a, "boolean",
                    Se, "isActive");
                this.Zc = a
            }
        }, transactionResult: {
            configurable: !0, get: function () {
                return this.vx
            }, set: function (a) {
                null !== a && A(a, "string", Se, "transactionResult");
                this.vx = a
            }
        }
    });
    Se.prototype.stopTransaction = Se.prototype.Wg;
    Se.prototype.startTransaction = Se.prototype.Ca;
    Se.className = "Tool";

    function Ua() {
        Se.call(this);
        this.name = "ToolManager";
        this.Ic = new H;
        this.$c = new H;
        this.Pd = new H;
        this.W = this.Oa = 850;
        this.w = (new Hb(2, 2)).ia();
        this.kb = 5E3;
        this.Pa = We;
        this.L = Ye;
        this.Yr = this.l = null;
        this.tk = -1
    }

    ma(Ua, Se);
    Ua.prototype.initializeStandardTools = function () {
    };
    Ua.prototype.updateAdornments = function (a) {
        var b = this.currentToolTip;
        if (b instanceof Xe && this.Yr === a) {
            var c = b.adornedObject;
            (null !== a ? c.part === a : null === c) ? this.showToolTip(b, c) : this.hideToolTip()
        }
    };
    Ua.prototype.doMouseDown = function () {
        var a = this.diagram, b = a.lastInput;
        b.isTouchEvent && this.gestureBehavior === Ze && (b.bubbles = !1);
        if (b.isMultiTouch) {
            this.cancelWaitAfter();
            if (this.gestureBehavior === ef) {
                b.bubbles = !0;
                return
            }
            if (this.gestureBehavior === Ze) return;
            if (a.currentTool.canStartMultiTouch()) {
                a.currentTool.standardPinchZoomStart();
                return
            }
        }
        var c = a.undoManager;
        F && c.checksTransactionLevel && 0 !== c.transactionLevel && Ea("WARNING: In ToolManager.doMouseDown: UndoManager.transactionLevel is not zero");
        c = this.mouseDownTools.length;
        for (var d = 0; d < c; d++) {
            var e = this.mouseDownTools.M(d);
            e.diagram = this.diagram;
            if (e.canStart()) {
                a.doFocus();
                a.currentTool = e;
                a.currentTool === e && (e.isActive || e.doActivate(), e.doMouseDown());
                return
            }
        }
        1 === a.lastInput.button && (this.mouseWheelBehavior === We ? this.mouseWheelBehavior = Ve : this.mouseWheelBehavior === Ve && (this.mouseWheelBehavior = We));
        this.doActivate();
        this.standardWaitAfter(this.holdDelay, b)
    };
    Ua.prototype.doMouseMove = function () {
        var a = this.diagram, b = a.lastInput;
        if (b.isMultiTouch) {
            if (this.gestureBehavior === ef) {
                b.bubbles = !0;
                return
            }
            if (this.gestureBehavior === Ze) return;
            if (a.currentTool.canStartMultiTouch()) {
                a.currentTool.standardPinchZoomMove();
                return
            }
        }
        if (this.isActive) for (var c = this.mouseMoveTools.length, d = 0; d < c; d++) {
            var e = this.mouseMoveTools.M(d);
            e.diagram = this.diagram;
            if (e.canStart()) {
                a.doFocus();
                a.currentTool = e;
                a.currentTool === e && (e.isActive || e.doActivate(), e.doMouseMove());
                return
            }
        }
        ff(this,
            a);
        a = b.event;
        null === a || "mousemove" !== a.type && "pointermove" !== a.type && a.cancelable || (b.bubbles = !0)
    };

    function ff(a, b) {
        a.standardMouseOver();
        a.isBeyondDragSize() && a.standardWaitAfter(a.isActive ? a.holdDelay : a.hoverDelay, b.lastInput)
    }

    Ua.prototype.doCurrentObjectChanged = function (a, b) {
        a = this.currentToolTip;
        null === a || null !== b && a instanceof Xe && (b === a || b.Tg(a)) || this.hideToolTip()
    };
    Ua.prototype.doWaitAfter = function (a) {
        var b = this.diagram;
        b.Aa && (this.doMouseHover(), this.isActive || this.doToolTip(), a.isTouchEvent && !b.lastInput.handled && (a = a.copy(), a.button = 2, a.buttons = 2, b.lastInput = a, b.sk = !0, b.doMouseUp()))
    };
    Ua.prototype.doMouseHover = function () {
        var a = this.diagram, b = a.lastInput;
        null === b.targetObject && (b.targetObject = a.ac(b.documentPoint, null, null));
        var c = b.targetObject;
        if (null !== c) for (b.handled = !1; null !== c;) {
            a = this.isActive ? c.mouseHold : c.mouseHover;
            if (null !== a && (a(b, c), b.handled)) break;
            c = c.panel
        } else c = this.isActive ? a.mouseHold : a.mouseHover, null !== c && c(b)
    };
    Ua.prototype.doToolTip = function () {
        var a = this.diagram, b = a.lastInput;
        null === b.targetObject && (b.targetObject = a.ac(b.documentPoint, null, null));
        b = b.targetObject;
        if (null !== b) {
            if (a = this.currentToolTip, !(a instanceof Xe) || b !== a && !b.Tg(a)) {
                for (; null !== b;) {
                    a = b.toolTip;
                    if (null !== a) {
                        this.showToolTip(a, b);
                        return
                    }
                    b = b.panel
                }
                this.hideToolTip()
            }
        } else b = a.toolTip, null !== b ? this.showToolTip(b, null) : this.hideToolTip()
    };
    Ua.prototype.showToolTip = function (a, b) {
        !F || a instanceof Xe || a instanceof gf || v("showToolTip:tooltip must be an Adornment or HTMLInfo.");
        null !== b && w(b, N, Ua, "showToolTip:obj");
        var c = this.diagram;
        a !== this.currentToolTip && this.hideToolTip();
        if (a instanceof Xe) {
            a.layerName = "Tool";
            a.selectable = !1;
            a.scale = 1 / c.scale;
            a.category = "ToolTip";
            null !== a.placeholder && (a.placeholder.scale = c.scale);
            var d = a.diagram;
            null !== d && d !== c && d.remove(a);
            c.add(a);
            null !== b ? a.adornedObject = b : a.data = c.model;
            a.Ya();
            this.positionToolTip(a,
                b)
        } else a instanceof gf && a !== this.currentToolTip && a.show(b, c, this);
        this.currentToolTip = a;
        -1 !== this.tk && (qa.clearTimeout(this.tk), this.tk = -1);
        a = this.toolTipDuration;
        if (0 < a && Infinity !== a) {
            var e = this;
            this.tk = ta(function () {
                e.hideToolTip()
            }, a)
        }
    };
    Ua.prototype.positionToolTip = function (a) {
        if (null === a.placeholder) {
            var b = this.diagram, c = b.lastInput.documentPoint.copy(), d = a.measuredBounds, e = b.viewportBounds;
            b.lastInput.isTouchEvent && (c.x -= d.width);
            c.x + d.width > e.right && (c.x -= d.width + 5 / b.scale);
            c.x < e.x && (c.x = e.x);
            c.y = c.y + 20 / b.scale + d.height > e.bottom ? c.y - (d.height + 5 / b.scale) : c.y + 20 / b.scale;
            c.y < e.y && (c.y = e.y);
            a.position = c
        }
    };
    Ua.prototype.hideToolTip = function () {
        -1 !== this.tk && (qa.clearTimeout(this.tk), this.tk = -1);
        var a = this.diagram, b = this.currentToolTip;
        null !== b && (b instanceof Xe ? (a.remove(b), null !== this.Yr && this.Yr.Tf(b.category), b.data = null, b.adornedObject = null) : b instanceof gf && null !== b.hide && b.hide(a, this), this.currentToolTip = null)
    };
    Ua.prototype.doMouseUp = function () {
        this.cancelWaitAfter();
        var a = this.diagram;
        if (this.isActive) for (var b = this.mouseUpTools.length, c = 0; c < b; c++) {
            var d = this.mouseUpTools.M(c);
            d.diagram = this.diagram;
            if (d.canStart()) {
                a.doFocus();
                a.currentTool = d;
                a.currentTool === d && (d.isActive || d.doActivate(), d.doMouseUp());
                return
            }
        }
        a.doFocus();
        this.doDeactivate()
    };
    Ua.prototype.doMouseWheel = function () {
        this.standardMouseWheel()
    };
    Ua.prototype.doKeyDown = function () {
        var a = this.diagram;
        null !== a.commandHandler && a.commandHandler.doKeyDown()
    };
    Ua.prototype.doKeyUp = function () {
        var a = this.diagram;
        null !== a.commandHandler && a.commandHandler.doKeyUp()
    };
    Ua.prototype.findTool = function (a) {
        A(a, "string", Ua, "findTool:name");
        for (var b = this.mouseDownTools.length, c = 0; c < b; c++) {
            var d = this.mouseDownTools.M(c);
            if (d.name === a) return d
        }
        b = this.mouseMoveTools.length;
        for (c = 0; c < b; c++) if (d = this.mouseMoveTools.M(c), d.name === a) return d;
        b = this.mouseUpTools.length;
        for (c = 0; c < b; c++) if (d = this.mouseUpTools.M(c), d.name === a) return d;
        return null
    };
    Ua.prototype.replaceTool = function (a, b) {
        A(a, "string", Ua, "replaceTool:name");
        null !== b && (w(b, Se, Ua, "replaceTool:newtool"), b.diagram = this.diagram);
        for (var c = this.mouseDownTools.length, d = 0; d < c; d++) {
            var e = this.mouseDownTools.M(d);
            if (e.name === a) return null !== b ? this.mouseDownTools.Vc(d, b) : this.mouseDownTools.jb(d), e
        }
        c = this.mouseMoveTools.length;
        for (d = 0; d < c; d++) if (e = this.mouseMoveTools.M(d), e.name === a) return null !== b ? this.mouseMoveTools.Vc(d, b) : this.mouseMoveTools.jb(d), e;
        c = this.mouseUpTools.length;
        for (d =
                 0; d < c; d++) if (e = this.mouseUpTools.M(d), e.name === a) return null !== b ? this.mouseUpTools.Vc(d, b) : this.mouseUpTools.jb(d), e;
        return null
    };
    Ua.prototype.eb = function (a, b, c) {
        A(a, "string", Ua, "replaceStandardTool:name");
        w(c, H, Ua, "replaceStandardTool:list");
        null !== b && (w(b, Se, Ua, "replaceStandardTool:newtool"), b.name = a, b.diagram = this.diagram);
        this.findTool(a) ? this.replaceTool(a, b) : null !== b && c.add(b)
    };
    na.Object.defineProperties(Ua.prototype, {
        mouseWheelBehavior: {
            configurable: !0, get: function () {
                return this.Pa
            }, set: function (a) {
                ib(a, Ua, Ua, "mouseWheelBehavior");
                this.Pa = a
            }
        }, gestureBehavior: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                ib(a, Ua, Ua, "gestureBehavior");
                this.L = a
            }
        }, currentToolTip: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                !F || null === a || a instanceof Xe || a instanceof gf || v("ToolManager.currentToolTip must be an Adornment or HTMLInfo.");
                this.l = a;
                this.Yr = null !== a && a instanceof Xe ? a.adornedPart : null
            }
        }, mouseDownTools: {
            configurable: !0, get: function () {
                return this.Ic
            }
        }, mouseMoveTools: {
            configurable: !0, get: function () {
                return this.$c
            }
        }, mouseUpTools: {
            configurable: !0, get: function () {
                return this.Pd
            }
        }, hoverDelay: {
            configurable: !0, get: function () {
                return this.Oa
            }, set: function (a) {
                A(a, "number", Ua, "hoverDelay");
                this.Oa = a
            }
        }, holdDelay: {
            configurable: !0, get: function () {
                return this.W
            }, set: function (a) {
                A(a,
                    "number", Ua, "holdDelay");
                this.W = a
            }
        }, dragSize: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                w(a, Hb, Ua, "dragSize");
                this.w = a.J()
            }
        }, toolTipDuration: {
            configurable: !0, get: function () {
                return this.kb
            }, set: function (a) {
                A(a, "number", Ua, "toolTipDuration");
                this.kb = a
            }
        }
    });
    Ua.prototype.replaceStandardTool = Ua.prototype.eb;
    var We = new E(Ua, "WheelScroll", 0), Ve = new E(Ua, "WheelZoom", 1), hf = new E(Ua, "WheelNone", 2),
        Ye = new E(Ua, "GestureZoom", 3), Ze = new E(Ua, "GestureCancel", 4), ef = new E(Ua, "GestureNone", 5);
    Ua.className = "ToolManager";
    Ua.WheelScroll = We;
    Ua.WheelZoom = Ve;
    Ua.WheelNone = hf;
    Ua.GestureZoom = Ye;
    Ua.GestureCancel = Ze;
    Ua.GestureNone = ef;

    function jf() {
        Se.call(this);
        0 < arguments.length && Ba(jf);
        this.name = "Dragging";
        this.L = this.$c = !0;
        this.w = this.kb = this.Oa = this.Cg = null;
        this.co = this.Pd = !1;
        this.tm = new J(NaN, NaN);
        this.tt = new J;
        this.Ic = !0;
        this.zl = 100;
        this.jh = [];
        this.Ar = (new I).freeze();
        this.Pa = new kf;
        this.Mo = null;
        this.W = "copy";
        this.fi = "";
        this.gi = "no-drop"
    }

    ma(jf, Se);
    jf.prototype.canStart = function () {
        if (!this.isEnabled) return !1;
        var a = this.diagram;
        if (a.isReadOnly && !a.allowDragOut || !a.allowMove && !a.allowCopy && !a.allowDragOut || !a.allowSelect) return !1;
        var b = a.lastInput;
        return !b.left || a.currentTool !== this && (!this.isBeyondDragSize() || b.isTouchEvent && b.timestamp - a.firstInput.timestamp < this.zl) ? !1 : null !== this.findDraggablePart()
    };
    jf.prototype.findDraggablePart = function () {
        var a = this.diagram;
        a = a.Lm(a.firstInput.documentPoint, !1);
        if (null === a) return null;
        for (; null !== a && !a.canSelect();) a = a.containingGroup;
        return null !== a && (a.canMove() || a.canCopy()) ? a : null
    };
    jf.prototype.standardMouseSelect = function () {
        var a = this.diagram;
        if (a.allowSelect) {
            var b = a.Lm(a.firstInput.documentPoint, !1);
            if (null !== b) {
                for (; null !== b && !b.canSelect();) b = b.containingGroup;
                this.currentPart = b;
                null === this.currentPart || this.currentPart.isSelected || (a.U("ChangingSelection", a.selection), b = a.lastInput, (eb ? b.meta : b.control) || b.shift || a.clearSelection(!0), this.currentPart.isSelected = !0, a.U("ChangedSelection", a.selection))
            }
        }
    };
    jf.prototype.doActivate = function () {
        var a = this.diagram;
        this.Mo = null;
        null === this.currentPart && this.standardMouseSelect();
        var b = this.currentPart;
        null !== b && (b.canMove() || b.canCopy()) && (lf = null, this.isActive = !0, this.tm.set(a.position), mf(this, a.selection), this.jh.length = 0, a.animationManager.Xc(), this.draggedParts = this.computeEffectiveCollection(a.selection, this.dragOptions), a.xu = !0, !0 === a.Te("temporaryPixelRatio") && 30 < a.oy && nf(a), of(a, this.draggedParts), this.Ca("Drag"), this.startPoint = a.firstInput.documentPoint,
            a.isMouseCaptured = !0, a.allowDragOut && (this.isDragOutStarted = !0, this.co = !1, lf = this, pf = this.diagram, this.doSimulatedDragOut()))
    };

    function mf(a, b) {
        if (a.dragsLink) {
            var c = a.diagram;
            c.allowRelink && (c.model.Kk() && 1 === b.count && b.first() instanceof S ? (a.draggedLink = b.first(), a.draggedLink.canRelinkFrom() && a.draggedLink.canRelinkTo() && a.draggedLink.yk(), a.Cg = c.toolManager.findTool("Relinking"), null === a.Cg && (a.Cg = new qf, a.Cg.diagram = c)) : (a.draggedLink = null, a.Cg = null))
        }
    }

    jf.prototype.computeEffectiveCollection = function (a, b) {
        return this.diagram.commandHandler.computeEffectiveCollection(a, b)
    };
    jf.prototype.Ed = function (a) {
        return void 0 === a ? new rf(Ob) : this.isGridSnapEnabled ? new rf(new J(Math.round(1E3 * a.x) / 1E3, Math.round(1E3 * a.y) / 1E3)) : new rf(a.copy())
    };
    jf.prototype.doDeactivate = function () {
        this.isActive = !1;
        var a = this.diagram;
        a.Vf();
        sf(this);
        tf(a, this.draggedParts);
        this.draggedParts = this.currentPart = this.Mo = null;
        this.co = this.isDragOutStarted = !1;
        if (0 < uf.count) {
            for (var b = uf, c = b.length, d = 0; d < c; d++) {
                var e = b.M(d);
                vf(e);
                zf(e);
                sf(e);
                e.diagram.Vf()
            }
            b.clear()
        }
        vf(this);
        this.tm.h(NaN, NaN);
        lf = pf = null;
        zf(this);
        a.isMouseCaptured = !1;
        a.currentCursor = "";
        a.xu = !1;
        this.Wg();
        Af(a, !0)
    };

    function sf(a) {
        var b = a.diagram, c = b.skipsUndoManager;
        b.skipsUndoManager = !0;
        Bf(a, b.lastInput, null);
        b.skipsUndoManager = c;
        a.jh.length = 0
    }

    function Cf() {
        var a = lf;
        zf(a);
        Df(a);
        var b = a.diagram;
        a.tm.o() && (b.position = a.tm);
        b.Vf()
    }

    jf.prototype.doCancel = function () {
        zf(this);
        Df(this);
        var a = this.diagram;
        this.tm.o() && (a.position = this.tm);
        this.stopTool()
    };
    jf.prototype.doKeyDown = function () {
        var a = this.diagram, b = a.lastInput;
        this.isActive && ("Esc" === b.key ? this.doCancel() : b.key !== a.previousInput.key && this.doMouseMove())
    };
    jf.prototype.doKeyUp = function () {
        this.isActive && this.doMouseMove()
    };

    function Ef(a, b) {
        if (null === a.copiedParts) {
            var c = a.diagram;
            if ((!b || !c.isReadOnly && !c.isModelReadOnly) && null !== a.draggedParts) {
                var d = c.undoManager;
                d.isEnabled && d.isInTransaction ? null !== d.currentTransaction && 0 < d.currentTransaction.changes.count && (c.undoManager.Uf(), c.Ca("Drag")) : Df(a);
                c.skipsUndoManager = !b;
                c.partManager.addsToTemporaryLayer = !b;
                a.startPoint = c.firstInput.documentPoint;
                b = a.copiesEffectiveCollection ? a.draggedParts.Wf() : c.selection;
                b = c.Dk(b, c, !0);
                c = new Db;
                for (d = a.draggedParts.iterator; d.next();) {
                    var e =
                        d.key;
                    if (e.Tc() && e.canCopy()) {
                        var f = b.K(e);
                        null !== f && (f.location = e.location, f.Ya(), c.add(f, a.Ed(f.location)))
                    }
                }
                for (b = b.iterator; b.next();) d = b.value, d instanceof S && d.canCopy() && c.add(d, a.Ed());
                a.copiedParts = c;
                mf(a, c.Wf());
                null !== a.draggedLink && (c = a.draggedLink, b = c.routeBounds, Ff(c, a.startPoint.x - (b.x + b.width / 2), a.startPoint.y - (b.y + b.height / 2)))
            }
        }
    }

    function zf(a) {
        var b = a.diagram;
        if (null !== a.copiedParts && (b.ru(a.copiedParts.Wf(), !1), a.copiedParts = null, null !== a.draggedParts)) for (var c = a.draggedParts.iterator; c.next();) c.key instanceof S && (c.value.point = new J(0, 0));
        b.skipsUndoManager = !1;
        b.partManager.addsToTemporaryLayer = !1;
        a.startPoint = b.firstInput.documentPoint
    }

    function vf(a) {
        if (null !== a.draggedLink) {
            if (a.dragsLink && null !== a.Cg) {
                var b = a.Cg;
                b.diagram.remove(b.temporaryFromNode);
                b.diagram.remove(b.temporaryToNode)
            }
            a.draggedLink = null;
            a.Cg = null
        }
    }

    function Gf(a, b, c) {
        var d = a.diagram, e = a.startPoint, f = J.alloc();
        f.assign(d.lastInput.documentPoint);
        a.moveParts(b, f.ke(e), c);
        J.free(f);
        !0 === d.Te("temporaryPixelRatio") && null === d.Ih && 30 < d.oy && (nf(d), d.kr())
    }

    jf.prototype.moveParts = function (a, b, c) {
        var d = this.diagram;
        null !== d && Hf(d, a, b, this.dragOptions, c)
    };

    function Df(a) {
        if (null !== a.draggedParts) {
            for (var b = a.diagram, c = a.draggedParts.iterator; c.next();) {
                var d = c.key;
                d.Tc() && (d.location = c.value.point)
            }
            for (c = a.draggedParts.iterator; c.next();) if (d = c.key, d instanceof S && d.suspendsRouting) {
                var e = c.value.point;
                a.draggedParts.add(d, a.Ed());
                Ff(d, -e.x, -e.y)
            }
            b.md()
        }
    }

    function If(a, b) {
        var c = a.diagram;
        a.dragsLink && (null !== a.draggedLink && (a.draggedLink.fromNode = null, a.draggedLink.toNode = null), Jf(a, !1));
        var d = a.findDragOverObject(b), e = c.lastInput;
        e.targetObject = d;
        a.doUpdateCursor(d);
        var f = c.skipsUndoManager, g = !1;
        try {
            c.skipsUndoManager = !0;
            g = Bf(a, e, d);
            if (!a.isActive && null === lf) return;
            var h = null !== d ? d.part : null;
            if (null === h || c.handlesDragDropForTopLevelParts && h.isTopLevel && !(h instanceof Kf)) {
                var k = c.mouseDragOver;
                null !== k && (k(e), g = !0)
            }
            if (!a.isActive && null === lf) return;
            a.doDragOver(b, d);
            if (!a.isActive && null === lf) return
        } finally {
            c.skipsUndoManager = f, g && c.md()
        }
        a.Mo = d;
        c.isReadOnly || !c.allowMove && !c.allowCopy || !c.allowHorizontalScroll && !c.allowVerticalScroll || c.Qt(e.viewPoint)
    }

    jf.prototype.findDragOverObject = function (a) {
        var b = this;
        return Lf(this.diagram, a, null, function (a) {
            null === a ? a = !0 : (a = a.part, a = null === a || a instanceof Xe || a.layer.isTemporary || b.draggedParts && b.draggedParts.contains(a) || b.copiedParts && b.copiedParts.contains(a) ? !0 : !1);
            return !a
        })
    };
    jf.prototype.doUpdateCursor = function (a) {
        var b = this.diagram;
        this.Mo !== a && (!this.diagram.currentTool.isActive || this.mayCopy() ? b.currentCursor = this.copyCursor : this.mayMove() ? b.currentCursor = this.moveCursor : this.mayDragOut() && (b.currentCursor = this.nodropCursor))
    };

    function Bf(a, b, c) {
        var d = !1, e = a.jh.length, f = 0 < e ? a.jh[0] : null;
        if (c === f) return !1;
        b.handled = !1;
        for (var g = 0; g < e; g++) {
            var h = a.jh[g], k = h.mouseDragLeave;
            if (null !== k && (k(b, h, c), d = !0, b.handled)) break
        }
        a.jh.length = 0;
        if (!a.isActive && null === lf || null === c) return d;
        b.handled = !1;
        for (e = c; null !== e;) a.jh.push(e), e = Mf(e);
        e = a.jh.length;
        for (c = 0; c < e && (g = a.jh[c], h = g.mouseDragEnter, null === h || (h(b, g, f), d = !0, !b.handled)); c++) ;
        return d
    }

    function Mf(a) {
        var b = a.panel;
        return null !== b ? b : a instanceof T && !(a instanceof Kf) && (a = a.containingGroup, null !== a && a.handlesDragDropForMembers) ? a : null
    }

    function Nf(a, b, c) {
        var d = a.Cg;
        if (null === d) return null;
        var e = a.diagram.Rg(b, d.portGravity, function (a) {
            return d.findValidLinkablePort(a, c)
        });
        a = J.alloc();
        var f = Infinity, g = null;
        for (e = e.iterator; e.next();) {
            var h = e.value;
            if (null !== h.part) {
                var k = h.ja(Mc, a);
                k = b.Re(k);
                k < f && (g = h, f = k)
            }
        }
        J.free(a);
        return g
    }

    function Jf(a, b) {
        var c = a.draggedLink;
        if (null !== c && !(2 > c.pointsCount)) {
            var d = a.diagram;
            if (!d.isReadOnly) {
                var e = a.Cg;
                if (null !== e) {
                    var f = null, g = null;
                    null === c.fromNode && (f = Nf(a, c.i(0), !1), null !== f && (g = f.part));
                    var h = null, k = null;
                    null === c.toNode && (h = Nf(a, c.i(c.pointsCount - 1), !0), null !== h && (k = h.part));
                    e.isValidLink(g, f, k, h) ? b ? (c.defaultFromPoint = c.i(0), c.defaultToPoint = c.i(c.pointsCount - 1), c.suspendsRouting = !1, c.fromNode = g, null !== f && (c.fromPortId = f.portId), c.toNode = k, null !== h && (c.toPortId = h.portId), c.fromPort !==
                    d.$y && d.U("LinkRelinked", c, d.$y), c.toPort !== d.az && d.U("LinkRelinked", c, d.az)) : Of(e, g, f, k, h) : Of(e, null, null, null, null)
                }
            }
        }
    }

    jf.prototype.doDragOver = function () {
    };

    function Pf(a, b) {
        var c = a.diagram;
        a.dragsLink && Jf(a, !0);
        sf(a);
        var d = a.findDragOverObject(b), e = c.lastInput;
        e.targetObject = d;
        if (null !== d) {
            e.handled = !1;
            for (var f = d; null !== f;) {
                var g = f.mouseDrop;
                if (null !== g && (g(e, f), e.handled)) break;
                Qf(a, e, f);
                f = Mf(f)
            }
        } else f = c.mouseDrop, null !== f && f(e);
        if (a.isActive || null !== lf) {
            for (e = (a.copiedParts || a.draggedParts).iterator; e.next();) f = e.key, f instanceof V && f.linksConnected.each(function (a) {
                a.suspendsRouting = !1
            });
            a.doDropOnto(b, d);
            if (a.isActive || null !== lf) {
                a = L.alloc();
                for (b =
                         c.selection.iterator; b.next();) d = b.value, d instanceof V && Rf(c, d, a);
                L.free(a)
            }
        }
    }

    function Qf(a, b, c) {
        a = a.diagram;
        c = c.part;
        !a.handlesDragDropForTopLevelParts || !c.isTopLevel || c instanceof Kf || (c = a.mouseDrop, null !== c && c(b))
    }

    function Rf(a, b, c) {
        var d = !1;
        b.getAvoidableRect(c);
        a.viewportBounds.Pe(c) && (d = !0);
        a = a.gw(c, function (a) {
            return a.part
        }, function (a) {
            return a instanceof S
        }, !0, function (a) {
            return a instanceof S
        }, d);
        if (0 !== a.count) for (a = a.iterator; a.next();) c = a.value, !c.Ld(b) && c.isAvoiding && c.Za()
    }

    jf.prototype.doDropOnto = function () {
    };
    jf.prototype.doMouseMove = function () {
        if (this.isActive) {
            var a = this.diagram, b = a.lastInput;
            this.simulatedMouseMove(b.event, b.documentPoint, b.targetDiagram) || null === this.currentPart || null === this.draggedParts || (this.mayCopy() ? (Ef(this, !1), of(a, this.copiedParts), Gf(this, this.copiedParts, !1), tf(a, this.copiedParts)) : this.mayMove() ? (zf(this), Gf(this, this.draggedParts, !0)) : this.mayDragOut() ? (Ef(this, !1), Gf(this, this.copiedParts, !1)) : zf(this), If(this, a.lastInput.documentPoint))
        }
    };
    jf.prototype.doMouseUp = function () {
        if (this.isActive) {
            var a = this.diagram, b = a.lastInput;
            if (!this.simulatedMouseUp(b.event, b.documentPoint, b.targetDiagram)) {
                b = !1;
                var c = this.mayCopy();
                c && null !== this.copiedParts ? (zf(this), Ef(this, !0), of(a, this.copiedParts), Gf(this, this.copiedParts, !1), tf(a, this.copiedParts), null !== this.copiedParts && (a.U("ChangingSelection", a.selection), a.clearSelection(!0), this.copiedParts.iteratorKeys.each(function (a) {
                    a.isSelected = !0
                }))) : (b = !0, zf(this), this.mayMove() && (Gf(this, this.draggedParts,
                    !0), If(this, a.lastInput.documentPoint)));
                this.co = !0;
                Pf(this, a.lastInput.documentPoint);
                if (this.isActive) {
                    var d = c ? this.copiedParts.Wf() : this.draggedParts.Wf();
                    this.copiedParts = null;
                    b && Sf(this);
                    a.Ua();
                    tf(a, this.draggedParts);
                    this.transactionResult = c ? "Copy" : "Move";
                    a.U(c ? "SelectionCopied" : "SelectionMoved", d)
                }
                this.stopTool();
                c && a.U("ChangedSelection", a.selection)
            }
        }
    };
    jf.prototype.simulatedMouseMove = function (a, b, c) {
        if (null === lf) return !1;
        var d = lf.diagram;
        c instanceof Q || (c = null);
        var e = pf;
        c !== e && (null !== e && e !== d && (e.Vf(), lf.isDragOutStarted = !1, e = e.toolManager.findTool("Dragging"), null !== e && e.doSimulatedDragLeave()), pf = c, null !== c && c !== d && (Cf(), e = c.toolManager.findTool("Dragging"), null !== e && (uf.contains(e) || uf.add(e), e.doSimulatedDragEnter())));
        if (null === c || c === d || !c.allowDrop || c.isReadOnly || !c.allowInsert) return !1;
        d = c.toolManager.findTool("Dragging");
        null !== d && (null !==
        a && (void 0 !== a.targetTouches && (0 < a.targetTouches.length ? a = a.targetTouches[0] : 0 < a.changedTouches.length && (a = a.changedTouches[0])), b = c.getMouse(a)), c.lastInput.documentPoint = b, c.lastInput.viewPoint = c.vr(b), c.lastInput.down = !1, c.lastInput.up = !1, d.doSimulatedDragOver());
        return !0
    };
    jf.prototype.simulatedMouseUp = function (a, b, c) {
        if (null === lf) return !1;
        var d = pf, e = lf.diagram;
        if (null === c) return lf.doCancel(), !0;
        if (c !== d) {
            var f = d.toolManager.findTool("Dragging");
            if (null !== d && d !== e && null !== f) return d.Vf(), lf.isDragOutStarted = !1, f.doSimulatedDragLeave(), !1;
            pf = c;
            d = c.toolManager.findTool("Dragging");
            null !== d && (Cf(), uf.contains(d) || uf.add(d), d.doSimulatedDragEnter())
        }
        return c !== this.diagram ? (null !== a ? (void 0 !== a.targetTouches && (0 < a.targetTouches.length ? a = a.targetTouches[0] : 0 < a.changedTouches.length &&
            (a = a.changedTouches[0])), b = c.getMouse(a)) : null === b && (b = new J), c.lastInput.documentPoint = b, c.lastInput.viewPoint = c.vr(b), c.lastInput.down = !1, c.lastInput.up = !0, a = c.toolManager.findTool("Dragging"), null !== a && a.doSimulatedDrop(), a = lf, null !== a && (c = a.mayCopy(), a.transactionResult = c ? "Copy" : "Move", a.stopTool()), !0) : !1
    };

    function Sf(a) {
        if (null !== a.draggedParts) for (var b = a.draggedParts.iterator; b.next();) {
            var c = b.key;
            c instanceof V && (c = c.containingGroup, null === c || null === c.placeholder || a.draggedParts.contains(c) || c.placeholder.v())
        }
    }

    jf.prototype.mayCopy = function () {
        if (!this.isCopyEnabled) return !1;
        var a = this.diagram;
        if (a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.allowCopy || (eb ? !a.lastInput.alt : !a.lastInput.control)) return !1;
        for (a = a.selection.iterator; a.next();) if (a.value.canCopy()) return !0;
        return null !== this.draggedLink && this.dragsLink && this.draggedLink.canCopy() ? !0 : !1
    };
    jf.prototype.mayDragOut = function () {
        if (!this.isCopyEnabled) return !1;
        var a = this.diagram;
        if (!a.allowDragOut || !a.allowCopy || a.allowMove) return !1;
        for (a = a.selection.iterator; a.next();) if (a.value.canCopy()) return !0;
        return null !== this.draggedLink && this.dragsLink && this.draggedLink.canCopy() ? !0 : !1
    };
    jf.prototype.mayMove = function () {
        var a = this.diagram;
        if (a.isReadOnly || !a.allowMove) return !1;
        for (a = a.selection.iterator; a.next();) if (a.value.canMove()) return !0;
        return null !== this.draggedLink && this.dragsLink && this.draggedLink.canMove() ? !0 : !1
    };
    jf.prototype.computeBorder = function (a, b, c) {
        return this.co || null === this.draggedParts || this.draggedParts.contains(a) ? null : c.assign(b)
    };
    jf.prototype.DA = function () {
        return lf
    };
    jf.prototype.mayDragIn = function () {
        var a = this.diagram;
        if (!a.allowDrop || a.isReadOnly || a.isModelReadOnly || !a.allowInsert) return !1;
        var b = lf;
        return null === b || b.diagram.model.dataFormat !== a.model.dataFormat ? !1 : !0
    };
    jf.prototype.doSimulatedDragEnter = function () {
        if (this.mayDragIn()) {
            var a = this.diagram;
            a.animationManager.Xc();
            Tf(a);
            a.animationManager.Xc();
            var b = lf;
            null !== b && (b.diagram.xu = !1);
            this.doUpdateCursor(a.grid)
        }
    };
    jf.prototype.doSimulatedDragLeave = function () {
        var a = lf;
        null !== a && a.doSimulatedDragOut();
        this.doCancel()
    };
    jf.prototype.doSimulatedDragOver = function () {
        var a = this.diagram;
        a.animationManager.Dn = !0;
        var b = lf;
        if (null !== b && null !== b.draggedParts) {
            if (!this.mayDragIn()) return;
            Xf(this, b.draggedParts.Wf(), !1, a.firstInput);
            Gf(this, this.copiedParts, !1);
            If(this, a.lastInput.documentPoint)
        }
        a.animationManager.Dn = !1
    };
    jf.prototype.doSimulatedDrop = function () {
        var a = this.diagram, b = lf;
        if (null !== b) {
            var c = b.diagram;
            b.co = !0;
            zf(this);
            if (!this.mayDragIn()) return;
            a.animationManager.Dn = !0;
            a.U("ChangingSelection", a.selection);
            this.Ca("Drop");
            Xf(this, b.draggedParts.Wf(), !0, a.lastInput);
            Gf(this, this.copiedParts, !1);
            null !== this.copiedParts && (a.clearSelection(!0), this.copiedParts.iteratorKeys.each(function (a) {
                a.isSelected = !0
            }));
            Pf(this, a.lastInput.documentPoint);
            a.Ua();
            b = a.selection;
            null !== this.copiedParts ? this.transactionResult =
                "ExternalCopy" : b = new I;
            this.copiedParts = null;
            a.doFocus();
            a.U("ExternalObjectsDropped", b, c);
            this.Wg();
            a.U("ChangedSelection", a.selection)
        }
        a.animationManager.Dn = !1
    };

    function Xf(a, b, c, d) {
        if (null === a.copiedParts) {
            var e = a.diagram;
            if (!e.isReadOnly && !e.isModelReadOnly) {
                e.skipsUndoManager = !c;
                e.partManager.addsToTemporaryLayer = !c;
                a.startPoint = d.documentPoint;
                c = e.Dk(b, e, !0);
                var f = L.alloc();
                e = d = Infinity;
                for (var g = -Infinity, h = -Infinity, k = b.iterator; k.next();) {
                    var l = k.value;
                    if (l.isVisible()) {
                        var m = l.location;
                        l = m.x;
                        m = m.y;
                        isNaN(l) || isNaN(m) || (l < d && (d = l), m < e && (e = m), l > g && (g = l), m > h && (h = m))
                    }
                }
                Infinity === d ? f.h(0, 0, 0, 0) : f.h(d, e, g - d, h - e);
                d = f.x + f.width / 2;
                e = f.y + f.height / 2;
                L.free(f);
                f = a.tt;
                g = new Db;
                h = J.alloc();
                for (k = b.iterator; k.next();) l = k.value, l instanceof S && l.canCopy() && (m = c.K(l), null !== m && (m.points = l.points, Ff(m, f.x - d, f.y - e), m.suspendsRouting = !0, g.add(m, a.Ed())));
                for (b = b.iterator; b.next();) l = b.value, l.Tc() && l.canCopy() && (k = c.K(l), null !== k && (l = l.location, h.h(f.x - (d - l.x), f.y - (e - l.y)), k.location = h, k.Ya(), g.add(k, a.Ed(h))));
                J.free(h);
                a.copiedParts = g;
                mf(a, g.Wf());
                null !== a.draggedLink && (c = a.draggedLink, b = c.routeBounds, Ff(c, a.startPoint.x - (b.x + b.width / 2), a.startPoint.y - (b.y + b.height /
                    2)))
            }
        }
    }

    jf.prototype.doSimulatedDragOut = function () {
        var a = this.diagram;
        a.xu = !1;
        this.mayCopy() || this.mayMove() ? a.currentCursor = "" : a.currentCursor = this.nodropCursor;
        this.Mo = null
    };
    jf.prototype.computeMove = function (a, b, c, d) {
        c = this.diagram;
        return null !== c ? c.computeMove(a, b, this.dragOptions, d) : new J
    };
    na.Object.defineProperties(jf.prototype, {
        isCopyEnabled: {
            configurable: !0, get: function () {
                return this.$c
            }, set: function (a) {
                A(a, "boolean", jf, "isCopyEnabled");
                this.$c = a
            }
        }, copiesEffectiveCollection: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                A(a, "boolean", jf, "copiesEffectiveCollection");
                this.L = a
            }
        }, dragOptions: {
            configurable: !0, get: function () {
                return this.Pa
            }, set: function (a) {
                w(a, kf, jf, "dragOptions");
                this.Pa = a
            }
        }, isGridSnapEnabled: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.dragOptions.isGridSnapEnabled
            }, set: function (a) {
                A(a, "boolean", jf, "isGridSnapEnabled");
                this.dragOptions.isGridSnapEnabled = a
            }
        }, isComplexRoutingRealtime: {
            configurable: !0, get: function () {
                return this.Ic
            }, set: function (a) {
                A(a, "boolean", jf, "isComplexRoutingRealtime");
                this.Ic = a
            }
        }, isGridSnapRealtime: {
            configurable: !0, get: function () {
                return this.dragOptions.isGridSnapRealtime
            }, set: function (a) {
                A(a, "boolean", jf, "isGridSnapRealtime");
                this.dragOptions.isGridSnapRealtime =
                    a
            }
        }, gridSnapCellSize: {
            configurable: !0, get: function () {
                return this.dragOptions.gridSnapCellSize
            }, set: function (a) {
                w(a, Hb, jf, "gridSnapCellSize");
                this.dragOptions.gridSnapCellSize.A(a) || (a = a.J(), this.dragOptions.gridSnapCellSize = a)
            }
        }, gridSnapCellSpot: {
            configurable: !0, get: function () {
                return this.dragOptions.gridSnapCellSpot
            }, set: function (a) {
                w(a, M, jf, "gridSnapCellSpot");
                this.dragOptions.gridSnapCellSpot.A(a) || (a = a.J(), this.dragOptions.gridSnapCellSpot = a)
            }
        }, gridSnapOrigin: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.dragOptions.gridSnapOrigin
            }, set: function (a) {
                w(a, J, jf, "gridSnapOrigin");
                this.dragOptions.gridSnapOrigin.A(a) || (a = a.J(), this.dragOptions.gridSnapOrigin = a)
            }
        }, dragsLink: {
            configurable: !0, get: function () {
                return this.dragOptions.dragsLink
            }, set: function (a) {
                A(a, "boolean", jf, "dragsLink");
                this.dragOptions.dragsLink = a
            }
        }, dragsTree: {
            configurable: !0, get: function () {
                return this.dragOptions.dragsTree
            }, set: function (a) {
                A(a, "boolean", jf, "dragsTree");
                this.dragOptions.dragsTree = a
            }
        }, copyCursor: {
            configurable: !0, get: function () {
                return this.W
            }, set: function (a) {
                this.W = a
            }
        }, moveCursor: {
            configurable: !0, get: function () {
                return this.fi
            }, set: function (a) {
                this.fi = a
            }
        }, nodropCursor: {
            configurable: !0, get: function () {
                return this.gi
            }, set: function (a) {
                this.gi = a
            }
        }, currentPart: {
            configurable: !0, get: function () {
                return this.Oa
            }, set: function (a) {
                null !== a && w(a, T, jf, "currentPart");
                this.Oa = a
            }
        }, copiedParts: {
            configurable: !0,
            get: function () {
                return this.w
            }, set: function (a) {
                this.w = a
            }
        }, draggedParts: {
            configurable: !0, get: function () {
                return this.kb
            }, set: function (a) {
                this.kb = a
            }
        }, draggingParts: {
            configurable: !0, get: function () {
                return null !== this.copiedParts ? this.copiedParts.Wf() : null !== this.draggedParts ? this.draggedParts.Wf() : this.Ar
            }
        }, draggedLink: {
            configurable: !0, get: function () {
                return this.diagram.draggedLink
            }, set: function (a) {
                null !== a && w(a, S, jf, "draggedLink");
                this.diagram.draggedLink = a
            }
        },
        isDragOutStarted: {
            configurable: !0, get: function () {
                return this.Pd
            }, set: function (a) {
                this.Pd = a
            }
        }, startPoint: {
            configurable: !0, get: function () {
                return this.tt
            }, set: function (a) {
                w(a, J, jf, "startPoint");
                this.tt.A(a) || this.tt.assign(a)
            }
        }, delay: {
            configurable: !0, get: function () {
                return this.zl
            }, set: function (a) {
                A(a, "number", jf, "delay");
                this.zl = a
            }
        }
    });
    jf.prototype.getDraggingSource = jf.prototype.DA;
    var uf = null, lf = null, pf = null;
    jf.className = "DraggingTool";
    uf = new H;
    Sa("draggingTool", function () {
        return this.findTool("Dragging")
    }, function (a) {
        this.eb("Dragging", a, this.mouseMoveTools)
    });
    Ua.prototype.doCancel = function () {
        null !== lf && lf.doCancel();
        Se.prototype.doCancel.call(this)
    };

    function Yf() {
        0 < arguments.length && Ba(Yf);
        Se.call(this);
        this.gi = 100;
        this.Pa = !1;
        this.zi = "pointer";
        var a = new S, b = new Zf;
        b.isPanelMain = !0;
        b.stroke = "blue";
        a.add(b);
        b = new Zf;
        b.toArrow = "Standard";
        b.fill = "blue";
        b.stroke = "blue";
        a.add(b);
        a.layerName = "Tool";
        this.tx = a;
        a = new V;
        b = new Zf;
        b.portId = "";
        b.figure = "Rectangle";
        b.fill = null;
        b.stroke = "magenta";
        b.strokeWidth = 2;
        b.desiredSize = Ub;
        a.add(b);
        a.selectable = !1;
        a.layerName = "Tool";
        this.sx = a;
        this.l = b;
        a = new V;
        b = new Zf;
        b.portId = "";
        b.figure = "Rectangle";
        b.fill = null;
        b.stroke =
            "magenta";
        b.strokeWidth = 2;
        b.desiredSize = Ub;
        a.add(b);
        a.selectable = !1;
        a.layerName = "Tool";
        this.ux = a;
        this.w = b;
        this.fi = this.Pd = this.Ic = this.kb = this.$c = null;
        this.Oa = !0;
        this.sz = new Db;
        this.Ar = this.Ri = this.qx = null
    }

    ma(Yf, Se);
    Yf.prototype.doStop = function () {
        this.diagram.Vf();
        this.originalToPort = this.originalToNode = this.originalFromPort = this.originalFromNode = this.originalLink = null;
        this.validPortsCache.clear();
        this.targetPort = null
    };
    Yf.prototype.copyPortProperties = function (a, b, c, d, e) {
        if (null !== a && null !== b && null !== c && null !== d) {
            var f = b.Mf(), g = Hb.alloc();
            g.width = b.naturalBounds.width * f;
            g.height = b.naturalBounds.height * f;
            d.desiredSize = g;
            Hb.free(g);
            e ? (d.toSpot = b.toSpot, d.toEndSegmentLength = b.toEndSegmentLength) : (d.fromSpot = b.fromSpot, d.fromEndSegmentLength = b.fromEndSegmentLength);
            c.locationSpot = Mc;
            f = J.alloc();
            c.location = b.ja(Mc, f);
            J.free(f);
            d.angle = b.vj();
            null !== this.portTargeted && this.portTargeted(a, b, c, d, e)
        }
    };
    Yf.prototype.setNoTargetPortProperties = function (a, b, c) {
        null !== b && (b.desiredSize = Ub, b.fromSpot = Ec, b.toSpot = Ec);
        null !== a && (a.location = this.diagram.lastInput.documentPoint);
        null !== this.portTargeted && this.portTargeted(null, null, a, b, c)
    };
    Yf.prototype.doMouseDown = function () {
        this.isActive && this.doMouseMove()
    };
    Yf.prototype.doMouseMove = function () {
        if (this.isActive) {
            var a = this.diagram;
            this.targetPort = this.findTargetPort(this.isForwards);
            if (null !== this.targetPort && this.targetPort.part instanceof V) {
                var b = this.targetPort.part;
                this.isForwards ? this.copyPortProperties(b, this.targetPort, this.temporaryToNode, this.temporaryToPort, !0) : this.copyPortProperties(b, this.targetPort, this.temporaryFromNode, this.temporaryFromPort, !1)
            } else this.isForwards ? this.setNoTargetPortProperties(this.temporaryToNode, this.temporaryToPort,
                !0) : this.setNoTargetPortProperties(this.temporaryFromNode, this.temporaryFromPort, !1);
            (a.allowHorizontalScroll || a.allowVerticalScroll) && a.Qt(a.lastInput.viewPoint)
        }
    };
    Yf.prototype.findValidLinkablePort = function (a, b) {
        if (null === a) return null;
        var c = a.part;
        if (!(c instanceof V)) return null;
        for (; null !== a;) {
            var d = b ? a.toLinkable : a.fromLinkable;
            if (!0 === d && (null !== a.portId || a instanceof V) && (b ? this.isValidTo(c, a) : this.isValidFrom(c, a))) return a;
            if (!1 === d) break;
            a = a.panel
        }
        return null
    };
    Yf.prototype.findTargetPort = function (a) {
        var b = this.diagram, c = b.lastInput.documentPoint, d = this.portGravity;
        0 >= d && (d = .1);
        var e = this, f = b.Rg(c, d, function (b) {
            return e.findValidLinkablePort(b, a)
        }, null, !0);
        d = Infinity;
        b = null;
        for (f = f.iterator; f.next();) {
            var g = f.value, h = g.part;
            if (h instanceof V) {
                var k = g.ja(Mc, J.alloc()), l = c.x - k.x, m = c.y - k.y;
                J.free(k);
                k = l * l + m * m;
                k < d && (l = this.validPortsCache.K(g), null !== l ? l && (b = g, d = k) : a && this.isValidLink(this.originalFromNode, this.originalFromPort, h, g) || !a && this.isValidLink(h,
                    g, this.originalToNode, this.originalToPort) ? (this.validPortsCache.add(g, !0), b = g, d = k) : this.validPortsCache.add(g, !1))
            }
        }
        return null !== b && (c = b.part, c instanceof V && (null === c.layer || c.layer.allowLink)) ? b : null
    };
    Yf.prototype.isValidFrom = function (a, b) {
        if (null === a || null === b) return this.isUnconnectedLinkValid;
        if (this.diagram.currentTool === this && (null !== a.layer && !a.layer.allowLink || !0 !== b.fromLinkable)) return !1;
        var c = b.fromMaxLinks;
        if (Infinity > c) {
            if (null !== this.originalLink && a === this.originalFromNode && b === this.originalFromPort) return !0;
            b = b.portId;
            null === b && (b = "");
            if (a.Oq(b).count >= c) return !1
        }
        return !0
    };
    Yf.prototype.isValidTo = function (a, b) {
        if (null === a || null === b) return this.isUnconnectedLinkValid;
        if (this.diagram.currentTool === this && (null !== a.layer && !a.layer.allowLink || !0 !== b.toLinkable)) return !1;
        var c = b.toMaxLinks;
        if (Infinity > c) {
            if (null !== this.originalLink && a === this.originalToNode && b === this.originalToPort) return !0;
            b = b.portId;
            null === b && (b = "");
            if (a.Jd(b).count >= c) return !1
        }
        return !0
    };
    Yf.prototype.isInSameNode = function (a, b) {
        if (null === a || null === b) return !1;
        if (a === b) return !0;
        a = a.part;
        b = b.part;
        return null !== a && a === b
    };
    Yf.prototype.isLinked = function (a, b) {
        if (null === a || null === b) return !1;
        var c = a.part;
        if (!(c instanceof V)) return !1;
        a = a.portId;
        null === a && (a = "");
        var d = b.part;
        if (!(d instanceof V)) return !1;
        b = b.portId;
        null === b && (b = "");
        for (b = d.Jd(b); b.next();) if (d = b.value, d.fromNode === c && d.fromPortId === a) return !0;
        return !1
    };
    Yf.prototype.isValidLink = function (a, b, c, d) {
        if (!this.isValidFrom(a, b) || !this.isValidTo(c, d) || !(null === b || null === d || (b.fromLinkableSelfNode && d.toLinkableSelfNode || !this.isInSameNode(b, d)) && (b.fromLinkableDuplicates && d.toLinkableDuplicates || !this.isLinked(b, d))) || null !== this.originalLink && (null !== a && this.isLabelDependentOnLink(a, this.originalLink) || null !== c && this.isLabelDependentOnLink(c, this.originalLink)) || null !== a && null !== c && (null === a.data && null !== c.data || null !== a.data && null === c.data) || !this.isValidCycle(a,
            c, this.originalLink)) return !1;
        if (null !== a) {
            var e = a.linkValidation;
            if (null !== e && !e(a, b, c, d, this.originalLink)) return !1
        }
        if (null !== c && (e = c.linkValidation, null !== e && !e(a, b, c, d, this.originalLink))) return !1;
        e = this.linkValidation;
        return null !== e ? e(a, b, c, d, this.originalLink) : !0
    };
    Yf.prototype.isLabelDependentOnLink = function (a, b) {
        if (null === a) return !1;
        var c = a.labeledLink;
        if (null === c) return !1;
        if (c === b) return !0;
        var d = new I;
        d.add(a);
        return $f(this, c, b, d)
    };

    function $f(a, b, c, d) {
        if (b === c) return !0;
        var e = b.fromNode;
        if (null !== e && e.isLinkLabel && (d.add(e), $f(a, e.labeledLink, c, d))) return !0;
        b = b.toNode;
        return null !== b && b.isLinkLabel && (d.add(b), $f(a, b.labeledLink, c, d)) ? !0 : !1
    }

    Yf.prototype.isValidCycle = function (a, b, c) {
        void 0 === c && (c = null);
        if (null === a || null === b) return this.isUnconnectedLinkValid;
        var d = this.diagram.validCycle;
        if (d !== ag) {
            if (d === bg) {
                d = c || this.temporaryLink;
                if (null !== d && !d.isTreeLink) return !0;
                for (d = b.linksConnected; d.next();) {
                    var e = d.value;
                    if (e !== c && e.isTreeLink && e.toNode === b) return !1
                }
                return !cg(this, a, b, c, !0)
            }
            if (d === dg) {
                d = c || this.temporaryLink;
                if (null !== d && !d.isTreeLink) return !0;
                for (d = a.linksConnected; d.next();) if (e = d.value, e !== c && e.isTreeLink && e.fromNode ===
                a) return !1;
                return !cg(this, a, b, c, !0)
            }
            if (d === eg) return a === b ? a = !0 : (d = new I, d.add(b), a = fg(this, d, a, b, c)), !a;
            if (d === gg) return !cg(this, a, b, c, !1);
            if (d === hg) return a === b ? a = !0 : (d = new I, d.add(b), a = ig(this, d, a, b, c)), !a
        }
        return !0
    };

    function cg(a, b, c, d, e) {
        if (b === c) return !0;
        if (null === b || null === c) return !1;
        for (var f = b.linksConnected; f.next();) {
            var g = f.value;
            if (g !== d && (!e || g.isTreeLink) && g.toNode === b && (g = g.fromNode, g !== b && cg(a, g, c, d, e))) return !0
        }
        return !1
    }

    function fg(a, b, c, d, e) {
        if (c === d) return !0;
        if (null === c || null === d || b.contains(c)) return !1;
        b.add(c);
        for (var f = c.linksConnected; f.next();) {
            var g = f.value;
            if (g !== e && g.toNode === c && (g = g.fromNode, g !== c && fg(a, b, g, d, e))) return !0
        }
        return !1
    }

    function ig(a, b, c, d, e) {
        if (c === d) return !0;
        if (null === c || null === d || b.contains(c)) return !1;
        b.add(c);
        for (var f = c.linksConnected; f.next();) {
            var g = f.value;
            if (g !== e) {
                var h = g.fromNode;
                g = g.toNode;
                h = h === c ? g : h;
                if (h !== c && ig(a, b, h, d, e)) return !0
            }
        }
        return !1
    }

    na.Object.defineProperties(Yf.prototype, {
        portGravity: {
            configurable: !0, get: function () {
                return this.gi
            }, set: function (a) {
                A(a, "number", Yf, "portGravity");
                0 <= a && (this.gi = a)
            }
        }, isUnconnectedLinkValid: {
            configurable: !0, get: function () {
                return this.Pa
            }, set: function (a) {
                A(a, "boolean", Yf, "isUnconnectedLinkValid");
                this.Pa = a
            }
        }, linkingCursor: {
            configurable: !0, get: function () {
                return this.zi
            }, set: function (a) {
                this.zi = a
            }
        }, temporaryLink: {
            configurable: !0, get: function () {
                return this.tx
            },
            set: function (a) {
                w(a, S, Yf, "temporaryLink");
                this.tx = a
            }
        }, temporaryFromNode: {
            configurable: !0, get: function () {
                return this.sx
            }, set: function (a) {
                w(a, V, Yf, "temporaryFromNode");
                if (this.sx = a) this.l = a.port
            }
        }, temporaryFromPort: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                w(a, N, Yf, "temporaryFromPort");
                if (null !== this.l) {
                    var b = this.l.panel;
                    if (null !== b) {
                        var c = b.$.indexOf(this.l);
                        b.jb(c);
                        b.Bb(c, a)
                    }
                }
                this.l = a
            }
        }, temporaryToNode: {
            configurable: !0, get: function () {
                return this.ux
            },
            set: function (a) {
                w(a, V, Yf, "temporaryToNode");
                if (this.ux = a) this.w = a.port
            }
        }, temporaryToPort: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                w(a, N, Yf, "temporaryToPort");
                if (null !== this.w) {
                    var b = this.w.panel;
                    if (null !== b) {
                        var c = b.$.indexOf(this.w);
                        b.jb(c);
                        b.Bb(c, a)
                    }
                }
                this.w = a
            }
        }, originalLink: {
            configurable: !0, get: function () {
                return this.$c
            }, set: function (a) {
                null !== a && w(a, S, Yf, "originalLink");
                this.$c = a
            }
        }, originalFromNode: {
            configurable: !0, get: function () {
                return this.kb
            },
            set: function (a) {
                null !== a && w(a, V, Yf, "originalFromNode");
                this.kb = a
            }
        }, originalFromPort: {
            configurable: !0, get: function () {
                return this.Ic
            }, set: function (a) {
                null !== a && w(a, N, Yf, "originalFromPort");
                this.Ic = a
            }
        }, originalToNode: {
            configurable: !0, get: function () {
                return this.Pd
            }, set: function (a) {
                null !== a && w(a, V, Yf, "originalToNode");
                this.Pd = a
            }
        }, originalToPort: {
            configurable: !0, get: function () {
                return this.fi
            }, set: function (a) {
                null !== a && w(a, N, Yf, "originalToPort");
                this.fi = a
            }
        }, isForwards: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Oa
            }, set: function (a) {
                A(a, "boolean", Yf, "isForwards");
                this.Oa = a
            }
        }, validPortsCache: {
            configurable: !0, get: function () {
                return this.sz
            }
        }, targetPort: {
            configurable: !0, get: function () {
                return this.qx
            }, set: function (a) {
                null !== a && w(a, N, Yf, "targetPort");
                this.qx = a
            }
        }, linkValidation: {
            configurable: !0, get: function () {
                return this.Ri
            }, set: function (a) {
                null !== a && A(a, "function", Yf, "linkValidation");
                this.Ri = a
            }
        }, portTargeted: {
            configurable: !0,
            get: function () {
                return this.Ar
            }, set: function (a) {
                null !== a && A(a, "function", Yf, "portTargeted");
                this.Ar = a
            }
        }
    });
    Yf.className = "LinkingBaseTool";

    function jg() {
        0 < arguments.length && Ba(jg);
        Yf.call(this);
        this.name = "Linking";
        this.W = {};
        this.L = null;
        this.N = kg;
        this.pn = null
    }

    ma(jg, Yf);
    jg.prototype.canStart = function () {
        if (!this.isEnabled) return !1;
        var a = this.diagram;
        return a.isReadOnly || a.isModelReadOnly || !a.allowLink || !a.model.gu() || !a.lastInput.left || a.currentTool !== this && !this.isBeyondDragSize() ? !1 : null !== this.findLinkablePort()
    };
    jg.prototype.findLinkablePort = function () {
        var a = this.diagram, b = this.startObject;
        null === b && (b = a.ac(a.firstInput.documentPoint, null, null));
        if (null === b || !(b.part instanceof V)) return null;
        a = this.direction;
        if (a === kg || a === lg) {
            var c = this.findValidLinkablePort(b, !1);
            if (null !== c) return this.isForwards = !0, c
        }
        if (a === kg || a === mg) if (b = this.findValidLinkablePort(b, !0), null !== b) return this.isForwards = !1, b;
        return null
    };
    jg.prototype.doActivate = function () {
        var a = this.diagram, b = this.findLinkablePort();
        null !== b && (this.Ca(this.name), a.isMouseCaptured = !0, a.currentCursor = this.linkingCursor, this.isForwards ? (null === this.temporaryToNode || this.temporaryToNode.location.o() || (this.temporaryToNode.location = a.lastInput.documentPoint), this.originalFromPort = b, b = this.originalFromPort.part, b instanceof V && (this.originalFromNode = b), this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort,
            !1)) : (null === this.temporaryFromNode || this.temporaryFromNode.location.o() || (this.temporaryFromNode.location = a.lastInput.documentPoint), this.originalToPort = b, b = this.originalToPort.part, b instanceof V && (this.originalToNode = b), this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, !0)), a.add(this.temporaryFromNode), a.add(this.temporaryToNode), null !== this.temporaryLink && (null !== this.temporaryFromNode && (this.temporaryLink.fromNode = this.temporaryFromNode),
        null !== this.temporaryToNode && (this.temporaryLink.toNode = this.temporaryToNode), this.temporaryLink.isTreeLink = this.isNewTreeLink(), this.temporaryLink.Za(), a.add(this.temporaryLink)), this.isActive = !0)
    };
    jg.prototype.doDeactivate = function () {
        this.isActive = !1;
        var a = this.diagram;
        a.remove(this.temporaryLink);
        a.remove(this.temporaryFromNode);
        a.remove(this.temporaryToNode);
        a.isMouseCaptured = !1;
        a.currentCursor = "";
        this.Wg()
    };
    jg.prototype.doStop = function () {
        Yf.prototype.doStop.call(this);
        this.startObject = null
    };
    jg.prototype.doMouseUp = function () {
        var a = this.diagram;
        if (this.isActive) {
            var b = this.transactionResult = null, c = null, d = null, e = null, f = null;
            try {
                var g = this.targetPort = this.findTargetPort(this.isForwards);
                if (null !== g) {
                    var h = g.part;
                    h instanceof V && (this.isForwards ? (null !== this.originalFromNode && (b = this.originalFromNode, c = this.originalFromPort), d = h, e = g) : (b = h, c = g, null !== this.originalToNode && (d = this.originalToNode, e = this.originalToPort)))
                } else this.isForwards ? null !== this.originalFromNode && this.isUnconnectedLinkValid &&
                    (b = this.originalFromNode, c = this.originalFromPort) : null !== this.originalToNode && this.isUnconnectedLinkValid && (d = this.originalToNode, e = this.originalToPort);
                null !== b || null !== d ? (f = this.insertLink(b, c, d, e), null !== f ? (null === g && (this.isForwards ? f.defaultToPoint = a.lastInput.documentPoint : f.defaultFromPoint = a.lastInput.documentPoint), a.allowSelect && (a.U("ChangingSelection", a.selection), a.clearSelection(!0), f.isSelected = !0), this.transactionResult = this.name, a.U("LinkDrawn", f)) : this.doNoLink(b, c, d, e)) : this.isForwards ?
                    this.doNoLink(this.originalFromNode, this.originalFromPort, null, null) : this.doNoLink(null, null, this.originalToNode, this.originalToPort)
            } finally {
                this.stopTool(), f && a.allowSelect && a.U("ChangedSelection", a.selection)
            }
        }
    };
    jg.prototype.isNewTreeLink = function () {
        var a = this.archetypeLinkData;
        if (null === a) return !0;
        if (a instanceof S) return a.isTreeLink;
        var b = this.diagram;
        if (null === b) return !0;
        a = b.partManager.getLinkCategoryForData(a);
        b = b.partManager.findLinkTemplateForCategory(a);
        return null !== b ? b.isTreeLink : !0
    };
    jg.prototype.insertLink = function (a, b, c, d) {
        return this.diagram.partManager.insertLink(a, b, c, d)
    };
    jg.prototype.doNoLink = function () {
    };
    na.Object.defineProperties(jg.prototype, {
        archetypeLinkData: {
            configurable: !0, get: function () {
                return this.W
            }, set: function (a) {
                null !== a && A(a, "object", jg, "archetypeLinkData");
                a instanceof N && w(a, S, jg, "archetypeLinkData");
                this.W = a
            }
        }, archetypeLabelNodeData: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                null !== a && A(a, "object", jg, "archetypeLabelNodeData");
                a instanceof N && w(a, V, jg, "archetypeLabelNodeData");
                this.L = a
            }
        }, direction: {
            configurable: !0, get: function () {
                return this.N
            },
            set: function (a) {
                ib(a, jg, jg, "direction");
                this.N = a
            }
        }, startObject: {
            configurable: !0, get: function () {
                return this.pn
            }, set: function (a) {
                null !== a && w(a, N, jg, "startObject");
                this.pn = a
            }
        }
    });
    var kg = new E(jg, "Either", 0), lg = new E(jg, "ForwardsOnly", 0), mg = new E(jg, "BackwardsOnly", 0);
    jg.className = "LinkingTool";
    jg.Either = kg;
    jg.ForwardsOnly = lg;
    jg.BackwardsOnly = mg;

    function qf() {
        0 < arguments.length && Ba(qf);
        Yf.call(this);
        this.name = "Relinking";
        var a = new Zf;
        a.figure = "Diamond";
        a.desiredSize = Wb;
        a.fill = "lightblue";
        a.stroke = "dodgerblue";
        a.cursor = this.linkingCursor;
        a.segmentIndex = 0;
        this.W = a;
        a = new Zf;
        a.figure = "Diamond";
        a.desiredSize = Wb;
        a.fill = "lightblue";
        a.stroke = "dodgerblue";
        a.cursor = this.linkingCursor;
        a.segmentIndex = -1;
        this.pn = a;
        this.L = null;
        this.Ux = new L
    }

    ma(qf, Yf);
    qf.prototype.updateAdornments = function (a) {
        if (null !== a && a instanceof S) {
            var b = "RelinkFrom", c = null;
            if (a.isSelected && !this.diagram.isReadOnly) {
                var d = a.selectionObject;
                null !== d && a.canRelinkFrom() && a.actualBounds.o() && a.isVisible() && d.actualBounds.o() && d.Sf() && (c = a.Gk(b), null === c && (c = this.makeAdornment(d, !1), a.Qh(b, c)))
            }
            null === c && a.Tf(b);
            b = "RelinkTo";
            c = null;
            a.isSelected && !this.diagram.isReadOnly && (d = a.selectionObject, null !== d && a.canRelinkTo() && a.actualBounds.o() && a.isVisible() && d.actualBounds.o() && d.Sf() &&
            (c = a.Gk(b), null === c ? (c = this.makeAdornment(d, !0), a.Qh(b, c)) : c.v()));
            null === c && a.Tf(b)
        }
    };
    qf.prototype.makeAdornment = function (a, b) {
        var c = new Xe;
        c.type = W.Link;
        b = b ? this.toHandleArchetype : this.fromHandleArchetype;
        null !== b && c.add(b.copy());
        c.adornedObject = a;
        return c
    };
    qf.prototype.canStart = function () {
        if (!this.isEnabled) return !1;
        var a = this.diagram;
        if (a.isReadOnly || a.isModelReadOnly || !a.allowRelink || !a.model.gu() || !a.lastInput.left) return !1;
        var b = this.findToolHandleAt(a.firstInput.documentPoint, "RelinkFrom");
        null === b && (b = this.findToolHandleAt(a.firstInput.documentPoint, "RelinkTo"));
        return null !== b
    };
    qf.prototype.doActivate = function () {
        var a = this.diagram;
        if (null === this.originalLink) {
            var b = this.handle;
            null === b && (b = this.findToolHandleAt(a.firstInput.documentPoint, "RelinkFrom"), null === b && (b = this.findToolHandleAt(a.firstInput.documentPoint, "RelinkTo")));
            if (null === b) return;
            var c = b.part;
            if (!(c instanceof Xe && c.adornedPart instanceof S)) return;
            this.handle = b;
            this.isForwards = null === c || "RelinkTo" === c.category;
            this.originalLink = c.adornedPart
        }
        this.Ca(this.name);
        a.isMouseCaptured = !0;
        a.currentCursor = this.linkingCursor;
        this.originalFromPort = this.originalLink.fromPort;
        this.originalFromNode = this.originalLink.fromNode;
        this.originalToPort = this.originalLink.toPort;
        this.originalToNode = this.originalLink.toNode;
        this.Ux.set(this.originalLink.actualBounds);
        null !== this.originalLink && 0 < this.originalLink.pointsCount && (null === this.originalLink.fromNode && (null !== this.temporaryFromPort && (this.temporaryFromPort.desiredSize = Tb), null !== this.temporaryFromNode && (this.temporaryFromNode.location = this.originalLink.i(0))), null === this.originalLink.toNode &&
        (null !== this.temporaryToPort && (this.temporaryToPort.desiredSize = Tb), null !== this.temporaryToNode && (this.temporaryToNode.location = this.originalLink.i(this.originalLink.pointsCount - 1))));
        this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort, !1);
        this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, !0);
        a.add(this.temporaryFromNode);
        a.add(this.temporaryToNode);
        null !== this.temporaryLink && (null !==
        this.temporaryFromNode && (this.temporaryLink.fromNode = this.temporaryFromNode), null !== this.temporaryToNode && (this.temporaryLink.toNode = this.temporaryToNode), this.copyLinkProperties(this.originalLink, this.temporaryLink), this.temporaryLink.Za(), a.add(this.temporaryLink));
        this.isActive = !0
    };
    qf.prototype.copyLinkProperties = function (a, b) {
        if (null !== a && null !== b) {
            b.adjusting = a.adjusting;
            b.corner = a.corner;
            var c = a.curve;
            if (c === ng || c === og) c = pg;
            b.curve = c;
            b.curviness = a.curviness;
            b.isTreeLink = a.isTreeLink;
            b.points = a.points;
            b.routing = a.routing;
            b.smoothness = a.smoothness;
            b.fromSpot = a.fromSpot;
            b.fromEndSegmentLength = a.fromEndSegmentLength;
            b.fromShortLength = a.fromShortLength;
            b.toSpot = a.toSpot;
            b.toEndSegmentLength = a.toEndSegmentLength;
            b.toShortLength = a.toShortLength
        }
    };
    qf.prototype.doDeactivate = function () {
        this.isActive = !1;
        var a = this.diagram;
        a.remove(this.temporaryLink);
        a.remove(this.temporaryFromNode);
        a.remove(this.temporaryToNode);
        a.isMouseCaptured = !1;
        a.currentCursor = "";
        this.Wg()
    };
    qf.prototype.doStop = function () {
        Yf.prototype.doStop.call(this);
        this.handle = null
    };
    qf.prototype.doMouseUp = function () {
        if (this.isActive) {
            var a = this.diagram;
            this.transactionResult = null;
            var b = this.originalFromNode, c = this.originalFromPort, d = this.originalToNode, e = this.originalToPort,
                f = this.originalLink;
            this.targetPort = this.findTargetPort(this.isForwards);
            if (null !== this.targetPort) {
                var g = this.targetPort.part;
                g instanceof V && (this.isForwards ? (d = g, e = this.targetPort) : (b = g, c = this.targetPort))
            } else this.isUnconnectedLinkValid ? this.isForwards ? e = d = null : c = b = null : f = null;
            null !== f ? (this.reconnectLink(f,
                this.isForwards ? d : b, this.isForwards ? e : c, this.isForwards), null === this.targetPort && (this.isForwards ? f.defaultToPoint = a.lastInput.documentPoint : f.defaultFromPoint = a.lastInput.documentPoint, f.Za()), a.allowSelect && (f.isSelected = !0), this.transactionResult = this.name, a.U("LinkRelinked", f, this.isForwards ? this.originalToPort : this.originalFromPort)) : this.doNoRelink(this.originalLink, this.isForwards);
            this.originalLink.Yq(this.Ux)
        }
        this.stopTool()
    };
    qf.prototype.reconnectLink = function (a, b, c, d) {
        c = null !== c && null !== c.portId ? c.portId : "";
        d ? (a.toNode = b, a.toPortId = c) : (a.fromNode = b, a.fromPortId = c);
        return !0
    };
    qf.prototype.doNoRelink = function () {
    };

    function Of(a, b, c, d, e) {
        null !== b ? (a.copyPortProperties(b, c, a.temporaryFromNode, a.temporaryFromPort, !1), a.diagram.add(a.temporaryFromNode)) : a.diagram.remove(a.temporaryFromNode);
        null !== d ? (a.copyPortProperties(d, e, a.temporaryToNode, a.temporaryToPort, !0), a.diagram.add(a.temporaryToNode)) : a.diagram.remove(a.temporaryToNode)
    }

    na.Object.defineProperties(qf.prototype, {
        fromHandleArchetype: {
            configurable: !0, get: function () {
                return this.W
            }, set: function (a) {
                null !== a && w(a, N, qf, "fromHandleArchetype");
                this.W = a
            }
        }, toHandleArchetype: {
            configurable: !0, get: function () {
                return this.pn
            }, set: function (a) {
                null !== a && w(a, N, qf, "toHandleArchetype");
                this.pn = a
            }
        }, handle: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                if (null !== a && (w(a, N, qf, "handle"), !(a.part instanceof Xe))) throw Error("new handle is not in an Adornment: " +
                    a);
                this.L = a
            }
        }
    });
    qf.className = "RelinkingTool";
    Sa("linkingTool", function () {
        return this.findTool("Linking")
    }, function (a) {
        this.eb("Linking", a, this.mouseMoveTools)
    });
    Sa("relinkingTool", function () {
        return this.findTool("Relinking")
    }, function (a) {
        this.eb("Relinking", a, this.mouseDownTools)
    });

    function qg() {
        0 < arguments.length && Ba(qg);
        Se.call(this);
        this.name = "LinkReshaping";
        var a = new Zf;
        a.figure = "Rectangle";
        a.desiredSize = Vb;
        a.fill = "lightblue";
        a.stroke = "dodgerblue";
        this.w = a;
        a = new Zf;
        a.figure = "Diamond";
        a.desiredSize = Wb;
        a.fill = "lightblue";
        a.stroke = "dodgerblue";
        a.cursor = "move";
        this.L = a;
        this.W = 3;
        this.Gu = this.l = null;
        this.Vx = new J;
        this.Vs = new H
    }

    ma(qg, Se);
    qg.prototype.kw = function (a) {
        return a && a.bt && 0 !== a.bt.value ? a.bt : rg
    };
    qg.prototype.jn = function (a, b) {
        w(a, N, qg, "setReshapingBehavior:obj");
        ib(b, qg, qg, "setReshapingBehavior:behavior");
        a.bt = b
    };
    qg.prototype.updateAdornments = function (a) {
        if (null !== a && a instanceof S) {
            var b = null;
            if (a.isSelected && !this.diagram.isReadOnly) {
                var c = a.path;
                null !== c && a.canReshape() && a.actualBounds.o() && a.isVisible() && c.actualBounds.o() && c.Sf() && (b = a.Gk(this.name), null === b || b.Rx !== a.pointsCount || b.hy !== a.resegmentable) && (b = this.makeAdornment(c), null !== b && (b.Rx = a.pointsCount, b.hy = a.resegmentable, a.Qh(this.name, b)))
            }
            null === b && a.Tf(this.name)
        }
    };
    qg.prototype.makeAdornment = function (a) {
        var b = a.part, c = b.pointsCount, d = b.isOrthogonal, e = null;
        if (null !== b.points && 1 < c) {
            e = new Xe;
            e.type = W.Link;
            c = b.firstPickIndex;
            var f = b.lastPickIndex, g = d ? 1 : 0;
            if (b.resegmentable && b.computeCurve() !== sg) for (var h = c + g; h < f - g; h++) {
                var k = this.makeResegmentHandle(a, h);
                null !== k && (k.segmentIndex = h, k.segmentFraction = .5, k.fromMaxLinks = 999, e.add(k))
            }
            for (g = c + 1; g < f; g++) if (h = this.makeHandle(a, g), null !== h) {
                h.segmentIndex = g;
                if (g !== c) if (g === c + 1 && d) {
                    k = b.i(c);
                    var l = b.i(c + 1);
                    K.C(k.x, l.x) &&
                    K.C(k.y, l.y) && (l = b.i(c - 1));
                    K.C(k.x, l.x) ? (this.jn(h, tg), h.cursor = "n-resize") : K.C(k.y, l.y) && (this.jn(h, ug), h.cursor = "w-resize")
                } else g === f - 1 && d ? (k = b.i(f - 1), l = b.i(f), K.C(k.x, l.x) && K.C(k.y, l.y) && (k = b.i(f + 1)), K.C(k.x, l.x) ? (this.jn(h, tg), h.cursor = "n-resize") : K.C(k.y, l.y) && (this.jn(h, ug), h.cursor = "w-resize")) : g !== f && (this.jn(h, vg), h.cursor = "move");
                e.add(h)
            }
            e.adornedObject = a
        }
        return e
    };
    qg.prototype.makeHandle = function () {
        var a = this.handleArchetype;
        return null === a ? null : a.copy()
    };
    qg.prototype.makeResegmentHandle = function () {
        var a = this.midHandleArchetype;
        return null === a ? null : a.copy()
    };
    qg.prototype.canStart = function () {
        if (!this.isEnabled) return !1;
        var a = this.diagram;
        return !a.isReadOnly && a.allowReshape && a.lastInput.left ? null !== this.findToolHandleAt(a.firstInput.documentPoint, this.name) : !1
    };
    qg.prototype.doActivate = function () {
        var a = this.diagram;
        null === this.handle && (this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name));
        if (null !== this.handle) {
            var b = this.handle.part.adornedPart;
            if (b instanceof S) {
                this.Gu = b;
                a.isMouseCaptured = !0;
                this.Ca(this.name);
                if (b.resegmentable && 999 === this.handle.fromMaxLinks) {
                    var c = b.points.copy(), d = this.getResegmentingPoint();
                    c.Bb(this.handle.segmentIndex + 1, d);
                    b.isOrthogonal && c.Bb(this.handle.segmentIndex + 1, d);
                    b.points = c;
                    b.Sb();
                    b.updateAdornments();
                    this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name);
                    if (null === this.handle) {
                        this.doDeactivate();
                        return
                    }
                }
                this.Vx = b.i(this.handle.segmentIndex);
                this.Vs = b.points.copy();
                this.isActive = !0
            }
        }
    };
    qg.prototype.doDeactivate = function () {
        this.Wg();
        this.Gu = this.handle = null;
        this.isActive = this.diagram.isMouseCaptured = !1
    };
    qg.prototype.doCancel = function () {
        var a = this.adornedLink;
        null !== a && (a.points = this.Vs);
        this.stopTool()
    };
    qg.prototype.getResegmentingPoint = function () {
        return this.handle.ja(Mc)
    };
    qg.prototype.doMouseMove = function () {
        var a = this.diagram;
        this.isActive && (a = this.computeReshape(a.lastInput.documentPoint), this.reshape(a))
    };
    qg.prototype.doMouseUp = function () {
        var a = this.diagram;
        if (this.isActive) {
            var b = this.computeReshape(a.lastInput.documentPoint);
            this.reshape(b);
            b = this.adornedLink;
            if (null !== b && b.resegmentable) {
                var c = this.handle.segmentIndex, d = b.i(c - 1), e = b.i(c), f = b.i(c + 1);
                if (b.isOrthogonal) {
                    if (c > b.firstPickIndex + 1 && c < b.lastPickIndex - 1) {
                        var g = b.i(c - 2);
                        if (Math.abs(d.x - e.x) < this.resegmentingDistance && Math.abs(d.y - e.y) < this.resegmentingDistance && (wg(this, g, d, e, f, !0) || wg(this, g, d, e, f, !1))) {
                            var h = b.points.copy();
                            wg(this, g, d,
                                e, f, !0) ? (h.Vc(c - 2, new J(g.x, (f.y + g.y) / 2)), h.Vc(c + 1, new J(f.x, (f.y + g.y) / 2))) : (h.Vc(c - 2, new J((f.x + g.x) / 2, g.y)), h.Vc(c + 1, new J((f.x + g.x) / 2, f.y)));
                            h.jb(c);
                            h.jb(c - 1);
                            b.points = h;
                            b.Sb()
                        } else g = b.i(c + 2), Math.abs(e.x - f.x) < this.resegmentingDistance && Math.abs(e.y - f.y) < this.resegmentingDistance && (wg(this, d, e, f, g, !0) || wg(this, d, e, f, g, !1)) && (h = b.points.copy(), wg(this, d, e, f, g, !0) ? (h.Vc(c - 1, new J(d.x, (d.y + g.y) / 2)), h.Vc(c + 2, new J(g.x, (d.y + g.y) / 2))) : (h.Vc(c - 1, new J((d.x + g.x) / 2, d.y)), h.Vc(c + 2, new J((d.x + g.x) / 2, g.y))),
                            h.jb(c + 1), h.jb(c), b.points = h, b.Sb())
                    }
                } else g = J.alloc(), K.$h(d.x, d.y, f.x, f.y, e.x, e.y, g) && g.Re(e) < this.resegmentingDistance * this.resegmentingDistance && (d = b.points.copy(), d.jb(c), b.points = d, b.Sb()), J.free(g)
            }
            a.Ua();
            this.transactionResult = this.name;
            a.U("LinkReshaped", this.adornedLink, this.Vs)
        }
        this.stopTool()
    };

    function wg(a, b, c, d, e, f) {
        return f ? Math.abs(b.y - c.y) < a.resegmentingDistance && Math.abs(c.y - d.y) < a.resegmentingDistance && Math.abs(d.y - e.y) < a.resegmentingDistance : Math.abs(b.x - c.x) < a.resegmentingDistance && Math.abs(c.x - d.x) < a.resegmentingDistance && Math.abs(d.x - e.x) < a.resegmentingDistance
    }

    qg.prototype.reshape = function (a) {
        var b = this.adornedLink;
        b.ci();
        var c = this.handle.segmentIndex, d = this.kw(this.handle);
        if (b.isOrthogonal) if (c === b.firstPickIndex + 1) c = b.firstPickIndex + 1, d === tg ? (b.O(c, b.i(c - 1).x, a.y), b.O(c + 1, b.i(c + 2).x, a.y)) : d === ug && (b.O(c, a.x, b.i(c - 1).y), b.O(c + 1, a.x, b.i(c + 2).y)); else if (c === b.lastPickIndex - 1) c = b.lastPickIndex - 1, d === tg ? (b.O(c - 1, b.i(c - 2).x, a.y), b.O(c, b.i(c + 1).x, a.y)) : d === ug && (b.O(c - 1, a.x, b.i(c - 2).y), b.O(c, a.x, b.i(c + 1).y)); else {
            d = c;
            var e = b.i(d), f = b.i(d - 1), g = b.i(d + 1);
            K.C(f.x,
                e.x) && K.C(e.y, g.y) ? (K.C(f.x, b.i(d - 2).x) && !K.C(f.y, b.i(d - 2).y) ? (b.m(d, a.x, f.y), c++, d++) : b.O(d - 1, a.x, f.y), K.C(g.y, b.i(d + 2).y) && !K.C(g.x, b.i(d + 2).x) ? b.m(d + 1, g.x, a.y) : b.O(d + 1, g.x, a.y)) : K.C(f.y, e.y) && K.C(e.x, g.x) ? (K.C(f.y, b.i(d - 2).y) && !K.C(f.x, b.i(d - 2).x) ? (b.m(d, f.x, a.y), c++, d++) : b.O(d - 1, f.x, a.y), K.C(g.x, b.i(d + 2).x) && !K.C(g.y, b.i(d + 2).y) ? b.m(d + 1, a.x, g.y) : b.O(d + 1, a.x, g.y)) : K.C(f.x, e.x) && K.C(e.x, g.x) ? (K.C(f.x, b.i(d - 2).x) && !K.C(f.y, b.i(d - 2).y) ? (b.m(d, a.x, f.y), c++, d++) : b.O(d - 1, a.x, f.y), K.C(g.x, b.i(d + 2).x) &&
            !K.C(g.y, b.i(d + 2).y) ? b.m(d + 1, a.x, g.y) : b.O(d + 1, a.x, g.y)) : K.C(f.y, e.y) && K.C(e.y, g.y) && (K.C(f.y, b.i(d - 2).y) && !K.C(f.x, b.i(d - 2).x) ? (b.m(d, f.x, a.y), c++, d++) : b.O(d - 1, f.x, a.y), K.C(g.y, b.i(d + 2).y) && !K.C(g.x, b.i(d + 2).x) ? b.m(d + 1, g.x, a.y) : b.O(d + 1, g.x, a.y));
            b.O(c, a.x, a.y)
        } else b.O(c, a.x, a.y), d = b.fromNode, e = b.fromPort, null !== d && (f = d.findVisibleNode(), null !== f && f !== d && (d = f, e = d.port)), 1 === c && b.computeSpot(!0, e).Tb() && (f = e.ja(Mc, J.alloc()), d = b.getLinkPointFromPoint(d, e, f, a, !0, J.alloc()), b.O(0, d.x, d.y), J.free(f),
            J.free(d)), d = b.toNode, e = b.toPort, null !== d && (f = d.findVisibleNode(), null !== f && f !== d && (d = f, e = d.port)), c === b.pointsCount - 2 && b.computeSpot(!1, e).Tb() && (c = e.ja(Mc, J.alloc()), a = b.getLinkPointFromPoint(d, e, c, a, !1, J.alloc()), b.O(b.pointsCount - 1, a.x, a.y), J.free(c), J.free(a));
        b.Jf()
    };
    qg.prototype.computeReshape = function (a) {
        var b = this.adornedLink, c = this.handle.segmentIndex;
        switch (this.kw(this.handle)) {
            case vg:
                return a;
            case tg:
                return new J(b.i(c).x, a.y);
            case ug:
                return new J(a.x, b.i(c).y);
            default:
            case rg:
                return b.i(c)
        }
    };
    na.Object.defineProperties(qg.prototype, {
        handleArchetype: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                null !== a && w(a, N, qg, "handleArchetype");
                this.w = a
            }
        }, midHandleArchetype: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                null !== a && w(a, N, qg, "midHandleArchetype");
                this.L = a
            }
        }, handle: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                if (null !== a && (w(a, N, qg, "handle"), !(a.part instanceof Xe))) throw Error("new handle is not in an Adornment: " +
                    a);
                this.l = a
            }
        }, adornedLink: {
            configurable: !0, get: function () {
                return this.Gu
            }
        }, resegmentingDistance: {
            configurable: !0, get: function () {
                return this.W
            }, set: function (a) {
                A(a, "number", qg, "resegmentingDistance");
                this.W = a
            }
        }, originalPoint: {
            configurable: !0, get: function () {
                return this.Vx
            }
        }, originalPoints: {
            configurable: !0, get: function () {
                return this.Vs
            }
        }
    });
    qg.prototype.setReshapingBehavior = qg.prototype.jn;
    qg.prototype.getReshapingBehavior = qg.prototype.kw;
    var rg = new E(qg, "None", 0), ug = new E(qg, "Horizontal", 1), tg = new E(qg, "Vertical", 2),
        vg = new E(qg, "All", 3);
    qg.className = "LinkReshapingTool";
    qg.None = rg;
    qg.Horizontal = ug;
    qg.Vertical = tg;
    qg.All = vg;
    Sa("linkReshapingTool", function () {
        return this.findTool("LinkReshaping")
    }, function (a) {
        this.eb("LinkReshaping", a, this.mouseDownTools)
    });

    function xg() {
        0 < arguments.length && Ba(xg);
        Se.call(this);
        this.name = "Resizing";
        this.sg = (new Hb(1, 1)).freeze();
        this.rg = (new Hb(9999, 9999)).freeze();
        this.dh = (new Hb(NaN, NaN)).freeze();
        this.L = !1;
        this.W = !0;
        this.ne = null;
        var a = new Zf;
        a.alignmentFocus = Mc;
        a.figure = "Rectangle";
        a.desiredSize = Vb;
        a.fill = "lightblue";
        a.stroke = "dodgerblue";
        a.strokeWidth = 1;
        a.cursor = "pointer";
        this.w = a;
        this.l = null;
        this.Us = new J;
        this.Tx = new Hb;
        this.yp = new J;
        this.Xu = new Hb(0, 0);
        this.Wu = new Hb(Infinity, Infinity);
        this.Vu = new Hb(1, 1);
        this.Qx =
            !0
    }

    ma(xg, Se);
    xg.prototype.updateAdornments = function (a) {
        if (!(null === a || a instanceof S)) {
            if (a.isSelected && !this.diagram.isReadOnly) {
                var b = a.resizeObject, c = a.Gk(this.name);
                if (null !== b && a.canResize() && a.actualBounds.o() && a.isVisible() && b.actualBounds.o() && b.Sf()) {
                    if (null === c || c.adornedObject !== b) c = this.makeAdornment(b);
                    if (null !== c) {
                        b = b.vj();
                        Lg(a) && this.updateResizeHandles(c, b);
                        a.Qh(this.name, c);
                        return
                    }
                }
            }
            a.Tf(this.name)
        }
    };
    xg.prototype.makeAdornment = function (a) {
        var b = a.part.resizeAdornmentTemplate;
        if (null === b) {
            b = new Xe;
            b.type = W.Spot;
            b.locationSpot = Mc;
            var c = new Mg;
            c.isPanelMain = !0;
            b.add(c);
            b.add(this.makeHandle(a, Fc));
            b.add(this.makeHandle(a, Hc));
            b.add(this.makeHandle(a, Rc));
            b.add(this.makeHandle(a, Oc));
            b.add(this.makeHandle(a, od));
            b.add(this.makeHandle(a, qd));
            b.add(this.makeHandle(a, rd));
            b.add(this.makeHandle(a, pd))
        } else if (Ng(b), b = b.copy(), null === b) return null;
        b.adornedObject = a;
        return b
    };
    xg.prototype.makeHandle = function (a, b) {
        a = this.handleArchetype;
        if (null === a) return null;
        a = a.copy();
        a.alignment = b;
        return a
    };
    xg.prototype.updateResizeHandles = function (a, b) {
        if (null !== a) if (!a.alignment.Jb() && ("pointer" === a.cursor || 0 < a.cursor.indexOf("resize"))) a:{
            var c = a.alignment;
            c.Tb() && (c = Mc);
            if (0 >= c.x) b = 0 >= c.y ? b + 225 : 1 <= c.y ? b + 135 : b + 180; else if (1 <= c.x) 0 >= c.y ? b += 315 : 1 <= c.y && (b += 45); else if (0 >= c.y) b += 270; else if (1 <= c.y) b += 90; else break a;
            0 > b ? b += 360 : 360 <= b && (b -= 360);
            a.cursor = 22.5 > b ? "e-resize" : 67.5 > b ? "se-resize" : 112.5 > b ? "s-resize" : 157.5 > b ? "sw-resize" : 202.5 > b ? "w-resize" : 247.5 > b ? "nw-resize" : 292.5 > b ? "n-resize" : 337.5 > b ? "ne-resize" :
                "e-resize"
        } else if (a instanceof W) for (a = a.elements; a.next();) this.updateResizeHandles(a.value, b)
    };
    xg.prototype.canStart = function () {
        if (!this.isEnabled) return !1;
        var a = this.diagram;
        return !a.isReadOnly && a.allowResize && a.lastInput.left ? null !== this.findToolHandleAt(a.firstInput.documentPoint, this.name) : !1
    };
    xg.prototype.doActivate = function () {
        var a = this.diagram;
        null === this.handle && (this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name));
        null !== this.handle && (this.adornedObject = this.handle.part.adornedObject, null !== this.adornedObject && (a.isMouseCaptured = !0, this.Qx = a.animationManager.isEnabled, a.animationManager.isEnabled = !1, this.Ca(this.name), this.Us.set(this.adornedObject.ja(this.handle.alignment.ww())), this.yp.set(this.adornedObject.part.location), this.Tx.set(this.adornedObject.desiredSize),
            this.Vu = this.computeCellSize(), this.Xu = this.computeMinSize(), this.Wu = this.computeMaxSize(), this.isActive = !0))
    };
    xg.prototype.doDeactivate = function () {
        var a = this.diagram;
        this.Wg();
        this.ne = this.handle = null;
        this.isActive = a.isMouseCaptured = !1;
        a.animationManager.isEnabled = this.Qx
    };
    xg.prototype.doCancel = function () {
        null !== this.adornedObject && (this.adornedObject.desiredSize = this.originalDesiredSize, this.adornedObject.part.location = this.originalLocation);
        this.stopTool()
    };
    xg.prototype.doMouseMove = function () {
        var a = this.diagram;
        if (this.isActive) {
            var b = this.Xu, c = this.Wu, d = this.Vu, e = this.adornedObject.Yt(a.lastInput.documentPoint, J.alloc()),
                f = this.computeReshape();
            b = this.computeResize(e, this.handle.alignment, b, c, d, f);
            this.resize(b);
            a.md();
            J.free(e)
        }
    };
    xg.prototype.doMouseUp = function () {
        var a = this.diagram;
        if (this.isActive) {
            var b = this.Xu, c = this.Wu, d = this.Vu, e = this.adornedObject.Yt(a.lastInput.documentPoint, J.alloc()),
                f = this.computeReshape();
            b = this.computeResize(e, this.handle.alignment, b, c, d, f);
            this.resize(b);
            J.free(e);
            a.Ua();
            this.transactionResult = this.name;
            a.U("PartResized", this.adornedObject, this.originalDesiredSize)
        }
        this.stopTool()
    };
    xg.prototype.resize = function (a) {
        var b = this.diagram, c = this.adornedObject;
        if (null !== c) {
            c.desiredSize = a.size;
            a = c.part;
            a.Ya();
            c = c.ja(this.handle.alignment.ww());
            if (a instanceof Kf) {
                var d = new H;
                d.add(a);
                if (!this.dragsMembers && null === a.placeholder) {
                    var e = new kf;
                    e.dragsMembers = !1
                }
                b.moveParts(d, this.oppositePoint.copy().ke(c), !0, e)
            } else a.location = a.location.copy().ke(c).add(this.oppositePoint);
            b.md()
        }
    };
    xg.prototype.computeResize = function (a, b, c, d, e, f) {
        b.Tb() && (b = Mc);
        var g = this.adornedObject.naturalBounds, h = g.x, k = g.y, l = g.x + g.width, m = g.y + g.height, n = 1;
        if (!f) {
            n = g.width;
            var p = g.height;
            0 >= n && (n = 1);
            0 >= p && (p = 1);
            n = p / n
        }
        p = J.alloc();
        K.Pq(a.x, a.y, h, k, e.width, e.height, p);
        a = g.copy();
        0 >= b.x ? 0 >= b.y ? (a.x = Math.max(p.x, l - d.width), a.x = Math.min(a.x, l - c.width), a.width = Math.max(l - a.x, c.width), a.y = Math.max(p.y, m - d.height), a.y = Math.min(a.y, m - c.height), a.height = Math.max(m - a.y, c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n *
            a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width), a.x = l - a.width, a.y = m - a.height)) : 1 <= b.y ? (a.x = Math.max(p.x, l - d.width), a.x = Math.min(a.x, l - c.width), a.width = Math.max(l - a.x, c.width), a.height = Math.max(Math.min(p.y - k, d.height), c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width), a.x = l - a.width)) : (a.x =
            Math.max(p.x, l - d.width), a.x = Math.min(a.x, l - c.width), a.width = l - a.x, f || (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n, a.y = k + .5 * (m - k - a.height))) : 1 <= b.x ? 0 >= b.y ? (a.width = Math.max(Math.min(p.x - h, d.width), c.width), a.y = Math.max(p.y, m - d.height), a.y = Math.min(a.y, m - c.height), a.height = Math.max(m - a.y, c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width),
            a.y = m - a.height)) : 1 <= b.y ? (a.width = Math.max(Math.min(p.x - h, d.width), c.width), a.height = Math.max(Math.min(p.y - k, d.height), c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width))) : (a.width = Math.max(Math.min(p.x - h, d.width), c.width), f || (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n, a.y = k + .5 * (m - k - a.height))) : 0 >= b.y ? (a.y = Math.max(p.y, m - d.height),
            a.y = Math.min(a.y, m - c.height), a.height = m - a.y, f || (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width, a.x = h + .5 * (l - h - a.width))) : 1 <= b.y && (a.height = Math.max(Math.min(p.y - k, d.height), c.height), f || (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width, a.x = h + .5 * (l - h - a.width)));
        J.free(p);
        return a
    };
    xg.prototype.computeReshape = function () {
        var a = Og;
        this.adornedObject instanceof Zf && (a = Pg(this.adornedObject));
        return !(a === Qg || this.diagram.lastInput.shift)
    };
    xg.prototype.computeMinSize = function () {
        var a = this.adornedObject.minSize.copy(), b = this.minSize;
        !isNaN(b.width) && b.width > a.width && (a.width = b.width);
        !isNaN(b.height) && b.height > a.height && (a.height = b.height);
        return a
    };
    xg.prototype.computeMaxSize = function () {
        var a = this.adornedObject.maxSize.copy(), b = this.maxSize;
        !isNaN(b.width) && b.width < a.width && (a.width = b.width);
        !isNaN(b.height) && b.height < a.height && (a.height = b.height);
        return a
    };
    xg.prototype.computeCellSize = function () {
        var a = new Hb(NaN, NaN), b = this.adornedObject.part;
        null !== b && (b = b.resizeCellSize, !isNaN(b.width) && 0 < b.width && (a.width = b.width), !isNaN(b.height) && 0 < b.height && (a.height = b.height));
        b = this.cellSize;
        isNaN(a.width) && !isNaN(b.width) && 0 < b.width && (a.width = b.width);
        isNaN(a.height) && !isNaN(b.height) && 0 < b.height && (a.height = b.height);
        b = this.diagram;
        (isNaN(a.width) || isNaN(a.height)) && b && (b = b.grid, null !== b && b.visible && this.isGridSnapEnabled && (b = b.gridCellSize, isNaN(a.width) &&
        !isNaN(b.width) && 0 < b.width && (a.width = b.width), isNaN(a.height) && !isNaN(b.height) && 0 < b.height && (a.height = b.height)));
        if (isNaN(a.width) || 0 === a.width || Infinity === a.width) a.width = 1;
        if (isNaN(a.height) || 0 === a.height || Infinity === a.height) a.height = 1;
        return a
    };
    na.Object.defineProperties(xg.prototype, {
        handleArchetype: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                null !== a && w(a, N, xg, "handleArchetype");
                this.w = a
            }
        }, handle: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                if (null !== a && (w(a, N, xg, "handle"), !(a.part instanceof Xe))) throw Error("new handle is not in an Adornment: " + a);
                this.l = a
            }
        }, adornedObject: {
            configurable: !0, get: function () {
                return this.ne
            }, set: function (a) {
                if (null !== a && (w(a, N,
                    xg, "handle"), a.part instanceof Xe)) throw Error("new handle must not be in an Adornment: " + a);
                this.ne = a
            }
        }, minSize: {
            configurable: !0, get: function () {
                return this.sg
            }, set: function (a) {
                w(a, Hb, xg, "minSize");
                if (!this.sg.A(a)) {
                    var b = a.width;
                    isNaN(b) && (b = 0);
                    a = a.height;
                    isNaN(a) && (a = 0);
                    this.sg.h(b, a)
                }
            }
        }, maxSize: {
            configurable: !0, get: function () {
                return this.rg
            }, set: function (a) {
                w(a, Hb, xg, "maxSize");
                if (!this.rg.A(a)) {
                    var b = a.width;
                    isNaN(b) && (b = Infinity);
                    a = a.height;
                    isNaN(a) && (a = Infinity);
                    this.rg.h(b, a)
                }
            }
        }, cellSize: {
            configurable: !0, get: function () {
                return this.dh
            }, set: function (a) {
                w(a, Hb, xg, "cellSize");
                this.dh.A(a) || this.dh.assign(a)
            }
        }, isGridSnapEnabled: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                A(a, "boolean", xg, "isGridSnapEnabled");
                this.L = a
            }
        }, dragsMembers: {
            configurable: !0, get: function () {
                return this.W
            }, set: function (a) {
                A(a, "boolean", xg, "dragsMembers");
                this.W = a
            }
        }, oppositePoint: {
            configurable: !0, get: function () {
                return this.Us
            },
            set: function (a) {
                w(a, J, xg, "oppositePoint");
                this.Us.A(a) || this.Us.assign(a)
            }
        }, originalDesiredSize: {
            configurable: !0, get: function () {
                return this.Tx
            }
        }, originalLocation: {
            configurable: !0, get: function () {
                return this.yp
            }
        }
    });
    xg.className = "ResizingTool";
    Sa("resizingTool", function () {
        return this.findTool("Resizing")
    }, function (a) {
        this.eb("Resizing", a, this.mouseDownTools)
    });

    function Rg() {
        0 < arguments.length && Ba(Rg);
        Se.call(this);
        this.name = "Rotating";
        this.Pa = 45;
        this.Oa = 2;
        this.yp = new J;
        this.ne = null;
        var a = new Zf;
        a.figure = "Ellipse";
        a.desiredSize = Wb;
        a.fill = "lightblue";
        a.stroke = "dodgerblue";
        a.strokeWidth = 1;
        a.cursor = "pointer";
        this.w = a;
        this.l = null;
        this.Sx = 0;
        this.xv = new J(NaN, NaN);
        this.L = 0;
        this.W = 50
    }

    ma(Rg, Se);
    Rg.prototype.updateAdornments = function (a) {
        if (null !== a) {
            if (a.Zh()) {
                var b = a.rotateObject;
                if (b === a || b === a.path || b.isPanelMain) return
            }
            if (a.isSelected && !this.diagram.isReadOnly && (b = a.rotateObject, null !== b && a.canRotate() && a.actualBounds.o() && a.isVisible() && b.actualBounds.o() && b.Sf())) {
                var c = a.Gk(this.name);
                if (null === c || c.adornedObject !== b) c = this.makeAdornment(b);
                if (null !== c) {
                    c.angle = b.vj();
                    null === c.placeholder && (c.location = this.computeAdornmentLocation(b));
                    a.Qh(this.name, c);
                    return
                }
            }
            a.Tf(this.name)
        }
    };
    Rg.prototype.makeAdornment = function (a) {
        var b = a.part.rotateAdornmentTemplate;
        if (null === b) {
            b = new Xe;
            b.type = W.Position;
            b.locationSpot = Mc;
            var c = this.handleArchetype;
            null !== c && b.add(c.copy())
        } else if (Ng(b), b = b.copy(), null === b) return null;
        b.adornedObject = a;
        return b
    };
    Rg.prototype.canStart = function () {
        if (!this.isEnabled) return !1;
        var a = this.diagram;
        return !a.isReadOnly && a.allowRotate && a.lastInput.left ? null !== this.findToolHandleAt(a.firstInput.documentPoint, this.name) : !1
    };
    Rg.prototype.doActivate = function () {
        var a = this.diagram;
        if (null === this.adornedObject) {
            null === this.handle && (this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name));
            if (null === this.handle) return;
            this.adornedObject = this.handle.part.adornedObject
        }
        null !== this.adornedObject && (a.isMouseCaptured = !0, a.delaysLayout = !0, this.Ca(this.name), this.Sx = this.adornedObject.angle, this.xv = this.computeRotationPoint(this.adornedObject), this.yp = this.adornedObject.part.location.copy(), this.isActive = !0)
    };
    Rg.prototype.computeRotationPoint = function (a) {
        var b = a.part, c = b.locationObject;
        return b.rotationSpot.cb() ? a.ja(b.rotationSpot) : a === b || a === c ? c.ja(b.locationSpot) : a.ja(Mc)
    };
    Rg.prototype.computeAdornmentLocation = function (a) {
        var b = this.rotationPoint;
        b.o() || (b = this.computeRotationPoint(a));
        b = a.Yt(b);
        var c = this.handleAngle;
        0 > c ? c += 360 : 360 <= c && (c -= 360);
        c = Math.round(45 * Math.round(c / 45));
        var d = this.handleDistance;
        0 === c ? b.x = a.naturalBounds.width + d : 45 === c ? (b.x = a.naturalBounds.width + d, b.y = a.naturalBounds.height + d) : 90 === c ? b.y = a.naturalBounds.height + d : 135 === c ? (b.x = -d, b.y = a.naturalBounds.height + d) : 180 === c ? b.x = -d : 225 === c ? (b.x = -d, b.y = -d) : 270 === c ? b.y = -d : 315 === c && (b.x = a.naturalBounds.width +
            d, b.y = -d);
        return a.ja(b)
    };
    Rg.prototype.doDeactivate = function () {
        var a = this.diagram;
        this.Wg();
        this.ne = this.handle = null;
        this.xv = new J(NaN, NaN);
        this.isActive = a.isMouseCaptured = !1
    };
    Rg.prototype.doCancel = function () {
        this.diagram.delaysLayout = !1;
        this.rotate(this.originalAngle);
        this.stopTool()
    };
    Rg.prototype.doMouseMove = function () {
        var a = this.diagram;
        this.isActive && (a = this.computeRotate(a.lastInput.documentPoint), this.rotate(a))
    };
    Rg.prototype.doMouseUp = function () {
        var a = this.diagram;
        if (this.isActive) {
            a.delaysLayout = !1;
            var b = this.computeRotate(a.lastInput.documentPoint);
            this.rotate(b);
            a.Ua();
            this.transactionResult = this.name;
            a.U("PartRotated", this.adornedObject, this.originalAngle)
        }
        this.stopTool()
    };
    Rg.prototype.rotate = function (a) {
        F && C(a, Rg, "rotate:newangle");
        var b = this.adornedObject;
        if (null !== b) {
            b.angle = a;
            b = b.part;
            b.Ya();
            var c = b.locationObject, d = b.rotateObject;
            if (c === d || c.Tg(d)) c = this.yp.copy(), b.location = c.ke(this.rotationPoint).rotate(a - this.originalAngle).add(this.rotationPoint);
            this.diagram.md()
        }
    };
    Rg.prototype.computeRotate = function (a) {
        a = this.rotationPoint.Xa(a) - this.handleAngle;
        var b = this.adornedObject.panel;
        null !== b && (a -= b.vj());
        360 <= a ? a -= 360 : 0 > a && (a += 360);
        b = Math.min(Math.abs(this.snapAngleMultiple), 180);
        var c = Math.min(Math.abs(this.snapAngleEpsilon), b / 2);
        !this.diagram.lastInput.shift && 0 < b && 0 < c && (a % b < c ? a = Math.floor(a / b) * b : a % b > b - c && (a = (Math.floor(a / b) + 1) * b));
        360 <= a ? a -= 360 : 0 > a && (a += 360);
        return a
    };
    na.Object.defineProperties(Rg.prototype, {
        handleArchetype: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                null !== a && w(a, N, Rg, "handleArchetype");
                this.w = a
            }
        }, handle: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                if (null !== a && (w(a, N, Rg, "handle"), !(a.part instanceof Xe))) throw Error("new handle is not in an Adornment: " + a);
                this.l = a
            }
        }, adornedObject: {
            configurable: !0, get: function () {
                return this.ne
            }, set: function (a) {
                if (null !== a && (w(a, N,
                    Rg, "handle"), a.part instanceof Xe)) throw Error("new handle must not be in an Adornment: " + a);
                this.ne = a
            }
        }, snapAngleMultiple: {
            configurable: !0, get: function () {
                return this.Pa
            }, set: function (a) {
                A(a, "number", Rg, "snapAngleMultiple");
                this.Pa = a
            }
        }, snapAngleEpsilon: {
            configurable: !0, get: function () {
                return this.Oa
            }, set: function (a) {
                A(a, "number", Rg, "snapAngleEpsilon");
                this.Oa = a
            }
        }, originalAngle: {
            configurable: !0, get: function () {
                return this.Sx
            }
        }, rotationPoint: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.xv
            }
        }, handleAngle: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                A(a, "number", Rg, "handleAngle");
                this.L = a
            }
        }, handleDistance: {
            configurable: !0, get: function () {
                return this.W
            }, set: function (a) {
                A(a, "number", Rg, "handleDistance");
                this.W = a
            }
        }
    });
    Rg.className = "RotatingTool";
    Sa("rotatingTool", function () {
        return this.findTool("Rotating")
    }, function (a) {
        this.eb("Rotating", a, this.mouseDownTools)
    });

    function Sg() {
        Se.call(this);
        0 < arguments.length && Ba(Sg);
        this.name = "ClickSelecting"
    }

    ma(Sg, Se);
    Sg.prototype.canStart = function () {
        return !this.isEnabled || this.isBeyondDragSize() ? !1 : !0
    };
    Sg.prototype.doMouseUp = function () {
        this.isActive && (this.standardMouseSelect(), !this.standardMouseClick() && this.diagram.lastInput.isTouchEvent && this.diagram.toolManager.doToolTip());
        this.stopTool()
    };
    Sg.className = "ClickSelectingTool";

    function Tg() {
        Se.call(this);
        0 < arguments.length && Ba(Tg);
        this.name = "Action";
        this.fl = null
    }

    ma(Tg, Se);
    Tg.prototype.canStart = function () {
        if (!this.isEnabled) return !1;
        var a = this.diagram, b = a.lastInput, c = a.ac(b.documentPoint, function (a) {
            for (; null !== a.panel && !a.isActionable;) a = a.panel;
            return a
        });
        if (null !== c) {
            if (!c.isActionable) return !1;
            this.fl = c;
            a.Oj = a.ac(b.documentPoint, null, null);
            return !0
        }
        return !1
    };
    Tg.prototype.doMouseDown = function () {
        if (this.isActive) {
            var a = this.diagram.lastInput, b = this.fl;
            null !== b && (a.targetObject = b, null !== b.actionDown && b.actionDown(a, b))
        } else this.canStart() && this.doActivate()
    };
    Tg.prototype.doMouseMove = function () {
        if (this.isActive) {
            var a = this.diagram.lastInput, b = this.fl;
            null !== b && (a.targetObject = b, null !== b.actionMove && b.actionMove(a, b))
        }
    };
    Tg.prototype.doMouseUp = function () {
        if (this.isActive) {
            var a = this.diagram.lastInput, b = this.fl;
            if (null === b) return;
            a.targetObject = b;
            null !== b.actionUp && b.actionUp(a, b);
            this.standardMouseClick(function (a) {
                for (; null !== a.panel && (!a.isActionable || a !== b);) a = a.panel;
                return a
            }, function (a) {
                return a === b
            })
        }
        this.stopTool()
    };
    Tg.prototype.doCancel = function () {
        var a = this.diagram.lastInput, b = this.fl;
        null !== b && (a.targetObject = b, null !== b.actionCancel && b.actionCancel(a, b), this.stopTool())
    };
    Tg.prototype.doStop = function () {
        this.fl = null
    };
    Tg.className = "ActionTool";

    function Ug() {
        Se.call(this);
        0 < arguments.length && Ba(Ug);
        this.name = "ClickCreating";
        this.Kj = null;
        this.w = !0;
        this.l = !1;
        this.Kx = new J(0, 0)
    }

    ma(Ug, Se);
    Ug.prototype.canStart = function () {
        if (!this.isEnabled || null === this.archetypeNodeData) return !1;
        var a = this.diagram;
        if (a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.lastInput.left || this.isBeyondDragSize()) return !1;
        if (this.isDoubleClick) {
            if (1 === a.lastInput.clickCount && (this.Kx = a.lastInput.viewPoint.copy()), 2 !== a.lastInput.clickCount || this.isBeyondDragSize(this.Kx)) return !1
        } else if (1 !== a.lastInput.clickCount) return !1;
        return a.currentTool !== this && null !== a.Lm(a.lastInput.documentPoint, !0) ? !1 : !0
    };
    Ug.prototype.doMouseUp = function () {
        var a = this.diagram;
        this.isActive && this.insertPart(a.lastInput.documentPoint);
        this.stopTool()
    };
    Ug.prototype.insertPart = function (a) {
        var b = this.diagram, c = this.archetypeNodeData;
        if (null === c) return null;
        var d = null;
        try {
            b.U("ChangingSelection", b.selection);
            this.Ca(this.name);
            if (c instanceof T) c.Tc() && (Ng(c), d = c.copy(), null !== d && b.add(d)); else if (null !== c) {
                var e = b.model.copyNodeData(c);
                Ga(e) && (b.model.Gf(e), d = b.Fc(e))
            }
            if (null !== d) {
                var f = J.allocAt(a.x, a.y);
                this.isGridSnapEnabled && Vg(this.diagram, d, a, f);
                d.location = f;
                b.allowSelect && (b.clearSelection(!0), d.isSelected = !0);
                J.free(f)
            }
            b.Ua();
            this.transactionResult =
                this.name;
            b.U("PartCreated", d)
        } finally {
            this.Wg(), b.U("ChangedSelection", b.selection)
        }
        return d
    };
    na.Object.defineProperties(Ug.prototype, {
        archetypeNodeData: {
            configurable: !0, get: function () {
                return this.Kj
            }, set: function (a) {
                null !== a && A(a, "object", Ug, "archetypeNodeData");
                this.Kj = a
            }
        }, isDoubleClick: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                A(a, "boolean", Ug, "isDoubleClick");
                this.w = a
            }
        }, isGridSnapEnabled: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                A(a, "boolean", Ug, "isGridSnapEnabled");
                this.l = a
            }
        }
    });
    Ug.className = "ClickCreatingTool";

    function Wg() {
        Se.call(this);
        0 < arguments.length && Ba(Wg);
        this.name = "DragSelecting";
        this.zl = 175;
        this.w = !1;
        var a = new T;
        a.layerName = "Tool";
        a.selectable = !1;
        var b = new Zf;
        b.name = "SHAPE";
        b.figure = "Rectangle";
        b.fill = null;
        b.stroke = "magenta";
        a.add(b);
        this.l = a
    }

    ma(Wg, Se);
    Wg.prototype.canStart = function () {
        if (!this.isEnabled) return !1;
        var a = this.diagram;
        if (!a.allowSelect) return !1;
        var b = a.lastInput;
        return !b.left || a.currentTool !== this && (!this.isBeyondDragSize() || b.timestamp - a.firstInput.timestamp < this.delay || null !== a.Lm(b.documentPoint, !0)) ? !1 : !0
    };
    Wg.prototype.doActivate = function () {
        var a = this.diagram;
        this.isActive = !0;
        a.isMouseCaptured = !0;
        a.skipsUndoManager = !0;
        a.add(this.box);
        this.doMouseMove()
    };
    Wg.prototype.doDeactivate = function () {
        var a = this.diagram;
        a.Vf();
        a.remove(this.box);
        a.skipsUndoManager = !1;
        this.isActive = a.isMouseCaptured = !1
    };
    Wg.prototype.doMouseMove = function () {
        var a = this.diagram;
        if (this.isActive && null !== this.box) {
            var b = this.computeBoxBounds(), c = this.box.hb("SHAPE");
            null === c && (c = this.box.wb());
            var d = Hb.alloc().h(b.width, b.height);
            b = J.allocAt(b.x, b.y);
            c.desiredSize = d;
            this.box.position = b;
            Hb.free(d);
            J.free(b);
            (a.allowHorizontalScroll || a.allowVerticalScroll) && a.Qt(a.lastInput.viewPoint)
        }
    };
    Wg.prototype.doMouseUp = function () {
        if (this.isActive) {
            var a = this.diagram;
            a.remove(this.box);
            try {
                a.currentCursor = "wait", a.U("ChangingSelection", a.selection), this.selectInRect(this.computeBoxBounds()), a.U("ChangedSelection", a.selection)
            } finally {
                a.currentCursor = ""
            }
        }
        this.stopTool()
    };
    Wg.prototype.computeBoxBounds = function () {
        var a = this.diagram;
        return new L(a.firstInput.documentPoint, a.lastInput.documentPoint)
    };
    Wg.prototype.selectInRect = function (a) {
        var b = this.diagram, c = b.lastInput;
        a = b.Hy(a, this.isPartialInclusion);
        if (eb ? c.meta : c.control) if (c.shift) for (a = a.iterator; a.next();) b = a.value, b.isSelected && (b.isSelected = !1); else for (a = a.iterator; a.next();) b = a.value, b.isSelected = !b.isSelected; else if (c.shift) for (a = a.iterator; a.next();) b = a.value, b.isSelected || (b.isSelected = !0); else {
            c = new H;
            for (b = b.selection.iterator; b.next();) {
                var d = b.value;
                a.contains(d) || c.add(d)
            }
            for (b = c.iterator; b.next();) b.value.isSelected = !1;
            for (a =
                     a.iterator; a.next();) b = a.value, b.isSelected || (b.isSelected = !0)
        }
    };
    na.Object.defineProperties(Wg.prototype, {
        delay: {
            configurable: !0, get: function () {
                return this.zl
            }, set: function (a) {
                A(a, "number", Wg, "delay");
                this.zl = a
            }
        }, isPartialInclusion: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                A(a, "boolean", Wg, "isPartialInclusion");
                this.w = a
            }
        }, box: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                null !== a && w(a, T, Wg, "box");
                this.l = a
            }
        }
    });
    Wg.className = "DragSelectingTool";

    function Xg() {
        Se.call(this);
        0 < arguments.length && Ba(Xg);
        this.name = "Panning";
        this.uv = new J;
        this.Az = new J;
        this.bh = !1;
        var a = this;
        this.Yx = function () {
            var b = a.diagram;
            null !== b && b.removeEventListener(qa.document, "scroll", a.Yx, !1);
            a.stopTool()
        }
    }

    ma(Xg, Se);
    Xg.prototype.canStart = function () {
        if (!this.isEnabled) return !1;
        var a = this.diagram;
        return !a.allowHorizontalScroll && !a.allowVerticalScroll || !a.lastInput.left || a.currentTool !== this && !this.isBeyondDragSize() ? !1 : !0
    };
    Xg.prototype.doActivate = function () {
        var a = this.diagram;
        this.bh ? (a.lastInput.bubbles = !0, a.addEventListener(qa.document, "scroll", this.Yx, !1)) : (a.currentCursor = "move", a.isMouseCaptured = !0, this.uv.assign(a.position));
        this.isActive = !0
    };
    Xg.prototype.doDeactivate = function () {
        var a = this.diagram;
        a.currentCursor = "";
        this.isActive = a.isMouseCaptured = !1
    };
    Xg.prototype.doCancel = function () {
        var a = this.diagram;
        a.position = this.uv;
        a.isMouseCaptured = !1;
        this.stopTool()
    };
    Xg.prototype.doMouseMove = function () {
        this.move()
    };
    Xg.prototype.doMouseUp = function () {
        this.move();
        this.stopTool()
    };
    Xg.prototype.move = function () {
        var a = this.diagram;
        if (this.isActive && a) if (this.bh) a.lastInput.bubbles = !0; else {
            var b = a.position, c = a.firstInput.documentPoint, d = a.lastInput.documentPoint, e = b.x + c.x - d.x;
            c = b.y + c.y - d.y;
            a.allowHorizontalScroll || (e = b.x);
            a.allowVerticalScroll || (c = b.y);
            a.position = this.Az.h(e, c)
        }
    };
    na.Object.defineProperties(Xg.prototype, {
        bubbles: {
            configurable: !0, get: function () {
                return this.bh
            }, set: function (a) {
                A(a, "boolean", Xg, "bubbles");
                this.bh = a
            }
        }, originalPosition: {
            configurable: !0, get: function () {
                return this.uv
            }
        }
    });
    Xg.className = "PanningTool";
    Sa("clickCreatingTool", function () {
        return this.findTool("ClickCreating")
    }, function (a) {
        this.eb("ClickCreating", a, this.mouseUpTools)
    });
    Sa("clickSelectingTool", function () {
        return this.findTool("ClickSelecting")
    }, function (a) {
        this.eb("ClickSelecting", a, this.mouseUpTools)
    });
    Sa("panningTool", function () {
        return this.findTool("Panning")
    }, function (a) {
        this.eb("Panning", a, this.mouseMoveTools)
    });
    Sa("dragSelectingTool", function () {
        return this.findTool("DragSelecting")
    }, function (a) {
        this.eb("DragSelecting", a, this.mouseMoveTools)
    });
    Sa("actionTool", function () {
        return this.findTool("Action")
    }, function (a) {
        this.eb("Action", a, this.mouseDownTools)
    });

    function gf() {
        this.W = this.L = this.l = this.w = null
    }

    na.Object.defineProperties(gf.prototype, {
        mainElement: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                null !== a && w(a, HTMLElement, gf, "mainElement");
                this.L = a
            }
        }, show: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                this.w !== a && (null !== a && A(a, "function", gf, "show"), this.w = a)
            }
        }, hide: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                this.l !== a && (null !== a && A(a, "function", gf, "hide"), this.l = a)
            }
        }, valueFunction: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.W
            }, set: function (a) {
                this.W = a
            }
        }
    });
    gf.className = "HTMLInfo";

    function Yg(a, b, c) {
        this.text = a;
        this.ty = b;
        this.visible = c
    }

    Yg.className = "ContextMenuButtonInfo";

    function Zg() {
        Se.call(this);
        0 < arguments.length && Ba(Zg);
        this.name = "ContextMenu";
        this.w = this.Mu = this.l = null;
        this.Px = new J;
        this.Nu = null;
        this.hv = !1;
        var a = this;
        this.Hv = function () {
            a.stopTool()
        }
    }

    ma(Zg, Se);

    function $g(a) {
        var b = new gf;
        b.show = function (a, b, c) {
            c.showDefaultContextMenu()
        };
        b.hide = function (a, b) {
            b.hideDefaultContextMenu()
        };
        ah = b;
        a.Hv = function () {
            a.stopTool()
        };
        b = ua("div");
        var c = ua("div");
        b.style.cssText = "top: 0px;z-index:10002;position: fixed;display: none;text-align: center;left: 25%;width: 50%;background-color: #F5F5F5;padding: 16px;border: 16px solid #444;border-radius: 10px;margin-top: 10px";
        c.style.cssText = "z-index:10001;position: fixed;display: none;top: 0;left: 0;width: 100%;height: 100%;background-color: black;opacity: 0.8;";
        var d = ua("style");
        qa.document.getElementsByTagName("head")[0].appendChild(d);
        d.sheet.insertRule(".goCXul { list-style: none; }", 0);
        d.sheet.insertRule(".goCXli {font:700 1.5em Helvetica, Arial, sans-serif;position: relative;min-width: 60px; }", 0);
        d.sheet.insertRule(".goCXa {color: #444;display: inline-block;padding: 4px;text-decoration: none;margin: 2px;border: 1px solid gray;border-radius: 10px; }", 0);
        d = a.diagram;
        null !== d && (d.addEventListener(b, "contextmenu", bh, !1), d.addEventListener(b, "selectstart",
            bh, !1), d.addEventListener(c, "contextmenu", bh, !1));
        b.className = "goCXforeground";
        c.className = "goCXbackground";
        qa.document.body && (qa.document.body.appendChild(b), qa.document.body.appendChild(c));
        ch = b;
        dh = c;
        eh = !0
    }

    function bh(a) {
        a.preventDefault();
        return !1
    }

    Zg.prototype.canStart = function () {
        if (!this.isEnabled) return !1;
        var a = this.diagram;
        return this.isBeyondDragSize() || !a.lastInput.right || 1 < a.lastInput.clickCount ? !1 : a.lastInput.isTouchEvent && null !== this.defaultTouchContextMenu || null !== this.findObjectWithContextMenu() ? !0 : !1
    };
    Zg.prototype.doStart = function () {
        this.Px.set(this.diagram.firstInput.documentPoint)
    };
    Zg.prototype.doStop = function () {
        this.hideContextMenu();
        this.currentObject = null
    };
    Zg.prototype.findObjectWithContextMenu = function (a) {
        void 0 === a && (a = null);
        var b = this.diagram, c = b.lastInput, d = null;
        a instanceof Q || (a instanceof N ? d = a : d = b.ac(c.documentPoint, null, function (a) {
            return !a.layer.isTemporary
        }));
        if (null !== d) {
            for (a = d; null !== a;) {
                if (null !== a.contextMenu) return a;
                a = a.panel
            }
            if (b.lastInput.isTouchEvent && this.defaultTouchContextMenu) return d.part
        } else if (null !== b.contextMenu) return b;
        return null
    };
    Zg.prototype.doActivate = function () {
    };
    Zg.prototype.doMouseDown = function () {
        Se.prototype.doMouseDown.call(this);
        if (this.isActive && this.currentContextMenu instanceof Xe) {
            var a = this.diagram.toolManager.findTool("Action");
            null !== a && a.canStart() && (a.doActivate(), a.doMouseDown(), a.doDeactivate())
        }
        this.diagram.toolManager.mouseDownTools.contains(this) && fh(this)
    };
    Zg.prototype.doMouseUp = function () {
        if (this.isActive && this.currentContextMenu instanceof Xe) {
            var a = this.diagram.toolManager.findTool("Action");
            null !== a && a.canStart() && (a.doActivate(), a.doCancel(), a.doDeactivate())
        }
        fh(this)
    };

    function fh(a) {
        var b = a.diagram;
        if (a.isActive) {
            var c = a.currentContextMenu;
            if (null !== c) {
                if (!(c instanceof gf)) {
                    var d = b.ac(b.lastInput.documentPoint, null, null);
                    null !== d && d.Tg(c) && a.standardMouseClick(null, null)
                }
                a.stopTool();
                a.canStart() && (b.currentTool = a, a.doMouseUp())
            }
        } else a.canStart() && (gh(a, !0), a.isActive || a.stopTool())
    }

    function gh(a, b, c) {
        void 0 === c && (c = null);
        if (!a.hv && (a.hv = !0, b && a.standardMouseSelect(), b = a.standardMouseClick(), a.hv = !1, !b)) {
            a.isActive = !0;
            b = ah;
            null === c && (c = a.findObjectWithContextMenu());
            if (null !== c) {
                var d = c.contextMenu;
                null !== d ? (a.currentObject = c instanceof N ? c : null, a.showContextMenu(d, a.currentObject)) : null !== b && a.showContextMenu(b, a.currentObject)
            } else null !== b && a.showContextMenu(b, null);
            a.currentContextMenu instanceof Xe && !a.currentContextMenu.visible && a.stopTool()
        }
    }

    Zg.prototype.doMouseMove = function () {
        var a = this.diagram.toolManager.findTool("Action");
        null !== a && a.doMouseMove();
        this.isActive && this.diagram.toolManager.doMouseMove()
    };
    Zg.prototype.showContextMenu = function (a, b) {
        !F || a instanceof Xe || a instanceof gf || v("showContextMenu:contextMenu must be an Adornment or HTMLInfo.");
        null !== b && w(b, N, Zg, "showContextMenu:obj");
        var c = this.diagram;
        a !== this.currentContextMenu && this.hideContextMenu();
        if (a instanceof Xe) {
            a.layerName = "Tool";
            a.selectable = !1;
            a.scale = 1 / c.scale;
            a.category = this.name;
            null !== a.placeholder && (a.placeholder.scale = c.scale);
            var d = a.diagram;
            null !== d && d !== c && d.remove(a);
            c.add(a);
            null !== b ? a.adornedObject = b : a.data = c.model;
            a.Ya();
            this.positionContextMenu(a, b)
        } else a instanceof gf && a.show(b, c, this);
        this.currentContextMenu = a
    };
    Zg.prototype.positionContextMenu = function (a) {
        if (null === a.placeholder) {
            var b = this.diagram, c = b.lastInput.documentPoint.copy(), d = a.measuredBounds, e = b.viewportBounds;
            b.lastInput.isTouchEvent && (c.x -= d.width);
            c.x + d.width > e.right && (c.x -= d.width + 5 / b.scale);
            c.x < e.x && (c.x = e.x);
            c.y + d.height > e.bottom && (c.y -= d.height + 5 / b.scale);
            c.y < e.y && (c.y = e.y);
            a.position = c
        }
    };
    Zg.prototype.hideContextMenu = function () {
        var a = this.diagram, b = this.currentContextMenu;
        null !== b && (b instanceof Xe ? (a.remove(b), null !== this.Mu && this.Mu.Tf(b.category), b.data = null, b.adornedObject = null) : b instanceof gf && (null !== b.hide ? b.hide(a, this) : null !== b.mainElement && (b.mainElement.style.display = "none")), this.currentContextMenu = null, this.standardMouseOver())
    };

    function hh(a) {
        var b = new H;
        b.add(new Yg("Copy", function (a) {
            a.commandHandler.copySelection()
        }, function (a) {
            return a.commandHandler.canCopySelection()
        }));
        b.add(new Yg("Cut", function (a) {
            a.commandHandler.cutSelection()
        }, function (a) {
            return a.commandHandler.canCutSelection()
        }));
        b.add(new Yg("Delete", function (a) {
            a.commandHandler.deleteSelection()
        }, function (a) {
            return a.commandHandler.canDeleteSelection()
        }));
        b.add(new Yg("Paste", function (b) {
            b.commandHandler.pasteSelection(a.mouseDownPoint)
        }, function (b) {
            return b.commandHandler.canPasteSelection(a.mouseDownPoint)
        }));
        b.add(new Yg("Select All", function (a) {
            a.commandHandler.selectAll()
        }, function (a) {
            return a.commandHandler.canSelectAll()
        }));
        b.add(new Yg("Undo", function (a) {
            a.commandHandler.undo()
        }, function (a) {
            return a.commandHandler.canUndo()
        }));
        b.add(new Yg("Redo", function (a) {
            a.commandHandler.redo()
        }, function (a) {
            return a.commandHandler.canRedo()
        }));
        b.add(new Yg("Scroll To Part", function (a) {
            a.commandHandler.scrollToPart()
        }, function (a) {
            return a.commandHandler.canScrollToPart()
        }));
        b.add(new Yg("Zoom To Fit", function (a) {
                a.commandHandler.zoomToFit()
            },
            function (a) {
                return a.commandHandler.canZoomToFit()
            }));
        b.add(new Yg("Reset Zoom", function (a) {
            a.commandHandler.resetZoom()
        }, function (a) {
            return a.commandHandler.canResetZoom()
        }));
        b.add(new Yg("Group Selection", function (a) {
            a.commandHandler.groupSelection()
        }, function (a) {
            return a.commandHandler.canGroupSelection()
        }));
        b.add(new Yg("Ungroup Selection", function (a) {
            a.commandHandler.ungroupSelection()
        }, function (a) {
            return a.commandHandler.canUngroupSelection()
        }));
        b.add(new Yg("Edit Text", function (a) {
                a.commandHandler.editTextBlock()
            },
            function (a) {
                return a.commandHandler.canEditTextBlock()
            }));
        return b
    }

    Zg.prototype.showDefaultContextMenu = function () {
        var a = this.diagram;
        null === this.Nu && (this.Nu = hh(this));
        ch.innerHTML = "";
        dh.addEventListener("click", this.Hv, !1);
        var b = this, c = ua("ul");
        c.className = "goCXul";
        ch.appendChild(c);
        c.innerHTML = "";
        for (var d = this.Nu.iterator; d.next();) {
            var e = d.value, f = e.visible;
            if ("function" === typeof e.ty && ("function" !== typeof f || f(a))) {
                f = ua("li");
                f.className = "goCXli";
                var g = ua("a");
                g.className = "goCXa";
                g.href = "#";
                g.uz = e.ty;
                g.addEventListener("click", function (c) {
                    this.uz(a);
                    b.stopTool();
                    c.preventDefault();
                    return !1
                }, !1);
                g.textContent = e.text;
                f.appendChild(g);
                c.appendChild(f)
            }
        }
        ch.style.display = "block";
        dh.style.display = "block"
    };
    Zg.prototype.hideDefaultContextMenu = function () {
        if (null !== this.currentContextMenu && this.currentContextMenu === ah) {
            ch.style.display = "none";
            dh.style.display = "none";
            var a = this.diagram;
            null !== a && a.removeEventListener(dh, "click", this.Hv, !1);
            this.currentContextMenu = null
        }
    };
    na.Object.defineProperties(Zg.prototype, {
        currentContextMenu: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                !F || null === a || a instanceof Xe || a instanceof gf || v("ContextMenuTool.currentContextMenu must be an Adornment or HTMLInfo.");
                this.l = a;
                this.Mu = a instanceof Xe ? a.adornedPart : null
            }
        }, defaultTouchContextMenu: {
            configurable: !0, get: function () {
                !1 === eh && null === ah && ih && $g(this);
                return ah
            }, set: function (a) {
                !F || null === a || a instanceof Xe || a instanceof gf || v("ContextMenuTool.defaultTouchContextMenu must be an Adornment or HTMLInfo.");
                null === a && (eh = !0);
                ah = a
            }
        }, currentObject: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                null !== a && w(a, N, Zg, "currentObject");
                this.w = a
            }
        }, mouseDownPoint: {
            configurable: !0, get: function () {
                return this.Px
            }
        }
    });
    var ah = null, eh = !1, dh = null, ch = null;
    Zg.className = "ContextMenuTool";
    Sa("contextMenuTool", function () {
        return this.findTool("ContextMenu")
    }, function (a) {
        this.eb("ContextMenu", a, this.mouseUpTools)
    });

    function jh() {
        0 < arguments.length && Ba(jh);
        Se.call(this);
        this.name = "TextEditing";
        this.Jh = new kh;
        this.Pa = null;
        this.Oa = lh;
        this.fj = null;
        this.oa = mh;
        this.L = 1;
        this.W = !0;
        this.w = null;
        this.l = new gf;
        this.Ru = null;
        nh(this, this.l)
    }

    ma(jh, Se);

    function nh(a, b) {
        if (ih) {
            var c = ua("textarea");
            a.Ru = c;
            c.addEventListener("input", function () {
                if (null !== a.textBlock) {
                    var b = a.Zy(this.value);
                    this.style.width = 20 + b.measuredBounds.width * this.tB + "px";
                    this.rows = b.lineCount
                }
            }, !1);
            c.addEventListener("keydown", function (b) {
                if (null !== a.textBlock) {
                    var c = b.which;
                    13 === c ? (!1 === a.textBlock.isMultiline && b.preventDefault(), a.acceptText(oh)) : 9 === c ? (a.acceptText(ph), b.preventDefault()) : 27 === c && (a.doCancel(), null !== a.diagram && a.diagram.doFocus())
                }
            }, !1);
            c.addEventListener("focus",
                function () {
                    if (null !== a.currentTextEditor && a.state !== mh) {
                        var b = a.Ru;
                        a.oa === qh && (a.oa = rh);
                        "function" === typeof b.select && a.selectsTextOnActivate && (b.select(), b.setSelectionRange(0, 9999))
                    }
                }, !1);
            c.addEventListener("blur", function () {
                if (null !== a.currentTextEditor && a.state !== mh) {
                    var b = a.Ru;
                    "function" === typeof b.focus && b.focus();
                    "function" === typeof b.select && a.selectsTextOnActivate && (b.select(), b.setSelectionRange(0, 9999))
                }
            }, !1);
            b.valueFunction = function () {
                return c.value
            };
            b.mainElement = c;
            b.show = function (a,
                               b, f) {
                if (a instanceof kh && f instanceof jh) if (f.state === sh) c.style.border = "3px solid red", c.focus(); else {
                    var d = a.ja(Mc), e = b.position, k = b.scale, l = a.Mf() * k;
                    l < f.minimumEditorScale && (l = f.minimumEditorScale);
                    var m = a.naturalBounds.width * l + 6, n = a.naturalBounds.height * l + 2, p = (d.x - e.x) * k;
                    d = (d.y - e.y) * k;
                    c.value = a.text;
                    b.div.style.font = a.font;
                    c.style.position = "absolute";
                    c.style.zIndex = "100";
                    c.style.font = "inherit";
                    c.style.fontSize = 100 * l + "%";
                    c.style.lineHeight = "normal";
                    c.style.width = m + "px";
                    c.style.left = (p - m / 2 | 0) - 1 +
                        "px";
                    c.style.top = (d - n / 2 | 0) - 1 + "px";
                    c.style.textAlign = a.textAlign;
                    c.style.margin = "0";
                    c.style.padding = "1px";
                    c.style.border = "0";
                    c.style.outline = "none";
                    c.style.whiteSpace = "pre-wrap";
                    c.style.overflow = "hidden";
                    c.rows = a.lineCount;
                    c.tB = l;
                    c.className = "goTXarea";
                    b.div.appendChild(c);
                    c.focus();
                    f.selectsTextOnActivate && (c.select(), c.setSelectionRange(0, 9999))
                }
            };
            b.hide = function (a) {
                a.div.removeChild(c)
            }
        }
    }

    jh.prototype.canStart = function () {
        if (!this.isEnabled) return !1;
        var a = this.diagram;
        if (null === a || a.isReadOnly || th && th !== this && (th.acceptText(uh), th && th !== this) || !a.lastInput.left || this.isBeyondDragSize()) return !1;
        var b = a.ac(a.lastInput.documentPoint);
        if (!(null !== b && b instanceof kh && b.editable && b.part.canEdit())) return !1;
        b = b.part;
        return null === b || this.starting === lh && !b.isSelected || this.starting === vh && 2 > a.lastInput.clickCount ? !1 : !0
    };
    jh.prototype.doStart = function () {
        th = this;
        null !== this.textBlock && this.doActivate()
    };
    jh.prototype.doActivate = function () {
        if (!this.isActive) {
            var a = this.diagram;
            if (null !== a) {
                var b = this.textBlock;
                null === b && (b = a.ac(a.lastInput.documentPoint));
                if (null !== b && b instanceof kh && (this.textBlock = b, null !== b.part)) {
                    this.isActive = !0;
                    this.oa = qh;
                    var c = this.defaultTextEditor;
                    null !== b.textEditor && (c = b.textEditor);
                    this.Jh = this.textBlock.copy();
                    var d = new L(this.textBlock.ja(Fc), this.textBlock.ja(Rc));
                    a.Mw(d);
                    c.show(b, a, this);
                    this.currentTextEditor = c
                }
            }
        }
    };
    jh.prototype.doCancel = function () {
        this.stopTool()
    };
    jh.prototype.doMouseUp = function () {
        this.canStart() && this.doActivate()
    };
    jh.prototype.doMouseDown = function () {
        this.isActive && this.acceptText(uh)
    };
    jh.prototype.acceptText = function (a) {
        switch (a) {
            case uh:
                if (this.oa === wh) this.currentTextEditor instanceof HTMLElement && this.currentTextEditor.focus(); else if (this.oa === qh || this.oa === sh || this.oa === rh) this.oa = xh, yh(this);
                break;
            case zh:
            case oh:
            case ph:
                if (oh !== a || !0 !== this.textBlock.isMultiline) if (this.oa === qh || this.oa === sh || this.oa === rh) this.oa = xh, yh(this)
        }
    };

    function yh(a) {
        var b = a.textBlock, c = a.diagram, d = a.currentTextEditor;
        if (null !== b && null !== d) {
            var e = b.text, f = "";
            null !== d.valueFunction && (f = d.valueFunction());
            a.isValidText(b, e, f) ? (a.Ca(a.name), a.oa = wh, a.transactionResult = a.name, b.text = f, a.doSuccess(e, f), null !== c && c.U("TextEdited", b, e), a.Wg(), a.stopTool(), null !== c && c.doFocus()) : (a.oa = sh, a.doError(e, f), d.show(b, c, a))
        }
    }

    jh.prototype.doError = function (a, b) {
        var c = this.textBlock;
        null !== c.errorFunction && c.errorFunction(this, a, b)
    };
    jh.prototype.doSuccess = function (a, b) {
        var c = this.textBlock;
        null !== c.textEdited && c.textEdited(c, a, b)
    };
    jh.prototype.doDeactivate = function () {
        var a = this.diagram;
        null !== a && (this.oa = mh, this.textBlock = null, null !== this.currentTextEditor && this.currentTextEditor.hide(a, this), this.isActive = !1)
    };
    jh.prototype.doStop = function () {
        th = null
    };
    jh.prototype.isValidText = function (a, b, c) {
        w(a, kh, jh, "isValidText:textblock");
        var d = this.textValidation;
        if (null !== d && !d(a, b, c)) return !1;
        d = a.textValidation;
        return null === d || d(a, b, c) ? !0 : !1
    };
    jh.prototype.Zy = function (a) {
        var b = this.Jh;
        b.text = a;
        b.measure(this.textBlock.Ni, Infinity);
        return b
    };
    na.Object.defineProperties(jh.prototype, {
        textBlock: {
            configurable: !0, get: function () {
                return this.Pa
            }, set: function (a) {
                null !== a && w(a, kh, jh, "textBlock");
                this.Pa = a
            }
        }, currentTextEditor: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                this.w = a
            }
        }, defaultTextEditor: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                !F || a instanceof gf || v("TextEditingTool.defaultTextEditor must be an HTMLInfo.");
                this.l = a
            }
        }, starting: {
            configurable: !0,
            get: function () {
                return this.Oa
            }, set: function (a) {
                ib(a, jh, jh, "starting");
                this.Oa = a
            }
        }, textValidation: {
            configurable: !0, get: function () {
                return this.fj
            }, set: function (a) {
                null !== a && A(a, "function", jh, "textValidation");
                this.fj = a
            }
        }, minimumEditorScale: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                null !== a && A(a, "number", jh, "minimumEditorScale");
                this.L = a
            }
        }, selectsTextOnActivate: {
            configurable: !0, get: function () {
                return this.W
            }, set: function (a) {
                null !== a && A(a,
                    "boolean", jh, "selectsTextOnActivate");
                this.W = a
            }
        }, state: {
            configurable: !0, get: function () {
                return this.oa
            }, set: function (a) {
                this.oa !== a && (ib(a, jh, jh, "starting"), this.oa = a)
            }
        }
    });
    jh.prototype.measureTemporaryTextBlock = jh.prototype.Zy;
    var zh = new E(jh, "LostFocus", 0), uh = new E(jh, "MouseDown", 1), ph = new E(jh, "Tab", 2),
        oh = new E(jh, "Enter", 3), Ah = new E(jh, "SingleClick", 0), lh = new E(jh, "SingleClickSelected", 1),
        vh = new E(jh, "DoubleClick", 2), mh = new E(jh, "StateNone", 0), qh = new E(jh, "StateActive", 1),
        rh = new E(jh, "StateEditing", 2), xh = new E(jh, "StateValidating", 3), sh = new E(jh, "StateInvalid", 4),
        wh = new E(jh, "StateValidated", 5), th = null;
    jh.className = "TextEditingTool";
    jh.LostFocus = zh;
    jh.MouseDown = uh;
    jh.Tab = ph;
    jh.Enter = oh;
    jh.SingleClick = Ah;
    jh.SingleClickSelected = lh;
    jh.DoubleClick = vh;
    jh.StateNone = mh;
    jh.StateActive = qh;
    jh.StateEditing = rh;
    jh.StateValidating = xh;
    jh.StateInvalid = sh;
    jh.StateValidated = wh;
    Sa("textEditingTool", function () {
        return this.findTool("TextEditing")
    }, function (a) {
        this.eb("TextEditing", a, this.mouseUpTools)
    });

    function Bh() {
        Ch || (Dh(), Ch = !0);
        this.B = Te;
        this.Ll = this.rf = this.yc = this.Cs = this.pc = !1;
        this.ey = !0;
        this.Ml = Eh;
        this.Dn = !1;
        this.Ii = this.qd = !0;
        this.kh = 600;
        this.Bx = this.by = !1;
        this.af = new I;
        this.Rd = new Fh;
        this.Rd.ad = this;
        this.gl = new I;
        this.Ev = new I;
        this.zt = new I
    }

    Bh.prototype.ie = function (a) {
        this.B = a
    };
    Bh.prototype.canStart = function () {
        return !0
    };

    function Gh(a, b) {
        Hh(a, b) && (a.rf = !0)
    }

    function Hh(a, b) {
        if (!a.qd || !a.canStart(b)) return !1;
        a.af.add(b);
        a.defaultAnimation.isAnimating && a.Xc();
        return a.yc = !0
    }

    function Ih(a) {
        if (a.qd && a.yc) {
            var b = a.Rd, c = a.B, d = a.af.contains("Model");
            d && (a.Ll = !0, a.Ml === Eh ? (b.isViewportUnconstrained = !0, b.sc.clear(), b.add(c, "position", c.position.copy().offset(0, -200), c.position), b.add(c, "opacity", 0, 1)) : a.Ml === Jh && b.sc.clear(), a.ey = a.Ml === Kh && c.ft.A(c.ra) ? !0 : !1, c.U("InitialAnimationStarting", a));
            d && !a.Ii || 0 === b.sc.count ? (a.af.clear(), a.yc = !1, a.rf = !1, b.sc.clear(), Lh(b, c), a.Ll = !1, c.P()) : (a.af.clear(), c.Ne = !1, d = b.sc.get(c), c.autoScale !== Mh && null !== d && (delete d.start.scale, delete d.end.scale),
                qa.requestAnimationFrame(function () {
                    !1 === a.yc || b.pc || (c.Te("temporaryPixelRatio") && nf(c), Yh(c), a.yc = !1, a.rf = !1, b.start(), Zh(a), c.Ua(), $h(b, 0), Tf(c, !0), ai(a), c.U("AnimationStarting", a))
                }))
        }
    }

    function bi(a, b, c, d) {
        b instanceof S && (null !== b.fromNode || null !== b.toNode) || a.Rd.add(b, "position", c, d, !1)
    }

    t = Bh.prototype;
    t.nu = function (a) {
        return this.Rd.nu(a)
    };
    t.qw = function (a) {
        return this.Rd.qw(a)
    };

    function ci(a, b) {
        function c() {
            0 < e.zt.count && (d.addAll(e.zt), e.zt.clear(), e.pc = !0);
            if (!1 !== e.pc && 0 !== d.count) {
                e.Ev.addAll(d);
                for (var a = e.Ev.iterator; a.next();) {
                    var b = a.value;
                    if (!1 !== b.pc) {
                        a:if (0 < b.Am.count) var h = !0; else {
                            for (h = b.sc.iterator; h.next();) {
                                var k = h.key;
                                if (k instanceof N && null !== k.diagram || k instanceof Q) {
                                    h = !0;
                                    break a
                                }
                            }
                            h = !1
                        }
                        h ? di(b, !1) : b.Ul = !0
                    }
                }
                e.Ev.clear();
                Zh(e);
                Tf(e.B);
                ai(e);
                qa.requestAnimationFrame(c)
            }
        }

        var d = a.gl, e = a;
        a.pc ? a.zt.add(b) : (a.pc = !0, d.add(b), qa.requestAnimationFrame(function () {
            c()
        }))
    }

    function ei(a) {
        for (a = a.gl.iterator; a.next();) a.value.Ul = !1
    }

    function Zh(a) {
        if (!a.Cs) {
            var b = a.B;
            a.by = b.skipsUndoManager;
            a.Bx = b.skipsModelSourceBindings;
            b.skipsUndoManager = !0;
            b.skipsModelSourceBindings = !0;
            a.Cs = !0
        }
    }

    function ai(a) {
        var b = a.B;
        b.skipsUndoManager = a.by;
        b.skipsModelSourceBindings = a.Bx;
        a.Cs = !1
    }

    t.Xc = function (a) {
        var b = this.Rd;
        !0 === this.yc && (this.Ll = this.rf = this.yc = !1, this.af.clear(), 0 < b.sc.count && this.B.Kb());
        if (this.pc) {
            if (b.Im(!0), b.sc.clear(), Lh(b, null), !0 === a) for (a = this.gl.ta(), b = 0; b < a.length; b++) a[b].Im(!0)
        } else b.sc.clear(), Lh(b, this.B)
    };
    t.Im = function (a) {
        a === this.defaultAnimation && this.defaultAnimation.sc.clear();
        this.gl.remove(a);
        0 === this.gl.count && (this.pc = !1, this.B.Kb());
        a === this.defaultAnimation && (this.defaultAnimation.sc.clear(), this.B.U("AnimationFinished", this))
    };
    t.wk = function (a, b) {
        this.rf && (this.af.contains("Expand Tree") || this.af.contains("Expand SubGraph")) && this.Rd.wk(a, b)
    };
    t.uk = function (a, b) {
        this.rf && (this.af.contains("Collapse Tree") || this.af.contains("Collapse SubGraph")) && (this.Rd.uk(a, b), fi(this.Rd, b, "position", b.position, b.position))
    };

    function gi(a, b, c) {
        a.rf && !b.A(c) && (a.B.Aj || (b = c.copy()), fi(a.Rd, a.B, "position", b, c))
    }

    function hi(a, b, c, d, e) {
        null === a && (a = "rgba(0,0,0,0)");
        null === b && (b = "rgba(0,0,0,0)");
        ii(a);
        ji();
        var f = ki.l, g = ki.L, h = ki.w;
        a = ki.W;
        ii(b);
        ji();
        var k = ki.L, l = ki.w;
        b = ki.W;
        f = e(c, f, ki.l - f, d);
        g = e(c, g, k - g, d);
        h = e(c, h, l - h, d);
        c = e(c, a, b - a, d);
        return "hsla(" + f + ", " + g + "%, " + h + "%, " + c + ")"
    }

    function Dh() {
        var a = new Db;
        a.add("position:diagram", function (a, c, d, e, f, g) {
            a.position = new J(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g))
        });
        a.add("position", function (a, c, d, e, f, g) {
            f < g ? a.sr(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g), !1) : a.position = new J(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g))
        });
        a.add("location", function (a, c, d, e, f, g) {
            f < g ? a.sr(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g), !0) : a.location = new J(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g))
        });
        a.add("position:placeholder", function (a, c, d, e, f, g) {
            f < g ? a.sr(e(f, c.x, d.x - c.x,
                g), e(f, c.y, d.y - c.y, g), !1) : a.position = new J(e(f, c.x, d.x - c.x, g), e(f, c.y, d.y - c.y, g))
        });
        a.add("position:node", function (a, c, d, e, f, g) {
            var b = a.actualBounds, k = d.actualBounds;
            d = k.x + k.width / 2 - b.width / 2;
            b = k.y + k.height / 2 - b.height / 2;
            f < g ? a.sr(e(f, c.x, d - c.x, g), e(f, c.y, b - c.y, g), !1) : a.position = new J(e(f, c.x, d - c.x, g), e(f, c.y, b - c.y, g))
        });
        a.add("desiredSize", function (a, c, d, e, f, g) {
            a.desiredSize = new L(e(f, c.width, d.width - c.width, g), e(f, c.height, d.height - c.height, g))
        });
        a.add("width", function (a, c, d, e, f, g) {
            a.width = e(f, c,
                d - c, g)
        });
        a.add("height", function (a, c, d, e, f, g) {
            a.height = e(f, c, d - c, g)
        });
        a.add("fill", function (a, c, d, e, f, g) {
            a.fill = hi(c, d, f, g, e)
        });
        a.add("stroke", function (a, c, d, e, f, g) {
            a.stroke = hi(c, d, f, g, e)
        });
        a.add("strokeWidth", function (a, c, d, e, f, g) {
            a.strokeWidth = e(f, c, d - c, g)
        });
        a.add("strokeDashOffset", function (a, c, d, e, f, g) {
            a.strokeDashOffset = e(f, c, d - c, g)
        });
        a.add("background", function (a, c, d, e, f, g) {
            a.background = hi(c, d, f, g, e)
        });
        a.add("areaBackground", function (a, c, d, e, f, g) {
            a.areaBackground = hi(c, d, f, g, e)
        });
        a.add("opacity",
            function (a, c, d, e, f, g) {
                a.opacity = e(f, c, d - c, g)
            });
        a.add("scale", function (a, c, d, e, f, g) {
            a.scale = e(f, c, d - c, g)
        });
        a.add("angle", function (a, c, d, e, f, g) {
            a.angle = e(f, c, d - c, g)
        });
        li = a
    }

    na.Object.defineProperties(Bh.prototype, {
        animationReasons: {
            configurable: !0, get: function () {
                return this.af
            }
        }, isEnabled: {
            configurable: !0, get: function () {
                return this.qd
            }, set: function (a) {
                A(a, "boolean", Bh, "isEnabled");
                this.qd = a
            }
        }, duration: {
            configurable: !0, get: function () {
                return this.kh
            }, set: function (a) {
                A(a, "number", Bh, "duration");
                1 > a && za(a, ">= 1", Bh, "duration");
                this.kh = a
            }
        }, isAnimating: {
            configurable: !0, get: function () {
                return this.pc
            }
        }, isTicking: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Cs
            }
        }, isInitial: {
            configurable: !0, get: function () {
                return this.Ii
            }, set: function (a) {
                A(a, "boolean", Bh, "isInitial");
                this.Ii = a
            }
        }, defaultAnimation: {
            configurable: !0, get: function () {
                return this.Rd
            }
        }, activeAnimations: {
            configurable: !0, get: function () {
                return this.gl
            }
        }, initialAnimationStyle: {
            configurable: !0, get: function () {
                return this.Ml
            }, set: function (a) {
                F && ib(a, Bh, Bh, "initialAnimationStyle");
                this.Ml = a
            }
        }
    });
    Bh.prototype.stopAnimation = Bh.prototype.Xc;
    var li = null, Ch = !1, Eh = new E(Bh, "Default", 1), Kh = new E(Bh, "AnimateLocations", 2),
        Jh = new E(Bh, "None", 3);
    Bh.className = "AnimationManager";
    Bh.defineAnimationEffect = function (a, b) {
        Ch || (Dh(), Ch = !0);
        li.add(a, b)
    };
    Bh.Default = Eh;
    Bh.AnimateLocations = Kh;
    Bh.None = Jh;

    function Fh() {
        this.Iv = this.ay = this.ad = this.B = null;
        this.Ul = this.pc = this.l = !1;
        this.ko = this.Fd = 0;
        this.Wr = this.Uu = mi;
        this.Tl = this.Mp = !1;
        this.yv = 1;
        this.wv = 0;
        this.xd = this.kh = NaN;
        this.Gx = 0;
        this.lo = null;
        this.w = Ob;
        this.sc = new Db;
        this.sv = new Db;
        this.Am = new I;
        this.tv = new I;
        this.Cx = ni
    }

    Fh.prototype.suspend = function () {
        this.Ul = !0
    };
    Fh.prototype.advanceTo = function (a, b) {
        b && (this.Ul = !1);
        this.Mp && a >= this.xd && (this.Tl = !0, a -= this.xd);
        this.Gx = a;
        di(this, !0);
        Zh(this.ad);
        Tf(this.B);
        ai(this.ad);
        this.B.We()
    };

    function Lh(a, b) {
        a.sv.clear();
        a.Tl = !1;
        a.wv = 0;
        a.xd = NaN;
        0 < a.Am.count && a.Am.clear();
        0 < a.tv.count && a.tv.clear();
        if (null !== b) for (a = b.links; a.next();) a.value.Dg = null
    }

    t = Fh.prototype;
    t.start = function () {
        if (0 !== this.sc.count && !this.pc) {
            for (var a = this.B, b = this.sc.iterator; b.next();) {
                var c = b.value.end, d = b.key;
                if (c["position:placeholder"]) {
                    var e = d.findVisibleNode();
                    if (e instanceof Kf && null !== e.placeholder) {
                        var f = e.placeholder;
                        e = f.ja(Fc);
                        f = f.padding;
                        e.x += f.left;
                        e.y += f.top;
                        c["position:placeholder"] = e
                    }
                }
                null === a && (d instanceof Q ? a = d : d instanceof N && (a = d.diagram))
            }
            null !== a && (this.B = a, b = this.ad = a.animationManager, !1 !== b.isEnabled && (this.xd = isNaN(this.kh) ? b.duration : this.kh, this.Wr = this.Uu,
            b.Ll && b.Ml === Eh && this === b.defaultAnimation && (this.Wr = oi, this.xd = isNaN(this.kh) ? 600 === b.duration ? 900 : b.duration : this.kh), this.Cx = a.scrollMode, this.isViewportUnconstrained && (a.cj = pi), Zh(b), this.Am.each(function (b) {
                b.data = null;
                a.add(b)
            }), ai(b), this.pc = !0, this.Fd = +new Date, this.ko = this.Fd + this.xd, ci(b, this)))
        }
    };
    t.Hz = function (a, b) {
        a.Tc() && (F && (void 0 === b && v("addTemporaryPart: Required Diagram argument missing"), a.diagram === b && v("addTemporaryPart: Part already in Diagram, did you mean to pass in a copy?"), null !== this.B && this.B !== b && v("addTemporaryPart: A different Diagram is already associated with this Animation: " + this.B.toString())), this.Am.add(a), this.B = b)
    };
    t.add = function (a, b, c, d, e) {
        "position" === b && c.A(d) || (null === this.B && (a instanceof Q ? this.B = a : a instanceof N && null !== a.diagram && (this.B = a.diagram)), a instanceof T && !a.isAnimated || fi(this, a, b, c, d, e))
    };

    function fi(a, b, c, d, e, f) {
        var g = a.sc;
        b instanceof Q && "position" === c && (c = "position:diagram");
        if (g.contains(b)) {
            var h = g.K(b);
            var k = h.start;
            var l = h.end;
            void 0 === k[c] && (k[c] = qi(d));
            l[c] = qi(e)
        } else k = {}, l = {}, k[c] = qi(d), l[c] = qi(e), h = k.position, b instanceof N && h instanceof J && !h.o() && b.diagram.animationManager.af.contains("Expand SubGraph") && h.assign(l.position), h = new ri(k, l, f), g.add(b, h);
        g = k[c];
        g instanceof J && !g.o() && g.assign(a.w);
        f && 0 === c.indexOf("position:") && b instanceof T ? h.bw.location = qi(b.location) :
            f && (h.bw[c] = qi(d))
    }

    function qi(a) {
        return a instanceof J ? a.copy() : a instanceof Hb ? a.copy() : a
    }

    t.nu = function (a) {
        if (!this.pc) return !1;
        a = this.sc.K(a);
        return null !== a && a.Cw
    };
    t.qw = function (a) {
        if (!this.pc) return !1;
        a = this.sc.K(a);
        return null !== a && (a.start.position || a.start.location)
    };

    function di(a, b) {
        if (!a.Ul || b) {
            var c = a.ad;
            if (!1 !== a.pc) {
                var d = +new Date, e = d > a.ko ? a.xd : d - a.Fd;
                b && (e = a.Gx, e < a.xd ? (a.Fd = +new Date - e, a.ko = a.Fd + a.xd) : e = a.xd);
                Zh(c);
                $h(a, e);
                Tf(a.B, !0);
                ai(c);
                d > a.ko && (a.Mp && !a.Tl ? (a.Fd = +new Date, a.ko = a.Fd + a.xd, a.Tl = !0) : a.Im(!1))
            }
        }
    }

    function $h(a, b) {
        for (var c = a.xd, d = a.sc.iterator, e = a.Tl; d.next();) {
            var f = d.key;
            if (!(f instanceof N && null === f.diagram)) {
                var g = d.value, h = e ? g.end : g.start;
                g = e ? g.start : g.end;
                var k = li, l;
                for (l in g) "position" === l && (g["position:placeholder"] || g["position:node"]) || null === k.get(l) || k.get(l)(f, h[l], g[l], a.Wr, b, c, a)
            }
        }
    }

    t.stop = function () {
        this.pc && this.Im(!0)
    };
    t.Im = function (a) {
        null !== this.Iv && this.Iv.Tp.remove(this.ay);
        if (this.pc) {
            var b = this.B, c = this.ad;
            this.Ul = this.pc = c.Ll = !1;
            Zh(c);
            for (var d = this.sc, e = this.Am.iterator; e.next();) b.remove(e.value);
            for (e = this.tv.iterator; e.next();) e.value.v();
            e = this.Mp;
            d = d.iterator;
            for (var f = li; d.next();) {
                var g = d.key, h = d.value, k = e ? h.end : h.start, l = e ? h.start : h.end, m = h.bw, n;
                for (n in l) if (null !== f.get(n)) {
                    var p = n;
                    !h.Uv || "position:node" !== p && "position:placeholder" !== p || (p = "position");
                    f.get(p)(g, k[n], void 0 !== m[n] ? m[n] : h.Uv ? k[n] :
                        l[n], this.Wr, this.xd, this.xd, this)
                }
                h.Uv && void 0 !== m.location && g instanceof T && (g.location = m.location);
                h.Cw && g instanceof T && g.Vb(!1)
            }
            if (c.defaultAnimation === this) for (n = this.B.links; n.next();) e = n.value, null === e.Dg ? (d = e.path, null !== d && (e.nd = !1, e.v(), d.v())) : (e.points = e.Dg, e.Dg = null);
            b.iu.clear();
            Af(b, !1);
            b.Ua();
            b.P();
            Tf(b, !0);
            this.isViewportUnconstrained && (b.scrollMode = this.Cx);
            ai(c);
            this.wv++;
            !a && this.yv > this.wv ? (this.Tl = !1, this.start()) : (this.lo && this.lo(this), Lh(this, null), c.Im(this), b.Kb())
        }
    };
    t.wk = function (a, b) {
        var c = b.actualBounds, d = null;
        b instanceof Kf && (d = b.placeholder);
        null !== d ? (c = d.ja(Fc), d = d.padding, c.x += d.left, c.y += d.top, this.add(a, "position", c, a.position, !1)) : this.add(a, "position", new J(c.x + c.width / 2, c.y + c.height / 2), a.position, !1);
        this.add(a, "scale", .01, a.scale, !1);
        if (a instanceof Kf) for (a = a.memberParts; a.next();) d = a.value, d instanceof V && this.wk(d, b)
    };
    t.uk = function (a, b) {
        if (a.isVisible()) {
            var c = null;
            b instanceof Kf && (c = b.placeholder);
            null !== c ? this.add(a, "position:placeholder", a.position, c, !0) : this.add(a, "position:node", a.position, b, !0);
            this.add(a, "scale", a.scale, .01, !0);
            c = this.sc;
            c.contains(a) && (c.K(a).Cw = !0);
            if (a instanceof Kf) for (a = a.memberParts; a.next();) c = a.value, c instanceof V && this.uk(c, b)
        }
    };
    t.HA = function (a) {
        var b = this.sv.get(a);
        null === b && (b = {}, this.sv.add(a, b));
        return b
    };
    na.Object.defineProperties(Fh.prototype, {
        duration: {
            configurable: !0, get: function () {
                return this.kh
            }, set: function (a) {
                A(a, "number", Fh, "duration");
                1 > a && za(a, ">= 1", Fh, "duration");
                this.kh = a
            }
        }, reversible: {
            configurable: !0, get: function () {
                return this.Mp
            }, set: function (a) {
                this.Mp = a
            }
        }, runCount: {
            configurable: !0, get: function () {
                return this.yv
            }, set: function (a) {
                0 < a ? this.yv = a : v("Animation.runCount value must be a positive integer.")
            }
        }, finished: {
            configurable: !0,
            get: function () {
                return this.lo
            }, set: function (a) {
                this.lo !== a && (null !== a && A(a, "function", Q, "click"), this.lo = a)
            }
        }, easing: {
            configurable: !0, get: function () {
                return this.Uu
            }, set: function (a) {
                this.Uu = a
            }
        }, isViewportUnconstrained: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                this.l = a
            }
        }, isAnimating: {
            configurable: !0, get: function () {
                return this.pc
            }
        }
    });
    Fh.prototype.getTemporaryState = Fh.prototype.HA;
    Fh.prototype.stop = Fh.prototype.stop;
    Fh.prototype.add = Fh.prototype.add;
    Fh.prototype.addTemporaryPart = Fh.prototype.Hz;

    function mi(a, b, c, d) {
        a /= d / 2;
        return 1 > a ? c / 2 * a * a + b : -c / 2 * (--a * (a - 2) - 1) + b
    }

    function oi(a, b, c, d) {
        return a === d ? b + c : c * (-Math.pow(2, -10 * a / d) + 1) + b
    }

    Fh.className = "Animation";
    Fh.EaseLinear = function (a, b, c, d) {
        return c * a / d + b
    };
    Fh.EaseInOutQuad = mi;
    Fh.EaseInQuad = function (a, b, c, d) {
        return c * (a /= d) * a + b
    };
    Fh.EaseOutQuad = function (a, b, c, d) {
        return -c * (a /= d) * (a - 2) + b
    };
    Fh.EaseInExpo = function (a, b, c, d) {
        return 0 === a ? b : c * Math.pow(2, 10 * (a / d - 1)) + b
    };
    Fh.EaseOutExpo = oi;

    function ri(a, b, c) {
        this.start = a;
        this.end = b;
        this.bw = {};
        this.Uv = c;
        this.Cw = !1
    }

    ri.className = "AnimationState";

    function si(a, b, c) {
        this.td = null;
        this.tf = a;
        this.mq = c || ti;
        this.ll = null;
        void 0 !== b && (this.ll = b, void 0 === c && (this.mq = ui))
    }

    si.prototype.copy = function () {
        var a = new si(this.tf);
        a.mq = this.mq;
        var b = this.ll;
        if (null !== b) {
            var c = {};
            void 0 !== b.duration && (c.Cy = b.duration);
            void 0 !== b.finished && (c.Cy = b.finished);
            void 0 !== b.easing && (c.Cy = b.easing);
            a.ll = c
        }
        return a
    };

    function vi(a, b) {
        a = a.ll;
        null !== a && (a.duration && (b.duration = a.duration), a.finished && (b.finished = a.finished), a.easing && (b.easing = a.easing))
    }

    na.Object.defineProperties(si.prototype, {
        propertyName: {
            configurable: !0, get: function () {
                return this.tf
            }, set: function (a) {
                this.tf = a
            }
        }, animationSettings: {
            configurable: !0, get: function () {
                return this.ll
            }, set: function (a) {
                this.ll = a
            }
        }, startCondition: {
            configurable: !0, get: function () {
                return this.mq
            }, set: function (a) {
                F && ib(a, si, si, "startCondition");
                this.mq = a
            }
        }
    });
    var ti = new E(si, "Default", 1), ui = new E(si, "Immediate", 2), wi = new E(si, "Bundled", 3);
    si.className = "AnimationTrigger";
    si.Default = ti;
    si.Immediate = ui;
    si.Bundled = wi;

    function xi() {
        0 < arguments.length && Ba(xi);
        gb(this);
        this.B = null;
        this.Ia = new H;
        this.Wa = "";
        this.nb = 1;
        this.w = !1;
        this.l = this.Yi = this.L = this.ti = this.si = this.ri = this.pi = this.ni = this.oi = this.mi = this.vi = this.li = this.ui = this.ki = this.ji = !0;
        this.zp = []
    }

    t = xi.prototype;
    t.clear = function () {
        this.Ia.clear();
        this.zp.length = 0
    };
    t.ie = function (a) {
        this.B = a
    };
    t.toString = function (a) {
        void 0 === a && (a = 0);
        var b = 'Layer "' + this.name + '"';
        if (0 >= a) return b;
        for (var c = 0, d = 0, e = 0, f = 0, g = 0, h = this.Ia.iterator; h.next();) {
            var k = h.value;
            k instanceof Kf ? e++ : k instanceof V ? d++ : k instanceof S ? f++ : k instanceof Xe ? g++ : c++
        }
        h = "";
        0 < c && (h += c + " Parts ");
        0 < d && (h += d + " Nodes ");
        0 < e && (h += e + " Groups ");
        0 < f && (h += f + " Links ");
        0 < g && (h += g + " Adornments ");
        if (1 < a) for (a = this.Ia.iterator; a.next();) c = a.value, h += "\n    " + c.toString(), d = c.data, null !== d && rb(d) && (h += " #" + rb(d)), c instanceof V ? h += " " +
            Qa(d) : c instanceof S && (h += " " + Qa(c.fromNode) + " " + Qa(c.toNode));
        return b + " " + this.Ia.count + ": " + h
    };
    t.ac = function (a, b, c) {
        void 0 === b && (b = null);
        void 0 === c && (c = null);
        if (!1 === this.Yi) return null;
        F && !a.o() && v("findObjectAt: Point must have a real value, not: " + a.toString());
        var d = !1;
        null !== this.diagram && this.diagram.viewportBounds.ca(a) && (d = !0);
        for (var e = J.alloc(), f = this.Ia.j, g = f.length; g--;) {
            var h = f[g];
            if ((!0 !== d || !1 !== Lg(h)) && h.isVisible() && (e.assign(a), Jb(e, h.Hd), h = h.ac(e, b, c), null !== h && (null !== b && (h = b(h)), null !== h && (null === c || c(h))))) return J.free(e), h
        }
        J.free(e);
        return null
    };
    t.rj = function (a, b, c, d) {
        void 0 === b && (b = null);
        void 0 === c && (c = null);
        d instanceof H || d instanceof I || (d = new I);
        if (!1 === this.Yi) return d;
        F && !a.o() && v("findObjectsAt: Point must have a real value, not: " + a.toString());
        var e = !1;
        null !== this.diagram && this.diagram.viewportBounds.ca(a) && (e = !0);
        for (var f = J.alloc(), g = this.Ia.j, h = g.length; h--;) {
            var k = g[h];
            if ((!0 !== e || !1 !== Lg(k)) && k.isVisible()) {
                f.assign(a);
                Jb(f, k.Hd);
                var l = k;
                k.rj(f, b, c, d) && (null !== b && (l = b(l)), null === l || null !== c && !c(l) || d.add(l))
            }
        }
        J.free(f);
        return d
    };
    t.Lf = function (a, b, c, d, e) {
        void 0 === b && (b = null);
        void 0 === c && (c = null);
        void 0 === d && (d = !1);
        e instanceof H || e instanceof I || (e = new I);
        if (!1 === this.Yi) return e;
        F && !a.o() && v("findObjectsIn: Rect must have a real value, not: " + a.toString());
        var f = !1;
        null !== this.diagram && this.diagram.viewportBounds.Pe(a) && (f = !0);
        for (var g = this.Ia.j, h = g.length; h--;) {
            var k = g[h];
            if ((!0 !== f || !1 !== Lg(k)) && k.isVisible()) {
                var l = k;
                k.Lf(a, b, c, d, e) && (null !== b && (l = b(l)), null === l || null !== c && !c(l) || e.add(l))
            }
        }
        return e
    };
    t.gw = function (a, b, c, d, e, f, g) {
        if (!1 === this.Yi) return e;
        for (var h = this.Ia.j, k = h.length; k--;) {
            var l = h[k];
            if ((!0 !== g || !1 !== Lg(l)) && f(l) && l.isVisible()) {
                var m = l;
                l.Lf(a, b, c, d, e) && (null !== b && (m = b(m)), null === m || null !== c && !c(m) || e.add(m))
            }
        }
        return e
    };
    t.Rg = function (a, b, c, d, e, f) {
        void 0 === c && (c = null);
        void 0 === d && (d = null);
        void 0 === e && (e = !0);
        if (!1 !== e && !0 !== e) {
            if (e instanceof H || e instanceof I) f = e;
            e = !0
        }
        f instanceof H || f instanceof I || (f = new I);
        if (!1 === this.Yi) return f;
        F && !a.o() && v("findObjectsNear: Point must have a real value, not: " + a.toString());
        var g = !1;
        null !== this.diagram && this.diagram.viewportBounds.ca(a) && (g = !0);
        for (var h = J.alloc(), k = J.alloc(), l = this.Ia.j, m = l.length; m--;) {
            var n = l[m];
            if ((!0 !== g || !1 !== Lg(n)) && n.isVisible()) {
                h.assign(a);
                Jb(h, n.Hd);
                k.h(a.x + b, a.y);
                Jb(k, n.Hd);
                var p = n;
                n.Rg(h, k, c, d, e, f) && (null !== c && (p = c(p)), null === p || null !== d && !d(p) || f.add(p))
            }
        }
        J.free(h);
        J.free(k);
        return f
    };
    t.Od = function (a, b) {
        if (this.visible) {
            var c = this.Ia.j, d = c.length;
            if (0 !== d) {
                a = Ma();
                for (var e = Ma(), f = 0; f < d; f++) {
                    var g = c[f];
                    g.Nx = f;
                    if (g instanceof S) {
                        if (!1 === g.nd) continue
                    } else if (g instanceof Xe && null !== g.adornedPart) continue;
                    lc(g.actualBounds, b) ? (g.Od(!0), a.push(g)) : (g.Od(!1), null !== g.adornments && 0 < g.adornments.count && e.push(g))
                }
                for (b = 0; b < a.length; b++) for (c = a[b], yi(c), c = c.adornments; c.next();) d = c.value, d.measure(Infinity, Infinity), d.arrange(), d.Od(!0);
                for (b = 0; b < e.length; b++) yi(e[b]);
                Oa(a);
                Oa(e)
            }
        }
    };

    function zi(a, b) {
        var c = 1;
        1 !== a.nb && (c = b.globalAlpha, b.globalAlpha = c * a.nb);
        return c
    }

    t.ic = function (a, b, c) {
        if (this.visible && 0 !== this.nb && (void 0 === c && (c = !0), c || !this.isTemporary)) {
            c = this.Ia.j;
            var d = c.length;
            if (0 !== d) {
                var e = zi(this, a), f = this.zp;
                f.length = 0;
                for (var g = b.scale, h = L.alloc(), k = 0; k < d; k++) this.nj(a, c[k], b, f, g, h, !0);
                L.free(h);
                a.globalAlpha = e
            }
        }
    };
    t.nj = function (a, b, c, d, e, f, g) {
        if (!g || Lg(b)) {
            if (null !== d && b instanceof S && (b.isOrthogonal && d.push(b), !1 === b.nd)) return;
            g = !1;
            for (d = b.containingGroup; null !== d;) g ? null !== d.fb && f.Sy(d.fb) : null !== d.fb && (g = !0, f.assign(d.fb)), d = d.containingGroup;
            var h = b.actualBounds;
            d = !1;
            if (g && b.isVisible()) {
                if (!f.Sc(h)) return;
                d = !f.Pe(h)
            }
            d && (a.save(), a.beginPath(), a.rect(f.x, f.y, f.width, f.height), a.clip());
            h.width * e > c.ep || h.height * e > c.ep ? b.ic(a, c) : (e = b.actualBounds, f = b.naturalBounds, 0 === e.width || 0 === e.height || isNaN(e.x) ||
            isNaN(e.y) || !b.isVisible() || (c = b.transform, null !== b.areaBackground && (Ai(b, a, b.areaBackground, !0, !0, f, e), a.fillRect(e.x, e.y, e.width, e.height)), null === b.areaBackground && null === b.background && (Ai(b, a, "rgba(0,0,0,0.3)", !0, !1, f, e), a.fillRect(e.x, e.y, e.width, e.height)), null !== b.background && (a.transform(c.m11, c.m12, c.m21, c.m22, c.dx, c.dy), Ai(b, a, b.background, !0, !1, f, e), a.fillRect(0, 0, f.width / 2, f.height / 2), c.fu() || (b = 1 / (c.m11 * c.m22 - c.m12 * c.m21), a.transform(c.m22 * b, -c.m12 * b, -c.m21 * b, c.m11 * b, b * (c.m21 * c.dy - c.m22 *
                c.dx), b * (c.m12 * c.dx - c.m11 * c.dy))))));
            d && (a.restore(), a.Ac(!0))
        }
    };
    t.g = function (a, b, c, d, e) {
        var f = this.diagram;
        null !== f && f.ib(Le, a, this, b, c, d, e)
    };
    t.yj = function (a, b, c) {
        var d = this.Ia;
        b.Oi = this;
        if (a >= d.count) a = d.count; else if (d.M(a) === b) return -1;
        d.Bb(a, b);
        b.Vq(c);
        d = this.diagram;
        null !== d && (c ? d.P() : d.yj(b));
        Bi(this, a, b);
        return a
    };
    t.Rc = function (a, b, c) {
        if (!c && b.layer !== this && null !== b.layer) return b.layer.Rc(a, b, c);
        var d = this.Ia;
        if (0 > a || a >= d.length) {
            if (a = d.indexOf(b), 0 > a) return -1
        } else if (d.M(a) !== b && (a = d.indexOf(b), 0 > a)) return -1;
        b.Wq(c);
        d.jb(a);
        d = this.diagram;
        null !== d && (c ? d.P() : d.Rc(b));
        b.Oi = null;
        return a
    };

    function Bi(a, b, c) {
        b = Ci(a, b, c);
        if (c instanceof Kf && null !== c && isNaN(c.zOrder)) {
            if (0 !== c.memberParts.count) {
                for (var d = -1, e = a.Ia.j, f = e.length, g = 0; g < f; g++) {
                    var h = e[g];
                    if (h === c && (b = g, 0 <= d)) break;
                    if (0 > d && h.containingGroup === c && (d = g, 0 <= b)) break
                }
                !(0 > d) && d < b && (e = a.Ia, e.jb(b), e.Bb(d, c))
            }
            c = c.containingGroup;
            null !== c && Bi(a, -1, c)
        }
    }

    function Ci(a, b, c) {
        var d = c.zOrder;
        if (isNaN(d)) return b;
        a = a.Ia;
        var e = a.count;
        if (1 >= e) return b;
        0 > b && (b = a.indexOf(c));
        if (0 > b) return -1;
        for (var f = b - 1, g = NaN; 0 <= f;) {
            g = a.M(f).zOrder;
            if (!isNaN(g)) break;
            f--
        }
        for (var h = b + 1, k = NaN; h < e;) {
            k = a.M(h).zOrder;
            if (!isNaN(k)) break;
            h++
        }
        if (!isNaN(g) && g > d) for (; ;) {
            if (-1 === f || g <= d) {
                f++;
                if (f === b) break;
                a.jb(b);
                a.Bb(f, c);
                return f
            }
            for (g = NaN; 0 <= --f && (g = a.M(f).zOrder, isNaN(g));) ;
        } else if (!isNaN(k) && k < d) for (; ;) {
            if (h === e || k >= d) {
                h--;
                if (h === b) break;
                a.jb(b);
                a.Bb(h, c);
                return h
            }
            for (k = NaN; ++h <
            e && (k = a.M(h).zOrder, isNaN(k));) ;
        }
        return b
    }

    na.Object.defineProperties(xi.prototype, {
        parts: {
            configurable: !0, get: function () {
                return this.Ia.iterator
            }
        }, partsBackwards: {
            configurable: !0, get: function () {
                return this.Ia.iteratorBackwards
            }
        }, diagram: {
            configurable: !0, get: function () {
                return this.B
            }
        }, name: {
            configurable: !0, get: function () {
                return this.Wa
            }, set: function (a) {
                A(a, "string", xi, "name");
                var b = this.Wa;
                if (b !== a) {
                    var c = this.diagram;
                    if (null !== c) for ("" === b && v("Cannot rename default Layer to: " + a), c =
                        c.layers; c.next();) c.value.name === a && v("Layer.name is already present in this diagram: " + a);
                    this.Wa = a;
                    this.g("name", b, a);
                    for (a = this.Ia.iterator; a.next();) a.value.layerName = this.Wa
                }
            }
        }, opacity: {
            configurable: !0, get: function () {
                return this.nb
            }, set: function (a) {
                var b = this.nb;
                b !== a && (A(a, "number", xi, "opacity"), (0 > a || 1 < a) && za(a, "0 <= value <= 1", xi, "opacity"), this.nb = a, this.g("opacity", b, a), a = this.diagram, null !== a && a.P())
            }
        }, isTemporary: {
            configurable: !0, get: function () {
                return this.w
            },
            set: function (a) {
                var b = this.w;
                b !== a && (A(a, "boolean", xi, "isTemporary"), this.w = a, this.isInDocumentBounds = !1, this.g("isTemporary", b, a))
            }
        }, visible: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                var b = this.L;
                if (b !== a) {
                    A(a, "boolean", xi, "visible");
                    this.L = a;
                    this.g("visible", b, a);
                    for (b = this.Ia.iterator; b.next();) b.value.Vb(a);
                    a = this.diagram;
                    null !== a && a.P()
                }
            }
        }, pickable: {
            configurable: !0, get: function () {
                return this.Yi
            }, set: function (a) {
                var b = this.Yi;
                b !== a && (A(a, "boolean",
                    xi, "pickable"), this.Yi = a, this.g("pickable", b, a))
            }
        }, isInDocumentBounds: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                this.l !== a && (this.l = a, null !== this.diagram && this.diagram.Ua())
            }
        }, allowCopy: {
            configurable: !0, get: function () {
                return this.ji
            }, set: function (a) {
                var b = this.ji;
                b !== a && (A(a, "boolean", xi, "allowCopy"), this.ji = a, this.g("allowCopy", b, a))
            }
        }, allowDelete: {
            configurable: !0, get: function () {
                return this.ki
            }, set: function (a) {
                var b = this.ki;
                b !== a && (A(a,
                    "boolean", xi, "allowDelete"), this.ki = a, this.g("allowDelete", b, a))
            }
        }, allowTextEdit: {
            configurable: !0, get: function () {
                return this.ui
            }, set: function (a) {
                var b = this.ui;
                b !== a && (A(a, "boolean", xi, "allowTextEdit"), this.ui = a, this.g("allowTextEdit", b, a))
            }
        }, allowGroup: {
            configurable: !0, get: function () {
                return this.li
            }, set: function (a) {
                var b = this.li;
                b !== a && (A(a, "boolean", xi, "allowGroup"), this.li = a, this.g("allowGroup", b, a))
            }
        }, allowUngroup: {
            configurable: !0, get: function () {
                return this.vi
            },
            set: function (a) {
                var b = this.vi;
                b !== a && (A(a, "boolean", xi, "allowUngroup"), this.vi = a, this.g("allowUngroup", b, a))
            }
        }, allowLink: {
            configurable: !0, get: function () {
                return this.mi
            }, set: function (a) {
                var b = this.mi;
                b !== a && (A(a, "boolean", xi, "allowLink"), this.mi = a, this.g("allowLink", b, a))
            }
        }, allowRelink: {
            configurable: !0, get: function () {
                return this.oi
            }, set: function (a) {
                var b = this.oi;
                b !== a && (A(a, "boolean", xi, "allowRelink"), this.oi = a, this.g("allowRelink", b, a))
            }
        }, allowMove: {
            configurable: !0,
            get: function () {
                return this.ni
            }, set: function (a) {
                var b = this.ni;
                b !== a && (A(a, "boolean", xi, "allowMove"), this.ni = a, this.g("allowMove", b, a))
            }
        }, allowReshape: {
            configurable: !0, get: function () {
                return this.pi
            }, set: function (a) {
                var b = this.pi;
                b !== a && (A(a, "boolean", xi, "allowReshape"), this.pi = a, this.g("allowReshape", b, a))
            }
        }, allowResize: {
            configurable: !0, get: function () {
                return this.ri
            }, set: function (a) {
                var b = this.ri;
                b !== a && (A(a, "boolean", xi, "allowResize"), this.ri = a, this.g("allowResize", b, a))
            }
        },
        allowRotate: {
            configurable: !0, get: function () {
                return this.si
            }, set: function (a) {
                var b = this.si;
                b !== a && (A(a, "boolean", xi, "allowRotate"), this.si = a, this.g("allowRotate", b, a))
            }
        }, allowSelect: {
            configurable: !0, get: function () {
                return this.ti
            }, set: function (a) {
                var b = this.ti;
                b !== a && (A(a, "boolean", xi, "allowSelect"), this.ti = a, this.g("allowSelect", b, a))
            }
        }
    });
    xi.prototype.findObjectsNear = xi.prototype.Rg;
    xi.prototype.findObjectsIn = xi.prototype.Lf;
    xi.prototype.findObjectsAt = xi.prototype.rj;
    xi.prototype.findObjectAt = xi.prototype.ac;
    xi.className = "Layer";

    function Q(a) {
        1 < arguments.length && v("Diagram constructor can only take one optional argument, the DIV HTML element or its id.");
        Di || (Ei(), Di = !0);
        gb(this);
        Te = this;
        Wa = [];
        this.Yb = !0;
        this.ad = new Bh;
        this.ad.ie(this);
        this.ub = 17;
        this.Sl = this.Av = !1;
        this.et = "default";
        this.Ja = null;
        if (ih) {
            var b = this, c = function () {
                b.removeEventListener(qa.document, "DOMContentLoaded", c, !1);
                b.setRTL()
            };
            null !== qa.document.body ? this.setRTL() : b.addEventListener(qa.document, "DOMContentLoaded", c, !1)
        }
        this.Qa = new H;
        this.Da = this.Ea = 0;
        this.jm =
            this.Aa = null;
        this.Xx = new Db;
        this.uf = this.Nb = null;
        this.Jw();
        this.Xj = null;
        this.Iw();
        this.nb = 1;
        this.ra = (new J(NaN, NaN)).freeze();
        this.ft = new J(NaN, NaN);
        this.$n = this.Fa = 1;
        this.ss = (new J(NaN, NaN)).freeze();
        this.ts = NaN;
        this.Ks = 1E-4;
        this.Is = 100;
        this.vb = new Ib;
        this.It = (new J(NaN, NaN)).freeze();
        this.ns = (new L(NaN, NaN, NaN, NaN)).freeze();
        this.bj = (new jc(0, 0, 0, 0)).freeze();
        this.cj = ni;
        this.nt = !1;
        this.gt = this.at = null;
        this.ah = Mh;
        this.Nj = jd;
        this.kg = Mh;
        this.Bo = jd;
        this.us = this.rs = Fc;
        this.Kc = !0;
        this.Ql = !1;
        this.yd = new I;
        this.ih = new Db;
        this.Bl = !0;
        this.An = 250;
        this.Lj = -1;
        this.Cn = (new jc(16, 16, 16, 16)).freeze();
        this.Rj = this.Ne = !1;
        this.Uj = !0;
        this.hg = new Ae;
        this.hg.diagram = this;
        this.sd = new Ae;
        this.sd.diagram = this;
        this.th = new Ae;
        this.th.diagram = this;
        this.De = this.$f = null;
        this.sk = !1;
        this.ds = this.es = null;
        this.Jj = qa.PointerEvent && ($a || cb || db) && qa.navigator && !1 !== qa.navigator.msPointerEnabled;
        Fi(this);
        this.Nh = new I;
        this.Ds = !0;
        this.Ct = Gi;
        this.dv = !1;
        this.Et = ag;
        this.Pa = null;
        Hi.add("Model", Ii);
        this.Xr = this.$r = this.At = null;
        this.Zn =
            this.Vr = "auto";
        this.tg = this.Ns = this.vg = this.wg = this.yg = this.bg = this.fg = this.ag = null;
        this.qs = !1;
        this.cg = this.Jg = this.xg = this.ug = null;
        this.Os = !1;
        this.Zs = {};
        this.lk = [null, null];
        this.Pr = null;
        this.bs = this.rt = this.Cv = this.Hg = !1;
        this.kv = !0;
        this.Hi = this.qc = !1;
        this.hc = null;
        var d = this;
        this.Ic = function (a) {
            var b = d.partManager;
            if (a.model === b.diagram.model && b.diagram.ba) {
                b.diagram.ba = !1;
                try {
                    var c = a.change;
                    "" === a.modelChange && c === Le && b.updateDataBindings(a.object, a.propertyName)
                } finally {
                    b.diagram.ba = !0
                }
            }
        };
        this.$c =
            function (a) {
                d.partManager.doModelChanged(a)
            };
        this.Kv = !0;
        this.Xd = -2;
        this.Zi = new Db;
        this.Ys = new H;
        this.mg = !1;
        this.ki = this.ji = this.Cr = this.qd = !0;
        this.Dr = !1;
        this.Jr = this.Hr = this.ti = this.si = this.ri = this.pi = this.ni = this.oi = this.mi = this.Gr = this.vi = this.li = this.ui = this.Er = !0;
        this.lg = this.gv = !1;
        this.Ir = this.Fr = this.Il = this.Hl = !0;
        this.mt = this.it = 16;
        this.ht = this.Vp = !1;
        this.Wp = this.kt = null;
        this.jt = this.lt = 0;
        this.ob = (new jc(5)).freeze();
        this.Bv = (new I).freeze();
        this.Js = 999999999;
        this.av = (new I).freeze();
        this.Gi =
            this.Fi = this.Ei = !0;
        this.jf = this.ve = !1;
        this.rc = null;
        this.$g = !0;
        this.we = !1;
        this.Ox = new I;
        this.bv = new I;
        this.Nc = null;
        this.gm = 1;
        this.Dv = 0;
        this.de = {scale: 1, position: new J, bounds: new L, sw: !1};
        this.gy = (new L(NaN, NaN, NaN, NaN)).freeze();
        this.Cm = (new Hb(NaN, NaN)).freeze();
        this.ao = (new L(NaN, NaN, NaN, NaN)).freeze();
        this.Es = !1;
        this.So = this.zo = this.rp = this.Pu = this.Ou = this.Qu = this.og = this.rh = this.qf = this.hs = null;
        Ji(this);
        this.Pb = null;
        this.yo = !1;
        this.Oj = null;
        this.partManager = new Ii;
        this.toolManager = new Ua;
        this.toolManager.initializeStandardTools();
        this.currentTool = this.defaultTool = this.toolManager;
        this.gs = null;
        this.ul = new kf;
        this.Ts = this.Ss = null;
        this.oq = !1;
        this.commandHandler = Ki();
        this.model = Li();
        this.Hg = !0;
        Mi(this);
        this.layout = new Ni;
        this.Hg = !1;
        this.Hx = this.Tu = null;
        this.Zb = 1;
        this.Ih = null;
        this.ep = 1;
        this.kp = 0;
        this.rv = [0, 0, 0, 0, 0];
        this.lp = 0;
        this.zd = 1;
        this.bk = 0;
        this.No = new J;
        this.Bt = 500;
        this.Bn = new J;
        this.xe = !1;
        this.Xk = this.Yk = this.Wk = this.Vk = this.Qk = this.Sk = this.Rk = this.Ok = this.Pk = this.kx = this.Yw = this.Zw = this.$w = null;
        this.kr = function () {
        };
        this.preventDefault =
            null;
        this.Do = !1;
        this.Di = new Oi;
        this.pq = !1;
        void 0 !== a && Pi(this, a);
        this.mo = null;
        this.no = Sb;
        this.Yb = !1
    }

    Q.prototype.clear = function () {
        this.animationManager.Xc();
        this.model.clear();
        Qi = null;
        Ri = "";
        Si(this, !1);
        this.Ua();
        this.Ya();
        this.P()
    };

    function Si(a, b) {
        a.animationManager.Xc(!0);
        a.Bv = (new I).freeze();
        a.av = (new I).freeze();
        var c = a.skipsUndoManager;
        null !== a.model && (a.skipsUndoManager = !0);
        var d = null;
        null !== a.Pb && (d = a.Pb.part, null !== d && a.remove(d));
        var e = [], f = a.Qa.length;
        if (b) {
            for (b = 0; b < f; b++) for (var g = a.Qa.j[b].parts; g.next();) {
                var h = g.value;
                h !== d && null === h.data && e.push(h)
            }
            for (b = 0; b < e.length; b++) a.remove(e[b])
        }
        for (b = 0; b < f; b++) a.Qa.j[b].clear();
        a.partManager.clear();
        a.yd.clear();
        a.ih.clear();
        a.Nh.clear();
        a.Oj = null;
        Na = [];
        null !== d && (a.add(d),
            a.partManager.parts.remove(d));
        null !== a.model && (a.skipsUndoManager = c);
        return e
    }

    function Ki() {
        return null
    }

    Q.prototype.reset = function () {
        this.clear();
        this.Yb = !0;
        this.ad = new Bh;
        this.ad.ie(this);
        this.ub = 17;
        this.Sl = this.Av = !1;
        this.et = "default";
        this.Qa = new H;
        this.Xx = new Db;
        this.uf = null;
        this.Jw();
        this.Xj = null;
        this.Iw();
        this.nb = 1;
        this.ra = (new J(NaN, NaN)).freeze();
        this.ft = new J(NaN, NaN);
        this.$n = this.Fa = 1;
        this.ss = (new J(NaN, NaN)).freeze();
        this.ts = NaN;
        this.Ks = 1E-4;
        this.Is = 100;
        this.vb = new Ib;
        this.It = (new J(NaN, NaN)).freeze();
        this.ns = (new L(NaN, NaN, NaN, NaN)).freeze();
        this.bj = (new jc(0, 0, 0, 0)).freeze();
        this.cj = ni;
        this.nt = !1;
        this.gt = this.at = null;
        this.ah = Mh;
        this.Nj = jd;
        this.kg = Mh;
        this.Bo = jd;
        this.us = this.rs = Fc;
        this.Kc = !0;
        this.Ql = !1;
        this.yd = new I;
        this.ih = new Db;
        this.Bl = !0;
        this.An = 250;
        this.Lj = -1;
        this.Cn = (new jc(16, 16, 16, 16)).freeze();
        this.Rj = this.Ne = !1;
        this.Uj = !0;
        this.hg = new Ae;
        this.hg.diagram = this;
        this.sd = new Ae;
        this.sd.diagram = this;
        this.th = new Ae;
        this.th.diagram = this;
        this.De = this.$f = null;
        this.sk = !1;
        this.ds = this.es = null;
        this.Jj = qa.PointerEvent && ($a || cb || db) && qa.navigator && !1 !== qa.navigator.msPointerEnabled;
        Fi(this);
        this.Nh = new I;
        this.Ds = !0;
        this.Ct = Gi;
        this.dv = !1;
        this.Et = ag;
        this.Xr = this.$r = this.At = null;
        this.Zn = this.Vr = "auto";
        this.tg = this.Ns = this.vg = this.wg = this.yg = this.bg = this.fg = this.ag = null;
        this.qs = !1;
        this.cg = this.Jg = this.xg = this.ug = null;
        this.Os = !1;
        this.Zs = {};
        this.lk = [null, null];
        this.Pr = null;
        this.bs = this.rt = this.Cv = this.Hg = !1;
        this.kv = !0;
        this.Hi = this.qc = !1;
        this.Kv = !0;
        this.Xd = -2;
        this.Zi = new Db;
        this.Ys = new H;
        this.mg = !1;
        this.ki = this.ji = this.Cr = this.qd = !0;
        this.Dr = !1;
        this.Jr = this.Hr = this.ti = this.si = this.ri = this.pi =
            this.ni = this.oi = this.mi = this.Gr = this.vi = this.li = this.ui = this.Er = !0;
        this.lg = this.gv = !1;
        this.Ir = this.Fr = this.Il = this.Hl = !0;
        this.mt = this.it = 16;
        this.ht = this.Vp = !1;
        this.jt = this.lt = 0;
        this.ob = (new jc(5)).freeze();
        this.Bv = (new I).freeze();
        this.Js = 999999999;
        this.av = (new I).freeze();
        this.Gi = this.Fi = this.Ei = !0;
        this.jf = this.ve = !1;
        this.rc = null;
        this.$g = !0;
        this.we = !1;
        this.Ox = new I;
        this.bv = new I;
        this.Nc = null;
        this.gm = 1;
        this.Dv = 0;
        this.de = {scale: 1, position: new J, bounds: new L, sw: !1};
        this.gy = (new L(NaN, NaN, NaN, NaN)).freeze();
        this.Cm = (new Hb(NaN, NaN)).freeze();
        this.ao = (new L(NaN, NaN, NaN, NaN)).freeze();
        this.Es = !1;
        this.So = this.zo = this.rp = this.Pu = this.Ou = this.Qu = this.og = this.rh = this.qf = null;
        Ji(this);
        this.Pb = null;
        this.yo = !1;
        this.Oj = null;
        this.partManager = new Ii;
        this.toolManager = new Ua;
        this.toolManager.initializeStandardTools();
        this.currentTool = this.defaultTool = this.toolManager;
        this.gs = null;
        this.ul = new kf;
        this.Ts = this.Ss = null;
        this.oq = !1;
        this.commandHandler = Ki();
        this.Hg = !0;
        Mi(this);
        this.layout = new Ni;
        this.Hg = !1;
        this.model = Li();
        this.model.undoManager = new Qe;
        this.we = !1;
        this.Uj = !0;
        this.Ne = !1;
        this.Zb = 1;
        this.Ih = null;
        this.ep = 1;
        this.kp = 0;
        this.rv = [0, 0, 0, 0, 0];
        this.lp = 0;
        this.zd = 1;
        this.bk = 0;
        this.No = new J;
        this.Bt = 500;
        this.Bn = new J;
        this.pq = this.Do = this.xe = !1;
        this.mo = null;
        this.no = Sb;
        this.Yb = !1;
        this.P()
    };

    function Ji(a) {
        a.qf = new Db;
        var b = new V, c = new kh;
        c.bind(new Ti("text", "", Qa));
        b.add(c);
        a.Qu = b;
        a.qf.add("", b);
        b = new V;
        c = new kh;
        c.stroke = "brown";
        c.bind(new Ti("text", "", Qa));
        b.add(c);
        a.qf.add("Comment", b);
        b = new V;
        b.selectable = !1;
        b.avoidable = !1;
        c = new Zf;
        c.figure = "Ellipse";
        c.fill = "black";
        c.stroke = null;
        c.desiredSize = (new Hb(3, 3)).ia();
        b.add(c);
        a.qf.add("LinkLabel", b);
        a.rh = new Db;
        b = new Kf;
        b.selectionObjectName = "GROUPPANEL";
        b.type = W.Vertical;
        c = new kh;
        c.font = "bold 12pt sans-serif";
        c.bind(new Ti("text", "",
            Qa));
        b.add(c);
        c = new W(W.Auto);
        c.name = "GROUPPANEL";
        var d = new Zf;
        d.figure = "Rectangle";
        d.fill = "rgba(128,128,128,0.2)";
        d.stroke = "black";
        c.add(d);
        d = new Mg;
        d.padding = (new jc(5, 5, 5, 5)).ia();
        c.add(d);
        b.add(c);
        a.Ou = b;
        a.rh.add("", b);
        a.og = new Db;
        b = new S;
        c = new Zf;
        c.isPanelMain = !0;
        b.add(c);
        c = new Zf;
        c.toArrow = "Standard";
        c.fill = "black";
        c.stroke = null;
        c.strokeWidth = 0;
        b.add(c);
        a.Pu = b;
        a.og.add("", b);
        b = new S;
        c = new Zf;
        c.isPanelMain = !0;
        c.stroke = "brown";
        b.add(c);
        a.og.add("Comment", b);
        b = new Xe;
        b.type = W.Auto;
        c = new Zf;
        c.fill =
            null;
        c.stroke = "dodgerblue";
        c.strokeWidth = 3;
        b.add(c);
        c = new Mg;
        c.margin = (new jc(1.5, 1.5, 1.5, 1.5)).ia();
        b.add(c);
        a.rp = b;
        a.zo = b;
        b = new Xe;
        b.type = W.Link;
        c = new Zf;
        c.isPanelMain = !0;
        c.fill = null;
        c.stroke = "dodgerblue";
        c.strokeWidth = 3;
        b.add(c);
        a.So = b
    }

    Q.prototype.setRTL = function (a) {
        a = void 0 === a ? this.div : a;
        null === a && (a = qa.document.body);
        var b = ua("div");
        b.dir = "rtl";
        b.style.cssText = "font-size: 14px; width: 1px; height: 1px; position: absolute; top: -1000px; overflow: scroll;";
        b.textContent = "A";
        a.appendChild(b);
        var c = "reverse";
        0 < b.scrollLeft ? c = "default" : (b.scrollLeft = 1, 0 === b.scrollLeft && (c = "negative"));
        a.removeChild(b);
        this.et = c
    };
    Q.prototype.setScrollWidth = function (a) {
        a = void 0 === a ? this.div : a;
        null === a && (a = qa.document.body);
        var b = 0;
        if (ih) {
            var c = Ui;
            b = Vi;
            null === c && (c = Ui = ua("p"), c.style.width = "100%", c.style.height = "200px", c.style.boxSizing = "content-box", b = Vi = ua("div"), b.style.position = "absolute", b.style.visibility = "hidden", b.style.width = "200px", b.style.height = "150px", b.style.boxSizing = "content-box", b.appendChild(c));
            b.style.overflow = "hidden";
            a.appendChild(b);
            var d = c.offsetWidth;
            b.style.overflow = "scroll";
            c = c.offsetWidth;
            d === c &&
            (c = b.clientWidth);
            a.removeChild(b);
            b = d - c;
            0 !== b || fb || (b = 11)
        }
        this.ub = b;
        this.Av = !0
    };
    Q.prototype.pb = function (a) {
        a.classType === Q ? this.autoScale = a : Da(this, a)
    };
    Q.prototype.toString = function (a) {
        void 0 === a && (a = 0);
        var b = "";
        this.div && this.div.id && (b = this.div.id);
        b = 'Diagram "' + b + '"';
        if (0 >= a) return b;
        for (var c = this.Qa.iterator; c.next();) b += "\n  " + c.value.toString(a - 1);
        return b
    };
    Q.prototype.addEventListener = function (a, b, c, d) {
        a.addEventListener(b, c, {capture: d, passive: !1})
    };
    Q.prototype.removeEventListener = function (a, b, c, d) {
        a.removeEventListener(b, c, {capture: d})
    };

    function Wi(a) {
        var b = a.Aa.La;
        b instanceof HTMLCanvasElement && (a.Jj ? (a.addEventListener(b, "pointerdown", a.Vk, !1), a.addEventListener(b, "pointermove", a.Wk, !1), a.addEventListener(b, "pointerup", a.Yk, !1), a.addEventListener(b, "pointerout", a.Xk, !1)) : (a.addEventListener(b, "touchstart", a.$w, !1), a.addEventListener(b, "touchmove", a.Zw, !1), a.addEventListener(b, "touchend", a.Yw, !1), a.addEventListener(b, "mousemove", a.Pk, !1), a.addEventListener(b, "mousedown", a.Ok, !1), a.addEventListener(b, "mouseup", a.Rk, !1), a.addEventListener(b,
            "mouseout", a.Qk, !1)), a.addEventListener(b, "mouseenter", a.cA, !1), a.addEventListener(b, "mouseleave", a.dA, !1), a.addEventListener(b, "wheel", a.Sk, !1), a.addEventListener(b, "keydown", a.TA, !1), a.addEventListener(b, "keyup", a.UA, !1), a.addEventListener(b, "blur", a.Pz, !1), a.addEventListener(b, "focus", a.Qz, !1), a.addEventListener(b, "selectstart", function (a) {
            a.preventDefault();
            return !1
        }, !1), a.addEventListener(b, "contextmenu", function (a) {
            a.preventDefault();
            return !1
        }, !1), a.addEventListener(b, "gesturestart", function (b) {
            a.toolManager.gestureBehavior !==
            ef && (a.toolManager.gestureBehavior === Ze ? b.preventDefault() : a.xe && a.lastInput.handled || (b.preventDefault(), a.gm = a.scale, a.currentTool.doCancel()))
        }, !1), a.addEventListener(b, "gesturechange", function (b) {
            if (a.toolManager.gestureBehavior !== ef) if (a.toolManager.gestureBehavior === Ze) b.preventDefault(); else if (!a.xe || !a.lastInput.handled) {
                b.preventDefault();
                var c = b.scale;
                if (null !== a.gm) {
                    var e = a.Aa.getBoundingClientRect();
                    b = new J(b.pageX - qa.scrollX - a.Ea / e.width * e.left, b.pageY - qa.scrollY - a.Da / e.height * e.top);
                    c = a.gm * c;
                    e = a.commandHandler;
                    if (c !== a.scale && e.canResetZoom(c)) {
                        var f = a.zoomPoint;
                        a.zoomPoint = b;
                        e.resetZoom(c);
                        a.zoomPoint = f
                    }
                }
            }
        }, !1), a.addEventListener(qa, "resize", a.kx, !1))
    }

    function nf(a) {
        30 < a.kp && (a.Ih = 1)
    }

    function Af(a, b) {
        null !== a.Ih && (a.Ih = null, b && a.kr(), F && F.Ay || (a.kp = 0, a.rv = [0, 0, 0, 0, 0], a.lp = 0))
    }

    Q.prototype.computePixelRatio = function () {
        return null !== this.Ih ? this.Ih : qa.devicePixelRatio || 1
    };
    Q.prototype.doMouseMove = function () {
        this.currentTool.doMouseMove()
    };
    Q.prototype.doMouseDown = function () {
        this.currentTool.doMouseDown()
    };
    Q.prototype.doMouseUp = function () {
        this.currentTool.doMouseUp()
    };
    Q.prototype.doMouseWheel = function () {
        this.currentTool.doMouseWheel()
    };
    Q.prototype.doKeyDown = function () {
        this.currentTool.doKeyDown()
    };
    Q.prototype.doKeyUp = function () {
        this.currentTool.doKeyUp()
    };
    Q.prototype.doFocus = function () {
        this.focus()
    };
    Q.prototype.focus = function () {
        if (this.Aa) if (this.scrollsPageOnFocus) this.Aa.focus(); else {
            var a = qa.scrollX || qa.pageXOffset, b = qa.scrollY || qa.pageYOffset;
            this.Aa.focus();
            qa.scrollTo(a, b)
        }
    };
    Q.prototype.Qz = function () {
        this.B.U("GainedFocus")
    };
    Q.prototype.Pz = function () {
        this.B.U("LostFocus")
    };

    function Yh(a) {
        if (null !== a.Aa) {
            var b = a.Ja;
            if (0 !== b.clientWidth && 0 !== b.clientHeight) {
                a.Av || a.setScrollWidth();
                var c = a.jf ? a.ub : 0, d = a.ve ? a.ub : 0, e = a.Zb;
                a.Zb = a.computePixelRatio();
                a.Zb !== e && (a.Ql = !0, a.Kb());
                if (b.clientWidth !== a.Ea + c || b.clientHeight !== a.Da + d) a.Fi = !0, a.Kc = !0, b = a.layout, null !== b && b.isViewportSized && a.autoScale === Mh && (a.Rj = !0, b.D()), a.qc || a.Kb()
            }
        }
    }

    function Mi(a) {
        var b = new xi;
        b.name = "Background";
        a.Em(b);
        b = new xi;
        b.name = "";
        a.Em(b);
        b = new xi;
        b.name = "Foreground";
        a.Em(b);
        b = new xi;
        b.name = "Adornment";
        b.isTemporary = !0;
        b.isInDocumentBounds = !1;
        a.Em(b);
        b = new xi;
        b.name = "Tool";
        b.isTemporary = !0;
        b.isInDocumentBounds = !0;
        a.Em(b);
        b = new xi;
        b.name = "Grid";
        b.allowSelect = !1;
        b.pickable = !1;
        b.isTemporary = !0;
        b.isInDocumentBounds = !1;
        a.jy(b, a.Km("Background"))
    }

    function Xi(a) {
        a.Pb = new W(W.Grid);
        a.Pb.name = "GRID";
        var b = new Zf;
        b.figure = "LineH";
        b.stroke = "lightgray";
        b.strokeWidth = .5;
        b.interval = 1;
        a.Pb.add(b);
        b = new Zf;
        b.figure = "LineH";
        b.stroke = "gray";
        b.strokeWidth = .5;
        b.interval = 5;
        a.Pb.add(b);
        b = new Zf;
        b.figure = "LineH";
        b.stroke = "gray";
        b.strokeWidth = 1;
        b.interval = 10;
        a.Pb.add(b);
        b = new Zf;
        b.figure = "LineV";
        b.stroke = "lightgray";
        b.strokeWidth = .5;
        b.interval = 1;
        a.Pb.add(b);
        b = new Zf;
        b.figure = "LineV";
        b.stroke = "gray";
        b.strokeWidth = .5;
        b.interval = 5;
        a.Pb.add(b);
        b = new Zf;
        b.figure =
            "LineV";
        b.stroke = "gray";
        b.strokeWidth = 1;
        b.interval = 10;
        a.Pb.add(b);
        b = new T;
        b.add(a.Pb);
        b.layerName = "Grid";
        b.zOrder = 0;
        b.isInDocumentBounds = !1;
        b.isAnimated = !1;
        b.pickable = !1;
        b.locationObjectName = "GRID";
        a.add(b);
        a.partManager.parts.remove(b);
        a.Pb.visible = !1
    }

    function ej() {
        this.B.ht ? this.B.ht = !1 : this.B.isEnabled ? this.B.wy(this) : fj(this.B)
    }

    function gj(a) {
        this.B.isEnabled ? (this.B.lt = a.target.scrollTop, this.B.jt = a.target.scrollLeft) : fj(this.B)
    }

    Q.prototype.wy = function (a) {
        if (null !== this.Aa) {
            this.Vp = !0;
            var b = this.documentBounds, c = this.viewportBounds, d = this.bj, e = b.x - d.left, f = b.y - d.top,
                g = b.width + d.left + d.right, h = b.height + d.top + d.bottom, k = b.right + d.right;
            d = b.bottom + d.bottom;
            var l = c.x;
            b = c.y;
            var m = c.width, n = c.height, p = c.right, r = c.bottom;
            c = this.scale;
            var q = a.scrollLeft;
            if (this.Sl) switch (this.et) {
                case "negative":
                    q = q + a.scrollWidth - a.clientWidth;
                    break;
                case "reverse":
                    q = a.scrollWidth - q - a.clientWidth
            }
            var u = q;
            m < g || n < h ? (q = J.allocAt(this.position.x, this.position.y),
            this.allowHorizontalScroll && this.jt !== u && (q.x = u / c + e, this.jt = u), this.allowVerticalScroll && this.lt !== a.scrollTop && (q.y = a.scrollTop / c + f, this.lt = a.scrollTop), this.position = q, J.free(q), this.Fi = this.Vp = !1) : (q = J.alloc(), a.xz && this.allowHorizontalScroll && (e < l && (this.position = q.h(u + e, this.position.y)), k > p && (this.position = q.h(-(this.kt.scrollWidth - this.Ea) + u - this.Ea / c + k, this.position.y))), a.yz && this.allowVerticalScroll && (f < b && (this.position = q.h(this.position.x, a.scrollTop + f)), d > r && (this.position = q.h(this.position.x,
                -(this.kt.scrollHeight - this.Da) + a.scrollTop - this.Da / c + d))), J.free(q), hj(this), this.Fi = this.Vp = !1, b = this.documentBounds, c = this.viewportBounds, k = b.right, p = c.right, d = b.bottom, r = c.bottom, e = b.x, l = c.x, f = b.y, b = c.y, m >= g && e >= l && k <= p && (this.Wp.style.width = "1px"), n >= h && f >= b && d <= r && (this.Wp.style.height = "1px"))
        }
    };
    Q.prototype.computeBounds = function () {
        0 < this.yd.count && ij(this);
        return jj(this)
    };

    function jj(a) {
        if (a.fixedBounds.o()) {
            var b = a.fixedBounds.copy();
            b.Dq(a.ob);
            return b
        }
        for (var c = !0, d = a.Qa.j, e = d.length, f = 0; f < e; f++) {
            var g = d[f];
            if (g.visible && g.isInDocumentBounds) {
                g = g.Ia.j;
                for (var h = g.length, k = 0; k < h; k++) {
                    var l = g[k];
                    l.isInDocumentBounds && l.isVisible() && (l = l.actualBounds, l.o() && (c ? (c = !1, b = l.copy()) : b.Yc(l)))
                }
            }
        }
        c && (b = new L(0, 0, 0, 0));
        b.Dq(a.ob);
        return b
    }

    Q.prototype.computePartsBounds = function (a, b) {
        void 0 === b && (b = !1);
        var c = null;
        if (Ha(a)) for (var d = 0; d < a.length; d++) {
            var e = a[d];
            !b && e instanceof S || (e.Ya(), null === c ? c = e.actualBounds.copy() : c.Yc(e.actualBounds))
        } else for (a = a.iterator; a.next();) d = a.value, !b && d instanceof S || (d.Ya(), null === c ? c = d.actualBounds.copy() : c.Yc(d.actualBounds));
        return null === c ? new L(NaN, NaN, 0, 0) : c
    };

    function kj(a, b) {
        if ((b || a.we) && !a.Yb && null !== a.Aa && a.documentBounds.o()) {
            if (b) {
                var c = a.initialPosition;
                if (c.o()) {
                    a.position = c;
                    return
                }
                c = J.alloc();
                c.Ej(a.documentBounds, a.initialDocumentSpot);
                var d = a.viewportBounds;
                d = L.allocAt(0, 0, d.width, d.height);
                var e = J.alloc();
                e.Ej(d, a.initialViewportSpot);
                e.h(c.x - e.x, c.y - e.y);
                a.position = e;
                L.free(d);
                J.free(e);
                J.free(c)
            }
            a.Yb = !0;
            c = a.ah;
            b && a.kg !== Mh && (c = a.kg);
            d = c !== Mh ? lj(a, c) : a.scale;
            c = a.viewportBounds.copy();
            e = a.Ea / d;
            var f = a.Da / d, g = a.Nj, h = a.Bo;
            b && !g.cb() && (h.cb() ||
                h.Jb()) && (g = h.Jb() ? Mc : h);
            mj(a, a.documentBounds, e, f, g, b);
            b = a.scale;
            a.scale = d;
            a.Yb = !1;
            d = a.viewportBounds;
            d.Ta(c) || a.gr(c, d, b, !1);
            nj(a);
            oj(a, !0, !1)
        }
    }

    function lj(a, b) {
        var c = a.$n;
        if (null === a.Aa) return c;
        a.Ya();
        var d = a.documentBounds;
        if (!d.o()) return c;
        var e = d.width;
        d = d.height;
        var f = a.Ea + (a.jf ? a.ub : 0), g = a.Da + (a.ve ? a.ub : 0), h = f / e, k = g / d;
        return b === pj ? (b = Math.min(k, h), b > c && (b = c), b < a.minScale && (b = a.minScale), b > a.maxScale && (b = a.maxScale), b) : b === qj ? (b = k > h ? (g - a.ub) / d : (f - a.ub) / e, b > c && (b = c), b < a.minScale && (b = a.minScale), b > a.maxScale && (b = a.maxScale), b) : a.scale
    }

    Q.prototype.zoomToFit = function () {
        var a = this.cj;
        this.cj = ni;
        this.scale = lj(this, pj);
        a !== ni && (kj(this, !1), mj(this, this.documentBounds, this.Ea / this.Fa, this.Da / this.Fa, this.Nj, !1));
        this.cj = a
    };
    t = Q.prototype;
    t.BB = function (a, b) {
        void 0 === b && (b = pj);
        var c = a.width, d = a.height;
        if (!(0 === c || 0 === d || isNaN(c) && isNaN(d))) {
            var e = 1;
            if (b === pj || b === qj) if (isNaN(c)) e = this.viewportBounds.height * this.scale / d; else if (isNaN(d)) e = this.viewportBounds.width * this.scale / c; else {
                e = this.Ea;
                var f = this.Da;
                e = b === qj ? f / d > e / c ? (f - (this.ve ? this.ub : 0)) / d : (e - (this.jf ? this.ub : 0)) / c : Math.min(f / d, e / c)
            }
            this.scale = e;
            this.position = new J(a.x, a.y)
        }
    };
    t.Iz = function (a, b) {
        this.Ya();
        var c = this.documentBounds, d = this.viewportBounds;
        this.position = new J(c.x + (a.x * c.width + a.offsetX) - (b.x * d.width - b.offsetX), c.y + (a.y * c.height + a.offsetY) - (b.y * d.height - b.offsetY))
    };
    t.CA = function (a) {
        if (a instanceof N) {
            this.mo = a;
            var b = J.alloc();
            this.no = this.vr(a.ja(Fc, b));
            J.free(b)
        } else this.mo = null, this.no = Sb
    };

    function mj(a, b, c, d, e, f) {
        var g = J.allocAt(a.ra.x, a.ra.y), h = g.x, k = g.y;
        if (null !== a.mo) {
            var l = J.alloc();
            l = a.mo.ja(Fc, l);
            h = l.x - a.no.x / a.scale;
            k = l.y - a.no.y / a.scale;
            e = Ec;
            J.free(l)
        }
        if (f || a.scrollMode === ni) e.cb() && (c > b.width && (h = b.x + (e.x * b.width + e.offsetX) - (e.x * c - e.offsetX)), d > b.height && (k = b.y + (e.y * b.height + e.offsetY) - (e.y * d - e.offsetY))), e = a.bj, f = c - b.width, c < b.width + e.left + e.right ? (h = Math.min(h + c / 2, b.right + Math.max(f, e.right) - c / 2), h = Math.max(h, b.left - Math.max(f, e.left) + c / 2), h -= c / 2) : h > b.left ? h = b.left : h < b.right -
            c && (h = b.right - c), c = d - b.height, d < b.height + e.top + e.bottom ? (k = Math.min(k + d / 2, b.bottom + Math.max(c, e.bottom) - d / 2), k = Math.max(k, b.top - Math.max(c, e.top) + d / 2), k -= d / 2) : k > b.top ? k = b.top : k < b.bottom - d && (k = b.bottom - d);
        g.x = isFinite(h) ? h : -a.ob.left;
        g.y = isFinite(k) ? k : -a.ob.top;
        null !== a.positionComputation && (b = a.positionComputation(a, g), g.x = b.x, g.y = b.y);
        a.ad.yc && gi(a.ad, a.ra, g);
        a.ra.h(g.x, g.y);
        J.free(g)
    }

    t.Lm = function (a, b) {
        void 0 === b && (b = !0);
        if (b) {
            if (a = Lf(this, a, function (a) {
                return a.part
            }, function (a) {
                return a.canSelect()
            }), a instanceof T) return a
        } else if (a = Lf(this, a, function (a) {
            return a.part
        }), a instanceof T) return a;
        return null
    };
    t.ac = function (a, b, c) {
        void 0 === b && (b = null);
        void 0 === c && (c = null);
        ij(this);
        for (var d = this.Qa.iteratorBackwards; d.next();) {
            var e = d.value;
            if (e.visible && (e = e.ac(a, b, c), null !== e)) return e
        }
        return null
    };

    function Lf(a, b, c, d) {
        void 0 === c && (c = null);
        void 0 === d && (d = null);
        ij(a);
        for (a = a.Qa.iteratorBackwards; a.next();) {
            var e = a.value;
            if (e.visible && !e.isTemporary && (e = e.ac(b, c, d), null !== e)) return e
        }
        return null
    }

    t.qA = function (a, b, c) {
        void 0 === b && (b = !0);
        return rj(this, a, function (a) {
            return a.part
        }, b ? function (a) {
            return a instanceof T && a.canSelect()
        } : null, c)
    };

    function rj(a, b, c, d, e) {
        void 0 === c && (c = null);
        void 0 === d && (d = null);
        e instanceof H || e instanceof I || (e = new I);
        ij(a);
        for (a = a.Qa.iteratorBackwards; a.next();) {
            var f = a.value;
            f.visible && !f.isTemporary && f.rj(b, c, d, e)
        }
        return e
    }

    t.rj = function (a, b, c, d) {
        void 0 === b && (b = null);
        void 0 === c && (c = null);
        d instanceof H || d instanceof I || (d = new I);
        ij(this);
        for (var e = this.Qa.iteratorBackwards; e.next();) {
            var f = e.value;
            f.visible && f.rj(a, b, c, d)
        }
        return d
    };
    t.Hy = function (a, b, c, d) {
        void 0 === b && (b = !1);
        void 0 === c && (c = !0);
        return sj(this, a, function (a) {
            return a instanceof T && (!c || a.canSelect())
        }, b, d)
    };
    t.Lf = function (a, b, c, d, e) {
        void 0 === b && (b = null);
        void 0 === c && (c = null);
        void 0 === d && (d = !1);
        e instanceof H || e instanceof I || (e = new I);
        ij(this);
        for (var f = this.Qa.iteratorBackwards; f.next();) {
            var g = f.value;
            g.visible && g.Lf(a, b, c, d, e)
        }
        return e
    };
    t.gw = function (a, b, c, d, e, f) {
        var g = new I;
        ij(this);
        for (var h = this.Qa.iteratorBackwards; h.next();) {
            var k = h.value;
            k.visible && k.gw(a, b, c, d, g, e, f)
        }
        return g
    };

    function sj(a, b, c, d, e) {
        var f = null;
        void 0 === f && (f = null);
        void 0 === c && (c = null);
        void 0 === d && (d = !1);
        e instanceof H || e instanceof I || (e = new I);
        ij(a);
        for (a = a.Qa.iteratorBackwards; a.next();) {
            var g = a.value;
            g.visible && !g.isTemporary && g.Lf(b, f, c, d, e)
        }
        return e
    }

    t.rA = function (a, b, c, d, e) {
        void 0 === c && (c = !0);
        void 0 === d && (d = !0);
        return tj(this, a, b, function (a) {
            return a instanceof T && (!d || a.canSelect())
        }, c, e)
    };
    t.Rg = function (a, b, c, d, e, f) {
        void 0 === c && (c = null);
        void 0 === d && (d = null);
        void 0 === e && (e = !0);
        if (!1 !== e && !0 !== e) {
            if (e instanceof H || e instanceof I) f = e;
            e = !0
        }
        f instanceof H || f instanceof I || (f = new I);
        ij(this);
        for (var g = this.Qa.iteratorBackwards; g.next();) {
            var h = g.value;
            h.visible && h.Rg(a, b, c, d, e, f)
        }
        return f
    };

    function tj(a, b, c, d, e, f) {
        var g = null;
        void 0 === g && (g = null);
        void 0 === d && (d = null);
        void 0 === e && (e = !0);
        if (!1 !== e && !0 !== e) {
            if (e instanceof H || e instanceof I) f = e;
            e = !0
        }
        f instanceof H || f instanceof I || (f = new I);
        ij(a);
        for (a = a.Qa.iteratorBackwards; a.next();) {
            var h = a.value;
            h.visible && !h.isTemporary && h.Rg(b, c, g, d, e, f)
        }
        return f
    }

    Q.prototype.acceptEvent = function (a) {
        return uj(this, a, a instanceof MouseEvent)
    };

    function uj(a, b, c) {
        var d = a.sd;
        a.sd = a.th;
        a.th = d;
        d.diagram = a;
        d.event = b;
        c ? vj(a, b, d) : (d.viewPoint = a.sd.viewPoint, d.documentPoint = a.sd.documentPoint);
        a = 0;
        b.ctrlKey && (a += 1);
        b.altKey && (a += 2);
        b.shiftKey && (a += 4);
        b.metaKey && (a += 8);
        d.modifiers = a;
        d.button = b.button;
        void 0 === b.buttons || Za || (d.buttons = b.buttons);
        eb && 0 === b.button && b.ctrlKey && (d.button = 2);
        d.down = !1;
        d.up = !1;
        d.clickCount = 1;
        d.delta = 0;
        d.handled = !1;
        d.bubbles = !1;
        d.timestamp = b.timeStamp;
        d.isMultiTouch = !1;
        d.targetDiagram = wj(b);
        d.targetObject = null;
        return d
    }

    function wj(a) {
        var b = a.target.B;
        if (!b) {
            var c = a.path;
            c || "function" !== typeof a.composedPath || (c = a.composedPath());
            c && c[0] && (b = c[0].B)
        }
        return b ? b : null
    }

    function xj(a, b, c, d) {
        var e = yj(a, b, !0, !1, !0, d);
        vj(a, c, e);
        e.targetDiagram = wj(b);
        e.targetObject = null;
        d || e.clone(a.hg);
        return e
    }

    function zj(a, b, c, d) {
        d = yj(a, b, !1, !1, !1, d);
        if (null !== c) {
            var e = qa.document.elementFromPoint(c.clientX, c.clientY);
            null !== e && null !== e.shadowRoot && (e = e.shadowRoot.elementFromPoint(c.clientX, c.clientY));
            e && e.B ? (b = c, c = e.B) : (b = void 0 !== b.targetTouches ? b.targetTouches[0] : b, c = a);
            d.targetDiagram = c;
            vj(a, b, d)
        } else null !== a.sd ? (d.documentPoint = a.sd.documentPoint, d.viewPoint = a.sd.viewPoint, d.targetDiagram = a.sd.targetDiagram) : null !== a.hg && (d.documentPoint = a.hg.documentPoint, d.viewPoint = a.hg.viewPoint, d.targetDiagram =
            a.hg.targetDiagram);
        d.targetObject = null;
        return d
    }

    function yj(a, b, c, d, e, f) {
        var g = a.sd;
        a.sd = a.th;
        a.th = g;
        g.diagram = a;
        g.clickCount = 1;
        var h = g.delta = 0;
        b.ctrlKey && (h += 1);
        b.altKey && (h += 2);
        b.shiftKey && (h += 4);
        b.metaKey && (h += 8);
        g.modifiers = h;
        g.button = 0;
        g.buttons = 1;
        g.event = b;
        g.timestamp = b.timeStamp;
        a.Jj && b instanceof qa.PointerEvent && "touch" !== b.pointerType && (g.button = b.button, void 0 === b.buttons || Za || (g.buttons = b.buttons), eb && 0 === b.button && b.ctrlKey && (g.button = 2));
        g.down = c;
        g.up = d;
        g.handled = !1;
        g.bubbles = e;
        g.isMultiTouch = f;
        return g
    }

    function Aj(a, b, c) {
        if (b.bubbles) return F && F.Ry && Ea("NOT handled " + c.type + " " + b.toString()), !0;
        F && F.Ry && Ea("handled " + c.type + " " + a.currentTool.name + " " + b.toString());
        void 0 !== c.stopPropagation && c.stopPropagation();
        !1 !== c.cancelable && c.preventDefault();
        c.cancelBubble = !0;
        return !1
    }

    Q.prototype.TA = function (a) {
        var b = this.B;
        if (!this.B.isEnabled) return !1;
        var c = uj(b, a, !1);
        c.key = String.fromCharCode(a.which);
        c.down = !0;
        switch (a.which) {
            case 8:
                c.key = "Backspace";
                break;
            case 33:
                c.key = "PageUp";
                break;
            case 34:
                c.key = "PageDown";
                break;
            case 35:
                c.key = "End";
                break;
            case 36:
                c.key = "Home";
                break;
            case 37:
                c.key = "Left";
                break;
            case 38:
                c.key = "Up";
                break;
            case 39:
                c.key = "Right";
                break;
            case 40:
                c.key = "Down";
                break;
            case 45:
                c.key = "Insert";
                break;
            case 46:
                c.key = "Del";
                break;
            case 48:
                c.key = "0";
                break;
            case 187:
            case 61:
            case 107:
                c.key =
                    "Add";
                break;
            case 189:
            case 173:
            case 109:
                c.key = "Subtract";
                break;
            case 27:
                c.key = "Esc"
        }
        b.doKeyDown();
        return Aj(b, c, a)
    };
    Q.prototype.UA = function (a) {
        var b = this.B;
        if (!b.isEnabled) return !1;
        var c = uj(b, a, !1);
        c.key = String.fromCharCode(a.which);
        c.up = !0;
        switch (a.which) {
            case 8:
                c.key = "Backspace";
                break;
            case 33:
                c.key = "PageUp";
                break;
            case 34:
                c.key = "PageDown";
                break;
            case 35:
                c.key = "End";
                break;
            case 36:
                c.key = "Home";
                break;
            case 37:
                c.key = "Left";
                break;
            case 38:
                c.key = "Up";
                break;
            case 39:
                c.key = "Right";
                break;
            case 40:
                c.key = "Down";
                break;
            case 45:
                c.key = "Insert";
                break;
            case 46:
                c.key = "Del"
        }
        b.doKeyUp();
        return Aj(b, c, a)
    };
    Q.prototype.cA = function (a) {
        var b = this.B;
        if (!b.isEnabled) return !1;
        var c = uj(b, a, !0);
        null !== b.mouseEnter && b.mouseEnter(c);
        return Aj(b, c, a)
    };
    Q.prototype.dA = function (a) {
        var b = this.B;
        if (!b.isEnabled) return !1;
        var c = uj(b, a, !0);
        null !== b.mouseLeave && b.mouseLeave(c);
        return Aj(b, c, a)
    };
    Q.prototype.getMouse = function (a) {
        var b = this.Aa;
        if (null === b) return new J(0, 0);
        var c = b.getBoundingClientRect();
        b = a.clientX - this.Ea / c.width * c.left;
        a = a.clientY - this.Da / c.height * c.top;
        return null !== this.vb ? Jb(new J(b, a), this.vb) : new J(b, a)
    };

    function vj(a, b, c) {
        var d = a.Aa, e = a.Ea, f = a.Da, g = 0, h = 0;
        null !== d && (d = d.getBoundingClientRect(), g = b.clientX - e / d.width * d.left, h = b.clientY - f / d.height * d.top);
        c.viewPoint.h(g, h);
        null !== a.vb ? (b = J.allocAt(g, h), a.vb.Kd(b), c.documentPoint.assign(b), J.free(b)) : c.documentPoint.h(g, h)
    }

    function Be(a, b, c, d) {
        if (void 0 !== b.targetTouches) {
            if (2 > b.targetTouches.length) return;
            b = b.targetTouches[c]
        } else if (null !== a.lk[0]) b = a.lk[c]; else return;
        c = a.Aa;
        null !== c && (c = c.getBoundingClientRect(), d.h(b.clientX - a.Ea / c.width * c.left, b.clientY - a.Da / c.height * c.top))
    }

    t = Q.prototype;
    t.Ua = function () {
        this.Ei || (this.Ei = !0, this.Kb(!0))
    };

    function Bj(a) {
        a.qc || ij(a);
        a.Ya()
    }

    t.We = function () {
        this.Yb || this.qc || (this.P(), nj(this), hj(this), this.Ua(), this.md())
    };
    t.SA = function () {
        return this.Ne
    };
    t.Yz = function (a) {
        void 0 === a && (a = null);
        var b = this.animationManager, c = b.isEnabled;
        b.Xc();
        b.isEnabled = !1;
        Tf(this);
        this.we = !1;
        this.ft = new J(NaN, NaN);
        b.isEnabled = c;
        this.qc = !0;
        var d = this;
        null !== a && ta(function () {
            d.qc = !1;
            Gh(b, "Model");
            a()
        }, 1)
    };
    t.Kb = function (a) {
        void 0 === a && (a = !1);
        if (!0 !== this.Ne && !(this.Yb || !1 === a && this.qc)) {
            this.Ne = !0;
            var b = this;
            qa.requestAnimationFrame(function () {
                b.Ne && b.md()
            })
        }
    };
    t.md = function () {
        if (!this.Uj || this.Ne) this.Uj && (this.Uj = !1), Tf(this)
    };

    function oj(a, b, c) {
        a.animationManager.defaultAnimation.isAnimating || a.Yb || !a.Fi || fj(a) || (b && ij(a), c && kj(a, !1))
    }

    function Tf(a, b) {
        if (!a.qc && (a.Ne = !1, null !== a.Ja || a.Cm.o())) {
            a.qc = !0;
            var c = a.animationManager, d = a.Ys;
            if (!c.isAnimating && 0 !== d.length) {
                for (var e = d.j, f = e.length, g = 0; g < f; g++) {
                    var h = e[g];
                    Cj(h, !1);
                    h.v()
                }
                d.clear()
            }
            d = a.bv;
            0 < d.count && (d.each(function (a) {
                a.jx()
            }), d.clear());
            e = d = !1;
            c.isAnimating && (e = !0, d = a.skipsUndoManager, a.skipsUndoManager = !0);
            c.yc || Yh(a);
            oj(a, !1, !0);
            null !== a.Pb && (a.Pb.visible && !a.yo && (Dj(a), a.yo = !0), !a.Pb.visible && a.yo && (a.yo = !1));
            ij(a);
            f = !1;
            if (!a.we || a.$g) a.we ? Ej(a, !a.Rj) : (a.Ca("Initial Layout"),
            !1 === c.isEnabled && c.Xc(), Ej(a, !1)), f = !0;
            a.Rj = !1;
            ij(a);
            a.rt || Bj(a);
            oj(a, !0, !1);
            g = !1;
            f ? (c = L.alloc(), c.assign(a.viewportBounds), a.we || (g = a.we = !0, a.skipsUndoManager || (a.undoManager.isPendingClear = !0), a.undoManager.isPendingUnmodified = !0, Fj(a)), a.U("LayoutCompleted"), c.A(a.viewportBounds) || oj(a, !0, !1), L.free(c)) : c.Ll && c.ey && (a.kg !== Mh ? a.scale = lj(a, a.kg) : a.ah !== Mh ? a.scale = lj(a, a.ah) : (c = a.initialScale, isFinite(c) && 0 < c && (a.scale = c)), kj(a, !0));
            ij(a);
            f && g && a.bb("Initial Layout");
            a.Rv();
            b || a.ic(a.Nb);
            e && (a.skipsUndoManager =
                d);
            a.qc = !1
        }
    }

    function Fj(a) {
        var b = a.Fa;
        if (a.kg !== Mh) a.scale = lj(a, a.kg); else if (a.ah !== Mh) a.scale = lj(a, a.ah); else {
            var c = a.initialScale;
            isFinite(c) && 0 < c && (a.scale = c)
        }
        a.Fa !== b && (nj(a), oj(a, !0, !1));
        kj(a, !0);
        b = a.Qa.j;
        a.Od(b, b.length, a);
        a.U("InitialLayoutCompleted");
        a.ft.assign(a.ra);
        Dj(a)
    }

    function ij(a) {
        if ((a.qc || !a.animationManager.isTicking) && 0 !== a.yd.count) {
            for (var b = 0; 23 > b; b++) {
                var c = a.yd.iterator;
                if (null === c || 0 === a.yd.count) break;
                a.yd = new I;
                a.jx(c, a.yd);
                F && 22 === b && Ea("failure to validate parts")
            }
            a.nodes.each(function (a) {
                a instanceof Kf && 0 !== (a.T & 65536) !== !1 && (a.T = a.T ^ 65536)
            })
        }
    }

    t.jx = function (a, b) {
        for (a.reset(); a.next();) {
            var c = a.value;
            !c.Tc() || c instanceof Kf || (c.Cj() ? (c.measure(Infinity, Infinity), c.arrange()) : b.add(c))
        }
        for (a.reset(); a.next();) c = a.value, c instanceof Kf && c.isVisible() && Gj(this, c);
        for (a.reset(); a.next();) c = a.value, c instanceof S && c.isVisible() && (c.Cj() ? (c.measure(Infinity, Infinity), c.arrange()) : b.add(c));
        for (a.reset(); a.next();) c = a.value, c instanceof Xe && c.isVisible() && (c.Cj() ? (c.measure(Infinity, Infinity), c.arrange()) : b.add(c))
    };

    function Gj(a, b) {
        for (var c = Ma(), d = Ma(), e = b.memberParts; e.next();) {
            var f = e.value;
            f.isVisible() && (f instanceof Kf ? (Hj(f) || Ij(f) || Jj(f)) && Gj(a, f) : f instanceof S ? f.fromNode === b || f.toNode === b ? d.push(f) : c.push(f) : (f.measure(Infinity, Infinity), f.arrange()))
        }
        a = c.length;
        for (e = 0; e < a; e++) f = c[e], f.measure(Infinity, Infinity), f.arrange();
        Oa(c);
        b.measure(Infinity, Infinity);
        b.arrange();
        a = d.length;
        for (b = 0; b < a; b++) c = d[b], c.measure(Infinity, Infinity), c.arrange();
        Oa(d)
    }

    t.Od = function (a, b, c, d) {
        if (this.Gi || this.animationManager.isAnimating) {
            void 0 === d && (d = c.viewportBounds);
            for (var e = 0; e < b; e++) a[e].Od(c, d)
        }
    };
    t.ic = function (a, b) {
        void 0 === b && (b = null);
        if (null !== this.Ja) {
            null === this.Aa && v("No canvas specified");
            var c = this.animationManager;
            if (!c.yc && (!c.isAnimating || c.isTicking)) {
                var d = new Date;
                Kj(this);
                if ("0" !== this.Ja.style.opacity) {
                    var e = a !== this.Nb, f = this.Qa.j, g = f.length, h = this;
                    this.Od(f, g, h);
                    if (e) a.Ac(!0), hj(this); else if (!this.Kc && null === b && !c.isAnimating) return;
                    g = this.ra;
                    var k = this.Fa, l = Math.round(g.x * k) / k, m = Math.round(g.y * k) / k;
                    c = this.vb;
                    c.reset();
                    1 !== k && c.scale(k);
                    0 === g.x && 0 === g.y || c.translate(-l, -m);
                    k = this.Zb;
                    a.setTransform(1, 0, 0, 1, 0, 0);
                    a.scale(k, k);
                    a.clearRect(0, 0, this.Ea, this.Da);
                    1 !== this.nb && (a.globalAlpha = this.nb);
                    F && F.Gm && F.Zv && (a.setTransform(1, 0, 0, 1, 0, 0), a.scale(k, k), a.transform(c.m11, c.m12, c.m21, c.m22, c.dx, c.dy), F.Zv(this, a));
                    Lj(this, a);
                    l = null !== b ? function (c) {
                        var d = b;
                        if (c.visible && 0 !== c.nb) {
                            var e = c.Ia.j, f = e.length;
                            if (0 !== f) {
                                var g = zi(c, a), k = c.zp;
                                k.length = 0;
                                for (var l = h.scale, m = L.alloc(), n = 0; n < f; n++) {
                                    var D = e[n];
                                    d.contains(D) || c.nj(a, D, h, k, l, m, !0)
                                }
                                L.free(m);
                                a.globalAlpha = g
                            }
                        }
                    } : function (b) {
                        b.ic(a,
                            h)
                    };
                    g = f.length;
                    for (m = 0; m < g; m++) a.setTransform(1, 0, 0, 1, 0, 0), a.scale(k, k), a.transform(c.m11, c.m12, c.m21, c.m22, c.dx, c.dy), l(f[m]);
                    f = !1;
                    this.Di ? Mj(this.Di, this) && (f = this.hs()) : f = !0;
                    f && (Ib.prototype.Kd = Ib.prototype.py);
                    F && (F.By || F.Gm) && F.$v && F.$v(a, this, c);
                    e ? (this.Nb.Ac(!0), hj(this)) : this.Kc = this.Gi = !1;
                    f = +new Date - +d;
                    e = F && F.Ay;
                    d = this.rv;
                    if (e || null === this.Ih) {
                        d[this.lp] = f;
                        this.lp = (this.lp + 1) % d.length;
                        for (c = f = 0; c < d.length; c++) f += d[c];
                        this.kp = f / d.length
                    }
                    1 !== this.nb && (a.globalAlpha = 1);
                    if (e) for (a.setTransform(1,
                        0, 0, 1, 0, 0), e = 0; e < d.length; e++) a.fillText(d[e].toString(), 20, 150 + +(20 * e))
                }
            }
        }
    };

    function Nj(a, b, c, d, e, f, g, h, k, l) {
        if (null !== a.Ja) {
            null === a.Aa && v("No canvas specified");
            void 0 === g && (g = null);
            void 0 === h && (h = null);
            void 0 === k && (k = !1);
            void 0 === l && (l = !1);
            Kj(a);
            a.Nb.Ac(!0);
            hj(a);
            a.Hi = !0;
            var m = a.Fa;
            a.Fa = e;
            var n = a.Qa.j, p = n.length;
            try {
                var r = new L(f.x, f.y, d.width / e, d.height / e), q = r.copy();
                q.Dq(c);
                Dj(a, q);
                ij(a);
                a.Od(n, p, a, r);
                b.setTransform(1, 0, 0, 1, 0, 0);
                b.clearRect(0, 0, d.width, d.height);
                null !== h && "" !== h && (b.fillStyle = h, b.fillRect(0, 0, d.width, d.height));
                var u = a.Zb;
                b.scale(u, u);
                var x = Ib.alloc();
                x.reset();
                x.translate(c.left, c.top);
                x.scale(e);
                0 === f.x && 0 === f.y || x.translate(-f.x, -f.y);
                b.setTransform(x.m11, x.m12, x.m21, x.m22, x.dx, x.dy);
                Ib.free(x);
                Lj(a, b);
                b.globalAlpha = a.nb;
                if (null !== g) {
                    var y = new I, z = g.iterator;
                    for (z.reset(); z.next();) {
                        var B = z.value;
                        !1 === l && "Grid" === B.layer.name || null === B || y.add(B)
                    }
                    var D = function (c) {
                        if (c.visible && 0 !== c.nb && (k || !c.isTemporary)) {
                            var d = c.Ia.j, e = d.length;
                            if (0 !== e) {
                                var f = zi(c, b), g = c.zp;
                                g.length = 0;
                                for (var h = a.scale, l = L.alloc(), m = 0; m < e; m++) {
                                    var n = d[m];
                                    y.contains(n) &&
                                    c.nj(b, n, a, g, h, l, !1)
                                }
                                L.free(l);
                                b.globalAlpha = f
                            }
                        }
                    }
                } else if (!k && l) {
                    var G = a.grid.part, O = G.layer;
                    D = function (c) {
                        c === O ? G.ic(b, a) : c.ic(b, a, k)
                    }
                } else D = function (c) {
                    c.ic(b, a, k)
                };
                for (c = 0; c < p; c++) D(n[c]);
                a.Hi = !1;
                a.Di && Mj(a.Di, a) && a.hs()
            } finally {
                a.Fa = m, a.Nb.Ac(!0), hj(a), a.Od(n, p, a), Dj(a)
            }
        }
    }

    t.Te = function (a) {
        return this.uf[a]
    };
    t.iz = function (a, b) {
        "minDrawingLength" === a && (this.ep = b);
        this.uf[a] = b;
        this.We()
    };
    t.Jw = function () {
        this.uf = new kb;
        this.uf.drawShadows = !0;
        this.uf.textGreeking = !0;
        this.uf.viewportOptimizations = fb || $a || cb ? !1 : !0;
        this.uf.temporaryPixelRatio = !0;
        this.uf.pictureRatioOptimization = !0;
        this.ep = this.uf.minDrawingLength = 1
    };

    function Lj(a, b) {
        a = a.uf;
        null !== a && (void 0 !== a.imageSmoothingEnabled && b.hz(!!a.imageSmoothingEnabled), a = a.defaultFont, void 0 !== a && null !== a && (b.font = a))
    }

    t.Nm = function (a) {
        return this.Xj[a]
    };
    t.pB = function (a, b) {
        this.Xj[a] = b
    };
    t.Iw = function () {
        this.Xj = new kb;
        this.Xj.extraTouchArea = 10;
        this.Xj.extraTouchThreshold = 10;
        this.Xj.hasGestureZoom = !0
    };
    t.Rw = function (a) {
        Oj(this, a)
    };

    function Oj(a, b) {
        var c = a instanceof W, d = a instanceof Q, e;
        for (e in b) {
            "" === e && v("Setting properties requires non-empty property names");
            var f = a, g = e;
            if (c || d) {
                var h = e.indexOf(".");
                if (0 < h) {
                    var k = e.substring(0, h);
                    if (c) f = a.hb(k); else if (f = a[k], void 0 === f || null === f) f = a.toolManager[k];
                    Ga(f) ? g = e.substr(h + 1) : v("Unable to find object named: " + k + " in " + a.toString() + " when trying to set property: " + e)
                }
            }
            if ("_" !== g[0] && !Ra(f, g)) if (d && "ModelChanged" === g) {
                a.my(b[g]);
                continue
            } else if (d && "Changed" === g) {
                a.Rh(b[g]);
                continue
            } else if (d &&
                Ra(a.toolManager, g)) f = a.toolManager; else if (d && Pj(a, g)) {
                a.vk(g, b[g]);
                continue
            } else if (a instanceof X && "Changed" === g) {
                a.Rh(b[g]);
                continue
            } else v('Trying to set undefined property "' + g + '" on object: ' + f.toString());
            f[g] = b[e];
            "_" === g[0] && f instanceof N && f.iy(g)
        }
    }

    t.Rv = function () {
        if (0 === this.undoManager.transactionLevel && 0 !== this.ih.count) {
            for (; 0 < this.ih.count;) {
                var a = this.ih;
                this.ih = new Db;
                for (a = a.iterator; a.next();) {
                    var b = a.key;
                    b.Yq(a.value);
                    b.jc()
                }
            }
            this.P()
        }
    };
    t.P = function (a) {
        void 0 === a && (a = null);
        if (null === a) this.Kc = !0, this.Kb(); else {
            var b = this.viewportBounds;
            null !== a && a.o() && b.Sc(a) && (this.Kc = !0, this.Kb())
        }
        this.U("InvalidateDraw")
    };
    t.Uy = function (a, b) {
        if (!0 !== this.Kc) {
            this.Kc = !0;
            var c = !0 === this.Te("temporaryPixelRatio");
            if (!0 === this.Te("viewportOptimizations") && this.scrollMode !== pi && this.bj.pj(0, 0, 0, 0) && b.width === a.width && b.height === a.height) {
                var d = this.scale, e = Math.max(a.x, b.x), f = Math.max(a.y, b.y);
                d = L.allocAt(e, f, Math.max(0, Math.min(a.x + a.width, b.x + b.width) - e) * d, Math.max(0, Math.min(a.y + a.height, b.y + b.height) - f) * d);
                if (!this.pq && 0 < d.width && 0 < d.height) {
                    if (!(this.qc || (this.Ne = !1, null === this.Ja || (this.qc = !0, this.Rv(), this.documentBounds.o() ||
                    Qj(this, this.computeBounds()), e = this.Aa, null === e || e instanceof Rj)))) {
                        var g = this.Zb;
                        f = this.Ea * g;
                        var h = this.Da * g, k = this.scale * g,
                            l = Math.round(Math.round(b.x * k) - Math.round(a.x * k));
                        b = Math.round(Math.round(b.y * k) - Math.round(a.y * k));
                        k = this.Tu;
                        a = this.Hx;
                        k.width !== f && (k.width = f);
                        k.height !== h && (k.height = h);
                        a.clearRect(0, 0, f, h);
                        k = 190 * g;
                        var m = 70 * g, n = Math.max(l, 0), p = Math.max(b, 0), r = Math.floor(f - n),
                            q = Math.floor(h - p);
                        a.drawImage(e.La, n, p, r, q, 0, 0, r, q);
                        Mj(this.Di, this) && a.clearRect(0, 0, k, m);
                        e = Ma();
                        a = Ma();
                        q = Math.abs(l);
                        r = Math.abs(b);
                        var u = 0 === n ? 0 : f - q;
                        n = J.allocAt(u, 0);
                        q = J.allocAt(q + u, h);
                        a.push(new L(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y)));
                        var x = this.vb;
                        x.reset();
                        x.scale(g, g);
                        1 !== this.Fa && x.scale(this.Fa);
                        g = this.ra;
                        (0 !== g.x || 0 !== g.y) && isFinite(g.x) && isFinite(g.y) && x.translate(-g.x, -g.y);
                        Jb(n, x);
                        Jb(q, x);
                        e.push(new L(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y)));
                        u = 0 === p ? 0 : h - r;
                        n.h(0, u);
                        q.h(f, r + u);
                        a.push(new L(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x -
                            q.x), Math.abs(n.y - q.y)));
                        Jb(n, x);
                        Jb(q, x);
                        e.push(new L(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y)));
                        Mj(this.Di, this) && (f = 0 < l ? 0 : -l, h = 0 < b ? 0 : -b, n.h(f, h), q.h(k + f, m + h), a.push(new L(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y))), Jb(n, x), Jb(q, x), e.push(new L(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y))));
                        J.free(n);
                        J.free(q);
                        oj(this, !1, !0);
                        null === this.Ja && v("No div specified");
                        null === this.Aa && v("No canvas specified");
                        if (!this.animationManager.yc &&
                            (f = this.Nb, this.Kc)) {
                            Kj(this);
                            h = this.Zb;
                            f.setTransform(1, 0, 0, 1, 0, 0);
                            f.clearRect(0, 0, this.Ea * h, this.Da * h);
                            f.drawImage(this.Tu.La, 0 < l ? 0 : Math.round(-l), 0 < b ? 0 : Math.round(-b));
                            b = this.ra;
                            g = this.Fa;
                            k = Math.round(b.x * g) / g;
                            m = Math.round(b.y * g) / g;
                            l = this.vb;
                            l.reset();
                            1 !== g && l.scale(g);
                            0 === b.x && 0 === b.y || l.translate(-k, -m);
                            f.save();
                            f.beginPath();
                            b = a.length;
                            for (g = 0; g < b; g++) k = a[g], 0 !== k.width && 0 !== k.height && f.rect(Math.floor(k.x), Math.floor(k.y), Math.ceil(k.width), Math.ceil(k.height));
                            f.clip();
                            f.setTransform(1, 0,
                                0, 1, 0, 0);
                            f.scale(h, h);
                            f.transform(l.m11, l.m12, l.m21, l.m22, l.dx, l.dy);
                            F && F.Gm && F.Zv && F.Zv(this, f);
                            h = this.Qa.j;
                            b = h.length;
                            this.Od(h, b, this);
                            Lj(this, f);
                            f.globalAlpha = this.nb;
                            for (g = 0; g < b; g++) if (k = h[g], m = e, k.visible && 0 !== k.nb) {
                                p = zi(k, f);
                                n = k.zp;
                                n.length = 0;
                                r = this.scale;
                                q = L.alloc();
                                x = k.Ia.j;
                                u = x.length;
                                for (var y = m.length, z = 0; z < u; z++) {
                                    var B = x[z];
                                    a:{
                                        var D = Sj(B, B.actualBounds);
                                        for (var G = m, O = y, U = 2 / r, R = 4 / r, fa = 0; fa < O; fa++) {
                                            var Y = G[fa];
                                            if (0 !== Y.width && 0 !== Y.height && D.ow(Y.x - U, Y.y - U, Y.width + R, Y.height + R)) {
                                                D = !0;
                                                break a
                                            }
                                        }
                                        D =
                                            !1
                                    }
                                    D && k.nj(f, B, this, n, r, q, !0)
                                }
                                L.free(q);
                                f.globalAlpha = p
                            }
                            f.restore();
                            f.Ac(!0);
                            F && (F.By || F.Gm) && F.$v && F.$v(f, this, l);
                            this.Di && Mj(this.Di, this) && this.hs();
                            this.Kc = this.Gi = !1;
                            this.kr()
                        }
                        Oa(e);
                        Oa(a);
                        this.qc = !1
                    }
                } else this.md();
                L.free(d);
                c && (nf(this), this.md(), Af(this, !0))
            } else c ? (nf(this), this.md(), Af(this, !0)) : this.md()
        }
    };

    function nj(a) {
        !1 === a.Fi && (a.Fi = !0)
    }

    function hj(a) {
        !1 === a.Gi && (a.Gi = !0)
    }

    function Kj(a) {
        !1 !== a.Ql && (a.Ql = !1, Tj(a, a.Ea, a.Da))
    }

    function Tj(a, b, c) {
        var d = a.Zb;
        a.Aa.resize(b * d, c * d, b, c) && (a.Kc = !0, a.Nb.Ac(!0))
    }

    function fj(a) {
        var b = a.Aa;
        if (null === b) return !0;
        var c = a.Ja, d = a.Ea, e = a.Da, f = a.viewportBounds.copy();
        if (!f.o()) return !0;
        var g = !1, h = a.jf ? a.ub : 0, k = a.ve ? a.ub : 0, l = c.clientWidth || d + h, m = c.clientHeight || e + k;
        if (l !== d + h || m !== e + k) a.jf = !1, a.ve = !1, k = h = 0, a.Ea = l, a.Da = m, g = a.Ql = !0;
        if (!(g || a.jf || a.ve || a.Hl || a.Il)) return !0;
        a.Fi = !1;
        var n = a.viewportBounds, p = a.documentBounds, r = 0, q = 0, u = 0, x = 0;
        c = n.width;
        var y = n.height, z = a.bj;
        a.contentAlignment.cb() ? (p.width > c && (r = z.left, q = z.right), p.height > y && (u = z.top, x = z.bottom)) : (r = z.left,
            q = z.right, u = z.top, x = z.bottom);
        z = p.width + r + q;
        var B = p.height + u + x;
        r = p.x - r;
        var D = n.x;
        q = p.right + q;
        var G = n.right + h;
        u = p.y - u;
        var O = n.y;
        p = p.bottom + x;
        n = n.bottom + k;
        var U = "1px", R = "1px";
        x = a.scale;
        l = z > l / x;
        m = B > m / x;
        a.scrollMode === ni && (l || m) && (l && a.hasHorizontalScrollbar && a.allowHorizontalScroll && (l = 1, r + 1 < D && (l = Math.max((D - r) * x + a.Ea, l)), q > G + 1 && (l = Math.max((q - G) * x + a.Ea, l)), c + h + 1 < z && (l = Math.max((z - c) * x + a.Ea, l)), U = l.toString() + "px"), m && a.hasVerticalScrollbar && a.allowVerticalScroll && (l = 1, u + 1 < O && (l = Math.max((O - u) * x + a.Da,
            l)), p > n + 1 && (l = Math.max((p - n) * x + a.Da, l)), y + k + 1 < B && (l = Math.max((B - y) * x + a.Da, l)), R = l.toString() + "px"));
        l = "1px" !== U;
        m = "1px" !== R;
        l && m || !l && !m || (m && (G -= a.ub), l && (n -= a.ub), z < c + h || !a.hasHorizontalScrollbar || !a.allowHorizontalScroll || (h = 1, r + 1 < D && (h = Math.max((D - r) * x + a.Ea, h)), q > G + 1 && (h = Math.max((q - G) * x + a.Ea, h)), c + 1 < z && (h = Math.max((z - c) * x + a.Ea, h)), U = h.toString() + "px"), l = "1px" !== U, h = a.Da, l !== a.ve && (h = l ? a.Da - a.ub : a.Da + a.ub), B < y + k || !a.hasVerticalScrollbar || !a.allowVerticalScroll || (k = 1, u + 1 < O && (k = Math.max((O - u) * x +
            h, k)), p > n + 1 && (k = Math.max((p - n) * x + h, k)), y + 1 < B && (k = Math.max((B - y) * x + h, k)), R = k.toString() + "px"), m = "1px" !== R);
        if (a.Vp && l === a.ve && m === a.jf) return d === a.Ea && e === a.Da || a.md(), !1;
        l !== a.ve && ("1px" === U ? a.Da = a.Da + a.ub : a.Da = Math.max(a.Da - a.ub, 1), g = !0);
        a.ve = l;
        a.Wp.style.width = U;
        m !== a.jf && ("1px" === R ? a.Ea = a.Ea + a.ub : a.Ea = Math.max(a.Ea - a.ub, 1), g = !0, a.Sl && (k = J.alloc(), m ? (b.style.left = a.ub + "px", a.position = k.h(a.ra.x + a.ub / a.scale, a.ra.y)) : (b.style.left = "0px", a.position = k.h(a.ra.x - a.ub / a.scale, a.ra.y)), J.free(k)));
        a.jf =
            m;
        a.Wp.style.height = R;
        a.ht = !0;
        g && (a.Ql = !0);
        b = a.kt;
        k = b.scrollLeft;
        a.hasHorizontalScrollbar && a.allowHorizontalScroll && (c + 1 < z ? k = (a.position.x - r) * x : r + 1 < D ? k = b.scrollWidth - b.clientWidth : q > G + 1 && (k = a.position.x * x));
        if (a.Sl) switch (a.et) {
            case "negative":
                k = -(b.scrollWidth - k - b.clientWidth);
                break;
            case "reverse":
                k = b.scrollWidth - k - b.clientWidth
        }
        b.scrollLeft = k;
        a.hasVerticalScrollbar && a.allowVerticalScroll && (y + 1 < B ? b.scrollTop = (a.position.y - u) * x : u + 1 < O ? b.scrollTop = b.scrollHeight - b.clientHeight : p > n + 1 && (b.scrollTop = a.position.y *
            x));
        l = a.Ea;
        m = a.Da;
        b.style.width = l + (a.jf ? a.ub : 0) + "px";
        b.style.height = m + (a.ve ? a.ub : 0) + "px";
        return d !== l || e !== m || a.animationManager.yc ? (a.gr(f, a.viewportBounds, x, g), !1) : !0
    }

    t.add = function (a) {
        w(a, T, Q, "add:part");
        var b = a.diagram;
        if (b !== this && (null !== b && v("Cannot add part " + a.toString() + " to " + this.toString() + ". It is already a part of " + b.toString()), b = this.Km(a.layerName), null === b && (b = this.Km("")), null === b && v('Cannot add a Part when unable find a Layer named "' + a.layerName + '" and there is no default Layer'), a.layer !== b)) {
            var c = b.yj(99999999, a, a.diagram === this);
            0 <= c && this.ib(Ne, "parts", b, null, a, null, c);
            b.isTemporary || this.Ua();
            a.D(1);
            c = a.layerChanged;
            null !== c && c(a, null,
                b)
        }
    };
    t.yj = function (a) {
        this.partManager.yj(a);
        var b = this;
        Uj(a, function (a) {
            Vj(b, a)
        });
        (a instanceof Xe || a instanceof Kf && null !== a.placeholder) && a.v();
        null !== a.data && Uj(a, function (a) {
            Wj(b.partManager, a)
        });
        !0 !== Ij(a) && !0 !== Jj(a) || this.yd.add(a);
        Xj(a, !0, this);
        Yj(a) ? (a.actualBounds.o() && this.P(Sj(a, a.actualBounds)), this.Ua()) : a.isVisible() && a.actualBounds.o() && this.P(Sj(a, a.actualBounds));
        this.Kb()
    };
    t.Rc = function (a) {
        a.yk();
        this.partManager.Rc(a);
        var b = this;
        null !== a.data && Uj(a, function (a) {
            Zj(b.partManager, a, b)
        });
        this.yd.remove(a);
        Yj(a) ? (a.actualBounds.o() && this.P(Sj(a, a.actualBounds)), this.Ua()) : a.isVisible() && a.actualBounds.o() && this.P(Sj(a, a.actualBounds));
        this.Kb()
    };
    t.remove = function (a) {
        w(a, T, Q, "remove:part");
        ak(this, a, !0)
    };

    function ak(a, b, c) {
        var d = b.layer;
        null !== d && d.diagram === a && (b.isSelected = !1, b.isHighlighted = !1, b.D(2), c && b.Ek(), c = d.Rc(-1, b, !1), 0 <= c && a.ib(Oe, "parts", d, b, null, c, null), a = b.layerChanged, null !== a && a(b, d, null))
    }

    t.ru = function (a, b) {
        if (Ha(a)) for (var c = a.length, d = 0; d < c; d++) {
            var e = a[d];
            b && !e.canDelete() || this.remove(e)
        } else for (c = new I, c.addAll(a), a = c.iterator; a.next();) c = a.value, b && !c.canDelete() || this.remove(c)
    };
    t.Dk = function (a, b, c) {
        return this.partManager.Dk(a, b, c)
    };
    Q.prototype.moveParts = function (a, b, c, d) {
        void 0 === d && (d = bk(this));
        w(b, J, Q, "moveParts:offset");
        if (null !== this.toolManager) {
            var e = new Db;
            if (null !== a) if (Ha(a)) for (var f = 0; f < a.length; f++) ck(this, e, a[f], c, d); else for (a = a.iterator; a.next();) ck(this, e, a.value, c, d); else {
                for (a = this.parts; a.next();) ck(this, e, a.value, c, d);
                for (a = this.nodes; a.next();) ck(this, e, a.value, c, d);
                for (a = this.links; a.next();) ck(this, e, a.value, c, d)
            }
            Hf(this, e, b, d, c)
        }
    };

    function ck(a, b, c, d, e, f) {
        if (!b.contains(c) && (void 0 === f && (f = !1), !d || f || c.canMove() || c.canCopy())) if (void 0 === e && (e = bk(a)), c instanceof V) {
            b.add(c, a.Ed(e, c, c.location));
            if (c instanceof Kf && (null !== c.placeholder || e.dragsMembers)) for (f = c.memberParts; f.next();) ck(a, b, f.value, d, e, e.groupsAlwaysMove);
            for (f = c.linksConnected; f.next();) {
                var g = f.value;
                if (!b.contains(g)) {
                    var h = g.fromNode, k = g.toNode;
                    null !== h && b.contains(h) && null !== k && b.contains(k) && ck(a, b, g, d, e)
                }
            }
            if (e.dragsTree) for (c = c.hw(); c.next();) ck(a, b,
                c.value, d, e)
        } else if (c instanceof S) for (b.add(c, a.Ed(e, c)), c = c.labelNodes; c.next();) ck(a, b, c.value, d, e); else c instanceof Xe || b.add(c, a.Ed(e, c, c.location))
    }

    function Hf(a, b, c, d, e) {
        if (null !== b && (w(b, Db, Q, "moveParts:parts"), 0 !== b.count)) {
            var f = J.alloc(), g = J.alloc();
            g.assign(c);
            isNaN(g.x) && (g.x = 0);
            isNaN(g.y) && (g.y = 0);
            (c = a.oq) || of(a, b);
            for (var h = Ma(), k = Ma(), l = b.iterator, m = J.alloc(); l.next();) {
                var n = l.key, p = l.value;
                if (n.Tc()) {
                    var r = dk(a, n, b);
                    if (null !== r) h.push(new ek(n, p, r)); else if (!e || n.canMove()) r = p.point, f.assign(r), a.computeMove(n, f.add(g), d, m), n.location = m, void 0 === p.shifted && (p.shifted = new J), p.shifted.assign(m.ke(r))
                } else l.key instanceof S && k.push(l.qa)
            }
            J.free(m);
            e = h.length;
            for (l = 0; l < e; l++) n = h[l], f.assign(n.info.point), void 0 === n.lw.shifted && (n.lw.shifted = new J), n.node.location = f.add(n.lw.shifted);
            e = J.alloc();
            l = J.alloc();
            n = k.length;
            for (p = 0; p < n; p++) {
                var q = k[p];
                r = q.key;
                if (r instanceof S) if (r.suspendsRouting) {
                    r.Dg = null;
                    m = r.fromNode;
                    var u = r.toNode;
                    if (null !== a.draggedLink && d.dragsLink) if (u = q.value.point, null === r.dragComputation) b.add(r, a.Ed(d, r, g)), Ff(r, g.x - u.x, g.y - u.y); else {
                        q = J.allocAt(0, 0);
                        (m = r.i(0)) && m.o() && q.assign(m);
                        var x = m = J.alloc().assign(q).add(g);
                        d.isGridSnapEnabled &&
                        (d.isGridSnapRealtime || a.lastInput.up) && (x = J.alloc(), Vg(a, r, m, x, d));
                        m.assign(r.dragComputation(r, m, x)).ke(q);
                        b.add(r, a.Ed(d, r, m));
                        Ff(r, m.x - u.x, m.y - u.y);
                        J.free(q);
                        J.free(m);
                        x !== m && J.free(x)
                    } else null !== m && (e.assign(m.location), x = b.K(m), null !== x && e.ke(x.point)), null !== u && (l.assign(u.location), x = b.K(u), null !== x && l.ke(x.point)), null !== m && null !== u ? e.Ta(l) ? (m = q.value.point, u = f, u.assign(e), u.ke(m), b.add(r, a.Ed(d, r, e)), Ff(r, u.x, u.y)) : (r.suspendsRouting = !1, r.Za()) : (q = q.value.point, m = null !== m ? e : null !== u ? l :
                        g, b.add(r, a.Ed(d, r, m)), Ff(r, m.x - q.x, m.y - q.y))
                } else if (null === r.fromNode || null === r.toNode) m = q.value.point, b.add(r, a.Ed(d, r, g)), Ff(r, g.x - m.x, g.y - m.y)
            }
            J.free(f);
            J.free(g);
            J.free(e);
            J.free(l);
            Oa(h);
            Oa(k);
            c || (ij(a), tf(a, b))
        }
    }

    Q.prototype.computeMove = function (a, b, c, d) {
        void 0 === d && (d = new J);
        d.assign(b);
        if (null === a) return d;
        var e = b, f = c.isGridSnapEnabled;
        f && (c.isGridSnapRealtime || this.lastInput.up) && (e = J.alloc(), Vg(this, a, b, e, c));
        c = null !== a.dragComputation ? a.dragComputation(a, b, e) : e;
        var g = a.minLocation, h = g.x;
        isNaN(h) && (h = f ? Math.round(1E3 * a.location.x) / 1E3 : a.location.x);
        g = g.y;
        isNaN(g) && (g = f ? Math.round(1E3 * a.location.y) / 1E3 : a.location.y);
        var k = a.maxLocation, l = k.x;
        isNaN(l) && (l = f ? Math.round(1E3 * a.location.x) / 1E3 : a.location.x);
        k = k.y;
        isNaN(k) && (k = f ? Math.round(1E3 * a.location.y) / 1E3 : a.location.y);
        d.h(Math.max(h, Math.min(c.x, l)), Math.max(g, Math.min(c.y, k)));
        e !== b && J.free(e);
        return d
    };

    function bk(a) {
        var b = a.toolManager.findTool("Dragging");
        return null !== b ? b.dragOptions : a.ul
    }

    function Vg(a, b, c, d, e) {
        void 0 === e && (e = bk(a));
        d.assign(c);
        if (null !== b) {
            var f = a.grid;
            b = e.gridSnapCellSize;
            a = b.width;
            b = b.height;
            var g = e.gridSnapOrigin, h = g.x;
            g = g.y;
            e = e.gridSnapCellSpot;
            if (null !== f) {
                var k = f.gridCellSize;
                isNaN(a) && (a = k.width);
                isNaN(b) && (b = k.height);
                f = f.gridOrigin;
                isNaN(h) && (h = f.x);
                isNaN(g) && (g = f.y)
            }
            f = J.allocAt(0, 0);
            f.al(0, 0, a, b, e);
            K.Pq(c.x, c.y, h + f.x, g + f.y, a, b, d);
            J.free(f)
        }
    }

    function of(a, b) {
        if (null !== b) for (a.oq = !0, a = b.iterator; a.next();) b = a.key, b instanceof S && (b.suspendsRouting = !0)
    }

    function tf(a, b) {
        if (null !== b) {
            for (b = b.iterator; b.next();) {
                var c = b.key;
                c instanceof S && (c.suspendsRouting = !1, fk(c) && c.Za())
            }
            a.oq = !1
        }
    }

    function dk(a, b, c) {
        b = b.containingGroup;
        if (null !== b) {
            a = dk(a, b, c);
            if (null !== a) return a;
            a = c.K(b);
            if (null !== a) return a
        }
        return null
    }

    t = Q.prototype;
    t.Ed = function (a, b, c) {
        if (void 0 === c) return new rf(Ob);
        var d = a.isGridSnapEnabled;
        a.groupsSnapMembers || null === b.containingGroup || (d = !1);
        return d ? new rf(new J(Math.round(1E3 * c.x) / 1E3, Math.round(1E3 * c.y) / 1E3)) : new rf(c.copy())
    };

    function gk(a, b, c) {
        w(b, xi, Q, "addLayer:layer");
        null !== b.diagram && b.diagram !== a && v("Cannot share a Layer with another Diagram: " + b + " of " + b.diagram);
        null === c ? null !== b.diagram && v("Cannot add an existing Layer to this Diagram again: " + b) : (w(c, xi, Q, "addLayer:existingLayer"), c.diagram !== a && v("Existing Layer must be in this Diagram: " + c + " not in " + c.diagram), b === c && v("Cannot move a Layer before or after itself: " + b));
        if (b.diagram !== a) {
            b = b.name;
            a = a.Qa;
            c = a.count;
            for (var d = 0; d < c; d++) a.M(d).name === b && v("Cannot add Layer with the name '" +
                b + "'; a Layer with the same name is already present in this Diagram.")
        }
    }

    t.Em = function (a) {
        gk(this, a, null);
        a.ie(this);
        var b = this.Qa, c = b.count - 1;
        if (!a.isTemporary) for (; 0 <= c && b.M(c).isTemporary;) c--;
        b.Bb(c + 1, a);
        null !== this.hc && this.ib(Ne, "layers", this, null, a, null, c + 1);
        this.P();
        this.Ua()
    };
    t.jy = function (a, b) {
        gk(this, a, b);
        a.ie(this);
        var c = this.Qa, d = c.indexOf(a);
        0 <= d && (c.remove(a), null !== this.hc && this.ib(Oe, "layers", this, a, null, d, null));
        var e = c.count, f;
        for (f = 0; f < e; f++) if (c.M(f) === b) {
            c.Bb(f, a);
            break
        }
        null !== this.hc && this.ib(Ne, "layers", this, null, a, null, f);
        this.P();
        0 > d && this.Ua()
    };
    t.Dz = function (a, b) {
        gk(this, a, b);
        a.ie(this);
        var c = this.Qa, d = c.indexOf(a);
        0 <= d && (c.remove(a), null !== this.hc && this.ib(Oe, "layers", this, a, null, d, null));
        var e = c.count, f;
        for (f = 0; f < e; f++) if (c.M(f) === b) {
            c.Bb(f + 1, a);
            break
        }
        null !== this.hc && this.ib(Ne, "layers", this, null, a, null, f + 1);
        this.P();
        0 > d && this.Ua()
    };
    t.iB = function (a) {
        w(a, xi, Q, "removeLayer:layer");
        a.diagram !== this && v("Cannot remove a Layer from another Diagram: " + a + " of " + a.diagram);
        if ("" !== a.name) {
            var b = this.Qa, c = b.indexOf(a);
            if (b.remove(a)) {
                for (b = a.Ia.copy().iterator; b.next();) {
                    var d = b.value, e = d.layerName;
                    e !== a.name ? d.layerName = e : d.layerName = ""
                }
                null !== this.hc && this.ib(Oe, "layers", this, a, null, c, null);
                this.P();
                this.Ua()
            }
        }
    };
    t.Km = function (a) {
        for (var b = this.layers; b.next();) {
            var c = b.value;
            if (c.name === a) return c
        }
        return null
    };
    t.my = function (a) {
        A(a, "function", Q, "addModelChangedListener:listener");
        null === this.De && (this.De = new H);
        this.De.add(a);
        this.model.Rh(a)
    };
    t.kB = function (a) {
        A(a, "function", Q, "removeModelChangedListener:listener");
        null !== this.De && (this.De.remove(a), 0 === this.De.count && (this.De = null));
        this.model.$k(a)
    };
    t.Rh = function (a) {
        A(a, "function", Q, "addChangedListener:listener");
        null === this.$f && (this.$f = new H);
        this.$f.add(a)
    };
    t.$k = function (a) {
        A(a, "function", Q, "removeChangedListener:listener");
        null !== this.$f && (this.$f.remove(a), 0 === this.$f.count && (this.$f = null))
    };
    t.Kt = function (a) {
        this.skipsUndoManager || this.model.skipsUndoManager || this.model.undoManager.mw(a);
        a.change !== Me && (this.isModified = !0);
        if (null !== this.$f) for (var b = this.$f, c = b.length, d = 0; d < c; d++) b.M(d)(a)
    };
    t.ib = function (a, b, c, d, e, f, g) {
        void 0 === f && (f = null);
        void 0 === g && (g = null);
        var h = new Ke;
        h.diagram = this;
        h.change = a;
        h.propertyName = b;
        h.object = c;
        h.oldValue = d;
        h.oldParam = f;
        h.newValue = e;
        h.newParam = g;
        this.Kt(h)
    };
    t.g = function (a, b, c, d, e) {
        this.ib(Le, a, this, b, c, d, e)
    };
    Q.prototype.changeState = function (a, b) {
        if (null !== a && a.diagram === this) {
            var c = this.skipsModelSourceBindings;
            try {
                this.skipsModelSourceBindings = !0;
                var d = a.change;
                if (d === Le) {
                    var e = a.object;
                    hk(e, a.propertyName, a.K(b));
                    if (e instanceof N) {
                        var f = e.part;
                        null !== f && f.Sb()
                    }
                    this.isModified = !0
                } else if (d === Ne) {
                    var g = a.object, h = a.newParam, k = a.newValue;
                    if (g instanceof W) if ("number" === typeof h && k instanceof N) {
                        b ? g.Rc(h) : g.Bb(h, k);
                        var l = g.part;
                        null !== l && l.Sb()
                    } else {
                        if ("number" === typeof h && k instanceof ik) if (b) k.isRow ?
                            g.Gw(h) : g.Ew(h); else {
                            var m = k.isRow ? g.getRowDefinition(k.index) : g.getColumnDefinition(k.index);
                            m.Ot(k)
                        }
                    } else if (g instanceof xi) {
                        var n = !0 === a.oldParam;
                        "number" === typeof h && k instanceof T && (b ? (k.isSelected = !1, k.isHighlighted = !1, k.Sb(), g.Rc(n ? h : -1, k, n)) : g.yj(h, k, n))
                    } else g instanceof Q ? "number" === typeof h && k instanceof xi && (b ? this.Qa.jb(h) : (k.ie(this), this.Qa.Bb(h, k))) : v("unknown ChangedEvent.Insert object: " + a.toString());
                    this.isModified = !0
                } else if (d === Oe) {
                    var p = a.object, r = a.oldParam, q = a.oldValue;
                    if (p instanceof
                        W) "number" === typeof r && q instanceof N ? b ? p.Bb(r, q) : p.Rc(r) : "number" === typeof r && q instanceof ik && (b ? (m = q.isRow ? p.getRowDefinition(q.index) : p.getColumnDefinition(q.index), m.Ot(q)) : q.isRow ? p.Gw(r) : p.Ew(r)); else if (p instanceof xi) {
                        var u = !0 === a.newParam;
                        "number" === typeof r && q instanceof T && (b ? 0 > p.Ia.indexOf(q) && p.yj(r, q, u) : (q.isSelected = !1, q.isHighlighted = !1, q.Sb(), p.Rc(u ? r : -1, q, u)))
                    } else p instanceof Q ? "number" === typeof r && q instanceof xi && (b ? (q.ie(this), this.Qa.Bb(r, q)) : this.Qa.jb(r)) : v("unknown ChangedEvent.Remove object: " +
                        a.toString());
                    this.isModified = !0
                } else d !== Me && v("unknown ChangedEvent: " + a.toString())
            } finally {
                this.skipsModelSourceBindings = c
            }
        }
    };
    Q.prototype.Ca = function (a) {
        return this.undoManager.Ca(a)
    };
    Q.prototype.bb = function (a) {
        return this.undoManager.bb(a)
    };
    Q.prototype.Uf = function () {
        return this.undoManager.Uf()
    };
    Q.prototype.commit = function (a, b) {
        void 0 === b && (b = "");
        var c = this.skipsUndoManager;
        null === b && (this.skipsUndoManager = !0, b = "");
        this.undoManager.Ca(b);
        var d = !1;
        try {
            a(this), d = !0
        } finally {
            d ? this.undoManager.bb(b) : this.undoManager.Uf(), this.skipsUndoManager = c
        }
    };
    Q.prototype.updateAllTargetBindings = function (a) {
        this.partManager.updateAllTargetBindings(a)
    };
    Q.prototype.xr = function () {
        this.partManager.xr()
    };

    function jk(a, b, c) {
        var d = a.animationManager;
        if (a.Yb || a.qc) a.Fa = c, d.rf && d.Rd.add(d.B, "scale", b, a.Fa); else if (null === a.Aa) a.Fa = c; else {
            a.Yb = !0;
            var e = a.viewportBounds.copy(), f = a.Ea, g = a.Da;
            e.width = a.Ea / b;
            e.height = a.Da / b;
            var h = a.zoomPoint.x, k = a.zoomPoint.y, l = a.contentAlignment;
            isNaN(h) && (l.Uc() ? l.Qf(Tc) ? h = 0 : l.Qf(Uc) && (h = f - 1) : h = l.cb() ? l.x * (f - 1) : f / 2);
            isNaN(k) && (l.Uc() ? l.Qf(Sc) ? k = 0 : l.Qf(Vc) && (k = g - 1) : k = l.cb() ? l.y * (g - 1) : g / 2);
            null === a.scaleComputation || a.animationManager.isAnimating || (c = a.scaleComputation(a,
                c));
            c < a.minScale && (c = a.minScale);
            c > a.maxScale && (c = a.maxScale);
            f = J.allocAt(a.ra.x + h / b - h / c, a.ra.y + k / b - k / c);
            a.position = f;
            J.free(f);
            a.Fa = c;
            a.gr(e, a.viewportBounds, b, !1);
            a.Yb = !1;
            kj(a, !1);
            d.rf && d.Rd.add(d.B, "scale", b, a.Fa);
            a.P();
            nj(a)
        }
    }

    Q.prototype.gr = function (a, b, c, d) {
        if (!a.A(b)) {
            void 0 === d && (d = !1);
            d || nj(this);
            hj(this);
            var e = this.layout;
            null === e || !e.isViewportSized || this.autoScale !== Mh || d || a.width === b.width && a.height === b.height || e.D();
            e = this.currentTool;
            !0 === this.lg && e instanceof Ua && (this.lastInput.documentPoint = this.yu(this.lastInput.viewPoint), ff(e, this));
            this.Yb || this.Uy(a, b);
            Dj(this);
            this.de.scale = c;
            this.de.position.x = a.x;
            this.de.position.y = a.y;
            this.de.bounds.assign(a);
            this.de.sw = d;
            this.U("ViewportBoundsChanged", this.de, a);
            this.isVirtualized && this.links.each(function (a) {
                a.isAvoiding && a.actualBounds.Sc(b) && a.Za()
            })
        }
    };

    function Dj(a, b) {
        void 0 === b && (b = null);
        var c = a.Pb;
        if (null !== c && c.visible) {
            for (var d = Hb.alloc(), e = 1, f = 1, g = c.$.j, h = g.length, k = 0; k < h; k++) {
                var l = g[k], m = l.interval;
                2 > m || (kk(l.figure) ? f = f * m / K.Iy(f, m) : e = e * m / K.Iy(e, m))
            }
            g = c.gridCellSize;
            d.h(f * g.width, e * g.height);
            if (null !== b) e = b.width, f = b.height, a = b.x, g = b.y; else {
                b = L.alloc();
                a = a.viewportBounds;
                b.h(a.x, a.y, a.width, a.height);
                if (!b.o()) {
                    L.free(b);
                    return
                }
                e = b.width;
                f = b.height;
                a = b.x;
                g = b.y;
                L.free(b)
            }
            c.width = e + 2 * d.width;
            c.height = f + 2 * d.height;
            b = J.alloc();
            K.Pq(a, g, 0, 0,
                d.width, d.height, b);
            b.offset(-d.width, -d.height);
            Hb.free(d);
            c.part.location = b;
            J.free(b)
        }
    }

    Q.prototype.clearSelection = function (a) {
        void 0 === a && (a = !1);
        var b = this.selection;
        if (0 !== b.count) {
            a || this.U("ChangingSelection", b);
            for (var c = b.ta(), d = c.length, e = 0; e < d; e++) c[e].isSelected = !1;
            b.ka();
            b.clear();
            b.freeze();
            a || this.U("ChangedSelection", b)
        }
    };
    Q.prototype.select = function (a) {
        null !== a && (w(a, T, Q, "select:part"), a.layer.diagram === this && (!a.isSelected || 1 < this.selection.count) && (this.U("ChangingSelection", this.selection), this.clearSelection(!0), a.isSelected = !0, this.U("ChangedSelection", this.selection)))
    };
    Q.prototype.oB = function (a) {
        this.U("ChangingSelection", this.selection);
        this.clearSelection(!0);
        if (Ha(a)) for (var b = a.length, c = 0; c < b; c++) {
            var d = a[c];
            d instanceof T || v("Diagram.selectCollection given something that is not a Part: " + d);
            d.isSelected = !0
        } else for (a = a.iterator; a.next();) b = a.value, b instanceof T || v("Diagram.selectCollection given something that is not a Part: " + b), b.isSelected = !0;
        this.U("ChangedSelection", this.selection)
    };
    Q.prototype.clearHighlighteds = function () {
        var a = this.highlighteds;
        if (0 < a.count) {
            for (var b = a.ta(), c = b.length, d = 0; d < c; d++) b[d].isHighlighted = !1;
            a.ka();
            a.clear();
            a.freeze()
        }
    };
    t = Q.prototype;
    t.MA = function (a) {
        null !== a && a.layer.diagram === this && (w(a, T, Q, "highlight:part"), !a.isHighlighted || 1 < this.highlighteds.count) && (this.clearHighlighteds(), a.isHighlighted = !0)
    };
    t.NA = function (a) {
        a = (new I).addAll(a);
        for (var b = this.highlighteds.copy().lr(a).iterator; b.next();) b.value.isHighlighted = !1;
        for (a = a.iterator; a.next();) b = a.value, b instanceof T || v("Diagram.highlightCollection given something that is not a Part: " + b), b.isHighlighted = !0
    };
    t.scroll = function (a, b, c) {
        void 0 === c && (c = 1);
        var d = "up" === b || "down" === b, e = 0;
        if ("pixel" === a) e = c; else if ("line" === a) e = c * (d ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange); else if ("page" === a) a = d ? this.viewportBounds.height : this.viewportBounds.width, a *= this.scale, 0 !== a && (e = c * Math.max(a - (d ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange), 0)); else {
            if ("document" === a) {
                e = this.documentBounds;
                c = this.viewportBounds;
                d = J.alloc();
                "up" === b ? this.position = d.h(c.x, e.y) : "left" === b ? this.position =
                    d.h(e.x, c.y) : "down" === b ? this.position = d.h(c.x, e.bottom - c.height) : "right" === b && (this.position = d.h(e.right - c.width, c.y));
                J.free(d);
                return
            }
            v("scrolling unit must be 'pixel', 'line', 'page', or 'document', not: " + a)
        }
        e /= this.scale;
        c = this.position.copy();
        "up" === b ? c.y = this.position.y - e : "down" === b ? c.y = this.position.y + e : "left" === b ? c.x = this.position.x - e : "right" === b ? c.x = this.position.x + e : v("scrolling direction must be 'up', 'down', 'left', or 'right', not: " + b);
        this.position = c
    };
    t.Mw = function (a) {
        var b = this.viewportBounds;
        b.Pe(a) || (a = a.center, a.x -= b.width / 2, a.y -= b.height / 2, this.position = a)
    };
    t.Lt = function (a) {
        var b = this.viewportBounds;
        a = a.center;
        a.x -= b.width / 2;
        a.y -= b.height / 2;
        this.position = a
    };
    t.vr = function (a) {
        var b = this.vb;
        b.reset();
        1 !== this.Fa && b.scale(this.Fa);
        var c = this.ra;
        (0 !== c.x || 0 !== c.y) && isFinite(c.x) && isFinite(c.y) && b.translate(-c.x, -c.y);
        return a.copy().transform(this.vb)
    };
    t.xB = function (a) {
        var b = this.vb, c = a.x, d = a.y, e = c + a.width, f = d + a.height, g = b.m11, h = b.m12, k = b.m21,
            l = b.m22, m = b.dx, n = b.dy, p = c * g + d * k + m;
        b = c * h + d * l + n;
        var r = e * g + d * k + m;
        a = e * h + d * l + n;
        d = c * g + f * k + m;
        c = c * h + f * l + n;
        g = e * g + f * k + m;
        e = e * h + f * l + n;
        f = Math.min(p, r);
        p = Math.max(p, r);
        r = Math.min(b, a);
        b = Math.max(b, a);
        f = Math.min(f, d);
        p = Math.max(p, d);
        r = Math.min(r, c);
        b = Math.max(b, c);
        f = Math.min(f, g);
        p = Math.max(p, g);
        r = Math.min(r, e);
        b = Math.max(b, e);
        return new L(f, r, p - f, b - r)
    };
    t.yu = function (a) {
        var b = this.vb;
        b.reset();
        1 !== this.Fa && b.scale(this.Fa);
        var c = this.ra;
        (0 !== c.x || 0 !== c.y) && isFinite(c.x) && isFinite(c.y) && b.translate(-c.x, -c.y);
        return Jb(a.copy(), this.vb)
    };

    function lk(a) {
        var b = a.isModified;
        a.Kv !== b && (a.Kv = b, a.U("Modified"))
    }

    function mk(a) {
        a = Hi.get(a);
        return null !== a ? new a : new Ii
    }

    Q.prototype.doModelChanged = function (a) {
        var b = this;
        if (a.model === this.model) {
            var c = a.change, d = a.propertyName;
            if (c === Me && "S" === d[0]) if ("StartingFirstTransaction" === d) {
                var e = this;
                a = this.toolManager;
                a.mouseDownTools.each(function (a) {
                    a.diagram = e
                });
                a.mouseMoveTools.each(function (a) {
                    a.diagram = e
                });
                a.mouseUpTools.each(function (a) {
                    a.diagram = e
                });
                this.qc || this.we || (this.Rj = !0, this.Uj && (this.Ne = !0))
            } else "StartingUndo" === d || "StartingRedo" === d ? (a = this.animationManager, a.defaultAnimation.isAnimating && !this.skipsUndoManager &&
            a.Xc(), this.U("ChangingSelection", this.selection)) : "StartedTransaction" === d && (a = this.animationManager, a.defaultAnimation.isAnimating && !this.skipsUndoManager && a.Xc()); else if (this.ba) {
                this.ba = !1;
                try {
                    if ("" === a.modelChange && c === Me) {
                        if ("FinishedUndo" === d || "FinishedRedo" === d) this.U("ChangedSelection", this.selection), ij(this);
                        var f = this.animationManager;
                        "RolledBackTransaction" === d && f.Xc();
                        this.Rj = !0;
                        this.md();
                        0 !== this.undoManager.transactionLevel && 1 !== this.undoManager.transactionLevel || Ih(f);
                        "CommittedTransaction" ===
                        d && this.undoManager.isJustDiscarded && (this.Xd = Math.min(this.Xd, this.undoManager.historyIndex - 1));
                        "CommittedTransaction" !== d && "RolledBackTransaction" !== d || !this.undoManager.isPendingUnmodified || setTimeout(function () {
                            b.isModified = !1
                        }, 1);
                        var g = a.isTransactionFinished;
                        g && (lk(this), this.iu.clear(), ei(this.animationManager));
                        if (!this.Os && g && this.lastInput.targetDiagram) {
                            this.Os = !0;
                            var h = this;
                            ta(function () {
                                h.currentTool.standardMouseOver();
                                h.Os = !1
                            }, 10)
                        }
                    }
                } finally {
                    this.ba = !0
                }
            }
        }
    };

    function Vj(a, b) {
        b = b.$.j;
        for (var c = b.length, d = 0; d < c; d++) nk(a, b[d])
    }

    function nk(a, b) {
        if (b instanceof ok) {
            var c = b.element;
            if (null !== c && c instanceof HTMLImageElement) {
                var d = b.lh;
                null !== d && (d.Gl instanceof Event && null !== b.Jc && b.Jc(b, d.Gl), !0 === d.ys && (null !== b.Cf && b.Cf(b, d.zv), null !== b.diagram && b.diagram.Ys.add(b)));
                c = c.getAttribute("src");
                d = a.Zi.K(c);
                if (null === d) d = [], d.push(b), a.Zi.add(c, d); else {
                    for (a = 0; a < d.length; a++) if (d[a] === b) return;
                    d.push(b)
                }
            }
        }
    }

    function pk(a, b) {
        if (b instanceof ok) {
            var c = b.element;
            if (null !== c && c instanceof HTMLImageElement) {
                c = c.getAttribute("src");
                var d = a.Zi.K(c);
                if (null !== d) for (var e = 0; e < d.length; e++) if (d[e] === b) {
                    d.splice(e, 1);
                    0 === d.length && (a.Zi.remove(c), qk(c));
                    break
                }
            }
        }
    }

    Q.prototype.Nd = function () {
        this.partManager.Nd()
    };
    Q.prototype.uk = function (a, b) {
        this.ad.uk(a, b)
    };
    Q.prototype.wk = function (a, b) {
        this.ad.wk(a, b)
    };
    Q.prototype.findPartForKey = function (a) {
        return this.partManager.findPartForKey(a)
    };
    Q.prototype.Ib = function (a) {
        return this.partManager.Ib(a)
    };
    Q.prototype.findLinkForKey = function (a) {
        return this.partManager.findLinkForKey(a)
    };
    t = Q.prototype;
    t.Fc = function (a) {
        return this.partManager.Fc(a)
    };
    t.qj = function (a) {
        return this.partManager.qj(a)
    };
    t.Ec = function (a) {
        return this.partManager.Ec(a)
    };
    t.Ut = function (a) {
        for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];
        return this.partManager.Ut.apply(this.partManager, b instanceof Array ? b : ca(ba(b)))
    };
    t.Tt = function (a) {
        for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];
        return this.partManager.Tt.apply(this.partManager, b instanceof Array ? b : ca(ba(b)))
    };

    function Qj(a, b) {
        a.Ei = !1;
        var c = a.ao;
        c.A(b) || (b = b.J(), a.ao = b, kj(a, !1), a.U("DocumentBoundsChanged", null, c.copy()), nj(a))
    }

    t.Ya = function () {
        this.Ei && Qj(this, this.computeBounds())
    };
    t.vA = function () {
        for (var a = new I, b = this.nodes; b.next();) {
            var c = b.value;
            c.isTopLevel && a.add(c)
        }
        for (b = this.links; b.next();) c = b.value, c.isTopLevel && a.add(c);
        return a.iterator
    };
    t.uA = function () {
        return this.Nh.iterator
    };
    t.WA = function (a) {
        ij(this);
        a && rk(this, !0);
        this.Rj = !0;
        Tf(this)
    };

    function rk(a, b) {
        for (var c = a.Nh.iterator; c.next();) sk(a, c.value, b);
        null !== a.layout && (b ? a.layout.isValidLayout = !1 : a.layout.D())
    }

    function sk(a, b, c) {
        if (null !== b) {
            for (var d = b.dm.iterator; d.next();) sk(a, d.value, c);
            null !== b.layout && (c ? b.layout.isValidLayout = !1 : b.layout.D())
        }
    }

    function Ej(a, b) {
        if (a.$g && !a.bs) {
            var c = a.ba;
            a.ba = !0;
            var d = a.undoManager.transactionLevel, e = a.layout, f = a.animationManager;
            try {
                0 === d && (a.undoManager.isInternalTransaction = !0, a.Ca("Layout"));
                1 >= d && !f.isAnimating && !f.yc && (b || Gh(f, "Layout"));
                a.$g = !1;
                for (var g = a.Nh.iterator; g.next();) tk(a, g.value, b, d);
                e.isValidLayout || (!b || e.isRealtime || null === e.isRealtime || 0 === d ? (e.doLayout(a), ij(a), e.isValidLayout = !0) : a.$g = !0)
            } finally {
                b = a.undoManager.isInternalTransaction, 0 === d && (a.bb("Layout"), a.undoManager.isInternalTransaction =
                    !1), !b || 0 !== d && 1 !== d || Ih(f), a.ba = c
            }
        }
    }

    function tk(a, b, c, d) {
        if (null !== b) {
            for (var e = b.dm.iterator; e.next();) tk(a, e.value, c, d);
            e = b.layout;
            null === e || e.isValidLayout || (!c || e.isRealtime || 0 === d ? (b.ai = !b.location.o(), e.doLayout(b), b.D(32), Gj(a, b), e.isValidLayout = !0) : a.$g = !0)
        }
    }

    t.BA = function () {
        for (var a = new H, b = this.nodes; b.next();) {
            var c = b.value;
            c.isTopLevel && null === c.tj() && a.add(c)
        }
        return a.iterator
    };

    function Fi(a) {
        function b(a) {
            var b = a.toLowerCase(), e = new H;
            c.add(a, e);
            c.add(b, e);
            d.add(a, a);
            d.add(b, a)
        }

        var c = new Db, d = new Db;
        b("InitialAnimationStarting");
        b("AnimationStarting");
        b("AnimationFinished");
        b("BackgroundSingleClicked");
        b("BackgroundDoubleClicked");
        b("BackgroundContextClicked");
        b("ClipboardChanged");
        b("ClipboardPasted");
        b("DocumentBoundsChanged");
        b("ExternalObjectsDropped");
        b("GainedFocus");
        b("InitialLayoutCompleted");
        b("LayoutCompleted");
        b("LinkDrawn");
        b("LinkRelinked");
        b("LinkReshaped");
        b("LostFocus");
        b("Modified");
        b("ObjectSingleClicked");
        b("ObjectDoubleClicked");
        b("ObjectContextClicked");
        b("PartCreated");
        b("PartResized");
        b("PartRotated");
        b("SelectionMoved");
        b("SelectionCopied");
        b("SelectionDeleting");
        b("SelectionDeleted");
        b("SelectionGrouped");
        b("SelectionUngrouped");
        b("ChangingSelection");
        b("ChangedSelection");
        b("SubGraphCollapsed");
        b("SubGraphExpanded");
        b("TextEdited");
        b("TreeCollapsed");
        b("TreeExpanded");
        b("ViewportBoundsChanged");
        b("InvalidateDraw");
        a.es = c;
        a.ds = d
    }

    function Pj(a, b) {
        var c = a.ds.K(b);
        return null !== c ? c : a.ds.K(b.toLowerCase())
    }

    function uk(a, b) {
        var c = a.es.K(b);
        if (null !== c) return c;
        c = a.es.K(b.toLowerCase());
        if (null !== c) return c;
        v("Unknown DiagramEvent name: " + b)
    }

    t.vk = function (a, b) {
        A(a, "string", Q, "addDiagramListener:name");
        A(b, "function", Q, "addDiagramListener:listener");
        a = uk(this, a);
        null !== a && a.add(b)
    };
    t.Xm = function (a, b) {
        A(a, "string", Q, "removeDiagramListener:name");
        A(b, "function", Q, "addDiagramListener:listener");
        a = uk(this, a);
        null !== a && a.remove(b)
    };
    t.U = function (a, b, c) {
        F && A(a, "string", Q, "raiseDiagramEvent:name");
        var d = uk(this, a), e = new Ce;
        e.diagram = this;
        a = Pj(this, a);
        null !== a && (e.name = a);
        void 0 !== b && (e.subject = b);
        void 0 !== c && (e.parameter = c);
        b = d.length;
        if (1 === b) d.M(0)(e); else if (0 !== b) for (d = d.ta(), c = 0; c < b; c++) (0, d[c])(e)
    };

    function vk(a) {
        if (a.animationManager.isTicking) return !1;
        var b = a.currentTool;
        return b === a.toolManager.findTool("Dragging") ? !a.oq || b.isComplexRoutingRealtime : !0
    }

    t.Lk = function (a, b) {
        void 0 === b && (b = null);
        return wk(this, !1, null, b).Lk(a.x, a.y, a.width, a.height)
    };
    Q.prototype.computeOccupiedArea = function () {
        return this.isVirtualized ? this.viewportBounds.copy() : this.Ei ? jj(this) : this.documentBounds.copy()
    };

    function wk(a, b, c, d) {
        null === a.Nc && (a.Nc = new xk);
        if (a.Nc.cu || a.Nc.group !== c || a.Nc.kz !== d) {
            if (null === c) {
                b = a.computeOccupiedArea();
                b.Pc(100, 100);
                a.Nc.initialize(b);
                b = L.alloc();
                for (var e = a.nodes; e.next();) {
                    var f = e.value, g = f.layer;
                    null !== g && g.visible && !g.isTemporary && Gk(a, f, d, b)
                }
                L.free(b)
            } else {
                0 < c.memberParts.count && (b = a.computePartsBounds(c.memberParts, !1), b.Pc(20, 20), a.Nc.initialize(b));
                b = L.alloc();
                for (e = c.memberParts; e.next();) f = e.value, f instanceof V && Gk(a, f, d, b);
                L.free(b)
            }
            a.Nc.group = c;
            a.Nc.kz = d;
            a.Nc.cu =
                !1
        } else b && Kk(a.Nc);
        return a.Nc
    }

    function Gk(a, b, c, d) {
        if (b !== c) if (b.isVisible() && b.avoidable && !b.isLinkLabel) {
            b = b.getAvoidableRect(d);
            a = a.Nc;
            var e = b.x, f = b.y;
            if (Lk(a, e, f)) for (c = (f - a.Dd) / a.mc | 0, d = Math.min((e + b.width - a.Cd) / a.lc | 0, a.ij), b = Math.min((f + b.height - a.Dd) / a.mc | 0, a.jj), e = (e - a.Cd) / a.lc | 0; e <= d; e++) if (f = a.Xb[e], f.fill) f.fill(Mk, c, b + 1); else for (var g = c; g <= b; g++) f[g] = Mk
        } else if (b instanceof Kf) for (b = b.memberParts; b.next();) e = b.value, e instanceof V && Gk(a, e, c, d)
    }

    function Nk(a, b) {
        null !== a.Nc && !a.Nc.cu && (void 0 === b && (b = null), null === b || b.avoidable && !b.isLinkLabel) && (a.Nc.cu = !0)
    }

    Q.prototype.Qt = function (a) {
        this.Bn.assign(a);
        this.computeAutoScrollPosition(this.Bn).Ta(this.position) ? this.Vf() : Ok(this)
    };

    function Ok(a) {
        -1 === a.Lj && (a.Lj = ta(function () {
            if (-1 !== a.Lj && (a.Vf(), null !== a.lastInput.event)) {
                var b = a.computeAutoScrollPosition(a.Bn);
                b.Ta(a.position) || (a.position = b, a.lastInput.documentPoint = a.yu(a.Bn), a.doMouseMove(), a.Ei = !0, Qj(a, a.documentBounds.copy().Yc(a.computeBounds())), a.Kc = !0, a.md(), Ok(a))
            }
        }, a.An))
    }

    Q.prototype.Vf = function () {
        -1 !== this.Lj && (qa.clearTimeout(this.Lj), this.Lj = -1)
    };
    Q.prototype.computeAutoScrollPosition = function (a) {
        var b = this.position, c = this.Cn;
        if (0 >= c.top && 0 >= c.left && 0 >= c.right && 0 >= c.bottom) return b;
        var d = this.viewportBounds, e = this.scale;
        d = L.allocAt(0, 0, d.width * e, d.height * e);
        var f = J.allocAt(0, 0);
        if (a.x >= d.x && a.x < d.x + c.left && this.allowHorizontalScroll) {
            var g = Math.max(this.scrollHorizontalLineChange, 1);
            g |= 0;
            f.x -= g;
            a.x < d.x + c.left / 2 && (f.x -= g);
            a.x < d.x + c.left / 4 && (f.x -= 4 * g)
        } else a.x <= d.x + d.width && a.x > d.x + d.width - c.right && this.allowHorizontalScroll && (g = Math.max(this.scrollHorizontalLineChange,
            1), g |= 0, f.x += g, a.x > d.x + d.width - c.right / 2 && (f.x += g), a.x > d.x + d.width - c.right / 4 && (f.x += 4 * g));
        a.y >= d.y && a.y < d.y + c.top && this.allowVerticalScroll ? (g = Math.max(this.scrollVerticalLineChange, 1), g |= 0, f.y -= g, a.y < d.y + c.top / 2 && (f.y -= g), a.y < d.y + c.top / 4 && (f.y -= 4 * g)) : a.y <= d.y + d.height && a.y > d.y + d.height - c.bottom && this.allowVerticalScroll && (g = Math.max(this.scrollVerticalLineChange, 1), g |= 0, f.y += g, a.y > d.y + d.height - c.bottom / 2 && (f.y += g), a.y > d.y + d.height - c.bottom / 4 && (f.y += 4 * g));
        f.Ta(Ob) || (b = new J(b.x + f.x / e, b.y + f.y / e));
        L.free(d);
        J.free(f);
        return b
    };
    t = Q.prototype;
    t.ku = function () {
        return null
    };
    t.tw = function () {
        return null
    };
    t.Gz = function (a, b) {
        this.Xx.add(a, b)
    };

    function Pk(a, b, c) {
        function d() {
            var a = +new Date;
            f = !0;
            for (g.reset(); g.next();) if (!g.value[0].$l) {
                f = !1;
                break
            }
            f || a - l > k ? b(c, e, h) : qa.requestAnimationFrame(d)
        }

        for (var e = c.callback, f = !0, g = a.Zi.iterator; g.next();) if (!g.value[0].$l) {
            f = !1;
            break
        }
        if ("function" !== typeof e || f) return b(c, e, a);
        var h = a, k = c.callbackTimeout || 300, l = +new Date;
        qa.requestAnimationFrame(function () {
            d()
        });
        return null
    }

    t.YA = function (a) {
        if (!ih) return null;
        void 0 === a && (a = new kb);
        a.returnType = "Image";
        return this.Xy(a)
    };
    t.Xy = function (a) {
        void 0 === a && (a = new kb);
        return Pk(this, this.ZA, a)
    };
    t.ZA = function (a, b, c) {
        var d = Qk(c, a, "canvas", null);
        if (null === d) return null;
        c = d.aa.canvas;
        var e = null;
        if (null !== c) switch (e = a.returnType, void 0 === e ? e = "string" : e = e.toLowerCase(), e) {
            case Rk + "data":
                e = d.getImageData(0, 0, c.width, c.height);
                break;
            case Rk:
                d = (a.document || document).createElement("img");
                d.src = c.toDataURL(a.type, a.details);
                e = d;
                break;
            case "blob":
                "function" !== typeof b && v('Error: Diagram.makeImageData called with "returnType: toBlob", but no required "callback" function property defined.');
                if ("function" ===
                    typeof c.toBlob) return c.toBlob(b, a.type, a.details), "toBlob";
                if ("function" === typeof c.msToBlob) return b(c.msToBlob()), "msToBlob";
                b(null);
                return null;
            default:
                e = c.toDataURL(a.type, a.details)
        }
        return "function" === typeof b ? (b(e), null) : e
    };

    function Qk(a, b, c, d) {
        a.animationManager.Xc();
        a.md();
        if (null === a.Aa) return null;
        "object" !== typeof b && v("properties argument must be an Object.");
        var e = !1, f = b.size || null, g = b.scale || null;
        void 0 !== b.scale && isNaN(b.scale) && (g = "NaN");
        var h = b.maxSize;
        void 0 === b.maxSize && (e = !0, h = "SVG" === c ? new Hb(Infinity, Infinity) : new Hb(2E3, 2E3));
        var k = b.position || null, l = b.parts || null, m = void 0 === b.padding ? 1 : b.padding,
            n = b.background || null, p = b.omitTemporary;
        void 0 === p && (p = !0);
        var r = b.document || document, q = b.elementFinished ||
            null, u = b.showTemporary;
        void 0 === u && (u = !p);
        b = b.showGrid;
        void 0 === b && (b = u);
        null !== f && isNaN(f.width) && isNaN(f.height) && (f = null);
        "number" === typeof m ? m = new jc(m) : m instanceof jc || v("MakeImage padding must be a Margin or a number.");
        m.left = Math.max(m.left, 0);
        m.right = Math.max(m.right, 0);
        m.top = Math.max(m.top, 0);
        m.bottom = Math.max(m.bottom, 0);
        a.Nb.Ac(!0);
        p = new Sk(null, r);
        var x = p.context;
        if (!(f || g || l || k)) {
            p.width = a.Ea + Math.ceil(m.left + m.right);
            p.height = a.Da + Math.ceil(m.top + m.bottom);
            if ("SVG" === c) {
                if (null ===
                    d) return null;
                d.resize(p.width, p.height, p.width, p.height);
                d.ownerDocument = r;
                d.Mq = q;
                Nj(a, d.context, m, new Hb(p.width, p.height), a.Fa, a.ra, l, n, u, b);
                return d.context
            }
            a.Bl = !1;
            Nj(a, x, m, new Hb(p.width, p.height), a.Fa, a.ra, l, n, u, b);
            a.Bl = !0;
            return p.context
        }
        var y = a.$n, z = a.documentBounds.copy();
        z.Vw(a.ob);
        if (u) for (var B = a.Qa.j, D = B.length, G = 0; G < D; G++) {
            var O = B[G];
            if (O.visible && O.isTemporary) {
                O = O.Ia.j;
                for (var U = O.length, R = 0; R < U; R++) {
                    var fa = O[R];
                    fa.isInDocumentBounds && fa.isVisible() && (fa = fa.actualBounds, fa.o() &&
                    z.Yc(fa))
                }
            }
        }
        B = new J(z.x, z.y);
        if (null !== l) {
            D = !0;
            G = l.iterator;
            for (G.reset(); G.next();) if (O = G.value, O instanceof T && (U = O.layer, (null === U || U.visible) && (null === U || u || !U.isTemporary) && O.isVisible() && (O = O.actualBounds, O.o()))) if (D) {
                D = !1;
                var Y = O.copy()
            } else Y.Yc(O);
            D && (Y = new L(0, 0, 0, 0));
            z.width = Y.width;
            z.height = Y.height;
            B.x = Y.x;
            B.y = Y.y
        }
        null !== k && k.o() && (B = k, g || (g = y));
        Y = k = 0;
        null !== m && (k = m.left + m.right, Y = m.top + m.bottom);
        D = G = 0;
        null !== f && (G = f.width, D = f.height, isFinite(G) && (G = Math.max(0, G - k)), isFinite(D) && (D =
            Math.max(0, D - Y)));
        null !== f && null !== g ? ("NaN" === g && (g = y), f.o() ? (f = G, z = D) : isNaN(D) ? (f = G, z = z.height * g) : (f = z.width * g, z = D)) : null !== f ? f.o() ? (g = Math.min(G / z.width, D / z.height), f = G, z = D) : isNaN(D) ? (g = G / z.width, f = G, z = z.height * g) : (g = D / z.height, f = z.width * g, z = D) : null !== g ? "NaN" === g && h.o() ? (g = Math.min((h.width - k) / z.width, (h.height - Y) / z.height), g > y ? (g = y, f = z.width, z = z.height) : (f = h.width, z = h.height)) : (f = z.width * g, z = z.height * g) : (g = y, f = z.width, z = z.height);
        null !== m ? (f += k, z += Y) : m = new jc(0);
        null !== h && (y = h.width, h = h.height,
        "SVG" !== c && e && !Tk && F && (f > y || z > h) && (Ea("Diagram.makeImage(data): Diagram width or height is larger than the default max size. (" + Math.ceil(f) + "x" + Math.ceil(z) + " vs 2000x2000) Consider increasing the max size."), Tk = !0), isNaN(y) && (y = 2E3), isNaN(h) && (h = 2E3), isFinite(y) && (f = Math.min(f, y)), isFinite(h) && (z = Math.min(z, h)));
        p.width = Math.ceil(f);
        p.height = Math.ceil(z);
        if ("SVG" === c) {
            if (null === d) return null;
            d.resize(p.width, p.height, p.width, p.height);
            d.ownerDocument = r;
            d.Mq = q;
            Nj(a, d.context, m, new Hb(Math.ceil(f),
                Math.ceil(z)), g, B, l, n, u, b);
            return d.context
        }
        a.Bl = !1;
        Nj(a, x, m, new Hb(Math.ceil(f), Math.ceil(z)), g, B, l, n, u, b);
        a.Bl = !0;
        return p.context
    }

    na.Object.defineProperties(Q.prototype, {
        div: {
            configurable: !0, get: function () {
                return this.Ja
            }, set: function (a) {
                null !== a && w(a, HTMLDivElement, Q, "div");
                if (this.Ja !== a) {
                    Wa = [];
                    var b = this.Ja;
                    null !== b ? (b.B = void 0, b.goDiagram = void 0, b.innerHTML = "", null !== this.Aa && (b = this.Aa.La, this.Jj ? (this.removeEventListener(b, "pointermove", this.Wk, !1), this.removeEventListener(b, "pointerdown", this.Vk, !1), this.removeEventListener(b, "pointerup", this.Yk, !1), this.removeEventListener(b, "pointerout", this.Xk, !1)) : (this.removeEventListener(b,
                        "touchstart", this.$w, !1), this.removeEventListener(b, "touchmove", this.Zw, !1), this.removeEventListener(b, "touchend", this.Yw, !1)), this.Aa.yy()), this.jm && (this.jm.disconnect(), this.jm = null), b = this.toolManager, null !== b && (b.mouseDownTools.each(function (a) {
                        a.cancelWaitAfter()
                    }), b.mouseMoveTools.each(function (a) {
                        a.cancelWaitAfter()
                    }), b.mouseUpTools.each(function (a) {
                        a.cancelWaitAfter()
                    })), b.cancelWaitAfter(), this.currentTool.doCancel(), this.Nb = this.Aa = null, this.removeEventListener(qa, "resize", this.kx, !1),
                    this.Jj || (this.removeEventListener(qa, "mousemove", this.Pk, !0), this.removeEventListener(qa, "mousedown", this.Ok, !0), this.removeEventListener(qa, "mouseup", this.Rk, !0), this.removeEventListener(qa, "mouseout", this.Qk, !0)), this.removeEventListener(qa, "wheel", this.Sk, !0), Te === this && (Te = null)) : this.we = !1;
                    this.Ja = null;
                    if (null !== a) {
                        if (b = a.B) b.div = null;
                        Pi(this, a);
                        this.We()
                    }
                }
            }
        }, oy: {
            configurable: !0, get: function () {
                return this.kp
            }
        }, Aj: {
            configurable: !0, get: function () {
                return this.we
            }
        }, draggedLink: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.gs
            }, set: function (a) {
                this.gs !== a && (this.gs = a, null !== a && (this.Ss = a.fromPort, this.Ts = a.toPort))
            }
        }, $y: {
            configurable: !0, get: function () {
                return this.Ss
            }, set: function (a) {
                this.Ss = a
            }
        }, az: {
            configurable: !0, get: function () {
                return this.Ts
            }, set: function (a) {
                this.Ts = a
            }
        }, animationManager: {
            configurable: !0, get: function () {
                return this.ad
            }
        }, undoManager: {
            configurable: !0, get: function () {
                return this.hc.undoManager
            }
        }, skipsUndoManager: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Hg
            }, set: function (a) {
                A(a, "boolean", Q, "skipsUndoManager");
                this.Hg = a;
                this.hc.skipsUndoManager = a
            }
        }, delaysLayout: {
            configurable: !0, get: function () {
                return this.bs
            }, set: function (a) {
                this.bs = a
            }
        }, opacity: {
            configurable: !0, get: function () {
                return this.nb
            }, set: function (a) {
                var b = this.nb;
                b !== a && (A(a, "number", Q, "opacity"), (0 > a || 1 < a) && za(a, "0 <= value <= 1", Q, "opacity"), this.nb = a, this.g("opacity", b, a), this.P())
            }
        }, validCycle: {
            configurable: !0,
            get: function () {
                return this.Et
            }, set: function (a) {
                var b = this.Et;
                b !== a && (ib(a, Q, Q, "validCycle"), this.Et = a, this.g("validCycle", b, a))
            }
        }, layers: {
            configurable: !0, get: function () {
                return this.Qa.iterator
            }
        }, isModelReadOnly: {
            configurable: !0, get: function () {
                var a = this.hc;
                return null === a ? !1 : a.isReadOnly
            }, set: function (a) {
                var b = this.hc;
                null !== b && (b.isReadOnly = a)
            }
        }, isReadOnly: {
            configurable: !0, get: function () {
                return this.mg
            }, set: function (a) {
                var b = this.mg;
                b !== a && (A(a, "boolean",
                    Q, "isReadOnly"), this.mg = a, this.g("isReadOnly", b, a))
            }
        }, isEnabled: {
            configurable: !0, get: function () {
                return this.qd
            }, set: function (a) {
                var b = this.qd;
                b !== a && (A(a, "boolean", Q, "isEnabled"), this.qd = a, this.g("isEnabled", b, a))
            }
        }, allowClipboard: {
            configurable: !0, get: function () {
                return this.Cr
            }, set: function (a) {
                var b = this.Cr;
                b !== a && (A(a, "boolean", Q, "allowClipboard"), this.Cr = a, this.g("allowClipboard", b, a))
            }
        }, allowCopy: {
            configurable: !0, get: function () {
                return this.ji
            }, set: function (a) {
                var b =
                    this.ji;
                b !== a && (A(a, "boolean", Q, "allowCopy"), this.ji = a, this.g("allowCopy", b, a))
            }
        }, allowDelete: {
            configurable: !0, get: function () {
                return this.ki
            }, set: function (a) {
                var b = this.ki;
                b !== a && (A(a, "boolean", Q, "allowDelete"), this.ki = a, this.g("allowDelete", b, a))
            }
        }, allowDragOut: {
            configurable: !0, get: function () {
                return this.Dr
            }, set: function (a) {
                var b = this.Dr;
                b !== a && (A(a, "boolean", Q, "allowDragOut"), this.Dr = a, this.g("allowDragOut", b, a))
            }
        }, allowDrop: {
            configurable: !0, get: function () {
                return this.Er
            },
            set: function (a) {
                var b = this.Er;
                b !== a && (A(a, "boolean", Q, "allowDrop"), this.Er = a, this.g("allowDrop", b, a))
            }
        }, allowTextEdit: {
            configurable: !0, get: function () {
                return this.ui
            }, set: function (a) {
                var b = this.ui;
                b !== a && (A(a, "boolean", Q, "allowTextEdit"), this.ui = a, this.g("allowTextEdit", b, a))
            }
        }, allowGroup: {
            configurable: !0, get: function () {
                return this.li
            }, set: function (a) {
                var b = this.li;
                b !== a && (A(a, "boolean", Q, "allowGroup"), this.li = a, this.g("allowGroup", b, a))
            }
        }, allowUngroup: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.vi
            }, set: function (a) {
                var b = this.vi;
                b !== a && (A(a, "boolean", Q, "allowUngroup"), this.vi = a, this.g("allowUngroup", b, a))
            }
        }, allowInsert: {
            configurable: !0, get: function () {
                return this.Gr
            }, set: function (a) {
                var b = this.Gr;
                b !== a && (A(a, "boolean", Q, "allowInsert"), this.Gr = a, this.g("allowInsert", b, a))
            }
        }, allowLink: {
            configurable: !0, get: function () {
                return this.mi
            }, set: function (a) {
                var b = this.mi;
                b !== a && (A(a, "boolean", Q, "allowLink"), this.mi = a, this.g("allowLink",
                    b, a))
            }
        }, allowRelink: {
            configurable: !0, get: function () {
                return this.oi
            }, set: function (a) {
                var b = this.oi;
                b !== a && (A(a, "boolean", Q, "allowRelink"), this.oi = a, this.g("allowRelink", b, a))
            }
        }, allowMove: {
            configurable: !0, get: function () {
                return this.ni
            }, set: function (a) {
                var b = this.ni;
                b !== a && (A(a, "boolean", Q, "allowMove"), this.ni = a, this.g("allowMove", b, a))
            }
        }, allowReshape: {
            configurable: !0, get: function () {
                return this.pi
            }, set: function (a) {
                var b = this.pi;
                b !== a && (A(a, "boolean", Q, "allowReshape"),
                    this.pi = a, this.g("allowReshape", b, a))
            }
        }, allowResize: {
            configurable: !0, get: function () {
                return this.ri
            }, set: function (a) {
                var b = this.ri;
                b !== a && (A(a, "boolean", Q, "allowResize"), this.ri = a, this.g("allowResize", b, a))
            }
        }, allowRotate: {
            configurable: !0, get: function () {
                return this.si
            }, set: function (a) {
                var b = this.si;
                b !== a && (A(a, "boolean", Q, "allowRotate"), this.si = a, this.g("allowRotate", b, a))
            }
        }, allowSelect: {
            configurable: !0, get: function () {
                return this.ti
            }, set: function (a) {
                var b = this.ti;
                b !== a && (A(a, "boolean", Q, "allowSelect"), this.ti = a, this.g("allowSelect", b, a))
            }
        }, allowUndo: {
            configurable: !0, get: function () {
                return this.Hr
            }, set: function (a) {
                var b = this.Hr;
                b !== a && (A(a, "boolean", Q, "allowUndo"), this.Hr = a, this.g("allowUndo", b, a))
            }
        }, allowZoom: {
            configurable: !0, get: function () {
                return this.Jr
            }, set: function (a) {
                var b = this.Jr;
                b !== a && (A(a, "boolean", Q, "allowZoom"), this.Jr = a, this.g("allowZoom", b, a))
            }
        }, hasVerticalScrollbar: {
            configurable: !0, get: function () {
                return this.Il
            },
            set: function (a) {
                var b = this.Il;
                b !== a && (A(a, "boolean", Q, "hasVerticalScrollbar"), this.Il = a, nj(this), this.P(), this.g("hasVerticalScrollbar", b, a), kj(this, !1))
            }
        }, hasHorizontalScrollbar: {
            configurable: !0, get: function () {
                return this.Hl
            }, set: function (a) {
                var b = this.Hl;
                b !== a && (A(a, "boolean", Q, "hasHorizontalScrollbar"), this.Hl = a, nj(this), this.P(), this.g("hasHorizontalScrollbar", b, a), kj(this, !1))
            }
        }, allowHorizontalScroll: {
            configurable: !0, get: function () {
                return this.Fr
            }, set: function (a) {
                var b =
                    this.Fr;
                b !== a && (A(a, "boolean", Q, "allowHorizontalScroll"), this.Fr = a, this.g("allowHorizontalScroll", b, a), kj(this, !1))
            }
        }, allowVerticalScroll: {
            configurable: !0, get: function () {
                return this.Ir
            }, set: function (a) {
                var b = this.Ir;
                b !== a && (A(a, "boolean", Q, "allowVerticalScroll"), this.Ir = a, this.g("allowVerticalScroll", b, a), kj(this, !1))
            }
        }, scrollHorizontalLineChange: {
            configurable: !0, get: function () {
                return this.it
            }, set: function (a) {
                var b = this.it;
                b !== a && (A(a, "number", Q, "scrollHorizontalLineChange"),
                0 > a && za(a, ">= 0", Q, "scrollHorizontalLineChange"), this.it = a, this.g("scrollHorizontalLineChange", b, a))
            }
        }, scrollVerticalLineChange: {
            configurable: !0, get: function () {
                return this.mt
            }, set: function (a) {
                var b = this.mt;
                b !== a && (A(a, "number", Q, "scrollVerticalLineChange"), 0 > a && za(a, ">= 0", Q, "scrollVerticalLineChange"), this.mt = a, this.g("scrollVerticalLineChange", b, a))
            }
        }, lastInput: {
            configurable: !0, get: function () {
                return this.th
            }, set: function (a) {
                F && w(a, Ae, Q, "lastInput");
                this.th = a
            }
        }, previousInput: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.sd
            }, set: function (a) {
                F && w(a, Ae, Q, "previousInput");
                this.sd = a
            }
        }, firstInput: {
            configurable: !0, get: function () {
                return this.hg
            }, set: function (a) {
                F && w(a, Ae, Q, "firstInput");
                this.hg = a
            }
        }, currentCursor: {
            configurable: !0, get: function () {
                return this.Vr
            }, set: function (a) {
                "" === a && (a = this.Zn);
                if (this.Vr !== a) {
                    A(a, "string", Q, "currentCursor");
                    var b = this.Aa, c = this.Ja;
                    if (null !== b) {
                        this.Vr = a;
                        var d = b.style.cursor;
                        b.style.cursor = a;
                        c.style.cursor = a;
                        b.style.cursor ===
                        d && (b.style.cursor = "-webkit-" + a, c.style.cursor = "-webkit-" + a, b.style.cursor === d && (b.style.cursor = "-moz-" + a, c.style.cursor = "-moz-" + a, b.style.cursor === d && (b.style.cursor = a, c.style.cursor = a)))
                    }
                }
            }
        }, defaultCursor: {
            configurable: !0, get: function () {
                return this.Zn
            }, set: function (a) {
                "" === a && (a = "auto");
                var b = this.Zn;
                b !== a && (A(a, "string", Q, "defaultCursor"), this.Zn = a, this.g("defaultCursor", b, a))
            }
        }, click: {
            configurable: !0, get: function () {
                return this.ag
            }, set: function (a) {
                var b = this.ag;
                b !==
                a && (null !== a && A(a, "function", Q, "click"), this.ag = a, this.g("click", b, a))
            }
        }, doubleClick: {
            configurable: !0, get: function () {
                return this.fg
            }, set: function (a) {
                var b = this.fg;
                b !== a && (null !== a && A(a, "function", Q, "doubleClick"), this.fg = a, this.g("doubleClick", b, a))
            }
        }, contextClick: {
            configurable: !0, get: function () {
                return this.bg
            }, set: function (a) {
                var b = this.bg;
                b !== a && (null !== a && A(a, "function", Q, "contextClick"), this.bg = a, this.g("contextClick", b, a))
            }
        }, mouseOver: {
            configurable: !0,
            get: function () {
                return this.yg
            }, set: function (a) {
                var b = this.yg;
                b !== a && (null !== a && A(a, "function", Q, "mouseOver"), this.yg = a, this.g("mouseOver", b, a))
            }
        }, mouseHover: {
            configurable: !0, get: function () {
                return this.wg
            }, set: function (a) {
                var b = this.wg;
                b !== a && (null !== a && A(a, "function", Q, "mouseHover"), this.wg = a, this.g("mouseHover", b, a))
            }
        }, mouseHold: {
            configurable: !0, get: function () {
                return this.vg
            }, set: function (a) {
                var b = this.vg;
                b !== a && (null !== a && A(a, "function", Q, "mouseHold"), this.vg = a, this.g("mouseHold",
                    b, a))
            }
        }, mouseDragOver: {
            configurable: !0, get: function () {
                return this.Ns
            }, set: function (a) {
                var b = this.Ns;
                b !== a && (null !== a && A(a, "function", Q, "mouseDragOver"), this.Ns = a, this.g("mouseDragOver", b, a))
            }
        }, mouseDrop: {
            configurable: !0, get: function () {
                return this.tg
            }, set: function (a) {
                var b = this.tg;
                b !== a && (F && null !== a && A(a, "function", Q, "mouseDrop"), this.tg = a, this.g("mouseDrop", b, a))
            }
        }, handlesDragDropForTopLevelParts: {
            configurable: !0, get: function () {
                return this.qs
            }, set: function (a) {
                var b =
                    this.qs;
                b !== a && (A(a, "boolean", Q, "handlesDragDropForTopLevelParts"), this.qs = a, this.g("handlesDragDropForTopLevelParts", b, a))
            }
        }, mouseEnter: {
            configurable: !0, get: function () {
                return this.ug
            }, set: function (a) {
                var b = this.ug;
                b !== a && (null !== a && A(a, "function", Q, "mouseEnter"), this.ug = a, this.g("mouseEnter", b, a))
            }
        }, mouseLeave: {
            configurable: !0, get: function () {
                return this.xg
            }, set: function (a) {
                var b = this.xg;
                b !== a && (null !== a && A(a, "function", Q, "mouseLeave"), this.xg = a, this.g("mouseLeave", b, a))
            }
        },
        toolTip: {
            configurable: !0, get: function () {
                return this.Jg
            }, set: function (a) {
                var b = this.Jg;
                b !== a && (!F || null === a || a instanceof Xe || a instanceof gf || v("Diagram.toolTip must be an Adornment or HTMLInfo."), this.Jg = a, this.g("toolTip", b, a))
            }
        }, contextMenu: {
            configurable: !0, get: function () {
                return this.cg
            }, set: function (a) {
                var b = this.cg;
                b !== a && (!F || a instanceof Xe || a instanceof gf || v("Diagram.contextMenu must be an Adornment or HTMLInfo."), this.cg = a, this.g("contextMenu", b, a))
            }
        }, commandHandler: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Pr
            }, set: function (a) {
                this.Pr !== a && (this.Pr = a, a.ie(this))
            }
        }, toolManager: {
            configurable: !0, get: function () {
                return this.At
            }, set: function (a) {
                this.At !== a && (w(a, Ua, Q, "toolManager"), this.At = a, a.diagram = this)
            }
        }, defaultTool: {
            configurable: !0, get: function () {
                return this.$r
            }, set: function (a) {
                var b = this.$r;
                b !== a && (w(a, Se, Q, "defaultTool"), this.$r = a, a.diagram = this, this.currentTool === b && (this.currentTool = a))
            }
        }, currentTool: {
            configurable: !0,
            get: function () {
                return this.Xr
            }, set: function (a) {
                var b = this.Xr;
                null !== b && (b.isActive && b.doDeactivate(), b.cancelWaitAfter(), b.doStop());
                null === a && (a = this.defaultTool);
                null !== a && (w(a, Se, Q, "currentTool"), this.Xr = a, a.diagram = this, a.doStart())
            }
        }, selection: {
            configurable: !0, get: function () {
                return this.Bv
            }
        }, maxSelectionCount: {
            configurable: !0, get: function () {
                return this.Js
            }, set: function (a) {
                var b = this.Js;
                if (b !== a) if (A(a, "number", Q, "maxSelectionCount"), 0 <= a && !isNaN(a)) {
                    if (this.Js = a, this.g("maxSelectionCount",
                        b, a), !this.undoManager.isUndoingRedoing && (a = this.selection.count - a, 0 < a)) {
                        this.U("ChangingSelection", this.selection);
                        b = this.selection.ta();
                        for (var c = 0; c < a; c++) b[c].isSelected = !1;
                        this.U("ChangedSelection", this.selection)
                    }
                } else za(a, ">= 0", Q, "maxSelectionCount")
            }
        }, nodeSelectionAdornmentTemplate: {
            configurable: !0, get: function () {
                return this.rp
            }, set: function (a) {
                var b = this.rp;
                b !== a && (w(a, Xe, Q, "nodeSelectionAdornmentTemplate"), this.rp = a, this.g("nodeSelectionAdornmentTemplate", b, a))
            }
        }, groupSelectionAdornmentTemplate: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.zo
            }, set: function (a) {
                var b = this.zo;
                b !== a && (w(a, Xe, Q, "groupSelectionAdornmentTemplate"), this.zo = a, this.g("groupSelectionAdornmentTemplate", b, a))
            }
        }, linkSelectionAdornmentTemplate: {
            configurable: !0, get: function () {
                return this.So
            }, set: function (a) {
                var b = this.So;
                b !== a && (w(a, Xe, Q, "linkSelectionAdornmentTemplate"), this.So = a, this.g("linkSelectionAdornmentTemplate", b, a))
            }
        }, highlighteds: {
            configurable: !0, get: function () {
                return this.av
            }
        }, isModified: {
            configurable: !0,
            enumerable: !0, get: function () {
                var a = this.undoManager;
                return a.isEnabled ? null !== a.currentTransaction ? !0 : this.Do && this.Xd !== a.historyIndex : this.Do
            }, set: function (a) {
                if (this.Do !== a) {
                    A(a, "boolean", Q, "isModified");
                    this.Do = a;
                    var b = this.undoManager;
                    !a && b.isEnabled && (this.Xd = b.historyIndex);
                    a || lk(this)
                }
            }
        }, model: {
            configurable: !0, get: function () {
                return this.hc
            }, set: function (a) {
                var b = this.hc;
                if (b !== a) {
                    w(a, X, Q, "model");
                    this.currentTool.doCancel();
                    null !== b && b.undoManager !== a.undoManager && b.undoManager.isInTransaction &&
                    v("Do not replace a Diagram.model while a transaction is in progress.");
                    this.animationManager.Xc(!0);
                    var c = Si(this, !0);
                    this.we = !1;
                    this.Uj = !0;
                    this.Xd = -2;
                    this.Ne = !1;
                    var d = this.qc;
                    this.qc = !0;
                    Gh(this.animationManager, "Model");
                    null !== b && (null !== this.De && this.De.each(function (a) {
                        b.$k(a)
                    }), b.$k(this.$c));
                    this.hc = a;
                    this.partManager = mk(this.hc.type);
                    for (var e = 0; e < c.length; e++) this.add(c[e]);
                    a.Rh(this.Ic);
                    this.partManager.addAllModeledParts();
                    a.$k(this.Ic);
                    a.Rh(this.$c);
                    null !== this.De && this.De.each(function (b) {
                        a.Rh(b)
                    });
                    this.qc = d;
                    this.Yb || this.P();
                    null !== b && a.undoManager.copyProperties(b.undoManager)
                }
            }
        }, ba: {
            configurable: !0, get: function () {
                return this.kv
            }, set: function (a) {
                this.kv = a
            }
        }, iu: {
            configurable: !0, get: function () {
                return this.Ox
            }
        }, skipsModelSourceBindings: {
            configurable: !0, get: function () {
                return this.Cv
            }, set: function (a) {
                this.Cv = a
            }
        }, xu: {
            configurable: !0, get: function () {
                return this.rt
            }, set: function (a) {
                this.rt = a
            }
        }, nodeTemplate: {
            configurable: !0, get: function () {
                return this.qf.K("")
            },
            set: function (a) {
                var b = this.qf.K("");
                b !== a && (w(a, T, Q, "nodeTemplate"), this.qf.add("", a), this.g("nodeTemplate", b, a), this.undoManager.isUndoingRedoing || this.Nd())
            }
        }, nodeTemplateMap: {
            configurable: !0, get: function () {
                return this.qf
            }, set: function (a) {
                var b = this.qf;
                b !== a && (w(a, Db, Q, "nodeTemplateMap"), this.qf = a, this.g("nodeTemplateMap", b, a), this.undoManager.isUndoingRedoing || this.Nd())
            }
        }, groupTemplate: {
            configurable: !0, get: function () {
                return this.rh.K("")
            }, set: function (a) {
                var b = this.rh.K("");
                b !== a && (w(a, Kf, Q, "groupTemplate"), this.rh.add("", a), this.g("groupTemplate", b, a), this.undoManager.isUndoingRedoing || this.Nd())
            }
        }, groupTemplateMap: {
            configurable: !0, get: function () {
                return this.rh
            }, set: function (a) {
                var b = this.rh;
                b !== a && (w(a, Db, Q, "groupTemplateMap"), this.rh = a, this.g("groupTemplateMap", b, a), this.undoManager.isUndoingRedoing || this.Nd())
            }
        }, linkTemplate: {
            configurable: !0, get: function () {
                return this.og.K("")
            }, set: function (a) {
                var b = this.og.K("");
                b !== a && (w(a, S, Q, "linkTemplate"),
                    this.og.add("", a), this.g("linkTemplate", b, a), this.undoManager.isUndoingRedoing || this.Nd())
            }
        }, linkTemplateMap: {
            configurable: !0, get: function () {
                return this.og
            }, set: function (a) {
                var b = this.og;
                b !== a && (w(a, Db, Q, "linkTemplateMap"), this.og = a, this.g("linkTemplateMap", b, a), this.undoManager.isUndoingRedoing || this.Nd())
            }
        }, isMouseCaptured: {
            configurable: !0, get: function () {
                return this.gv
            }, set: function (a) {
                var b = this.Aa;
                null !== b && (b = b.La, b instanceof SVGElement || (a ? (this.lastInput.bubbles =
                    !1, this.Jj ? (this.removeEventListener(b, "pointermove", this.Wk, !1), this.removeEventListener(b, "pointerdown", this.Vk, !1), this.removeEventListener(b, "pointerup", this.Yk, !1), this.removeEventListener(b, "pointerout", this.Xk, !1), this.addEventListener(qa, "pointermove", this.Wk, !0), this.addEventListener(qa, "pointerdown", this.Vk, !0), this.addEventListener(qa, "pointerup", this.Yk, !0), this.addEventListener(qa, "pointerout", this.Xk, !0)) : (this.removeEventListener(b, "mousemove", this.Pk, !1), this.removeEventListener(b,
                    "mousedown", this.Ok, !1), this.removeEventListener(b, "mouseup", this.Rk, !1), this.removeEventListener(b, "mouseout", this.Qk, !1), this.addEventListener(qa, "mousemove", this.Pk, !0), this.addEventListener(qa, "mousedown", this.Ok, !0), this.addEventListener(qa, "mouseup", this.Rk, !0), this.addEventListener(qa, "mouseout", this.Qk, !0)), this.removeEventListener(b, "wheel", this.Sk, !1), this.addEventListener(qa, "wheel", this.Sk, !0), this.addEventListener(qa, "selectstart", this.preventDefault, !1)) : (this.Jj ? (this.removeEventListener(qa,
                    "pointermove", this.Wk, !0), this.removeEventListener(qa, "pointerdown", this.Vk, !0), this.removeEventListener(qa, "pointerup", this.Yk, !0), this.removeEventListener(qa, "pointerout", this.Xk, !0), this.addEventListener(b, "pointermove", this.Wk, !1), this.addEventListener(b, "pointerdown", this.Vk, !1), this.addEventListener(b, "pointerup", this.Yk, !1), this.addEventListener(b, "pointerout", this.Xk, !1)) : (this.removeEventListener(qa, "mousemove", this.Pk, !0), this.removeEventListener(qa, "mousedown", this.Ok, !0), this.removeEventListener(qa,
                    "mouseup", this.Rk, !0), this.removeEventListener(qa, "mouseout", this.Qk, !0), this.addEventListener(b, "mousemove", this.Pk, !1), this.addEventListener(b, "mousedown", this.Ok, !1), this.addEventListener(b, "mouseup", this.Rk, !1), this.addEventListener(b, "mouseout", this.Qk, !1)), this.removeEventListener(qa, "wheel", this.Sk, !0), this.removeEventListener(qa, "selectstart", this.preventDefault, !1), this.addEventListener(b, "wheel", this.Sk, !1)), this.gv = a))
            }
        }, position: {
            configurable: !0, get: function () {
                return this.ra
            },
            set: function (a) {
                var b = J.alloc().assign(this.ra);
                if (!b.A(a)) {
                    w(a, J, Q, "position");
                    var c = this.viewportBounds.copy();
                    this.ra.assign(a);
                    gi(this.animationManager, b, this.ra);
                    this.Yb || null === this.Aa && !this.Cm.o() || (this.Yb = !0, a = this.scale, mj(this, this.ao, this.Ea / a, this.Da / a, this.Nj, !1), this.Yb = !1);
                    this.Yb || this.gr(c, this.viewportBounds, this.Fa, !1)
                }
                J.free(b)
            }
        }, initialPosition: {
            configurable: !0, get: function () {
                return this.ss
            }, set: function (a) {
                this.ss.A(a) || (w(a, J, Q, "initialPosition"), this.ss = a.J())
            }
        },
        initialScale: {
            configurable: !0, get: function () {
                return this.ts
            }, set: function (a) {
                this.ts !== a && (A(a, "number", Q, "initialScale"), this.ts = a)
            }
        }, grid: {
            configurable: !0, get: function () {
                null === this.Pb && Xi(this);
                return this.Pb
            }, set: function (a) {
                var b = this.Pb;
                if (b !== a) {
                    null === b && (Xi(this), b = this.Pb);
                    w(a, W, Q, "grid");
                    a.type !== W.Grid && v("Diagram.grid must be a Panel of type Panel.Grid");
                    var c = b.panel;
                    null !== c && c.remove(b);
                    this.Pb = a;
                    a.name = "GRID";
                    null !== c && c.add(a);
                    Dj(this);
                    this.P();
                    this.g("grid",
                        b, a)
                }
            }
        }, viewportBounds: {
            configurable: !0, get: function () {
                var a = this.gy, b = this.ra, c = this.Fa;
                if (null === this.Aa) return this.Cm.o() && a.h(b.x, b.y, this.Ea / c, this.Da / c), a;
                a.h(b.x, b.y, Math.max(this.Ea, 0) / c, Math.max(this.Da, 0) / c);
                return a
            }
        }, viewSize: {
            configurable: !0, get: function () {
                return this.Cm
            }, set: function (a) {
                var b = this.viewSize;
                b.A(a) || (w(a, Hb, Q, "viewSize"), this.Cm = a = a.J(), this.Ea = a.width, this.Da = a.height, this.Ua(), this.g("viewSize", b, a))
            }
        }, fixedBounds: {
            configurable: !0,
            get: function () {
                return this.ns
            }, set: function (a) {
                var b = this.ns;
                b.A(a) || (w(a, L, Q, "fixedBounds"), (F && Infinity === a.width || -Infinity === a.width || Infinity === a.height || -Infinity === a.height) && v("fixedBounds width/height must not be Infinity"), this.ns = a = a.J(), this.Ua(), this.g("fixedBounds", b, a))
            }
        }, scrollMargin: {
            configurable: !0, get: function () {
                return this.bj
            }, set: function (a) {
                "number" === typeof a ? a = new jc(a) : w(a, jc, Q, "scrollMargin");
                var b = this.bj;
                b.A(a) || (this.bj = a = a.J(), this.g("scrollMargin", b, a),
                    this.kr())
            }
        }, scrollMode: {
            configurable: !0, get: function () {
                return this.cj
            }, set: function (a) {
                var b = this.cj;
                b !== a && (ib(a, Q, Q, "scrollMode"), this.cj = a, a === ni && kj(this, !1), this.g("scrollMode", b, a), this.P())
            }
        }, scrollsPageOnFocus: {
            configurable: !0, get: function () {
                return this.nt
            }, set: function (a) {
                var b = this.nt;
                b !== a && (A(a, "boolean", Q, "scrollsPageOnFocus"), this.nt = a, this.g("scrollsPageOnFocus", b, a))
            }
        }, positionComputation: {
            configurable: !0, get: function () {
                return this.at
            }, set: function (a) {
                var b =
                    this.at;
                b !== a && (null !== a && A(a, "function", Q, "positionComputation"), this.at = a, kj(this, !1), this.g("positionComputation", b, a))
            }
        }, scaleComputation: {
            configurable: !0, get: function () {
                return this.gt
            }, set: function (a) {
                var b = this.gt;
                b !== a && (null !== a && A(a, "function", Q, "scaleComputation"), this.gt = a, jk(this, this.scale, this.scale), this.g("scaleComputation", b, a))
            }
        }, documentBounds: {
            configurable: !0, get: function () {
                return this.ao
            }
        }, isVirtualized: {
            configurable: !0, get: function () {
                return this.Es
            },
            set: function (a) {
                var b = this.Es;
                b !== a && (A(a, "boolean", Q, "isVirtualized"), this.Es = a, this.g("isVirtualized", b, a))
            }
        }, scale: {
            configurable: !0, get: function () {
                return this.Fa
            }, set: function (a) {
                var b = this.Fa;
                C(a, Q, "scale");
                b !== a && jk(this, b, a)
            }
        }, defaultScale: {
            configurable: !0, get: function () {
                return this.$n
            }, set: function (a) {
                F && C(a, Q, "defaultScale");
                !F || 0 < a || v("defaultScale must be larger than zero, not: " + a);
                this.$n = a
            }
        }, autoScale: {
            configurable: !0, get: function () {
                return this.ah
            },
            set: function (a) {
                var b = this.ah;
                b !== a && (ib(a, Q, Q, "autoScale"), this.ah = a, this.g("autoScale", b, a), a !== Mh && kj(this, !1))
            }
        }, initialAutoScale: {
            configurable: !0, get: function () {
                return this.kg
            }, set: function (a) {
                var b = this.kg;
                b !== a && (ib(a, Q, Q, "initialAutoScale"), this.kg = a, this.g("initialAutoScale", b, a))
            }
        }, initialViewportSpot: {
            configurable: !0, get: function () {
                return this.us
            }, set: function (a) {
                var b = this.us;
                b !== a && (w(a, M, Q, "initialViewportSpot"), a.cb() || v("initialViewportSpot must be a specific Spot: " +
                    a), this.us = a, this.g("initialViewportSpot", b, a))
            }
        }, initialDocumentSpot: {
            configurable: !0, get: function () {
                return this.rs
            }, set: function (a) {
                var b = this.rs;
                b !== a && (w(a, M, Q, "initialDocumentSpot"), a.cb() || v("initialViewportSpot must be a specific Spot: " + a), this.rs = a, this.g("initialDocumentSpot", b, a))
            }
        }, minScale: {
            configurable: !0, get: function () {
                return this.Ks
            }, set: function (a) {
                C(a, Q, "minScale");
                var b = this.Ks;
                b !== a && (0 < a ? (this.Ks = a, this.g("minScale", b, a), a > this.scale && (this.scale = a)) :
                    za(a, "> 0", Q, "minScale"))
            }
        }, maxScale: {
            configurable: !0, get: function () {
                return this.Is
            }, set: function (a) {
                C(a, Q, "maxScale");
                var b = this.Is;
                b !== a && (0 < a ? (this.Is = a, this.g("maxScale", b, a), a < this.scale && (this.scale = a)) : za(a, "> 0", Q, "maxScale"))
            }
        }, zoomPoint: {
            configurable: !0, get: function () {
                return this.It
            }, set: function (a) {
                this.It.A(a) || (w(a, J, Q, "zoomPoint"), this.It = a = a.J())
            }
        }, contentAlignment: {
            configurable: !0, get: function () {
                return this.Nj
            }, set: function (a) {
                var b = this.Nj;
                b.A(a) || (w(a, M, Q, "contentAlignment"), this.Nj = a = a.J(), this.g("contentAlignment", b, a), kj(this, !1))
            }
        }, initialContentAlignment: {
            configurable: !0, get: function () {
                return this.Bo
            }, set: function (a) {
                var b = this.Bo;
                b.A(a) || (w(a, M, Q, "initialContentAlignment"), this.Bo = a = a.J(), this.g("initialContentAlignment", b, a))
            }
        }, padding: {
            configurable: !0, get: function () {
                return this.ob
            }, set: function (a) {
                "number" === typeof a ? a = new jc(a) : w(a, jc, Q, "padding");
                var b = this.ob;
                b.A(a) || (this.ob = a = a.J(), this.Ua(),
                    this.g("padding", b, a))
            }
        }, partManager: {
            configurable: !0, get: function () {
                return this.Pa
            }, set: function (a) {
                var b = this.Pa;
                b !== a && (w(a, Ii, Q, "partManager"), null !== a.diagram && v("Cannot share PartManagers between Diagrams: " + a.toString()), null !== b && b.ie(null), this.Pa = a, a.ie(this))
            }
        }, nodes: {
            configurable: !0, get: function () {
                return this.partManager.nodes.iterator
            }
        }, links: {
            configurable: !0, get: function () {
                return this.partManager.links.iterator
            }
        }, parts: {
            configurable: !0,
            get: function () {
                return this.partManager.parts.iterator
            }
        }, layout: {
            configurable: !0, get: function () {
                return this.rc
            }, set: function (a) {
                var b = this.rc;
                b !== a && (w(a, Ni, Q, "layout"), this.rc = a, a.diagram = this, a.group = null, this.$g = !0, this.g("layout", b, a), this.Kb())
            }
        }, isTreePathToChildren: {
            configurable: !0, get: function () {
                return this.Ds
            }, set: function (a) {
                var b = this.Ds;
                if (b !== a && (A(a, "boolean", Q, "isTreePathToChildren"), this.Ds = a, this.g("isTreePathToChildren", b, a), !this.undoManager.isUndoingRedoing)) for (a =
                                                                                                                                                                             this.nodes; a.next();) Uk(a.value)
            }
        }, treeCollapsePolicy: {
            configurable: !0, get: function () {
                return this.Ct
            }, set: function (a) {
                var b = this.Ct;
                b !== a && (a !== Gi && a !== Vk && a !== Wk && v("Unknown Diagram.treeCollapsePolicy: " + a), this.Ct = a, this.g("treeCollapsePolicy", b, a))
            }
        }, Ue: {
            configurable: !0, get: function () {
                return this.dv
            }, set: function (a) {
                this.dv = a
            }
        }, autoScrollInterval: {
            configurable: !0, get: function () {
                return this.An
            }, set: function (a) {
                var b = this.An;
                C(a, Q, "scale");
                b !== a && (this.An =
                    a, this.g("autoScrollInterval", b, a))
            }
        }, autoScrollRegion: {
            configurable: !0, get: function () {
                return this.Cn
            }, set: function (a) {
                "number" === typeof a ? a = new jc(a) : w(a, jc, Q, "autoScrollRegion");
                var b = this.Cn;
                b.A(a) || (this.Cn = a = a.J(), this.Ua(), this.g("autoScrollRegion", b, a))
            }
        }
    });
    na.Object.defineProperties(Q, {
        licenseKey: {
            configurable: !0, get: function () {
                return Xk.cc()
            }, set: function (a) {
                Xk.add(a)
            }
        }, version: {
            configurable: !0, get: function () {
                return Yk
            }
        }
    });
    Q.prototype.makeImageData = Q.prototype.Xy;
    Q.prototype.makeImage = Q.prototype.YA;
    Q.prototype.addRenderer = Q.prototype.Gz;
    Q.prototype.makeSVG = Q.prototype.tw;
    Q.prototype.makeSvg = Q.prototype.ku;
    Q.prototype.stopAutoScroll = Q.prototype.Vf;
    Q.prototype.doAutoScroll = Q.prototype.Qt;
    Q.prototype.isUnoccupied = Q.prototype.Lk;
    Q.prototype.raiseDiagramEvent = Q.prototype.U;
    Q.prototype.removeDiagramListener = Q.prototype.Xm;
    Q.prototype.addDiagramListener = Q.prototype.vk;
    Q.prototype.findTreeRoots = Q.prototype.BA;
    Q.prototype.layoutDiagram = Q.prototype.WA;
    Q.prototype.findTopLevelGroups = Q.prototype.uA;
    Q.prototype.findTopLevelNodesAndLinks = Q.prototype.vA;
    Q.prototype.ensureBounds = Q.prototype.Ya;
    Q.prototype.findLinksByExample = Q.prototype.Tt;
    Q.prototype.findNodesByExample = Q.prototype.Ut;
    Q.prototype.findLinkForData = Q.prototype.Ec;
    Q.prototype.findNodeForData = Q.prototype.qj;
    Q.prototype.findPartForData = Q.prototype.Fc;
    Q.prototype.findLinkForKey = Q.prototype.findLinkForKey;
    Q.prototype.findNodeForKey = Q.prototype.Ib;
    Q.prototype.findPartForKey = Q.prototype.findPartForKey;
    Q.prototype.rebuildParts = Q.prototype.Nd;
    Q.prototype.transformViewToDoc = Q.prototype.yu;
    Q.prototype.transformRectDocToView = Q.prototype.xB;
    Q.prototype.transformDocToView = Q.prototype.vr;
    Q.prototype.centerRect = Q.prototype.Lt;
    Q.prototype.scrollToRect = Q.prototype.Mw;
    Q.prototype.scroll = Q.prototype.scroll;
    Q.prototype.highlightCollection = Q.prototype.NA;
    Q.prototype.highlight = Q.prototype.MA;
    Q.prototype.selectCollection = Q.prototype.oB;
    Q.prototype.select = Q.prototype.select;
    Q.prototype.updateAllRelationshipsFromData = Q.prototype.xr;
    Q.prototype.updateAllTargetBindings = Q.prototype.updateAllTargetBindings;
    Q.prototype.commit = Q.prototype.commit;
    Q.prototype.rollbackTransaction = Q.prototype.Uf;
    Q.prototype.commitTransaction = Q.prototype.bb;
    Q.prototype.startTransaction = Q.prototype.Ca;
    Q.prototype.raiseChanged = Q.prototype.g;
    Q.prototype.raiseChangedEvent = Q.prototype.ib;
    Q.prototype.removeChangedListener = Q.prototype.$k;
    Q.prototype.addChangedListener = Q.prototype.Rh;
    Q.prototype.removeModelChangedListener = Q.prototype.kB;
    Q.prototype.addModelChangedListener = Q.prototype.my;
    Q.prototype.findLayer = Q.prototype.Km;
    Q.prototype.removeLayer = Q.prototype.iB;
    Q.prototype.addLayerAfter = Q.prototype.Dz;
    Q.prototype.addLayerBefore = Q.prototype.jy;
    Q.prototype.addLayer = Q.prototype.Em;
    Q.prototype.moveParts = Q.prototype.moveParts;
    Q.prototype.copyParts = Q.prototype.Dk;
    Q.prototype.removeParts = Q.prototype.ru;
    Q.prototype.remove = Q.prototype.remove;
    Q.prototype.add = Q.prototype.add;
    Q.prototype.clearDelayedGeometries = Q.prototype.Rv;
    Q.prototype.setProperties = Q.prototype.Rw;
    Q.prototype.resetInputOptions = Q.prototype.Iw;
    Q.prototype.setInputOption = Q.prototype.pB;
    Q.prototype.getInputOption = Q.prototype.Nm;
    Q.prototype.resetRenderingHints = Q.prototype.Jw;
    Q.prototype.setRenderingHint = Q.prototype.iz;
    Q.prototype.getRenderingHint = Q.prototype.Te;
    Q.prototype.maybeUpdate = Q.prototype.md;
    Q.prototype.requestUpdate = Q.prototype.Kb;
    Q.prototype.delayInitialization = Q.prototype.Yz;
    Q.prototype.isUpdateRequested = Q.prototype.SA;
    Q.prototype.redraw = Q.prototype.We;
    Q.prototype.invalidateDocumentBounds = Q.prototype.Ua;
    Q.prototype.findObjectsNear = Q.prototype.Rg;
    Q.prototype.findPartsNear = Q.prototype.rA;
    Q.prototype.findObjectsIn = Q.prototype.Lf;
    Q.prototype.findPartsIn = Q.prototype.Hy;
    Q.prototype.findObjectsAt = Q.prototype.rj;
    Q.prototype.findPartsAt = Q.prototype.qA;
    Q.prototype.findObjectAt = Q.prototype.ac;
    Q.prototype.findPartAt = Q.prototype.Lm;
    Q.prototype.focusObject = Q.prototype.CA;
    Q.prototype.alignDocument = Q.prototype.Iz;
    Q.prototype.zoomToRect = Q.prototype.BB;
    Q.prototype.zoomToFit = Q.prototype.zoomToFit;
    Q.prototype.diagramScroll = Q.prototype.wy;
    Q.prototype.focus = Q.prototype.focus;
    Q.prototype.reset = Q.prototype.reset;
    Q.useDOM = function (a) {
        ih = a ? void 0 !== qa.document : !1
    };
    Q.isUsingDOM = function () {
        return ih
    };
    var Te = null, Hi = new Db, Vi = null, Ui = null, ih = void 0 !== qa.document, Qi = null, Ri = "",
        Mh = new E(Q, "None", 0), pj = new E(Q, "Uniform", 1), qj = new E(Q, "UniformToFill", 2),
        ag = new E(Q, "CycleAll", 10), eg = new E(Q, "CycleNotDirected", 11), gg = new E(Q, "CycleNotDirectedFast", 12),
        hg = new E(Q, "CycleNotUndirected", 13), bg = new E(Q, "CycleDestinationTree", 14),
        dg = new E(Q, "CycleSourceTree", 15), ni = new E(Q, "DocumentScroll", 1), pi = new E(Q, "InfiniteScroll", 2),
        Gi = new E(Q, "TreeParentCollapsed", 21), Vk = new E(Q, "AllParentsCollapsed", 22), Wk = new E(Q,
        "AnyParentsCollapsed", 23), Xk = new H, Yk = "2.1.37", Rk = "image", Tk = !1, Zk = null, Di = !1;

    function Ei() {
        if (ih) {
            var a = qa.document.createElement("canvas"), b = a.getContext("2d"), c = Ya("7ca11abfd022028846");
            b[c] = Ya("398c3597c01238");
            for (var d = ["5da73c80a36455d5038e4972187c3cae51fd22", ra.Dx + "4ae6247590da4bb21c324ba3a84e385776", Ib.xF + "fb236cdfda5de14c134ba1a95a2d4c7cc6f93c1387", K.za], e = 1; 5 > e; e++) b[Ya("7ca11abfd7330390")](Ya(d[e - 1]), 10, 15 * e);
            b[c] = Ya("39f046ebb36e4b");
            for (c = 1; 5 > c; c++) b[Ya("7ca11abfd7330390")](Ya(d[c - 1]), 10, 15 * c);
            if (4 !== d.length || "5" !== d[0][0] || "7" !== d[3][0]) Ib.prototype.Kd = Ib.prototype.py;
            Zk = a
        }
    }

    Q.className = "Diagram";
    Q.fromDiv = function (a) {
        var b = a;
        "string" === typeof a && (b = qa.document.getElementById(a));
        return b instanceof HTMLDivElement && b.B instanceof Q ? b.B : null
    };
    Q.inherit = function (a, b) {
        function c() {
        }

        if (Object.getPrototypeOf(a).prototype) throw Error("Used go.Diagram.inherit defining already defined class \n" + a);
        A(a, "function", Q, "inherit");
        A(b, "function", Q, "inherit");
        c.prototype = b.prototype;
        a.prototype = new c;
        a.prototype.constructor = a
    };
    Q.None = Mh;
    Q.Uniform = pj;
    Q.UniformToFill = qj;
    Q.CycleAll = ag;
    Q.CycleNotDirected = eg;
    Q.CycleNotDirectedFast = gg;
    Q.CycleNotUndirected = hg;
    Q.CycleDestinationTree = bg;
    Q.CycleSourceTree = dg;
    Q.DocumentScroll = ni;
    Q.InfiniteScroll = pi;
    Q.TreeParentCollapsed = Gi;
    Q.AllParentsCollapsed = Vk;
    Q.AnyParentsCollapsed = Wk;

    function Oi() {
        this.zz = null;
        this.l = "zz@orderNum";
        "63ad05bbe23a1786468a4c741b6d2" === this._tk ? this.ff = this.l = !0 : this.ff = null
    }

    function Mj(a, b) {
        b.Nb.setTransform(b.Zb, 0, 0, b.Zb, 0, 0);
        if (null === a.ff) {
            b = "f";
            var c = qa[Ya("76a715b2f73f148a")][Ya("72ba13b5")];
            a.ff = !0;
            if (ih) {
                var d = Q[Ya("76a115b6ed251eaf4692")];
                if (d) for (var e = Xk.iterator; e.next();) {
                    d = e.value;
                    d = Ya(d).split(Ya("39e9"));
                    if (6 > d.length) break;
                    var f = Ya(d[1]).split(".");
                    if ("7da71ca0" !== d[4]) break;
                    var g = Ya(ra[Ya("6cae19")]).split(".");
                    if (f[0] > g[0] || f[0] === g[0] && f[1] >= g[1]) {
                        f = c[Ya("76ad18b4f73e")];
                        for (g = c[Ya("73a612b6fb191d")](Ya("35e7")) + 2; g < f; g++) b += c[g];
                        f = b[Ya("73a612b6fb191d")](Ya(d[2]));
                        0 > f && Ya(d[2]) !== Ya("7da71ca0ad381e90") && (f = b[Ya("73a612b6fb191d")](Ya("76a715b2ef3e149757")));
                        0 > f && (f = b[Ya("73a612b6fb191d")](Ya("76a715b2ef3e149757")));
                        0 > f && (f = c[Ya("73a612b6fb191d")](Ya("7baa19a6f76c1988428554")));
                        a.ff = !(0 <= f && f < b[Ya("73a612b6fb191d")](Ya("35")) || -1 === b[Ya("73a612b6fb191d")](Ya("35")));
                        if (!a.ff) break;
                        f = Ya(d[2]);
                        if ("#" !== f[0]) break;
                        g = qa.document.createElement("div");
                        for (var h = d[0].replace(/[A-Za-z]/g, ""); 4 > h.length;) h += "9";
                        h = h.substr(h.length - 4);
                        d = "";
                        d += ["gsh", "gsf"][parseInt(h.substr(0,
                            1), 10) % 2];
                        d += ["Header", "Background", "Display", "Feedback"][parseInt(h.substr(0, 1), 10) % 4];
                        g[Ya("79a417a0f0181a8946")] = d;
                        if (qa.document[Ya("78a712aa")]) {
                            qa.document[Ya("78a712aa")][Ya("7bb806b6ed32388c4a875b")](g);
                            h = qa.getComputedStyle(g).getPropertyValue(Ya("78a704b7e62456904c9b12701b6532a8"));
                            qa.document[Ya("78a712aa")][Ya("68ad1bbcf533388c4a875b")](g);
                            if (!h) break;
                            if (-1 !== h.indexOf(parseInt(f[1] + f[2], 16)) && -1 !== h.indexOf(parseInt(f[3] + f[4], 16))) {
                                a.ff = !1;
                                break
                            } else if (Za || $a || cb || db) for (d = "." + d, f = 0; f <
                            document.styleSheets.length; f++) {
                                g = document.styleSheets[f].rules || document.styleSheets[f].cssRules;
                                for (var k in g) if (d === g[k].selectorText) {
                                    a.ff = !1;
                                    break
                                }
                            }
                        } else a.ff = null, a.ff = !1
                    }
                } else {
                    k = c[Ya("76ad18b4f73e")];
                    for (e = c[Ya("73a612b6fb191d")](Ya("35e7")) + 2; e < k; e++) b += c[e];
                    c = b[Ya("73a612b6fb191d")](Ya("7da71ca0ad381e90"));
                    a.ff = !(0 <= c && c < b[Ya("73a612b6fb191d")](Ya("35")))
                }
            }
        }
        return 0 < a.ff && a !== a.zz ? !0 : !1
    }

    function Pi(a, b) {
        if (ih) {
            void 0 !== b && null !== b || v("Diagram setup requires an argument DIV.");
            null !== a.Ja && v("Diagram has already completed setup.");
            "string" === typeof b ? a.Ja = qa.document.getElementById(b) : b instanceof HTMLDivElement ? a.Ja = b : v("No DIV or DIV id supplied: " + b);
            null === a.Ja && v("Invalid DIV id; could not get element with id: " + b);
            void 0 !== a.Ja.B && v("Invalid div id; div already has a Diagram associated with it.");
            if (!a.jm && qa.ResizeObserver) {
                var c = sa(function () {
                    a.Kb()
                }, 250);
                a.jm = new qa.ResizeObserver(function () {
                    c()
                });
                a.jm.observe(a.Ja)
            }
            "static" === qa.getComputedStyle(a.Ja, null).position && (a.Ja.style.position = "relative");
            b = 5;
            var d = "rgba(2" + b + "5, 255, 255, 0)";
            b--;
            a.Ja.style["-webkit-tap-highlight-color"] = d;
            a.Ja.style["-ms-touch-action"] = "none";
            a.Ja.innerHTML = "";
            a.Ja.B = a;
            a.Ja.goDiagram = a;
            a.Ja.go = qa.go;
            var e = a.pq ? new Rj(a) : new Sk(a);
            void 0 !== e.style && (e.style.position = "absolute", e.style.top = "0px", e.style.left = "0px", "rtl" === qa.getComputedStyle(a.Ja, null).getPropertyValue("direction") && (a.Sl = !0), e.style.zIndex = "2",
                e.style.userSelect = "none", e.style.MozUserSelect = "none");
            a.Aa = e;
            a.Nb = e.context;
            d = a.Nb;
            a.Zb = a.computePixelRatio();
            a.Ea = a.Ja.clientWidth || 1;
            a.Da = a.Ja.clientHeight || 1;
            Tj(a, a.Ea, a.Da);
            a.Ja.insertBefore(e.La, a.Ja.firstChild);
            e = new Sk(null);
            e.width = 1;
            e.height = 1;
            a.Tu = e;
            a.Hx = e.context;
            if (ih) {
                e = ua("div");
                var f = ua("div");
                e.style.position = "absolute";
                e.style.overflow = "auto";
                e.style.width = a.Ea + "px";
                e.style.height = a.Da + "px";
                e.style.zIndex = "1";
                f.style.position = "absolute";
                f.style.width = "1px";
                f.style.height = "1px";
                a.Ja.appendChild(e);
                e.appendChild(f);
                e.onscroll = ej;
                e.addEventListener("mousedown", gj);
                e.addEventListener("touchstart", gj, {passive: !0});
                e.B = a;
                e.xz = !0;
                e.yz = !0;
                a.kt = e;
                a.Wp = f
            }
            a.kr = sa(function () {
                a.Ih = null;
                a.P()
            }, 300);
            a.kx = sa(function () {
                Yh(a)
            }, 250);
            a.preventDefault = function (a) {
                a.preventDefault();
                return !1
            };
            a.Pk = function (b) {
                if (a.isEnabled) {
                    a.lg = !0;
                    var c = uj(a, b, !0);
                    a.doMouseMove();
                    a.currentTool.isBeyondDragSize() && (a.zd = 0);
                    Aj(a, c, b)
                }
            };
            a.Ok = function (b) {
                if (a.isEnabled) if (a.lg = !0, a.xe) b.preventDefault(); else {
                    var c =
                        uj(a, b, !0);
                    c.down = !0;
                    c.clickCount = b.detail;
                    if ($a || cb) b.timeStamp - a.bk < a.Bt && !a.currentTool.isBeyondDragSize() ? a.zd++ : a.zd = 1, a.bk = b.timeStamp, c.clickCount = a.zd;
                    c.clone(a.firstInput);
                    a.doMouseDown();
                    1 === b.button ? b.preventDefault() : Aj(a, c, b)
                }
            };
            a.Rk = function (b) {
                if (a.isEnabled) if (a.xe && 2 === b.button) b.preventDefault(); else if (a.xe && 0 === b.button && (a.xe = !1), a.sk) b.preventDefault(); else {
                    a.lg = !0;
                    var c = uj(a, b, !0);
                    c.up = !0;
                    c.clickCount = b.detail;
                    if ($a || cb) c.clickCount = a.zd;
                    c.bubbles = b.bubbles;
                    c.targetDiagram = wj(b);
                    a.doMouseUp();
                    a.Vf();
                    Aj(a, c, b)
                }
            };
            a.Sk = function (b) {
                if (a.isEnabled) {
                    var c = uj(a, b, !0);
                    c.bubbles = !0;
                    var d = 0, e = 0;
                    c.delta = 0;
                    void 0 !== b.deltaX ? (0 !== b.deltaX && (d = 0 < b.deltaX ? 1 : -1), 0 !== b.deltaY && (e = 0 < b.deltaY ? 1 : -1), c.delta = Math.abs(b.deltaX) > Math.abs(b.deltaY) ? -d : -e) : void 0 !== b.wheelDeltaX ? (0 !== b.wheelDeltaX && (d = 0 < b.wheelDeltaX ? -1 : 1), 0 !== b.wheelDeltaY && (e = 0 < b.wheelDeltaY ? -1 : 1), c.delta = Math.abs(b.wheelDeltaX) > Math.abs(b.wheelDeltaY) ? -d : -e) : void 0 !== b.wheelDelta && 0 !== b.wheelDelta && (c.delta = 0 < b.wheelDelta ? 1 : -1);
                    a.doMouseWheel();
                    Aj(a, c, b)
                }
            };
            a.Qk = function (b) {
                a.isEnabled && (a.lg = !1, uj(a, b, !0), b = a.currentTool, b.cancelWaitAfter(), b.standardMouseOver())
            };
            a.$w = function (b) {
                if (a.isEnabled) {
                    a.sk = !1;
                    a.xe = !0;
                    var c = xj(a, b, b.targetTouches[0], 1 < b.touches.length), d = null;
                    0 < b.targetTouches.length ? d = b.targetTouches[0] : 0 < b.changedTouches.length && (d = b.changedTouches[0]);
                    if (null !== d) {
                        var e = d.screenX;
                        d = d.screenY;
                        var f = a.No;
                        b.timeStamp - a.bk < a.Bt && !(25 < Math.abs(f.x - e) || 25 < Math.abs(f.y - d)) ? a.zd++ : a.zd = 1;
                        c.clickCount = a.zd;
                        a.bk = b.timeStamp;
                        a.No.h(e, d)
                    }
                    a.doMouseDown();
                    Aj(a, c, b)
                }
            };
            a.Zw = function (b) {
                if (a.isEnabled) {
                    var c = null;
                    0 < b.targetTouches.length ? c = b.targetTouches[0] : 0 < b.changedTouches.length && (c = b.changedTouches[0]);
                    c = zj(a, b, c, 1 < b.touches.length);
                    a.doMouseMove();
                    Aj(a, c, b)
                }
            };
            a.Yw = function (b) {
                if (a.isEnabled) if (a.sk) b.preventDefault(); else if (!(1 < b.touches.length)) {
                    var c = null, d = null;
                    0 < b.targetTouches.length ? d = b.targetTouches[0] : 0 < b.changedTouches.length && (d = b.changedTouches[0]);
                    var e = yj(a, b, !1, !0, !1, !1);
                    null !== d && (c = qa.document.elementFromPoint(d.clientX,
                        d.clientY), null !== c && null !== c && null !== c.shadowRoot && (c = c.shadowRoot.elementFromPoint(d.clientX, d.clientY)), null !== c && c.B instanceof Q && c.B !== a && vj(c.B, d, e), vj(a, d, e), e.clickCount = a.zd);
                    null === c ? e.targetDiagram = wj(b) : c.B ? e.targetDiagram = c.B : e.targetDiagram = null;
                    e.targetObject = null;
                    a.doMouseUp();
                    Aj(a, e, b);
                    a.xe = !1
                }
            };
            a.Vk = function (b) {
                if (a.isEnabled) {
                    a.lg = !0;
                    var c = a.Zs;
                    void 0 === c[b.pointerId] && (c[b.pointerId] = b);
                    c = a.lk;
                    var d = !1;
                    if (null !== c[0] && c[0].pointerId === b.pointerId) c[0] = b; else if (null !== c[1] && c[1].pointerId ===
                        b.pointerId) c[1] = b, d = !0; else if (null === c[0]) c[0] = b; else if (null === c[1]) c[1] = b, d = !0; else {
                        b.preventDefault();
                        return
                    }
                    if ("touch" === b.pointerType || "pen" === b.pointerType) a.sk = !1, a.xe = !0;
                    c = xj(a, b, b, d);
                    d = a.No;
                    var e = "touch" === b.pointerType || "pen" === b.pointerType ? 25 : 10;
                    b.timeStamp - a.bk < a.Bt && !(Math.abs(d.x - b.screenX) > e || Math.abs(d.y - b.screenY) > e) ? a.zd++ : a.zd = 1;
                    c.clickCount = a.zd;
                    a.bk = b.timeStamp;
                    a.No.Vg(b.screenX, b.screenY);
                    a.doMouseDown();
                    1 === b.button ? b.preventDefault() : Aj(a, c, b)
                }
            };
            a.Wk = function (b) {
                if (a.isEnabled) {
                    a.lg =
                        !0;
                    var c = a.lk;
                    if (null !== c[0] && c[0].pointerId === b.pointerId) c[0] = b; else {
                        if (null !== c[1] && c[1].pointerId === b.pointerId) {
                            c[1] = b;
                            return
                        }
                        if (null === c[0]) c[0] = b; else return
                    }
                    c[0].pointerId === b.pointerId && (c = zj(a, b, b, null !== c[1]), c.targetDiagram = wj(b), a.doMouseMove(), Aj(a, c, b))
                }
            };
            a.Yk = function (b) {
                if (a.isEnabled) {
                    a.lg = !0;
                    var c = "touch" === b.pointerType || "pen" === b.pointerType, d = a.Zs;
                    if (c && a.sk) delete d[b.pointerId], b.preventDefault(); else if (d = a.lk, null !== d[0] && d[0].pointerId === b.pointerId) {
                        d[0] = null;
                        d = yj(a, b,
                            !1, !0, !0, !1);
                        var e = qa.document.elementFromPoint(b.clientX, b.clientY);
                        null !== e && e.B instanceof Q && e.B !== a && vj(e.B, b, d);
                        vj(a, b, d);
                        d.clickCount = a.zd;
                        null === e ? d.targetDiagram = wj(b) : e.B ? d.targetDiagram = e.B : d.targetDiagram = null;
                        d.targetObject = null;
                        a.doMouseUp();
                        Aj(a, d, b);
                        c && (a.xe = !1)
                    } else null !== d[1] && d[1].pointerId === b.pointerId && (d[1] = null)
                }
            };
            a.Xk = function (b) {
                if (a.isEnabled) {
                    a.lg = !1;
                    var c = a.Zs;
                    c[b.pointerId] && delete c[b.pointerId];
                    c = a.lk;
                    null !== c[0] && c[0].pointerId === b.pointerId && (c[0] = null);
                    null !== c[1] &&
                    c[1].pointerId === b.pointerId && (c[1] = null);
                    "touch" !== b.pointerType && "pen" !== b.pointerType && (b = a.currentTool, b.cancelWaitAfter(), b.standardMouseOver())
                }
            };
            a.hs = d.aa["d" + $k[1] + $k[2] + "wI" + Rk.slice(1, 5)]["b" + al.slice(1, b)](d.aa, Zk, b, b);
            d.Ac(!0);
            Wi(a)
        }
    }

    Oi.className = "DiagramHelper";

    function rf(a) {
        this.l = void 0 === a ? new J : a;
        this.w = new J
    }

    na.Object.defineProperties(rf.prototype, {
        point: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                this.l = a
            }
        }, shifted: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                this.w = a
            }
        }
    });
    var $k = "DraggingInfo";
    rf.className = "DraggingInfo";

    function ek(a, b, c) {
        this.node = a;
        this.info = b;
        this.lw = c
    }

    ek.className = "DraggingNodeInfoPair";

    function kf() {
        this.reset()
    }

    kf.prototype.reset = function () {
        this.isGridSnapEnabled = !1;
        this.isGridSnapRealtime = !0;
        this.gridSnapCellSize = (new Hb(NaN, NaN)).freeze();
        this.gridSnapCellSpot = Fc;
        this.gridSnapOrigin = (new J(NaN, NaN)).freeze();
        this.groupsSnapMembers = this.dragsTree = this.dragsLink = !1;
        this.dragsMembers = this.groupsAlwaysMove = !0
    };
    kf.className = "DraggingOptions";

    function bl(a) {
        1 < arguments.length && v("Palette constructor can only take one optional argument, the DIV HTML element or its id.");
        Q.call(this, a);
        cl(this)
    }

    ma(bl, Q);

    function cl(a) {
        a.allowDragOut = !0;
        a.allowMove = !1;
        a.isReadOnly = !0;
        a.contentAlignment = Gc;
        a.layout = new dl
    }

    bl.prototype.reset = function () {
        Q.prototype.reset.call(this);
        cl(this)
    };
    bl.className = "Palette";

    function el(a) {
        1 < arguments.length && v("Overview constructor can only take one optional argument, the DIV HTML element or its id.");
        Q.call(this, a);
        var b = this;
        this.animationManager.isEnabled = !1;
        this.Yb = !0;
        this.Oa = null;
        this.Il = this.Hl = !1;
        this.w = this.L = !0;
        this.kb = 0;
        this.W = !1;
        this.pm = null;
        this.iz("drawShadows", !1);
        var c = new T, d = new Zf;
        d.stroke = "magenta";
        d.strokeWidth = 2;
        d.fill = "transparent";
        d.name = "BOXSHAPE";
        c.selectable = !0;
        c.selectionAdorned = !1;
        c.selectionObjectName = "BOXSHAPE";
        c.locationObjectName = "BOXSHAPE";
        c.resizeObjectName = "BOXSHAPE";
        c.cursor = "move";
        c.add(d);
        this.l = c;
        this.allowDelete = this.allowCopy = !1;
        this.allowSelect = !0;
        this.autoScrollRegion = new jc(0, 0, 0, 0);
        this.ra.h(0, 0);
        this.toolManager.eb("Dragging", new fl, this.toolManager.mouseMoveTools);
        this.click = function () {
            var a = b.observed;
            if (null !== a) {
                var c = a.viewportBounds, d = b.lastInput.documentPoint;
                a.position = new J(d.x - c.width / 2, d.y - c.height / 2)
            }
        };
        this.gi = function () {
            b.Ua();
            gl(b)
        };
        this.fi = function () {
            null !== b.observed && (b.Ua(), b.P())
        };
        this.Zc = function () {
            1 >
            b.updateDelay ? b.P() : b.W || (b.W = !0, setTimeout(function () {
                b.W = !1;
                var a = b.Aa, c = b.Nb;
                if (null !== a && null !== c) {
                    Kj(b);
                    if (null === b.pm) {
                        var d = new Sk(null);
                        d.width = a.width;
                        d.height = a.height;
                        b.pm = d
                    }
                    try {
                        b.Aa = b.pm, b.Nb = b.Aa.context, b.Nb.Ac(!0), b.Nb.setTransform(1, 0, 0, 1, 0, 0), b.Nb.clearRect(0, 0, b.Aa.width, b.Aa.height), hl(b)
                    } finally {
                        b.Aa = a, b.Nb = c
                    }
                }
                b.P()
            }, b.updateDelay))
        };
        this.Pd = function () {
            null !== b.observed && gl(b)
        };
        this.autoScale = pj;
        this.Yb = !1
    }

    ma(el, Q);
    el.prototype.computePixelRatio = function () {
        return 1
    };
    el.prototype.ic = function () {
        null === this.Ja && v("No div specified");
        null === this.Aa && v("No canvas specified");
        if (!(this.Aa instanceof Rj) && (yi(this.box), this.Kc)) {
            var a = this.observed;
            if (null !== a && !a.animationManager.isAnimating && a.Aj) {
                Kj(this);
                var b = this.Aa;
                a = this.Nb;
                a.Ac(!0);
                a.setTransform(1, 0, 0, 1, 0, 0);
                a.clearRect(0, 0, b.width, b.height);
                1 > this.updateDelay ? hl(this) : null !== this.pm && (a.drawImage(this.pm.La, 0, 0), b = this.vb, b.reset(), 1 !== this.scale && b.scale(this.scale), 0 === this.position.x && 0 === this.position.y ||
                b.translate(-this.position.x, -this.position.y), a.scale(this.Zb, this.Zb), a.transform(b.m11, b.m12, b.m21, b.m22, b.dx, b.dy));
                b = this.Qa.j;
                for (var c = b.length, d = 0; d < c; d++) b[d].ic(a, this);
                this.Kc = this.Gi = !1
            }
        }
    };

    function hl(a) {
        var b = a.observed;
        if (null !== b) {
            var c = a.drawsTemporaryLayers, d = a.drawsGrid && c, e = b.grid;
            d && null !== e && e.visible && !isNaN(e.width) && !isNaN(e.height) && (e = L.alloc().assign(a.viewportBounds).Yc(b.viewportBounds), Dj(b, e), L.free(e), ij(b));
            var f = a.vb;
            f.reset();
            1 !== a.scale && f.scale(a.scale);
            0 === a.position.x && 0 === a.position.y || f.translate(-a.position.x, -a.position.y);
            e = a.Nb;
            e.scale(a.Zb, a.Zb);
            e.transform(f.m11, f.m12, f.m21, f.m22, f.dx, f.dy);
            b = b.Qa.j;
            f = b.length;
            for (var g = 0; g < f; g++) {
                var h = b[g], k = a;
                if (h.visible &&
                    0 !== h.opacity) {
                    var l = h.diagram.grid.part;
                    if (!c && h.isTemporary) d && l.layer === h && (h = zi(h, e), l.ic(e, k), e.globalAlpha = h); else {
                        for (var m = zi(h, e), n = k.scale, p = L.alloc(), r = h.Ia.j, q = r.length, u = 0; u < q; u++) {
                            var x = r[u];
                            (d || x !== l) && h.nj(e, x, k, null, n, p, !1)
                        }
                        L.free(p);
                        e.globalAlpha = m
                    }
                }
            }
        }
    }

    function gl(a) {
        var b = a.box;
        if (null !== b) {
            var c = a.observed;
            if (null !== c) {
                a.Kc = !0;
                c = c.viewportBounds;
                var d = b.selectionObject, e = Hb.alloc();
                e.h(c.width, c.height);
                d.desiredSize = e;
                Hb.free(e);
                a = 2 / a.scale;
                d instanceof Zf && (d.strokeWidth = a);
                b.location = new J(c.x - a / 2, c.y - a / 2);
                b.isSelected = !0
            }
        }
    }

    el.prototype.computeBounds = function () {
        var a = this.observed;
        if (null === a) return uc;
        var b = a.documentBounds.copy();
        b.Yc(a.viewportBounds);
        return b
    };
    el.prototype.Uy = function () {
        !0 !== this.Kc && (this.Kc = !0, this.Kb())
    };
    el.prototype.gr = function (a, b, c, d) {
        this.Yb || (hj(this), this.P(), nj(this), this.Ua(), gl(this), this.de.scale = c, this.de.position.x = a.x, this.de.position.y = a.y, this.de.bounds.assign(a), this.de.sw = d, this.U("ViewportBoundsChanged", this.de, a))
    };
    na.Object.defineProperties(el.prototype, {
        observed: {
            configurable: !0, get: function () {
                return this.Oa
            }, set: function (a) {
                var b = this.Oa;
                null !== a && w(a, Q, el, "observed");
                a instanceof el && v("Overview.observed Diagram may not be an Overview itself: " + a);
                if (b !== a) {
                    null !== b && (this.remove(this.box), b.Xm("ViewportBoundsChanged", this.gi), b.Xm("DocumentBoundsChanged", this.fi), b.Xm("InvalidateDraw", this.Zc), b.Xm("AnimationFinished", this.Pd));
                    this.Oa = a;
                    null !== a && (a.vk("ViewportBoundsChanged", this.gi), a.vk("DocumentBoundsChanged",
                        this.fi), a.vk("InvalidateDraw", this.Zc), a.vk("AnimationFinished", this.Pd), this.add(this.box));
                    this.Ua();
                    if (null === a) {
                        this.pm = null;
                        var c = this.Aa, d = this.Nb;
                        c && d && (d.setTransform(1, 0, 0, 1, 0, 0), d.clearRect(0, 0, c.width, c.height))
                    } else this.Zc(null), gl(this), this.P();
                    this.g("observed", b, a)
                }
            }
        }, box: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                var b = this.l;
                b !== a && (this.l = a, this.remove(b), this.add(this.l), gl(this), this.g("box", b, a))
            }
        }, drawsTemporaryLayers: {
            configurable: !0,
            get: function () {
                return this.L
            }, set: function (a) {
                this.L !== a && (this.L = a, this.We())
            }
        }, drawsGrid: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                this.w !== a && (this.w = a, this.We())
            }
        }, updateDelay: {
            configurable: !0, get: function () {
                return this.kb
            }, set: function (a) {
                0 > a && (a = 0);
                this.kb !== a && (this.kb = a)
            }
        }
    });
    el.className = "Overview";

    function fl() {
        jf.call(this);
        this.l = null
    }

    ma(fl, jf);
    fl.prototype.canStart = function () {
        if (!this.isEnabled) return !1;
        var a = this.diagram;
        if (null === a || !a.allowMove || !a.allowSelect) return !1;
        var b = a.observed;
        if (null === b) return !1;
        var c = a.lastInput;
        if (!c.left || a.currentTool !== this && (!this.isBeyondDragSize() || c.isTouchEvent && c.timestamp - a.firstInput.timestamp < this.delay)) return !1;
        null === this.findDraggablePart() && (c = b.viewportBounds, this.l = new J(c.width / 2, c.height / 2), a = a.firstInput.documentPoint, b.position = new J(a.x - this.l.x, a.y - this.l.y));
        return !0
    };
    fl.prototype.doActivate = function () {
        this.l = null;
        jf.prototype.doActivate.call(this)
    };
    fl.prototype.doUpdateCursor = function () {
        var a = this.diagram, b = a.box;
        null !== b && b.cursor && (a.currentCursor = b.cursor)
    };
    fl.prototype.moveParts = function () {
        var a = this.diagram, b = a.observed;
        if (null !== b) {
            var c = a.box;
            if (null !== c) {
                if (null === this.l) {
                    var d = a.firstInput.documentPoint;
                    c = c.location;
                    this.l = new J(d.x - c.x, d.y - c.y)
                }
                a = a.lastInput.documentPoint;
                b.position = new J(a.x - this.l.x, a.y - this.l.y)
            }
        }
    };
    fl.className = "OverviewDraggingTool";

    function il() {
        0 < arguments.length && Ba(il);
        gb(this);
        this.B = Te;
        this.kb = this.L = this.w = !0;
        this.W = this.Oa = this.Zc = this.Pa = !1;
        this.Ti = this.l = null;
        this.Pd = 1.05;
        this.lv = NaN;
        this.Mx = null;
        this.Mv = NaN;
        this.Lv = uc;
        this.Ic = !0;
        this.Eg = null;
        this.$c = 200
    }

    il.prototype.toString = function () {
        return "CommandHandler"
    };
    il.prototype.ie = function (a) {
        this.B = a
    };
    il.prototype.doKeyDown = function () {
        var a = this.diagram, b = a.lastInput, c = eb ? b.meta : b.control, d = b.shift, e = b.alt, f = b.key;
        !c || "C" !== f && "Insert" !== f ? c && "X" === f || d && "Del" === f ? this.canCutSelection() && this.cutSelection() : c && "V" === f || d && "Insert" === f ? this.canPasteSelection() && this.pasteSelection() : c && "Y" === f || e && d && "Backspace" === f ? this.canRedo() && this.redo() : c && "Z" === f || e && "Backspace" === f ? this.canUndo() && this.undo() : "Del" === f || "Backspace" === f ? this.canDeleteSelection() && this.deleteSelection() : c && "A" === f ? this.canSelectAll() &&
            this.selectAll() : "Esc" === f ? this.canStopCommand() && this.stopCommand() : "Up" === f ? a.allowVerticalScroll && (c ? a.scroll("pixel", "up") : a.scroll("line", "up")) : "Down" === f ? a.allowVerticalScroll && (c ? a.scroll("pixel", "down") : a.scroll("line", "down")) : "Left" === f ? a.allowHorizontalScroll && (c ? a.scroll("pixel", "left") : a.scroll("line", "left")) : "Right" === f ? a.allowHorizontalScroll && (c ? a.scroll("pixel", "right") : a.scroll("line", "right")) : "PageUp" === f ? d && a.allowHorizontalScroll ? a.scroll("page", "left") : a.allowVerticalScroll &&
            a.scroll("page", "up") : "PageDown" === f ? d && a.allowHorizontalScroll ? a.scroll("page", "right") : a.allowVerticalScroll && a.scroll("page", "down") : "Home" === f ? c && a.allowVerticalScroll ? a.scroll("document", "up") : !c && a.allowHorizontalScroll && a.scroll("document", "left") : "End" === f ? c && a.allowVerticalScroll ? a.scroll("document", "down") : !c && a.allowHorizontalScroll && a.scroll("document", "right") : " " === f ? this.canScrollToPart() && this.scrollToPart() : "Subtract" === f ? this.canDecreaseZoom() && this.decreaseZoom() : "Add" === f ? this.canIncreaseZoom() &&
            this.increaseZoom() : c && "0" === f ? this.canResetZoom() && this.resetZoom() : d && "Z" === f ? this.canZoomToFit() && this.zoomToFit() : c && !d && "G" === f ? this.canGroupSelection() && this.groupSelection() : c && d && "G" === f ? this.canUngroupSelection() && this.ungroupSelection() : b.event && 113 === b.event.which ? this.canEditTextBlock() && this.editTextBlock() : b.event && 93 === b.event.which ? this.canShowContextMenu() && this.showContextMenu() : b.bubbles = !0 : this.canCopySelection() && this.copySelection()
    };
    il.prototype.doKeyUp = function () {
        this.diagram.lastInput.bubbles = !0
    };
    il.prototype.stopCommand = function () {
        var a = this.diagram, b = a.currentTool;
        b instanceof Ua && a.allowSelect && a.clearSelection();
        null !== b && b.doCancel()
    };
    il.prototype.canStopCommand = function () {
        return !0
    };
    il.prototype.selectAll = function () {
        var a = this.diagram;
        a.P();
        try {
            a.currentCursor = "wait";
            a.U("ChangingSelection", a.selection);
            for (var b = a.parts; b.next();) b.value.isSelected = !0;
            for (var c = a.nodes; c.next();) c.value.isSelected = !0;
            for (var d = a.links; d.next();) d.value.isSelected = !0
        } finally {
            a.U("ChangedSelection", a.selection), a.currentCursor = ""
        }
    };
    il.prototype.canSelectAll = function () {
        return this.diagram.allowSelect
    };
    il.prototype.deleteSelection = function () {
        var a = this.diagram;
        try {
            a.currentCursor = "wait";
            a.U("ChangingSelection", a.selection);
            a.Ca("Delete");
            a.U("SelectionDeleting", a.selection);
            for (var b = new I, c = a.selection.iterator; c.next();) jl(b, c.value, !0, this.deletesTree ? Infinity : 0, this.deletesConnectedLinks ? null : !1, function (a) {
                return a.canDelete()
            });
            a.ru(b, !0);
            a.U("SelectionDeleted", b)
        } finally {
            a.bb("Delete"), a.U("ChangedSelection", a.selection), a.currentCursor = ""
        }
    };
    il.prototype.canDeleteSelection = function () {
        var a = this.diagram;
        return a.isReadOnly || a.isModelReadOnly || !a.allowDelete || 0 === a.selection.count ? !1 : !0
    };
    il.prototype.copySelection = function () {
        var a = this.diagram, b = new I;
        for (a = a.selection.iterator; a.next();) jl(b, a.value, !0, this.copiesTree ? Infinity : 0, this.copiesConnectedLinks, function (a) {
            return a.canCopy()
        });
        this.copyToClipboard(b)
    };
    il.prototype.canCopySelection = function () {
        var a = this.diagram;
        return a.allowCopy && a.allowClipboard && 0 !== a.selection.count ? !0 : !1
    };
    il.prototype.cutSelection = function () {
        this.copySelection();
        this.deleteSelection()
    };
    il.prototype.canCutSelection = function () {
        var a = this.diagram;
        return !a.isReadOnly && !a.isModelReadOnly && a.allowCopy && a.allowDelete && a.allowClipboard && 0 !== a.selection.count ? !0 : !1
    };
    il.prototype.copyToClipboard = function (a) {
        var b = this.diagram, c = null;
        if (null === a) Qi = null, Ri = ""; else {
            c = b.model;
            var d = !1, e = !1, f = null;
            try {
                c.Qm() && (d = c.Ck, c.Ck = this.copiesParentKey), c.Kk() && (e = c.Bk, c.Bk = this.copiesGroupKey), f = b.Dk(a, null, !0)
            } finally {
                c.Qm() && (c.Ck = d), c.Kk() && (c.Bk = e), c = new H, c.addAll(f), Qi = c, Ri = b.model.dataFormat
            }
        }
        b.U("ClipboardChanged", c)
    };
    il.prototype.pasteFromClipboard = function () {
        var a = new I, b = Qi;
        if (null === b) return a;
        var c = this.diagram;
        if (Ri !== c.model.dataFormat) return a;
        var d = c.model, e = !1, f = !1, g = null;
        try {
            d.Qm() && (e = d.Ck, d.Ck = this.copiesParentKey), d.Kk() && (f = d.Bk, d.Bk = this.copiesGroupKey), g = c.Dk(b, c, !1)
        } finally {
            for (d.Qm() && (d.Ck = e), d.Kk() && (d.Bk = f), b = g.iterator; b.next();) c = b.value, d = b.key, c.location.o() || (d.location.o() ? c.location = d.location : !c.position.o() && d.position.o() && (c.position = d.position)), a.add(c)
        }
        return a
    };
    il.prototype.pasteSelection = function (a) {
        void 0 === a && (a = null);
        var b = this.diagram;
        try {
            b.currentCursor = "wait";
            b.U("ChangingSelection", b.selection);
            b.Ca("Paste");
            var c = this.pasteFromClipboard();
            0 < c.count && b.clearSelection(!0);
            for (var d = c.iterator; d.next();) d.value.isSelected = !0;
            if (null !== a) {
                var e = b.computePartsBounds(b.selection);
                if (e.o()) {
                    var f = this.computeEffectiveCollection(b.selection, b.ul);
                    Hf(b, f, new J(a.x - e.centerX, a.y - e.centerY), b.ul, !1)
                }
            }
            b.U("ClipboardPasted", c)
        } finally {
            b.bb("Paste"), b.U("ChangedSelection",
                b.selection), b.currentCursor = ""
        }
    };
    il.prototype.canPasteSelection = function () {
        var a = this.diagram;
        return a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.allowClipboard || null === Qi || 0 === Qi.count || Ri !== a.model.dataFormat ? !1 : !0
    };
    il.prototype.undo = function () {
        this.diagram.undoManager.undo()
    };
    il.prototype.canUndo = function () {
        var a = this.diagram;
        return a.isReadOnly || a.isModelReadOnly ? !1 : a.allowUndo && a.undoManager.canUndo()
    };
    il.prototype.redo = function () {
        this.diagram.undoManager.redo()
    };
    il.prototype.canRedo = function () {
        var a = this.diagram;
        return a.isReadOnly || a.isModelReadOnly ? !1 : a.allowUndo && a.undoManager.canRedo()
    };
    il.prototype.decreaseZoom = function (a) {
        void 0 === a && (a = 1 / this.zoomFactor);
        C(a, il, "decreaseZoom:factor");
        var b = this.diagram;
        b.autoScale === Mh && (a = b.scale * a, a < b.minScale || a > b.maxScale || (b.scale = a))
    };
    il.prototype.canDecreaseZoom = function (a) {
        void 0 === a && (a = 1 / this.zoomFactor);
        C(a, il, "canDecreaseZoom:factor");
        var b = this.diagram;
        if (b.autoScale !== Mh) return !1;
        a = b.scale * a;
        return a < b.minScale || a > b.maxScale ? !1 : b.allowZoom
    };
    il.prototype.increaseZoom = function (a) {
        void 0 === a && (a = this.zoomFactor);
        C(a, il, "increaseZoom:factor");
        var b = this.diagram;
        b.autoScale === Mh && (a = b.scale * a, a < b.minScale || a > b.maxScale || (b.scale = a))
    };
    il.prototype.canIncreaseZoom = function (a) {
        void 0 === a && (a = this.zoomFactor);
        C(a, il, "canIncreaseZoom:factor");
        var b = this.diagram;
        if (b.autoScale !== Mh) return !1;
        a = b.scale * a;
        return a < b.minScale || a > b.maxScale ? !1 : b.allowZoom
    };
    il.prototype.resetZoom = function (a) {
        void 0 === a && (a = this.defaultScale);
        C(a, il, "resetZoom:newscale");
        var b = this.diagram;
        a < b.minScale || a > b.maxScale || (b.scale = a)
    };
    il.prototype.canResetZoom = function (a) {
        void 0 === a && (a = this.defaultScale);
        C(a, il, "canResetZoom:newscale");
        var b = this.diagram;
        return a < b.minScale || a > b.maxScale ? !1 : b.allowZoom
    };
    il.prototype.zoomToFit = function () {
        var a = this.diagram, b = a.animationManager;
        b.Xc();
        a.We();
        var c = a.position, d = a.scale;
        Gh(b, "Zoom To Fit");
        this.isZoomToFitRestoreEnabled && d === this.Mv && !isNaN(this.lv) && a.documentBounds.A(this.Lv) ? (a.scale = this.lv, a.position = this.Mx, this.Mv = NaN, this.Lv = uc) : (this.lv = d, this.Mx = c.copy(), a.zoomToFit(), this.Mv = a.scale, this.Lv = a.documentBounds.copy());
        Ih(b)
    };
    il.prototype.canZoomToFit = function () {
        return this.diagram.allowZoom
    };
    il.prototype.scrollToPart = function (a) {
        void 0 === a && (a = null);
        null !== a && w(a, T, il, "part");
        var b = this.diagram;
        b.Ya();
        if (null === a) {
            try {
                null !== this.Eg && (this.Eg.next() ? a = this.Eg.value : this.Eg = null)
            } catch (k) {
                this.Eg = null
            }
            null === a && (0 < b.highlighteds.count ? this.Eg = b.highlighteds.iterator : 0 < b.selection.count && (this.Eg = b.selection.iterator), null !== this.Eg && this.Eg.next() && (a = this.Eg.value))
        }
        if (null !== a) {
            var c = b.animationManager;
            Gh(c, "Scroll To Part");
            var d = this.scrollToPartPause;
            if (0 < d) {
                var e = kl(this, a, [a]);
                if (1 === e.length) b.Ca(), b.Lt(a.actualBounds), b.bb("Scroll To Part"); else {
                    var f = function () {
                        b.Ca();
                        for (var a = e.pop(); 0 < e.length && a instanceof V && a.isTreeExpanded && (!(a instanceof Kf) || a.isSubGraphExpanded);) a = e.pop();
                        0 < e.length ? (a instanceof T && b.Mw(a.actualBounds), a instanceof V && !a.isTreeExpanded && (a.isTreeExpanded = !0), a instanceof Kf && !a.isSubGraphExpanded && (a.isSubGraphExpanded = !0)) : (a instanceof T && b.Lt(a.actualBounds), b.Xm("LayoutCompleted", g));
                        b.bb("Scroll To Part")
                    }, g = function () {
                        ta(f, (c.isEnabled ?
                            c.duration : 0) + d)
                    };
                    b.vk("LayoutCompleted", g);
                    f()
                }
            } else {
                var h = b.position.copy();
                b.Lt(a.actualBounds);
                h.Ta(b.position) && c.Xc()
            }
        }
    };

    function kl(a, b, c) {
        if (b.isVisible()) return c;
        if (b instanceof Xe) kl(a, b.adornedPart, c); else if (b instanceof S) {
            var d = b.fromNode;
            null !== d && kl(a, d, c);
            b = b.toNode;
            null !== b && kl(a, b, c)
        } else b instanceof V && (d = b.labeledLink, null !== d && kl(a, d, c), d = b.Sg(), null !== d && (d.isTreeExpanded || d.wasTreeExpanded || c.push(d), kl(a, d, c))), b = b.containingGroup, null !== b && (b.isSubGraphExpanded || b.wasSubGraphExpanded || c.push(b), kl(a, b, c));
        return c
    }

    il.prototype.canScrollToPart = function (a) {
        void 0 === a && (a = null);
        if (null !== a && !(a instanceof T)) return !1;
        a = this.diagram;
        return 0 === a.selection.count && 0 === a.highlighteds.count ? !1 : a.allowHorizontalScroll && a.allowVerticalScroll
    };
    il.prototype.collapseTree = function (a) {
        void 0 === a && (a = null);
        var b = this.diagram;
        try {
            b.Ca("Collapse Tree");
            Gh(b.animationManager, "Collapse Tree");
            var c = new H;
            if (null !== a && a.isTreeExpanded) a.collapseTree(), c.add(a); else if (null === a) for (var d = b.selection.iterator; d.next();) {
                var e = d.value;
                e instanceof V && e.isTreeExpanded && (e.collapseTree(), c.add(e))
            }
            b.U("TreeCollapsed", c)
        } finally {
            b.bb("Collapse Tree")
        }
    };
    il.prototype.canCollapseTree = function (a) {
        void 0 === a && (a = null);
        var b = this.diagram;
        if (b.isReadOnly) return !1;
        if (null !== a) {
            if (!(a instanceof V && a.isTreeExpanded)) return !1;
            if (0 < a.Qq().count) return !0
        } else for (a = b.selection.iterator; a.next();) if (b = a.value, b instanceof V && b.isTreeExpanded && 0 < b.Qq().count) return !0;
        return !1
    };
    il.prototype.expandTree = function (a) {
        void 0 === a && (a = null);
        var b = this.diagram;
        try {
            b.Ca("Expand Tree");
            Gh(b.animationManager, "Expand Tree");
            var c = new H;
            if (null !== a && !a.isTreeExpanded) a.expandTree(), c.add(a); else if (null === a) for (var d = b.selection.iterator; d.next();) {
                var e = d.value;
                e instanceof V && !e.isTreeExpanded && (e.expandTree(), c.add(e))
            }
            b.U("TreeExpanded", c)
        } finally {
            b.bb("Expand Tree")
        }
    };
    il.prototype.canExpandTree = function (a) {
        void 0 === a && (a = null);
        var b = this.diagram;
        if (b.isReadOnly) return !1;
        if (null !== a) {
            if (!(a instanceof V) || a.isTreeExpanded) return !1;
            if (0 < a.Qq().count) return !0
        } else for (a = b.selection.iterator; a.next();) if (b = a.value, b instanceof V && !b.isTreeExpanded && 0 < b.Qq().count) return !0;
        return !1
    };
    il.prototype.groupSelection = function () {
        var a = this.diagram, b = a.model;
        if (b.zj()) {
            var c = this.archetypeGroupData;
            if (null !== c) {
                var d = null;
                try {
                    a.currentCursor = "wait";
                    a.U("ChangingSelection", a.selection);
                    a.Ca("Group");
                    for (var e = new H, f = a.selection.iterator; f.next();) {
                        var g = f.value;
                        g.Tc() && g.canGroup() && e.add(g)
                    }
                    for (var h = new H, k = e.iterator; k.next();) {
                        var l = k.value;
                        f = !1;
                        for (var m = e.iterator; m.next();) if (l.Ld(m.value)) {
                            f = !0;
                            break
                        }
                        f || h.add(l)
                    }
                    if (0 < h.count) {
                        var n = h.first().containingGroup;
                        if (null !== n) for (; null !==
                                               n;) {
                            e = !1;
                            for (var p = h.iterator; p.next();) if (!p.value.Ld(n)) {
                                e = !0;
                                break
                            }
                            if (e) n = n.containingGroup; else break
                        }
                        if (c instanceof Kf) Ng(c), d = c.copy(), null !== d && a.add(d); else if (b.eu(c)) {
                            var r = b.copyNodeData(c);
                            Ga(r) && (b.Gf(r), d = a.qj(r))
                        }
                        if (null !== d) {
                            null !== n && this.isValidMember(n, d) && (d.containingGroup = n);
                            for (var q = h.iterator; q.next();) {
                                var u = q.value;
                                this.isValidMember(d, u) && (u.containingGroup = d)
                            }
                            a.clearSelection(!0);
                            d.isSelected = !0
                        }
                    }
                    a.U("SelectionGrouped", d)
                } finally {
                    a.bb("Group"), a.U("ChangedSelection",
                        a.selection), a.currentCursor = ""
                }
            }
        }
    };
    il.prototype.canGroupSelection = function () {
        var a = this.diagram;
        if (a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.allowGroup || !a.model.zj() || null === this.archetypeGroupData) return !1;
        for (a = a.selection.iterator; a.next();) {
            var b = a.value;
            if (b.Tc() && b.canGroup()) return !0
        }
        return !1
    };

    function ll(a) {
        var b = Ma();
        for (a = a.iterator; a.next();) {
            var c = a.value;
            c instanceof S || b.push(c)
        }
        a = new I;
        c = b.length;
        for (var d = 0; d < c; d++) {
            for (var e = b[d], f = !0, g = 0; g < c; g++) if (e.Ld(b[g])) {
                f = !1;
                break
            }
            f && a.add(e)
        }
        Oa(b);
        return a
    }

    il.prototype.isValidMember = function (a, b) {
        if (null === b || a === b || b instanceof S) return !1;
        if (null !== a) {
            if (a === b || a.Ld(b)) return !1;
            var c = a.memberValidation;
            if (null !== c && !c(a, b) || null === a.data && null !== b.data || null !== a.data && null === b.data) return !1
        }
        c = this.memberValidation;
        return null !== c ? c(a, b) : !0
    };
    il.prototype.ungroupSelection = function (a) {
        void 0 === a && (a = null);
        var b = this.diagram, c = b.model;
        if (c.zj()) try {
            b.currentCursor = "wait";
            b.U("ChangingSelection", b.selection);
            b.Ca("Ungroup");
            var d = new H;
            if (null !== a) d.add(a); else for (var e = b.selection.iterator; e.next();) {
                var f = e.value;
                f instanceof Kf && f.canUngroup() && d.add(f)
            }
            var g = new H;
            if (0 < d.count) {
                b.clearSelection(!0);
                for (var h = d.iterator; h.next();) {
                    var k = h.value;
                    k.expandSubGraph();
                    var l = k.containingGroup, m = null !== l && null !== l.data ? c.pa(l.data) : void 0;
                    g.addAll(k.memberParts);
                    for (var n = g.iterator; n.next();) {
                        var p = n.value;
                        p.isSelected = !0;
                        if (!(p instanceof S)) {
                            var r = p.data;
                            null !== r ? c.rr(r, m) : p.containingGroup = l
                        }
                    }
                    b.remove(k)
                }
            }
            b.U("SelectionUngrouped", d, g)
        } finally {
            b.bb("Ungroup"), b.U("ChangedSelection", b.selection), b.currentCursor = ""
        }
    };
    il.prototype.canUngroupSelection = function (a) {
        void 0 === a && (a = null);
        var b = this.diagram;
        if (b.isReadOnly || b.isModelReadOnly || !b.allowDelete || !b.allowUngroup || !b.model.zj()) return !1;
        if (null !== a) {
            if (!(a instanceof Kf)) return !1;
            if (a.canUngroup()) return !0
        } else for (a = b.selection.iterator; a.next();) if (b = a.value, b instanceof Kf && b.canUngroup()) return !0;
        return !1
    };
    il.prototype.addTopLevelParts = function (a, b) {
        var c = !0;
        for (a = ll(a).iterator; a.next();) {
            var d = a.value;
            null !== d.containingGroup && (!b || this.isValidMember(null, d) ? d.containingGroup = null : c = !1)
        }
        return c
    };
    il.prototype.collapseSubGraph = function (a) {
        void 0 === a && (a = null);
        var b = this.diagram;
        try {
            b.Ca("Collapse SubGraph");
            Gh(b.animationManager, "Collapse SubGraph");
            var c = new H;
            if (null !== a && a.isSubGraphExpanded) a.collapseSubGraph(), c.add(a); else if (null === a) for (var d = b.selection.iterator; d.next();) {
                var e = d.value;
                e instanceof Kf && e.isSubGraphExpanded && (e.collapseSubGraph(), c.add(e))
            }
            b.U("SubGraphCollapsed", c)
        } finally {
            b.bb("Collapse SubGraph")
        }
    };
    il.prototype.canCollapseSubGraph = function (a) {
        void 0 === a && (a = null);
        var b = this.diagram;
        if (b.isReadOnly) return !1;
        if (null !== a) return a instanceof Kf && a.isSubGraphExpanded ? !0 : !1;
        for (a = b.selection.iterator; a.next();) if (b = a.value, b instanceof Kf && b.isSubGraphExpanded) return !0;
        return !1
    };
    il.prototype.expandSubGraph = function (a) {
        void 0 === a && (a = null);
        var b = this.diagram;
        try {
            b.Ca("Expand SubGraph");
            Gh(b.animationManager, "Expand SubGraph");
            var c = new H;
            if (null !== a && !a.isSubGraphExpanded) a.expandSubGraph(), c.add(a); else if (null === a) for (var d = b.selection.iterator; d.next();) {
                var e = d.value;
                e instanceof Kf && !e.isSubGraphExpanded && (e.expandSubGraph(), c.add(e))
            }
            b.U("SubGraphExpanded", c)
        } finally {
            b.bb("Expand SubGraph")
        }
    };
    il.prototype.canExpandSubGraph = function (a) {
        void 0 === a && (a = null);
        var b = this.diagram;
        if (b.isReadOnly) return !1;
        if (null !== a) return a instanceof Kf && !a.isSubGraphExpanded ? !0 : !1;
        for (a = b.selection.iterator; a.next();) if (b = a.value, b instanceof Kf && !b.isSubGraphExpanded) return !0;
        return !1
    };
    il.prototype.editTextBlock = function (a) {
        void 0 === a && (a = null);
        null !== a && w(a, kh, il, "editTextBlock");
        var b = this.diagram, c = b.toolManager.findTool("TextEditing");
        if (null !== c) {
            if (null === a) {
                a = null;
                for (var d = b.selection.iterator; d.next();) {
                    var e = d.value;
                    if (e.canEdit()) {
                        a = e;
                        break
                    }
                }
                if (null === a) return;
                a = a.Jm(function (a) {
                    return a instanceof kh && a.editable
                })
            }
            null !== a && (b.currentTool = null, c.textBlock = a, b.currentTool = c)
        }
    };
    il.prototype.canEditTextBlock = function (a) {
        void 0 === a && (a = null);
        var b = this.diagram;
        if (b.isReadOnly || b.isModelReadOnly || !b.allowTextEdit || null === b.toolManager.findTool("TextEditing")) return !1;
        if (null !== a) {
            if (!(a instanceof kh)) return !1;
            a = a.part;
            if (null !== a && a.canEdit()) return !0
        } else for (b = b.selection.iterator; b.next();) if (a = b.value, a.canEdit() && (a = a.Jm(function (a) {
            return a instanceof kh && a.editable
        }), null !== a)) return !0;
        return !1
    };
    il.prototype.showContextMenu = function (a) {
        var b = this.diagram, c = b.toolManager.findTool("ContextMenu");
        if (null !== c && (void 0 === a && (a = 0 < b.selection.count ? b.selection.first() : b), a = c.findObjectWithContextMenu(a), null !== a)) {
            var d = b.lastInput, e = null;
            a instanceof N ? e = a.ja(Mc) : b.viewportBounds.ca(d.documentPoint) || (e = b.viewportBounds, e = new J(e.x + e.width / 2, e.y + e.height / 2));
            null !== e && (d.viewPoint = b.vr(e), d.documentPoint = e, d.left = !1, d.right = !0, d.up = !0);
            b.currentTool = c;
            gh(c, !1, a)
        }
    };
    il.prototype.canShowContextMenu = function (a) {
        var b = this.diagram, c = b.toolManager.findTool("ContextMenu");
        if (null === c) return !1;
        void 0 === a && (a = 0 < b.selection.count ? b.selection.first() : b);
        return null === c.findObjectWithContextMenu(a) ? !1 : !0
    };
    il.prototype.computeEffectiveCollection = function (a, b) {
        var c = this.diagram, d = c.toolManager.findTool("Dragging"), e = c.currentTool === d;
        void 0 === b && (b = e ? d.dragOptions : c.ul);
        d = new Db;
        if (null === a) return d;
        for (var f = a.iterator; f.next();) ck(c, d, f.value, e, b);
        if (null !== c.draggedLink && b.dragsLink) return d;
        for (f = a.iterator; f.next();) a = f.value, a instanceof S && (b = a.fromNode, null === b || d.contains(b) ? (b = a.toNode, null === b || d.contains(b) || d.remove(a)) : d.remove(a));
        return d
    };
    na.Object.defineProperties(il.prototype, {
        diagram: {
            configurable: !0, get: function () {
                return this.B
            }
        }, copiesClipboardData: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                A(a, "boolean", il, "copiesClipboardData");
                this.w = a
            }
        }, copiesConnectedLinks: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                A(a, "boolean", il, "copiesConnectedLinks");
                this.L = a
            }
        }, deletesConnectedLinks: {
            configurable: !0, get: function () {
                return this.kb
            }, set: function (a) {
                A(a,
                    "boolean", il, "deletesConnectedLinks");
                this.kb = a
            }
        }, copiesTree: {
            configurable: !0, get: function () {
                return this.Pa
            }, set: function (a) {
                A(a, "boolean", il, "copiesTree");
                this.Pa = a
            }
        }, deletesTree: {
            configurable: !0, get: function () {
                return this.Zc
            }, set: function (a) {
                A(a, "boolean", il, "deletesTree");
                this.Zc = a
            }
        }, copiesParentKey: {
            configurable: !0, get: function () {
                return this.Oa
            }, set: function (a) {
                A(a, "boolean", il, "copiesParentKey");
                this.Oa = a
            }
        }, copiesGroupKey: {
            configurable: !0,
            get: function () {
                return this.W
            }, set: function (a) {
                A(a, "boolean", il, "copiesGroupKey");
                this.W = a
            }
        }, archetypeGroupData: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                null !== a && A(a, "object", il, "archetypeGroupData");
                var b = this.diagram;
                F && (b = b.model, !b.zj() || a instanceof Kf || b.eu(a) || v("CommandHandler.archetypeGroupData must be either a Group or a data object for which GraphLinksModel.isGroupForNodeData is true: " + a));
                this.l = a
            }
        }, memberValidation: {
            configurable: !0, get: function () {
                return this.Ti
            },
            set: function (a) {
                null !== a && A(a, "function", il, "memberValidation");
                this.Ti = a
            }
        }, defaultScale: {
            configurable: !0, get: function () {
                return this.diagram.defaultScale
            }, set: function (a) {
                this.diagram.defaultScale = a
            }
        }, zoomFactor: {
            configurable: !0, get: function () {
                return this.Pd
            }, set: function (a) {
                C(a, il, "zoomFactor");
                1 < a || v("zoomFactor must be larger than 1.0, not: " + a);
                this.Pd = a
            }
        }, isZoomToFitRestoreEnabled: {
            configurable: !0, get: function () {
                return this.Ic
            }, set: function (a) {
                A(a, "boolean",
                    il, "isZoomToFitRestoreEnabled");
                this.Ic = a
            }
        }, scrollToPartPause: {
            configurable: !0, get: function () {
                return this.$c
            }, set: function (a) {
                C(a, il, "scrollToPartPause");
                this.$c = a
            }
        }
    });
    il.className = "CommandHandler";
    Ki = function () {
        return new il
    };

    function N() {
        gb(this);
        this.I = 4225027;
        this.nb = 1;
        this.Bg = null;
        this.Wa = "";
        this.kc = this.rb = null;
        this.ra = (new J(NaN, NaN)).freeze();
        this.dd = ac;
        this.sg = Tb;
        this.rg = $b;
        this.vb = new Ib;
        this.ii = new Ib;
        this.pg = new Ib;
        this.Fa = this.Al = 1;
        this.dc = 0;
        this.Le = ml;
        this.vh = zc;
        this.vc = (new L(NaN, NaN, NaN, NaN)).freeze();
        this.Db = (new L(NaN, NaN, NaN, NaN)).freeze();
        this.wc = (new L(0, 0, NaN, NaN)).freeze();
        this.S = this.Ep = this.Fp = null;
        this.jl = this.Eb = jd;
        this.Qp = 0;
        this.Rp = 1;
        this.eh = 0;
        this.Jn = 1;
        this.kq = null;
        this.Xp = -Infinity;
        this.km =
            0;
        this.lm = Ob;
        this.mm = pg;
        this.zi = "";
        this.lb = this.R = null;
        this.nl = -1;
        this.om = this.fb = this.yi = this.sm = null;
        this.bt = Og;
        this.Tp = this.Zg = this.kk = null
    }

    var Jd, Og, Qg, ml, nl, ol, pl, ql, rl, sl;
    N.prototype.cloneProtected = function (a) {
        a.I = this.I | 6144;
        a.nb = this.nb;
        a.Wa = this.Wa;
        a.rb = this.rb;
        a.kc = this.kc;
        a.Zg = this.Zg;
        a.ra.assign(this.ra);
        a.dd = this.dd.J();
        a.sg = this.sg.J();
        a.rg = this.rg.J();
        a.pg = this.pg.copy();
        a.Fa = this.Fa;
        a.dc = this.dc;
        a.Le = this.Le;
        a.vh = this.vh.J();
        a.vc.assign(this.vc);
        a.Db.assign(this.Db);
        a.wc.assign(this.wc);
        a.Ep = this.Ep;
        null !== this.S && (a.S = this.S.copy());
        a.Eb = this.Eb.J();
        a.jl = this.jl.J();
        a.Qp = this.Qp;
        a.Rp = this.Rp;
        a.eh = this.eh;
        a.Jn = this.Jn;
        a.kq = this.kq;
        a.Xp = this.Xp;
        a.km = this.km;
        a.lm = this.lm.J();
        a.mm = this.mm;
        a.zi = this.zi;
        null !== this.R && (a.R = this.R.copy());
        a.lb = this.lb;
        a.nl = this.nl;
        null !== this.yi && (a.yi = Ja(this.yi));
        null !== this.fb && (a.fb = this.fb.copy());
        a.om = this.om
    };
    N.prototype.iy = function (a) {
        var b = this.yi;
        if (Ha(b)) for (var c = 0; c < b.length; c++) {
            if (b[c] === a) return
        } else this.yi = b = [];
        b.push(a)
    };
    N.prototype.Kf = function (a) {
        a.Fp = null;
        a.kk = null;
        a.v()
    };
    N.prototype.clone = function () {
        var a = new this.constructor;
        this.cloneProtected(a);
        if (null !== this.yi) for (var b = 0; b < this.yi.length; b++) {
            var c = this.yi[b];
            a[c] = this[c]
        }
        return a
    };
    N.prototype.copy = function () {
        return this.clone()
    };
    t = N.prototype;
    t.pb = function (a) {
        a.classType === S ? 0 === a.name.indexOf("Orient") ? this.segmentOrientation = a : v("Unknown Link enum value for GraphObject.segmentOrientation property: " + a) : a.classType === N ? this.stretch = a : Da(this, a)
    };
    t.toString = function () {
        return Pa(this.constructor) + "#" + rb(this)
    };

    function tl(a) {
        null === a.R && (a.R = new ul)
    }

    t.Qc = function () {
        if (null === this.S) {
            var a = new vl;
            a.oh = Ec;
            a.Mh = Ec;
            a.mh = 10;
            a.Kh = 10;
            a.nh = 0;
            a.Lh = 0;
            this.S = a
        }
    };
    t.ib = function (a, b, c, d, e, f, g) {
        var h = this.part;
        if (null !== h && (h.Zk(a, b, c, d, e, f, g), c === this && a === Le && wl(this) && xl(this, h, b), f = this.diagram, null === this.Zg || null === f || !f.Aj || f.undoManager.isUndoingRedoing || f.currentTool !== f.toolManager || f.animationManager.Dn || (a = this.Zg.get(b), null !== a && f.animationManager.isEnabled && !f.animationManager.isTicking && (null === this.Tp && (this.Tp = new Db), g = 0 === f.undoManager.transactionLevel, a.startCondition === ui ? g = !0 : a.startCondition === wi && (g = !1), g ? (f = new Fh, vi(a, f), g = this.Tp.get(a),
        null !== g && g.stop(), this.Tp.add(a, f), f.Iv = this, f.ay = a, f.add(this, b, d, e), f.start()) : (Hh(f.animationManager, "Trigger"), f.animationManager.defaultAnimation.add(this, b, d, e)))), this instanceof W && c === h && 0 !== (h.I & 16777216) && null !== h.data)) for (c = this.$.j, d = c.length, e = 0; e < d; e++) h = c[e], h instanceof W && Uj(h, function (a) {
            null !== a.data && 0 !== (a.I & 16777216) && a.Ha(b)
        })
    };

    function xl(a, b, c) {
        var d = a.sj();
        if (null !== d) for (var e = a.lb.iterator; e.next();) {
            var f = e.value, g = null;
            if (null !== f.sourceName) {
                g = yl(f, d, a);
                if (null === g) continue;
                f.yr(a, g, c, null)
            } else if (f.isToModel) {
                var h = b.diagram;
                null === h || h.skipsModelSourceBindings || f.yr(a, h.model.modelData, c, d)
            } else {
                h = d.data;
                if (null === h) continue;
                var k = b.diagram;
                null === k || k.skipsModelSourceBindings || f.yr(a, h, c, d)
            }
            g === a && (h = d.St(f.Hj), null !== h && f.hx(h, g, c))
        }
    }

    t.St = function (a) {
        return this.nl === a ? this : null
    };
    t.g = function (a, b, c) {
        this.ib(Le, a, this, b, c)
    };

    function zl(a, b, c, d, e) {
        var f = a.vc, g = a.pg;
        g.reset();
        Al(a, g, b, c, d, e);
        a.pg = g;
        f.h(b, c, d, e);
        g.fu() || g.ax(f)
    }

    function Bl(a, b, c, d) {
        if (!1 === a.pickable) return !1;
        d.multiply(a.transform);
        return c ? a.Sc(b, d) : a.Th(b, d)
    }

    t.Gy = function (a, b, c) {
        if (!1 === this.pickable) return !1;
        var d = this.naturalBounds;
        b = a.Re(b);
        return c ? Kb(a.x, a.y, 0, 0, 0, d.height) <= b || Kb(a.x, a.y, 0, d.height, d.width, d.height) <= b || Kb(a.x, a.y, d.width, d.height, d.width, 0) <= b || Kb(a.x, a.y, d.width, 0, 0, 0) <= b : a.ud(0, 0) <= b && a.ud(0, d.height) <= b && a.ud(d.width, 0) <= b && a.ud(d.width, d.height) <= b
    };
    t.le = function () {
        return !0
    };
    t.ca = function (a) {
        F && w(a, J, N, "containsPoint:p");
        var b = J.alloc();
        b.assign(a);
        this.transform.ya(b);
        var c = this.actualBounds;
        if (!c.o()) return J.free(b), !1;
        var d = this.diagram;
        if (null !== d && d.xe) {
            var e = d.Nm("extraTouchThreshold"), f = d.Nm("extraTouchArea"), g = f / 2, h = this.naturalBounds;
            d = this.Mf() * d.scale;
            var k = 1 / d;
            if (h.width * d < e && h.height * d < e) return a = pc(c.x - g * k, c.y - g * k, c.width + f * k, c.height + f * k, b.x, b.y), J.free(b), a
        }
        e = !1;
        if (this instanceof Xe || this instanceof Zf ? pc(c.x - 5, c.y - 5, c.width + 10, c.height + 10, b.x, b.y) :
            c.ca(b)) this.fb && !this.fb.ca(b) ? e = !1 : null !== this.kc && c.ca(b) ? e = !0 : null !== this.rb && this.wc.ca(a) ? e = !0 : e = this.Uh(a);
        J.free(b);
        return e
    };
    t.Uh = function (a) {
        var b = this.naturalBounds;
        return pc(0, 0, b.width, b.height, a.x, a.y)
    };
    t.Pe = function (a) {
        F && w(a, L, N, "containsRect:r");
        if (0 === this.angle) return this.actualBounds.Pe(a);
        var b = this.naturalBounds;
        b = L.allocAt(0, 0, b.width, b.height);
        var c = this.transform, d = !1, e = J.allocAt(a.x, a.y);
        b.ca(c.Kd(e)) && (e.h(a.x, a.bottom), b.ca(c.Kd(e)) && (e.h(a.right, a.bottom), b.ca(c.Kd(e)) && (e.h(a.right, a.y), b.ca(c.Kd(e)) && (d = !0))));
        J.free(e);
        L.free(b);
        return d
    };
    t.Th = function (a, b) {
        F && w(a, L, N, "containedInRect:r");
        if (void 0 === b) return a.Pe(this.actualBounds);
        var c = this.naturalBounds, d = !1, e = J.allocAt(0, 0);
        a.ca(b.ya(e)) && (e.h(0, c.height), a.ca(b.ya(e)) && (e.h(c.width, c.height), a.ca(b.ya(e)) && (e.h(c.width, 0), a.ca(b.ya(e)) && (d = !0))));
        J.free(e);
        return d
    };
    t.Sc = function (a, b) {
        F && w(a, L, N, "intersectsRect:r");
        if (void 0 === b && (b = this.transform, 0 === this.angle)) return a.Sc(this.actualBounds);
        var c = this.naturalBounds, d = J.allocAt(0, 0), e = J.allocAt(0, c.height), f = J.allocAt(c.width, c.height),
            g = J.allocAt(c.width, 0), h = !1;
        if (a.ca(b.ya(d)) || a.ca(b.ya(e)) || a.ca(b.ya(f)) || a.ca(b.ya(g))) h = !0; else {
            c = L.allocAt(0, 0, c.width, c.height);
            var k = J.allocAt(a.x, a.y);
            c.ca(b.Kd(k)) ? h = !0 : (k.h(a.x, a.bottom), c.ca(b.Kd(k)) ? h = !0 : (k.h(a.right, a.bottom), c.ca(b.Kd(k)) ? h = !0 : (k.h(a.right, a.y),
            c.ca(b.Kd(k)) && (h = !0))));
            J.free(k);
            L.free(c);
            !h && (K.bu(a, d, e) || K.bu(a, e, f) || K.bu(a, f, g) || K.bu(a, g, d)) && (h = !0)
        }
        J.free(d);
        J.free(e);
        J.free(f);
        J.free(g);
        return h
    };
    t.ja = function (a, b) {
        void 0 === b && (b = new J);
        if (a instanceof M) {
            F && a.Tb() && v("getDocumentPoint:s Spot must be specific: " + a.toString());
            var c = this.naturalBounds;
            b.h(a.x * c.width + a.offsetX, a.y * c.height + a.offsetY)
        } else b.set(a);
        this.Hd.ya(b);
        return b
    };
    t.wj = function (a) {
        void 0 === a && (a = new L);
        var b = this.naturalBounds, c = this.Hd, d = J.allocAt(0, 0).transform(c);
        a.h(d.x, d.y, 0, 0);
        d.h(b.width, 0).transform(c);
        oc(a, d.x, d.y, 0, 0);
        d.h(b.width, b.height).transform(c);
        oc(a, d.x, d.y, 0, 0);
        d.h(0, b.height).transform(c);
        oc(a, d.x, d.y, 0, 0);
        J.free(d);
        return a
    };
    t.vj = function () {
        var a = this.Hd;
        1 === a.m11 && 0 === a.m12 ? a = 0 : (a = 180 * Math.atan2(a.m12, a.m11) / Math.PI, 0 > a && (a += 360));
        return a
    };
    t.Mf = function () {
        if (0 !== (this.I & 4096) === !1) return this.Al;
        var a = this.Fa;
        return null !== this.panel ? a * this.panel.Mf() : a
    };
    t.Yt = function (a, b) {
        void 0 === b && (b = new J);
        b.assign(a);
        this.Hd.Kd(b);
        return b
    };
    t.Zt = function (a, b, c) {
        return this.Ik(a.x, a.y, b.x, b.y, c)
    };
    t.Ik = function (a, b, c, d, e) {
        var f = this.transform, g = 1 / (f.m11 * f.m22 - f.m12 * f.m21), h = f.m22 * g, k = -f.m12 * g, l = -f.m21 * g,
            m = f.m11 * g, n = g * (f.m21 * f.dy - f.m22 * f.dx), p = g * (f.m12 * f.dx - f.m11 * f.dy);
        if (null !== this.areaBackground) return f = this.actualBounds, K.Of(f.left, f.top, f.right, f.bottom, a, b, c, d, e);
        g = a * h + b * l + n;
        a = a * k + b * m + p;
        b = c * h + d * l + n;
        c = c * k + d * m + p;
        e.h(0, 0);
        d = this.naturalBounds;
        c = K.Of(0, 0, d.width, d.height, g, a, b, c, e);
        e.transform(f);
        return c
    };
    N.prototype.measure = function (a, b, c, d) {
        if (!1 !== Hj(this)) {
            var e = this.vh, f = e.right + e.left;
            e = e.top + e.bottom;
            a = Math.max(a - f, 0);
            b = Math.max(b - e, 0);
            c = Math.max((c || 0) - f, 0);
            d = Math.max((d || 0) - e, 0);
            f = this.angle;
            e = this.desiredSize;
            var g = 0;
            this instanceof Zf && (g = this.strokeWidth);
            90 === f || 270 === f ? (a = isFinite(e.height) ? e.height + g : a, b = isFinite(e.width) ? e.width + g : b) : (a = isFinite(e.width) ? e.width + g : a, b = isFinite(e.height) ? e.height + g : b);
            e = c || 0;
            g = d || 0;
            var h = this instanceof W;
            switch (Cl(this, !0)) {
                case Og:
                    g = e = 0;
                    h && (b = a = Infinity);
                    break;
                case Jd:
                    isFinite(a) && a > c && (e = a);
                    isFinite(b) && b > d && (g = b);
                    break;
                case nl:
                    isFinite(a) && a > c && (e = a);
                    g = 0;
                    h && (b = Infinity);
                    break;
                case ol:
                    isFinite(b) && b > d && (g = b), e = 0, h && (a = Infinity)
            }
            h = this.maxSize;
            var k = this.minSize;
            e > h.width && k.width < h.width && (e = h.width);
            g > h.height && k.height < h.height && (g = h.height);
            c = Math.max(e / this.scale, k.width);
            d = Math.max(g / this.scale, k.height);
            h.width < c && (c = Math.min(k.width, c));
            h.height < d && (d = Math.min(k.height, d));
            a = Math.min(h.width, a);
            b = Math.min(h.height, b);
            a = Math.max(c, a);
            b = Math.max(d,
                b);
            if (90 === f || 270 === f) f = a, a = b, b = f, f = c, c = d, d = f;
            this.vc.ka();
            this.Tm(a, b, c, d);
            this.vc.freeze();
            this.vc.o() || v("Non-real measuredBounds has been set. Object " + this + ", measuredBounds: " + this.vc.toString());
            Cj(this, !1)
        }
    };
    N.prototype.Tm = function () {
    };
    N.prototype.Rf = function () {
        return !1
    };
    N.prototype.arrange = function (a, b, c, d, e) {
        this.Rl();
        var f = L.alloc();
        f.assign(this.Db);
        this.Db.ka();
        !1 === Ij(this) ? this.Db.h(a, b, c, d) : this.Sh(a, b, c, d);
        this.Db.freeze();
        void 0 === e ? this.fb = null : this.fb = e;
        c = !1;
        if (void 0 !== e) c = !0; else if (e = this.panel, null === e || e.type !== W.TableRow && e.type !== W.TableColumn || (e = e.panel), null !== e && (e = e.wc, d = this.measuredBounds, null !== this.areaBackground && (d = this.Db), c = b + d.height, d = a + d.width, c = !(0 <= a + .05 && d <= e.width + .05 && 0 <= b + .05 && c <= e.height + .05), this instanceof kh && (a = this.naturalBounds,
        this.Hs > a.height || this.zb > a.width))) c = !0;
        this.I = c ? this.I | 256 : this.I & -257;
        this.Db.o() || v("Non-real actualBounds has been set. Object " + this + ", actualBounds: " + this.Db.toString());
        this.Um(f, this.Db);
        Dl(this, !1);
        L.free(f)
    };
    t = N.prototype;
    t.Sh = function () {
    };

    function El(a, b, c, d, e) {
        a.Db.h(b, c, d, e);
        if (!a.desiredSize.o()) {
            var f = a.vc;
            c = a.vh;
            b = c.right + c.left;
            var g = c.top + c.bottom;
            c = f.width + b;
            f = f.height + g;
            d += b;
            e += g;
            b = Cl(a, !0);
            c === d && f === e && (b = Og);
            switch (b) {
                case Og:
                    if (c > d || f > e) Cj(a, !0), a.measure(c > d ? d : c, f > e ? e : f, 0, 0);
                    break;
                case Jd:
                    Cj(a, !0);
                    a.measure(d, e, 0, 0);
                    break;
                case nl:
                    Cj(a, !0);
                    a.measure(d, f, 0, 0);
                    break;
                case ol:
                    Cj(a, !0), a.measure(c, e, 0, 0)
            }
        }
    }

    t.Um = function (a, b) {
        var c = this.part;
        null !== c && null !== c.diagram && (c.selectionObject !== this && c.resizeObject !== this && c.rotateObject !== this || Fl(c, !0), this.P(), hc(a, b) || (c.Yh(), this.tp(c)))
    };
    t.tp = function (a) {
        null !== this.portId && (Fl(a, !0), a instanceof V && Gl(a, this))
    };
    t.ic = function (a, b) {
        if (this.visible) {
            var c = this instanceof W && (this.type === W.TableRow || this.type === W.TableColumn), d = this.Db;
            if (c || 0 !== d.width && 0 !== d.height && !isNaN(d.x) && !isNaN(d.y)) {
                var e = this.opacity;
                if (0 !== e) {
                    var f = 1;
                    1 !== e && (f = a.globalAlpha, a.globalAlpha = f * e);
                    if (!this.zy(a, b)) if (c) Hl(this, a, b); else {
                        this instanceof S && this.Nk(!1);
                        F && F.Gm && F.eA && F.eA(a, this);
                        c = this.transform;
                        var g = this.panel;
                        0 !== (this.I & 4096) === !0 && Il(this);
                        var h = this.part, k = !1, l = 0;
                        if (h && b.Te("drawShadows") && (k = h.isShadowed)) {
                            var m =
                                h.shadowOffset;
                            l = Math.max(m.y, m.x) * b.scale * b.Zb
                        }
                        if (!(m = b.Hi || !this.Rf())) {
                            var n = this.naturalBounds;
                            m = this.ii;
                            var p = m.m11, r = m.m21, q = m.dx, u = m.m12, x = m.m22, y = m.dy, z, B = z = 0;
                            m = z * p + B * r + q;
                            var D = z * u + B * x + y;
                            z = n.width + l;
                            B = 0;
                            var G = z * p + B * r + q;
                            z = z * u + B * x + y;
                            B = Math.min(m, G);
                            var O = Math.min(D, z);
                            var U = Math.max(m + 0, G) - B;
                            var R = Math.max(D + 0, z) - O;
                            m = B;
                            D = O;
                            z = n.width + l;
                            B = n.height + l;
                            G = z * p + B * r + q;
                            z = z * u + B * x + y;
                            B = Math.min(m, G);
                            O = Math.min(D, z);
                            U = Math.max(m + U, G) - B;
                            R = Math.max(D + R, z) - O;
                            m = B;
                            D = O;
                            z = 0;
                            B = n.height + l;
                            G = z * p + B * r + q;
                            z = z * u + B * x + y;
                            B = Math.min(m, G);
                            O = Math.min(D, z);
                            U = Math.max(m + U, G) - B;
                            R = Math.max(D + R, z) - O;
                            m = B;
                            D = O;
                            l = b.viewportBounds;
                            n = l.x;
                            p = l.y;
                            m = !(m > l.width + n || n > U + m || D > l.height + p || p > R + D)
                        }
                        if (m) {
                            m = 0 !== (this.I & 256);
                            a.clipInsteadOfFill && (m = !1);
                            this instanceof kh && (a.font = this.font);
                            if (m) {
                                F && F.gA && Ea("clip" + this.toString());
                                D = g.le() ? g.naturalBounds : g.actualBounds;
                                null !== this.fb ? (n = this.fb, U = n.x, R = n.y, l = n.width, n = n.height) : (U = Math.max(d.x, D.x), R = Math.max(d.y, D.y), l = Math.min(d.right, D.right) - U, n = Math.min(d.bottom, D.bottom) - R);
                                if (U > d.width +
                                    d.x || d.x > D.width + D.x) {
                                    1 !== e && (a.globalAlpha = f);
                                    return
                                }
                                a.save();
                                a.beginPath();
                                a.rect(U, R, l, n);
                                a.clip()
                            }
                            if (this.Rf()) {
                                if (!h.isVisible()) {
                                    1 !== e && (a.globalAlpha = f);
                                    return
                                }
                                k && (D = h.shadowOffset, a.Uw(D.x * b.scale * b.Zb, D.y * b.scale * b.Zb, h.shadowBlur), Jl(a), a.shadowColor = h.shadowColor)
                            }
                            k && !0 === this.shadowVisible ? Jl(a) : k && !1 === this.shadowVisible && Kl(a);
                            h = this.naturalBounds;
                            null !== this.kc && (Ai(this, a, this.kc, !0, !0, h, d), this.kc instanceof Ll && this.kc.type === Ml ? (a.beginPath(), a.rect(d.x, d.y, d.width, d.height), a.Se(this.kc)) :
                                a.fillRect(d.x, d.y, d.width, d.height));
                            a.transform(c.m11, c.m12, c.m21, c.m22, c.dx, c.dy);
                            k && (null !== g && 0 !== (g.I & 512) || null !== g && (g.type === W.Auto || g.type === W.Spot) && g.wb() !== this) && null === this.shadowVisible && Kl(a);
                            null !== this.rb && (l = this.naturalBounds, U = D = 0, R = l.width, l = l.height, n = 0, this instanceof Zf && (l = this.ua.bounds, D = l.x, U = l.y, R = l.width, l = l.height, n = this.strokeWidth), Ai(this, a, this.rb, !0, !1, h, d), this.rb instanceof Ll && this.rb.type === Ml ? (a.beginPath(), a.rect(D - n / 2, U - n / 2, R + n, l + n), a.Se(this.rb)) : a.fillRect(D -
                                n / 2, U - n / 2, R + n, l + n));
                            F && F.Gm && F.fA && F.fA(a, this);
                            k && (null !== this.rb || null !== this.kc || null !== g && 0 !== (g.I & 512) || null !== g && (g.type === W.Auto || g.type === W.Spot) && g.wb() !== this) ? (Nl(this, !0), null === this.shadowVisible && Kl(a)) : Nl(this, !1);
                            this.oj(a, b);
                            k && 0 !== (this.I & 512) === !0 && Jl(a);
                            this.Rf() && k && Kl(a);
                            m ? (a.restore(), this instanceof W ? a.Ac(!0) : a.Ac(!1)) : c.fu() || (b = 1 / (c.m11 * c.m22 - c.m12 * c.m21), a.transform(c.m22 * b, -c.m12 * b, -c.m21 * b, c.m11 * b, b * (c.m21 * c.dy - c.m22 * c.dx), b * (c.m12 * c.dx - c.m11 * c.dy)))
                        }
                    }
                    1 !== e && (a.globalAlpha =
                        f)
                }
            }
        }
    };
    t.zy = function () {
        return !1
    };

    function Hl(a, b, c) {
        var d = a.Db, e = a.wc;
        null !== a.kc && (Ai(a, b, a.kc, !0, !0, e, d), a.kc instanceof Ll && a.kc.type === Ml ? (b.beginPath(), b.rect(d.x, d.y, d.width, d.height), b.Se(a.kc)) : b.fillRect(d.x, d.y, d.width, d.height));
        null !== a.rb && (Ai(a, b, a.rb, !0, !1, e, d), a.rb instanceof Ll && a.rb.type === Ml ? (b.beginPath(), b.rect(d.x, d.y, d.width, d.height), b.Se(a.rb)) : b.fillRect(d.x, d.y, d.width, d.height));
        a.oj(b, c)
    }

    t.oj = function () {
    };

    function Ai(a, b, c, d, e, f, g) {
        if (null !== c) {
            var h = 1, k = 1;
            if ("string" === typeof c) d ? b.fillStyle = c : b.strokeStyle = c; else if (c.type === Ol) d ? b.fillStyle = c.color : b.strokeStyle = c.color; else {
                var l = 0;
                a instanceof Zf && (l = a.strokeWidth);
                h = f.width;
                k = f.height;
                e ? (h = g.width, k = g.height) : d || (h += l, k += l);
                if ((f = b instanceof Pl) && c.qe && (c.type === Ql || c.ql === h && c.Ku === k)) var m = c.qe; else {
                    var n = 0, p = 0, r = 0, q = 0, u = 0, x = 0;
                    x = u = 0;
                    e ? (u = g.x, x = g.y) : d || (u -= l / 2, x -= l / 2);
                    n = c.start.x * h + c.start.offsetX;
                    p = c.start.y * k + c.start.offsetY;
                    r = c.end.x * h +
                        c.end.offsetX;
                    q = c.end.y * k + c.end.offsetY;
                    n += u;
                    r += u;
                    p += x;
                    q += x;
                    if (c.type === Rl) m = b.createLinearGradient(n, p, r, q); else if (c.type === Ml) x = isNaN(c.endRadius) ? Math.max(h, k) / 2 : c.endRadius, isNaN(c.startRadius) ? (u = 0, x = Math.max(h, k) / 2) : u = c.startRadius, m = b.createRadialGradient(n, p, u, r, q, x); else if (c.type === Ql) try {
                        m = b.createPattern(c.pattern, "repeat")
                    } catch (z) {
                        m = null
                    } else xa(c.type, "Brush type");
                    if (c.type !== Ql && (e = c.colorStops, null !== e)) for (e = e.iterator; e.next();) m.addColorStop(e.key, e.value);
                    if (f && (c.qe = m, null !==
                    m && (c.ql = h, c.Ku = k), null === m && c.type === Ql && -1 !== c.ql)) {
                        c.ql = -1;
                        var y = a.diagram;
                        null !== y && -1 === c.ql && ta(function () {
                            y.We()
                        }, 600)
                    }
                }
                d ? b.fillStyle = m : b.strokeStyle = m
            }
        }
    }

    t.Tg = function (a) {
        if (a instanceof W) a:{
            if (this !== a && null !== a) for (var b = this.panel; null !== b;) {
                if (b === a) {
                    a = !0;
                    break a
                }
                b = b.panel
            }
            a = !1
        } else a = !1;
        return a
    };
    t.Sf = function () {
        if (!this.visible) return !1;
        var a = this.panel;
        return null !== a ? a.Sf() : !0
    };
    t.Ug = function () {
        for (var a = this instanceof W ? this : this.panel; null !== a && a.isEnabled;) a = a.panel;
        return null === a
    };

    function Il(a) {
        if (0 !== (a.I & 2048) === !0) {
            var b = a.vb;
            b.reset();
            if (!a.Db.o() || !a.vc.o()) {
                Sl(a, !1);
                return
            }
            b.translate(a.Db.x - a.vc.x, a.Db.y - a.vc.y);
            if (1 !== a.scale || 0 !== a.angle) {
                var c = a.naturalBounds;
                Al(a, b, c.x, c.y, c.width, c.height)
            }
            Sl(a, !1);
            Tl(a, !0)
        }
        0 !== (a.I & 4096) === !0 && (b = a.panel, null === b ? (a.ii.set(a.vb), a.Al = a.scale, Tl(a, !1)) : null !== b.Hd && (c = a.ii, c.reset(), b.le() ? c.multiply(b.ii) : null !== b.panel && c.multiply(b.panel.ii), c.multiply(a.vb), a.Al = a.scale * b.Al, Tl(a, !1)))
    }

    function Al(a, b, c, d, e, f) {
        1 !== a.scale && b.scale(a.scale);
        if (0 !== a.dc) {
            var g = Mc;
            a.Rf() && a.locationSpot.cb() && (g = a.locationSpot);
            var h = J.alloc();
            if (a instanceof T && a.locationObject !== a) for (c = a.locationObject, d = c.naturalBounds, h.al(d.x, d.y, d.width, d.height, g), c.pg.ya(h), h.offset(-c.measuredBounds.x, -c.measuredBounds.y), g = c.panel; null !== g && g !== a;) g.pg.ya(h), h.offset(-g.measuredBounds.x, -g.measuredBounds.y), g = g.panel; else h.al(c, d, e, f, g);
            b.rotate(a.dc, h.x, h.y);
            J.free(h)
        }
    }

    t.v = function (a) {
        void 0 === a && (a = !1);
        if (!0 !== Hj(this)) {
            Cj(this, !0);
            Dl(this, !0);
            var b = this.panel;
            null === b || a || b.v()
        }
    };
    t.Pm = function () {
        !0 !== Hj(this) && (Cj(this, !0), Dl(this, !0))
    };

    function Ul(a) {
        if (!1 === Ij(a)) {
            var b = a.panel;
            null !== b ? b.v() : a.Rf() && (b = a.diagram, null !== b && (b.yd.add(a), a instanceof V && a.wd(), b.Kb()));
            Dl(a, !0)
        }
    }

    t.Rl = function () {
        0 !== (this.I & 2048) === !1 && (Sl(this, !0), Tl(this, !0))
    };
    t.pw = function () {
        Tl(this, !0)
    };
    t.P = function () {
        var a = this.part;
        null !== a && a.P()
    };

    function Cl(a, b) {
        var c = a.stretch, d = a.panel;
        if (null !== d && d.type === W.Table) return Vl(a, d.getRowDefinition(a.row), d.getColumnDefinition(a.column), b);
        if (null !== d && d.type === W.Auto && d.wb() === a) return Wl(a, Jd, b);
        if (c === ml) {
            if (null !== d) {
                if (d.type === W.Spot && d.wb() === a) return Wl(a, Jd, b);
                c = d.defaultStretch;
                return c === ml ? Wl(a, Og, b) : Wl(a, c, b)
            }
            return Wl(a, Og, b)
        }
        return Wl(a, c, b)
    }

    function Vl(a, b, c, d) {
        var e = a.stretch;
        if (e !== ml) return Wl(a, e, d);
        var f = e = null;
        switch (b.stretch) {
            case ol:
                f = !0;
                break;
            case Jd:
                f = !0
        }
        switch (c.stretch) {
            case nl:
                e = !0;
                break;
            case Jd:
                e = !0
        }
        b = a.panel.defaultStretch;
        null === e && (e = b === nl || b === Jd);
        null === f && (f = b === ol || b === Jd);
        return !0 === e && !0 === f ? Wl(a, Jd, d) : !0 === e ? Wl(a, nl, d) : !0 === f ? Wl(a, ol, d) : Wl(a, Og, d)
    }

    function Wl(a, b, c) {
        if (c) return b;
        if (b === Og) return Og;
        c = a.desiredSize;
        if (c.o()) return Og;
        a = a.angle;
        if (!isNaN(c.width)) if (90 !== a && 270 !== a) {
            if (b === nl) return Og;
            if (b === Jd) return ol
        } else {
            if (b === ol) return Og;
            if (b === Jd) return nl
        }
        if (!isNaN(c.height)) if (90 !== a && 270 !== a) {
            if (b === ol) return Og;
            if (b === Jd) return nl
        } else {
            if (b === nl) return Og;
            if (b === Jd) return ol
        }
        return b
    }

    function Nl(a, b) {
        a.I = b ? a.I | 512 : a.I & -513
    }

    function wl(a) {
        return 0 !== (a.I & 1024)
    }

    function Xl(a, b) {
        a.I = b ? a.I | 1024 : a.I & -1025
    }

    function Sl(a, b) {
        a.I = b ? a.I | 2048 : a.I & -2049
    }

    function Tl(a, b) {
        a.I = b ? a.I | 4096 : a.I & -4097
    }

    function Hj(a) {
        return 0 !== (a.I & 8192)
    }

    function Cj(a, b) {
        a.I = b ? a.I | 8192 : a.I & -8193
    }

    function Ij(a) {
        return 0 !== (a.I & 16384)
    }

    function Dl(a, b) {
        a.I = b ? a.I | 16384 : a.I & -16385
    }

    t.Dj = function (a) {
        this.Bg = a
    };
    t.wu = function () {
    };
    t.Qw = function (a) {
        this.ra.assign(a);
        Ul(this);
        return !0
    };
    t.sr = function (a, b) {
        if (this.ra.x !== a || this.ra.y !== b) this.ra.h(a, b), this.Rl()
    };

    function Yl(a) {
        var b = a.part;
        if (b instanceof V && (null !== a.portId || a === b.port)) {
            var c = b.diagram;
            null === c || c.undoManager.isUndoingRedoing || Gl(b, a)
        }
    }

    function Zl(a) {
        var b = a.diagram;
        null === b || b.undoManager.isUndoingRedoing || (a instanceof W ? a instanceof V ? a.wd() : a.cl(a, function (a) {
            Yl(a)
        }) : Yl(a))
    }

    t.bind = function (a) {
        a.td = this;
        var b = this.sj();
        null !== b && $l(b) && v("Cannot add a Binding to a template that has already been copied: " + a);
        null === this.lb && (this.lb = new H);
        this.lb.add(a)
    };
    t.sj = function () {
        for (var a = this instanceof W ? this : this.panel; null !== a;) {
            if (null !== a.wi) return a;
            a = a.panel
        }
        return null
    };
    t.Rw = function (a) {
        Oj(this, a)
    };
    t.bx = function (a) {
        a.td = this;
        null === this.Zg && (this.Zg = new Db);
        this.Zg.add(a.propertyName, a)
    };

    function am(a, b) {
        for (var c = 1; c < arguments.length; ++c) ;
        c = arguments;
        var d = null, e = null;
        if ("function" === typeof a) e = a; else if ("string" === typeof a) {
            var f = bm.K(a);
            "function" === typeof f ? (c = Ja(arguments), d = f(c), Ga(d) || v('GraphObject.make invoked object builder "' + a + '", but it did not return an Object')) : e = qa.go[a]
        }
        null === d && (void 0 !== e && null !== e && e.constructor || v("GraphObject.make requires a class function or GoJS class name or name of an object builder, not: " + a), d = new e);
        e = 1;
        if (d instanceof Q && 1 < c.length) {
            f =
                d;
            var g = c[1];
            if ("string" === typeof g || g instanceof HTMLDivElement) Pi(f, g), e++
        }
        for (; e < c.length; e++) f = c[e], void 0 === f ? v("Undefined value at argument " + e + " for object being constructed by GraphObject.make: " + d) : cm(d, f);
        return d
    }

    function cm(a, b) {
        if ("string" === typeof b) if (a instanceof kh) a.text = b; else if (a instanceof Zf) a.figure = b; else if (a instanceof ok) a.source = b; else if (a instanceof W) {
            var c = dm.K(b);
            null !== c ? a.type = c : F && v("Unknown Panel type as an argument to GraphObject.make: " + b + ". If building from source, you may need to call Panel.definePanelLayout.")
        } else a instanceof Ll ? (c = hb(Ll, b), null !== c ? a.type = c : v("Unknown Brush type as an argument to GraphObject.make: " + b)) : a instanceof Hd ? (c = hb(Hd, b), null !== c ? a.type = c : F && v("Unknown Geometry type as an argument to GraphObject.make: " +
            b)) : a instanceof ye ? (c = hb(ye, b), null !== c ? a.type = c : F && v("Unknown PathSegment type as an argument to GraphObject.make: " + b)) : F && v("Unable to use a string as an argument to GraphObject.make: " + b); else if (b instanceof N) a instanceof W || v("A GraphObject can only be added to a Panel, not to: " + a), a.add(b); else if (b instanceof ik) {
            var d;
            b.isRow && "function" === typeof a.getRowDefinition ? d = a.getRowDefinition(b.index) : b.isRow || "function" !== typeof a.getColumnDefinition || (d = a.getColumnDefinition(b.index));
            d instanceof
            ik ? d.Ot(b) : v("A RowColumnDefinition can only be added to an object that implements getRowDefinition/getColumnDefinition, not to: " + a)
        } else if (b instanceof E) "function" === typeof a.pb ? a.pb(b) : Da(a, b); else if (b instanceof em) a.type = b; else if (b instanceof Ti) a instanceof N ? a.bind(b) : a instanceof ik ? a.bind(b) : v("A Binding can only be applied to a GraphObject or RowColumnDefinition, not to: " + a); else if (b instanceof si) a instanceof N ? a.bx(b) : v("An AnimationTrigger can only be applied to a GraphObject, not to: " +
            a); else if (b instanceof xe) a instanceof Hd ? a.figures.add(b) : v("A PathFigure can only be added to a Geometry, not to: " + a); else if (b instanceof ye) a instanceof xe ? a.segments.add(b) : v("A PathSegment can only be added to a PathFigure, not to: " + a); else if (b instanceof Ni) a instanceof Q ? a.layout = b : a instanceof Kf ? a.layout = b : v("A Layout can only be assigned to a Diagram or a Group, not to: " + a); else if (Array.isArray(b)) for (c = 0; c < b.length; c++) cm(a, b[c]); else if ("object" === typeof b && null !== b) if (a instanceof
            Ll) {
            c = new kb;
            for (var e in b) d = parseFloat(e), isNaN(d) ? c[e] = b[e] : a.addColorStop(d, b[e]);
            Oj(a, c)
        } else if (a instanceof ik) {
            void 0 !== b.row ? (e = b.row, (void 0 === e || null === e || Infinity === e || isNaN(e) || 0 > e) && v("Must specify non-negative integer row for RowColumnDefinition " + b + ", not: " + e), a.isRow = !0, a.index = e) : void 0 !== b.column && (e = b.column, (void 0 === e || null === e || Infinity === e || isNaN(e) || 0 > e) && v("Must specify non-negative integer column for RowColumnDefinition " + b + ", not: " + e), a.isRow = !1, a.index = e);
            e = new kb;
            for (c in b) "row" !==
            c && "column" !== c && (e[c] = b[c]);
            Oj(a, e)
        } else Oj(a, b); else v('Unknown initializer "' + b + '" for object being constructed by GraphObject.make: ' + a)
    }

    function fm(a, b) {
        A(a, "string", N, "defineBuilder:name");
        A(b, "function", N, "defineBuilder:func");
        var c = a.toLowerCase();
        F && ("" === a || "none" === c || a === c) && v("Shape.defineFigureGenerator name must not be empty or None or all-lower-case: " + a);
        bm.add(a, b)
    }

    function gm(a, b, c) {
        void 0 === c && (c = null);
        var d = a[1];
        if ("function" === typeof c ? c(d) : "string" === typeof d) return a.splice(1, 1), d;
        if (void 0 === b) throw Error("no " + ("function" === typeof c ? "satisfactory" : "string") + " argument for GraphObject builder " + a[0]);
        return b
    }

    na.Object.defineProperties(N.prototype, {
        shadowVisible: {
            configurable: !0, get: function () {
                return this.om
            }, set: function (a) {
                var b = this.om;
                b !== a && (F && null !== a && A(a, "boolean", N, "shadowVisible"), this.om = a, this.P(), this.g("shadowVisible", b, a))
            }
        }, enabledChanged: {
            configurable: !0, get: function () {
                return null !== this.R ? this.R.ho : null
            }, set: function (a) {
                tl(this);
                var b = this.R.ho;
                b !== a && (null !== a && A(a, "function", N, "enabledChanged"), this.R.ho = a, this.g("enabledChanged", b, a))
            }
        }, segmentOrientation: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.mm
            }, set: function (a) {
                var b = this.mm;
                b !== a && (F && ib(a, S, N, "segmentOrientation"), this.mm = a, this.v(), this.g("segmentOrientation", b, a), a === pg && (this.angle = 0))
            }
        }, segmentIndex: {
            configurable: !0, get: function () {
                return this.Xp
            }, set: function (a) {
                F && A(a, "number", N, "segmentIndex");
                a = Math.round(a);
                var b = this.Xp;
                b !== a && (this.Xp = a, this.v(), this.g("segmentIndex", b, a))
            }
        }, segmentFraction: {
            configurable: !0, get: function () {
                return this.km
            }, set: function (a) {
                F &&
                A(a, "number", N, "segmentFraction");
                isNaN(a) ? a = 0 : 0 > a ? a = 0 : 1 < a && (a = 1);
                var b = this.km;
                b !== a && (this.km = a, this.v(), this.g("segmentFraction", b, a))
            }
        }, segmentOffset: {
            configurable: !0, get: function () {
                return this.lm
            }, set: function (a) {
                var b = this.lm;
                b.A(a) || (F && w(a, J, N, "segmentOffset"), this.lm = a = a.J(), this.v(), this.g("segmentOffset", b, a))
            }
        }, stretch: {
            configurable: !0, get: function () {
                return this.Le
            }, set: function (a) {
                var b = this.Le;
                b !== a && (F && ib(a, N, N, "stretch"), this.Le = a, this.v(), this.g("stretch",
                    b, a))
            }
        }, name: {
            configurable: !0, get: function () {
                return this.Wa
            }, set: function (a) {
                var b = this.Wa;
                b !== a && (F && A(a, "string", N, "name"), this.Wa = a, null !== this.part && (this.part.gk = null), this.g("name", b, a))
            }
        }, opacity: {
            configurable: !0, get: function () {
                return this.nb
            }, set: function (a) {
                var b = this.nb;
                b !== a && (A(a, "number", N, "opacity"), (0 > a || 1 < a) && za(a, "0 <= value <= 1", N, "opacity"), this.nb = a, this.g("opacity", b, a), a = this.diagram, b = this.part, null !== a && null !== b && a.P(Sj(b, b.actualBounds)))
            }
        }, visible: {
            configurable: !0,
            enumerable: !0, get: function () {
                return 0 !== (this.I & 1)
            }, set: function (a) {
                var b = 0 !== (this.I & 1);
                b !== a && (F && A(a, "boolean", N, "visible"), this.I ^= 1, this.g("visible", b, a), b = this.panel, null !== b ? b.v() : this.Rf() && this.Vb(a), this.P(), Zl(this))
            }
        }, pickable: {
            configurable: !0, get: function () {
                return 0 !== (this.I & 2)
            }, set: function (a) {
                var b = 0 !== (this.I & 2);
                b !== a && (F && A(a, "boolean", N, "pickable"), this.I ^= 2, this.g("pickable", b, a))
            }
        }, fromLinkableDuplicates: {
            configurable: !0, get: function () {
                return 0 !== (this.I &
                    4)
            }, set: function (a) {
                var b = 0 !== (this.I & 4);
                b !== a && (F && A(a, "boolean", N, "fromLinkableDuplicates"), this.I ^= 4, this.g("fromLinkableDuplicates", b, a))
            }
        }, fromLinkableSelfNode: {
            configurable: !0, get: function () {
                return 0 !== (this.I & 8)
            }, set: function (a) {
                var b = 0 !== (this.I & 8);
                b !== a && (F && A(a, "boolean", N, "fromLinkableSelfNode"), this.I ^= 8, this.g("fromLinkableSelfNode", b, a))
            }
        }, toLinkableDuplicates: {
            configurable: !0, get: function () {
                return 0 !== (this.I & 16)
            }, set: function (a) {
                var b = 0 !== (this.I & 16);
                b !==
                a && (F && A(a, "boolean", N, "toLinkableDuplicates"), this.I ^= 16, this.g("toLinkableDuplicates", b, a))
            }
        }, toLinkableSelfNode: {
            configurable: !0, get: function () {
                return 0 !== (this.I & 32)
            }, set: function (a) {
                var b = 0 !== (this.I & 32);
                b !== a && (F && A(a, "boolean", N, "toLinkableSelfNode"), this.I ^= 32, this.g("toLinkableSelfNode", b, a))
            }
        }, isPanelMain: {
            configurable: !0, get: function () {
                return 0 !== (this.I & 64)
            }, set: function (a) {
                var b = 0 !== (this.I & 64);
                b !== a && (F && A(a, "boolean", N, "isPanelMain"), this.I ^= 64, this.v(),
                    this.g("isPanelMain", b, a))
            }
        }, isActionable: {
            configurable: !0, get: function () {
                return 0 !== (this.I & 128)
            }, set: function (a) {
                var b = 0 !== (this.I & 128);
                b !== a && (F && A(a, "boolean", N, "isActionable"), this.I ^= 128, this.g("isActionable", b, a))
            }
        }, areaBackground: {
            configurable: !0, get: function () {
                return this.kc
            }, set: function (a) {
                var b = this.kc;
                b !== a && (null !== a && hm(a, "GraphObject.areaBackground"), a instanceof Ll && a.freeze(), this.kc = a, this.P(), this.g("areaBackground", b, a))
            }
        }, background: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.rb
            }, set: function (a) {
                var b = this.rb;
                b !== a && (null !== a && hm(a, "GraphObject.background"), a instanceof Ll && a.freeze(), this.rb = a, this.P(), this.g("background", b, a))
            }
        }, part: {
            configurable: !0, get: function () {
                if (this.Rf()) return this;
                if (null !== this.kk) return this.kk;
                var a;
                for (a = this.panel; a;) {
                    if (a instanceof T) return this.kk = a;
                    a = a.panel
                }
                return null
            }
        }, svg: {
            configurable: !0, get: function () {
                return this.pq
            }, set: function (a) {
                this.pq = a
            }
        }, panel: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Bg
            }
        }, layer: {
            configurable: !0, get: function () {
                var a = this.part;
                return null !== a ? a.layer : null
            }
        }, diagram: {
            configurable: !0, get: function () {
                var a = this.part;
                return null !== a ? a.diagram : null
            }
        }, position: {
            configurable: !0, get: function () {
                return this.ra
            }, set: function (a) {
                F && w(a, J, N, "position");
                var b = a.x, c = a.y, d = this.ra, e = d.x, f = d.y;
                (e === b || isNaN(e) && isNaN(b)) && (f === c || isNaN(f) && isNaN(c)) ? this.wu() : (a = a.copy(), this.Qw(a, d) && this.g("position",
                    d.copy(), a.copy()))
            }
        }, actualBounds: {
            configurable: !0, get: function () {
                return this.Db
            }
        }, scale: {
            configurable: !0, get: function () {
                return this.Fa
            }, set: function (a) {
                var b = this.Fa;
                b !== a && (F && C(a, N, "scale"), 0 >= a && v("GraphObject.scale for " + this + " must be greater than zero, not: " + a), this.Fa = a, this.v(), this.g("scale", b, a))
            }
        }, angle: {
            configurable: !0, get: function () {
                return this.dc
            }, set: function (a) {
                var b = this.dc;
                b !== a && (F && C(a, N, "angle"), a %= 360, 0 > a && (a += 360), b !== a && (this.dc =
                    a, Zl(this), this.v(), this.g("angle", b, a)))
            }
        }, desiredSize: {
            configurable: !0, get: function () {
                return this.dd
            }, set: function (a) {
                F && w(a, Hb, N, "desiredSize");
                var b = a.width, c = a.height, d = this.dd, e = d.width, f = d.height;
                (e === b || isNaN(e) && isNaN(b)) && (f === c || isNaN(f) && isNaN(c)) || (this.dd = a = a.J(), this.v(), this instanceof Zf && this.jc(), this.g("desiredSize", d, a), wl(this) && (a = this.part, null !== a && (xl(this, a, "width"), xl(this, a, "height"))))
            }
        }, width: {
            configurable: !0, get: function () {
                return this.dd.width
            },
            set: function (a) {
                var b = this.dd.width;
                b === a || isNaN(b) && isNaN(a) || (F && A(a, "number", N, "width"), b = this.dd, this.dd = a = (new Hb(a, this.dd.height)).freeze(), this.v(), this instanceof Zf && this.jc(), this.g("desiredSize", b, a), wl(this) && (a = this.part, null !== a && xl(this, a, "width")))
            }
        }, height: {
            configurable: !0, get: function () {
                return this.dd.height
            }, set: function (a) {
                var b = this.dd.height;
                b === a || isNaN(b) && isNaN(a) || (F && A(a, "number", N, "height"), b = this.dd, this.dd = a = (new Hb(this.dd.width, a)).freeze(), this.v(),
                this instanceof Zf && this.jc(), this.g("desiredSize", b, a), wl(this) && (a = this.part, null !== a && xl(this, a, "height")))
            }
        }, minSize: {
            configurable: !0, get: function () {
                return this.sg
            }, set: function (a) {
                var b = this.sg;
                b.A(a) || (F && w(a, Hb, N, "minSize"), a = a.copy(), isNaN(a.width) && (a.width = 0), isNaN(a.height) && (a.height = 0), a.freeze(), this.sg = a, this.v(), this.g("minSize", b, a))
            }
        }, maxSize: {
            configurable: !0, get: function () {
                return this.rg
            }, set: function (a) {
                var b = this.rg;
                b.A(a) || (F && w(a, Hb, N, "maxSize"),
                    a = a.copy(), isNaN(a.width) && (a.width = Infinity), isNaN(a.height) && (a.height = Infinity), a.freeze(), this.rg = a, this.v(), this.g("maxSize", b, a))
            }
        }, measuredBounds: {
            configurable: !0, get: function () {
                return this.vc
            }
        }, naturalBounds: {
            configurable: !0, get: function () {
                return this.wc
            }
        }, margin: {
            configurable: !0, get: function () {
                return this.vh
            }, set: function (a) {
                "number" === typeof a ? a = new jc(a) : F && w(a, jc, N, "margin");
                var b = this.vh;
                b.A(a) || (this.vh = a = a.J(), this.v(), this.g("margin", b, a))
            }
        },
        transform: {
            configurable: !0, get: function () {
                0 !== (this.I & 2048) === !0 && Il(this);
                return this.vb
            }
        }, Hd: {
            configurable: !0, get: function () {
                0 !== (this.I & 4096) === !0 && Il(this);
                return this.ii
            }
        }, alignment: {
            configurable: !0, get: function () {
                return this.Eb
            }, set: function (a) {
                var b = this.Eb;
                b.A(a) || (F && w(a, M, N, "alignment"), a.Tb() && !a.Jb() && v("GraphObject.alignment for " + this + " must be a real Spot or Spot.Default, not: " + a), this.Eb = a = a.J(), Ul(this), this.g("alignment", b, a))
            }
        }, column: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.eh
            }, set: function (a) {
                F && C(a, N, "column");
                a = Math.round(a);
                var b = this.eh;
                b !== a && (0 > a && za(a, ">= 0", N, "column"), this.eh = a, this.v(), this.g("column", b, a))
            }
        }, columnSpan: {
            configurable: !0, get: function () {
                return this.Jn
            }, set: function (a) {
                F && A(a, "number", N, "columnSpan");
                a = Math.round(a);
                var b = this.Jn;
                b !== a && (1 > a && za(a, ">= 1", N, "columnSpan"), this.Jn = a, this.v(), this.g("columnSpan", b, a))
            }
        }, row: {
            configurable: !0, get: function () {
                return this.Qp
            }, set: function (a) {
                F &&
                C(a, N, "row");
                a = Math.round(a);
                var b = this.Qp;
                b !== a && (0 > a && za(a, ">= 0", N, "row"), this.Qp = a, this.v(), this.g("row", b, a))
            }
        }, rowSpan: {
            configurable: !0, get: function () {
                return this.Rp
            }, set: function (a) {
                F && A(a, "number", N, "rowSpan");
                a = Math.round(a);
                var b = this.Rp;
                b !== a && (1 > a && za(a, ">= 1", N, "rowSpan"), this.Rp = a, this.v(), this.g("rowSpan", b, a))
            }
        }, spanAllocation: {
            configurable: !0, get: function () {
                return this.kq
            }, set: function (a) {
                var b = this.kq;
                b !== a && (null !== a && A(a, "function", N, "spanAllocation"),
                    this.kq = a, this.v(), this.g("spanAllocation", b, a))
            }
        }, alignmentFocus: {
            configurable: !0, get: function () {
                return this.jl
            }, set: function (a) {
                var b = this.jl;
                b.A(a) || (F && w(a, M, N, "alignmentFocus"), !F || !a.Tb() || a.Jb() || a.Zq() && this instanceof V || v("GraphObject.alignmentFocus must be a real Spot or Spot.Default, not: " + a), this.jl = a = a.J(), this.v(), this.g("alignmentFocus", b, a))
            }
        }, portId: {
            configurable: !0, get: function () {
                return this.Ep
            }, set: function (a) {
                var b = this.Ep;
                if (b !== a) {
                    F && null !== a && A(a,
                        "string", N, "portId");
                    var c = this.part;
                    null === c || c instanceof V || (v("Cannot set portID on a Link: " + a), c = null);
                    null !== b && null !== c && im(c, this);
                    this.Ep = a;
                    null !== a && null !== c && (c.Xh = !0, jm(c, this));
                    this.g("portId", b, a)
                }
            }
        }, toSpot: {
            configurable: !0, get: function () {
                return null !== this.S ? this.S.Mh : Ec
            }, set: function (a) {
                this.Qc();
                var b = this.S.Mh;
                b.A(a) || (F && w(a, M, N, "toSpot"), a = a.J(), this.S.Mh = a, this.g("toSpot", b, a), Yl(this))
            }
        }, toEndSegmentLength: {
            configurable: !0, get: function () {
                return null !==
                this.S ? this.S.Kh : 10
            }, set: function (a) {
                this.Qc();
                var b = this.S.Kh;
                b !== a && (F && A(a, "number", N, "toEndSegmentLength"), 0 > a && za(a, ">= 0", N, "toEndSegmentLength"), this.S.Kh = a, this.g("toEndSegmentLength", b, a), Yl(this))
            }
        }, toShortLength: {
            configurable: !0, get: function () {
                return null !== this.S ? this.S.Lh : 0
            }, set: function (a) {
                this.Qc();
                var b = this.S.Lh;
                b !== a && (F && A(a, "number", N, "toShortLength"), this.S.Lh = a, this.g("toShortLength", b, a), Yl(this))
            }
        }, toLinkable: {
            configurable: !0, get: function () {
                return null !==
                this.S ? this.S.tq : null
            }, set: function (a) {
                this.Qc();
                var b = this.S.tq;
                b !== a && (F && null !== a && A(a, "boolean", N, "toLinkable"), this.S.tq = a, this.g("toLinkable", b, a))
            }
        }, toMaxLinks: {
            configurable: !0, get: function () {
                return null !== this.S ? this.S.uq : Infinity
            }, set: function (a) {
                this.Qc();
                var b = this.S.uq;
                b !== a && (F && A(a, "number", N, "toMaxLinks"), 0 > a && za(a, ">= 0", N, "toMaxLinks"), this.S.uq = a, this.g("toMaxLinks", b, a))
            }
        }, fromSpot: {
            configurable: !0, get: function () {
                return null !== this.S ? this.S.oh : Ec
            }, set: function (a) {
                this.Qc();
                var b = this.S.oh;
                b.A(a) || (F && w(a, M, N, "fromSpot"), a = a.J(), this.S.oh = a, this.g("fromSpot", b, a), Yl(this))
            }
        }, fromEndSegmentLength: {
            configurable: !0, get: function () {
                return null !== this.S ? this.S.mh : 10
            }, set: function (a) {
                this.Qc();
                var b = this.S.mh;
                b !== a && (F && A(a, "number", N, "fromEndSegmentLength"), 0 > a && za(a, ">= 0", N, "fromEndSegmentLength"), this.S.mh = a, this.g("fromEndSegmentLength", b, a), Yl(this))
            }
        }, fromShortLength: {
            configurable: !0, get: function () {
                return null !== this.S ? this.S.nh : 0
            }, set: function (a) {
                this.Qc();
                var b = this.S.nh;
                b !== a && (F && A(a, "number", N, "fromShortLength"), this.S.nh = a, this.g("fromShortLength", b, a), Yl(this))
            }
        }, fromLinkable: {
            configurable: !0, get: function () {
                return null !== this.S ? this.S.oo : null
            }, set: function (a) {
                this.Qc();
                var b = this.S.oo;
                b !== a && (F && null !== a && A(a, "boolean", N, "fromLinkable"), this.S.oo = a, this.g("fromLinkable", b, a))
            }
        }, fromMaxLinks: {
            configurable: !0, get: function () {
                return null !== this.S ? this.S.po : Infinity
            }, set: function (a) {
                this.Qc();
                var b = this.S.po;
                b !== a && (F &&
                A(a, "number", N, "fromMaxLinks"), 0 > a && za(a, ">= 0", N, "fromMaxLinks"), this.S.po = a, this.g("fromMaxLinks", b, a))
            }
        }, cursor: {
            configurable: !0, get: function () {
                return this.zi
            }, set: function (a) {
                var b = this.zi;
                b !== a && (A(a, "string", N, "cursor"), this.zi = a, this.g("cursor", b, a))
            }
        }, click: {
            configurable: !0, get: function () {
                return null !== this.R ? this.R.ag : null
            }, set: function (a) {
                tl(this);
                var b = this.R.ag;
                b !== a && (null !== a && A(a, "function", N, "click"), this.R.ag = a, this.g("click", b, a))
            }
        }, doubleClick: {
            configurable: !0,
            enumerable: !0, get: function () {
                return null !== this.R ? this.R.fg : null
            }, set: function (a) {
                tl(this);
                var b = this.R.fg;
                b !== a && (null !== a && A(a, "function", N, "doubleClick"), this.R.fg = a, this.g("doubleClick", b, a))
            }
        }, contextClick: {
            configurable: !0, get: function () {
                return null !== this.R ? this.R.bg : null
            }, set: function (a) {
                tl(this);
                var b = this.R.bg;
                b !== a && (null !== a && A(a, "function", N, "contextClick"), this.R.bg = a, this.g("contextClick", b, a))
            }
        }, mouseEnter: {
            configurable: !0, get: function () {
                return null !== this.R ?
                    this.R.ug : null
            }, set: function (a) {
                tl(this);
                var b = this.R.ug;
                b !== a && (null !== a && A(a, "function", N, "mouseEnter"), this.R.ug = a, this.g("mouseEnter", b, a))
            }
        }, mouseLeave: {
            configurable: !0, get: function () {
                return null !== this.R ? this.R.xg : null
            }, set: function (a) {
                tl(this);
                var b = this.R.xg;
                b !== a && (null !== a && A(a, "function", N, "mouseLeave"), this.R.xg = a, this.g("mouseLeave", b, a))
            }
        }, mouseOver: {
            configurable: !0, get: function () {
                return null !== this.R ? this.R.yg : null
            }, set: function (a) {
                tl(this);
                var b = this.R.yg;
                b !== a && (null !== a && A(a, "function", N, "mouseOver"), this.R.yg = a, this.g("mouseOver", b, a))
            }
        }, mouseHover: {
            configurable: !0, get: function () {
                return null !== this.R ? this.R.wg : null
            }, set: function (a) {
                tl(this);
                var b = this.R.wg;
                b !== a && (null !== a && A(a, "function", N, "mouseHover"), this.R.wg = a, this.g("mouseHover", b, a))
            }
        }, mouseHold: {
            configurable: !0, get: function () {
                return null !== this.R ? this.R.vg : null
            }, set: function (a) {
                tl(this);
                var b = this.R.vg;
                b !== a && (null !== a && A(a, "function", N, "mouseHold"), this.R.vg =
                    a, this.g("mouseHold", b, a))
            }
        }, mouseDragEnter: {
            configurable: !0, get: function () {
                return null !== this.R ? this.R.hp : null
            }, set: function (a) {
                tl(this);
                var b = this.R.hp;
                b !== a && (null !== a && A(a, "function", N, "mouseDragEnter"), this.R.hp = a, this.g("mouseDragEnter", b, a))
            }
        }, mouseDragLeave: {
            configurable: !0, get: function () {
                return null !== this.R ? this.R.ip : null
            }, set: function (a) {
                tl(this);
                var b = this.R.ip;
                b !== a && (null !== a && A(a, "function", N, "mouseDragLeave"), this.R.ip = a, this.g("mouseDragLeave", b, a))
            }
        },
        mouseDrop: {
            configurable: !0, get: function () {
                return null !== this.R ? this.R.tg : null
            }, set: function (a) {
                tl(this);
                var b = this.R.tg;
                b !== a && (null !== a && A(a, "function", N, "mouseDrop"), this.R.tg = a, this.g("mouseDrop", b, a))
            }
        }, actionDown: {
            configurable: !0, get: function () {
                return null !== this.R ? this.R.rn : null
            }, set: function (a) {
                tl(this);
                var b = this.R.rn;
                b !== a && (null !== a && A(a, "function", N, "actionDown"), this.R.rn = a, this.g("actionDown", b, a))
            }
        }, actionMove: {
            configurable: !0, get: function () {
                return null !==
                this.R ? this.R.sn : null
            }, set: function (a) {
                tl(this);
                var b = this.R.sn;
                b !== a && (null !== a && A(a, "function", N, "actionMove"), this.R.sn = a, this.g("actionMove", b, a))
            }
        }, actionUp: {
            configurable: !0, get: function () {
                return null !== this.R ? this.R.tn : null
            }, set: function (a) {
                tl(this);
                var b = this.R.tn;
                b !== a && (null !== a && A(a, "function", N, "actionUp"), this.R.tn = a, this.g("actionUp", b, a))
            }
        }, actionCancel: {
            configurable: !0, get: function () {
                return null !== this.R ? this.R.qn : null
            }, set: function (a) {
                tl(this);
                var b = this.R.qn;
                b !== a && (null !== a && A(a, "function", N, "actionCancel"), this.R.qn = a, this.g("actionCancel", b, a))
            }
        }, toolTip: {
            configurable: !0, get: function () {
                return null !== this.R ? this.R.Jg : null
            }, set: function (a) {
                tl(this);
                var b = this.R.Jg;
                b !== a && (!F || null === a || a instanceof Xe || a instanceof gf || v("GraphObject.toolTip must be an Adornment or HTMLInfo."), this.R.Jg = a, this.g("toolTip", b, a))
            }
        }, contextMenu: {
            configurable: !0, get: function () {
                return null !== this.R ? this.R.cg : null
            }, set: function (a) {
                tl(this);
                var b =
                    this.R.cg;
                b !== a && (!F || a instanceof Xe || a instanceof gf || v("GraphObject.contextMenu must be an Adornment or HTMLInfo."), this.R.cg = a, this.g("contextMenu", b, a))
            }
        }
    });
    N.prototype.trigger = N.prototype.bx;
    N.prototype.setProperties = N.prototype.Rw;
    N.prototype.findTemplateBinder = N.prototype.sj;
    N.prototype.bind = N.prototype.bind;
    N.prototype.isEnabledObject = N.prototype.Ug;
    N.prototype.isVisibleObject = N.prototype.Sf;
    N.prototype.isContainedBy = N.prototype.Tg;
    N.prototype.getNearestIntersectionPoint = N.prototype.Zt;
    N.prototype.getLocalPoint = N.prototype.Yt;
    N.prototype.getDocumentScale = N.prototype.Mf;
    N.prototype.getDocumentAngle = N.prototype.vj;
    N.prototype.getDocumentBounds = N.prototype.wj;
    N.prototype.getDocumentPoint = N.prototype.ja;
    N.prototype.intersectsRect = N.prototype.Sc;
    N.prototype.containedInRect = N.prototype.Th;
    N.prototype.containsRect = N.prototype.Pe;
    N.prototype.containsPoint = N.prototype.ca;
    N.prototype.raiseChanged = N.prototype.g;
    N.prototype.raiseChangedEvent = N.prototype.ib;
    N.prototype.addCopyProperty = N.prototype.iy;
    var bm = null;
    N.className = "GraphObject";
    bm = new Db;
    fm("Button", function () {
        function a(a, b) {
            return null !== a.diagram.ac(a.documentPoint, function (a) {
                for (; null !== a.panel && !a.isActionable;) a = a.panel;
                return a
            }, function (a) {
                return a === b
            })
        }

        var b = am(W, W.Auto, {
            isActionable: !0,
            enabledChanged: function (a, b) {
                if (a instanceof W) {
                    var c = a.hb("ButtonBorder");
                    null !== c && (c.fill = b ? a._buttonFillNormal : a._buttonFillDisabled)
                }
            },
            cursor: "pointer",
            _buttonFillNormal: "#F5F5F5",
            _buttonStrokeNormal: "#BDBDBD",
            _buttonFillOver: "#E0E0E0",
            _buttonStrokeOver: "#9E9E9E",
            _buttonFillPressed: "#BDBDBD",
            _buttonStrokePressed: "#9E9E9E",
            _buttonFillDisabled: "#E5E5E5"
        }, am(Zf, {
            name: "ButtonBorder",
            figure: "RoundedRectangle",
            spot1: new M(0, 0, 2.76142374915397, 2.761423749153969),
            spot2: new M(1, 1, -2.76142374915397, -2.761423749153969),
            parameter1: 2,
            parameter2: 2,
            fill: "#F5F5F5",
            stroke: "#BDBDBD"
        }));
        b.mouseEnter = function (a, b) {
            if (b.Ug() && b instanceof W && (a = b.hb("ButtonBorder"), a instanceof Zf)) {
                var c = b._buttonFillOver;
                b._buttonFillNormal = a.fill;
                a.fill = c;
                c = b._buttonStrokeOver;
                b._buttonStrokeNormal = a.stroke;
                a.stroke = c
            }
        };
        b.mouseLeave = function (a, b) {
            b.Ug() && b instanceof W && (a = b.hb("ButtonBorder"), a instanceof Zf && (a.fill = b._buttonFillNormal, a.stroke = b._buttonStrokeNormal))
        };
        b.actionDown = function (a, b) {
            if (b.Ug() && b instanceof W && null !== b._buttonFillPressed && 0 === a.button) {
                var c = b.hb("ButtonBorder");
                if (c instanceof Zf) {
                    a = a.diagram;
                    var d = a.skipsUndoManager;
                    a.skipsUndoManager = !0;
                    var g = b._buttonFillPressed;
                    b._buttonFillOver = c.fill;
                    c.fill = g;
                    g = b._buttonStrokePressed;
                    b._buttonStrokeOver = c.stroke;
                    c.stroke = g;
                    a.skipsUndoManager =
                        d
                }
            }
        };
        b.actionUp = function (b, d) {
            if (d.Ug() && d instanceof W && null !== d._buttonFillPressed && 0 === b.button) {
                var c = d.hb("ButtonBorder");
                if (c instanceof Zf) {
                    var f = b.diagram, g = f.skipsUndoManager;
                    f.skipsUndoManager = !0;
                    a(b, d) ? (c.fill = d._buttonFillOver, c.stroke = d._buttonStrokeOver) : (c.fill = d._buttonFillNormal, c.stroke = d._buttonStrokeNormal);
                    f.skipsUndoManager = g
                }
            }
        };
        b.actionCancel = function (b, d) {
            if (d.Ug() && d instanceof W && null !== d._buttonFillPressed) {
                var c = d.hb("ButtonBorder");
                if (c instanceof Zf) {
                    var f = b.diagram,
                        g = f.skipsUndoManager;
                    f.skipsUndoManager = !0;
                    a(b, d) ? (c.fill = d._buttonFillOver, c.stroke = d._buttonStrokeOver) : (c.fill = d._buttonFillNormal, c.stroke = d._buttonStrokeNormal);
                    f.skipsUndoManager = g
                }
            }
        };
        b.actionMove = function (b, d) {
            if (d.Ug() && d instanceof W && null !== d._buttonFillPressed) {
                var c = b.diagram;
                if (0 === c.firstInput.button && (c.currentTool.standardMouseOver(), a(b, d) && (b = d.hb("ButtonBorder"), b instanceof Zf))) {
                    var f = c.skipsUndoManager;
                    c.skipsUndoManager = !0;
                    var g = d._buttonFillPressed;
                    b.fill !== g && (b.fill = g);
                    g =
                        d._buttonStrokePressed;
                    b.stroke !== g && (b.stroke = g);
                    c.skipsUndoManager = f
                }
            }
        };
        return b
    });
    fm("TreeExpanderButton", function () {
        var a = am("Button", {
            _treeExpandedFigure: "MinusLine",
            _treeCollapsedFigure: "PlusLine"
        }, am(Zf, {
            name: "ButtonIcon",
            figure: "MinusLine",
            stroke: "#424242",
            strokeWidth: 2,
            desiredSize: Wb
        }, (new Ti("figure", "isTreeExpanded", function (a, c) {
            c = c.panel;
            return a ? c._treeExpandedFigure : c._treeCollapsedFigure
        })).fr()), {visible: !1}, (new Ti("visible", "isTreeLeaf", function (a) {
            return !a
        })).fr());
        a.click = function (a, c) {
            c = c.part;
            c instanceof Xe && (c = c.adornedPart);
            if (c instanceof V) {
                var b = c.diagram;
                if (null !== b) {
                    b = b.commandHandler;
                    if (c.isTreeExpanded) {
                        if (!b.canCollapseTree(c)) return
                    } else if (!b.canExpandTree(c)) return;
                    a.handled = !0;
                    c.isTreeExpanded ? b.collapseTree(c) : b.expandTree(c)
                }
            }
        };
        return a
    });
    fm("SubGraphExpanderButton", function () {
        var a = am("Button", {
            _subGraphExpandedFigure: "MinusLine",
            _subGraphCollapsedFigure: "PlusLine"
        }, am(Zf, {
            name: "ButtonIcon",
            figure: "MinusLine",
            stroke: "#424242",
            strokeWidth: 2,
            desiredSize: Wb
        }, (new Ti("figure", "isSubGraphExpanded", function (a, c) {
            c = c.panel;
            return a ? c._subGraphExpandedFigure : c._subGraphCollapsedFigure
        })).fr()));
        a.click = function (a, c) {
            c = c.part;
            c instanceof Xe && (c = c.adornedPart);
            if (c instanceof Kf) {
                var b = c.diagram;
                if (null !== b) {
                    b = b.commandHandler;
                    if (c.isSubGraphExpanded) {
                        if (!b.canCollapseSubGraph(c)) return
                    } else if (!b.canExpandSubGraph(c)) return;
                    a.handled = !0;
                    c.isSubGraphExpanded ? b.collapseSubGraph(c) : b.expandSubGraph(c)
                }
            }
        };
        return a
    });
    fm("ToolTip", function () {
        return am(Xe, W.Auto, {
            isShadowed: !0,
            shadowColor: "rgba(0, 0, 0, .4)",
            shadowOffset: new J(0, 3),
            shadowBlur: 5
        }, am(Zf, {
            name: "Border",
            figure: "RoundedRectangle",
            parameter1: 1,
            parameter2: 1,
            fill: "#F5F5F5",
            stroke: "#F0F0F0",
            spot1: new M(0, 0, 4, 6),
            spot2: new M(1, 1, -4, -4)
        }))
    });
    fm("ContextMenu", function () {
        return am(Xe, W.Vertical, {
            background: "#F5F5F5",
            isShadowed: !0,
            shadowColor: "rgba(0, 0, 0, .4)",
            shadowOffset: new J(0, 3),
            shadowBlur: 5
        }, new Ti("background", "", function (a) {
            return null !== a.adornedPart && null !== a.placeholder ? null : "#F5F5F5"
        }))
    });
    fm("ContextMenuButton", function () {
        var a = am("Button");
        a.stretch = nl;
        var b = a.hb("ButtonBorder");
        b instanceof Zf && (b.figure = "Rectangle", b.strokeWidth = 0, b.spot1 = new M(0, 0, 2, 3), b.spot2 = new M(1, 1, -2, -2));
        return a
    });
    fm("PanelExpanderButton", function (a) {
        var b = gm(a, "COLLAPSIBLE"), c = am("Button", {
            _buttonExpandedFigure: "M0 0 M0 6 L4 2 8 6 M8 8",
            _buttonCollapsedFigure: "M0 0 M0 2 L4 6 8 2 M8 8",
            _buttonFillNormal: "rgba(0, 0, 0, 0)",
            _buttonStrokeNormal: null,
            _buttonFillOver: "rgba(0, 0, 0, .2)",
            _buttonStrokeOver: null,
            _buttonFillPressed: "rgba(0, 0, 0, .4)",
            _buttonStrokePressed: null
        }, am(Zf, {name: "ButtonIcon", strokeWidth: 2}, (new Ti("geometryString", "visible", function (a) {
            return a ? c._buttonExpandedFigure : c._buttonCollapsedFigure
        })).fr(b)));
        a = c.hb("ButtonBorder");
        a instanceof Zf && (a.stroke = null, a.fill = "rgba(0, 0, 0, 0)");
        c.click = function (a, c) {
            var d = c.diagram;
            if (null !== d && !d.isReadOnly) {
                var e = c.sj();
                null === e && (e = c.part);
                null !== e && (c = e.hb(b), null !== c && (a.handled = !0, d.Ca("Collapse/Expand Panel"), c.visible = !c.visible, d.bb("Collapse/Expand Panel")))
            }
        };
        return c
    });
    fm("CheckBoxButton", function (a) {
        var b = gm(a);
        a = am("Button", {desiredSize: new Hb(14, 14)}, am(Zf, {
            name: "ButtonIcon",
            geometryString: "M0 0 M0 8.85 L4.9 13.75 16.2 2.45 M16.2 16.2",
            strokeWidth: 2,
            stretch: Jd,
            geometryStretch: Qg,
            visible: !1
        }, "" !== b ? (new Ti("visible", b)).Yy() : []));
        a.click = function (a, d) {
            if (d instanceof W) {
                var c = a.diagram;
                if (!(null === c || c.isReadOnly || "" !== b && c.model.isReadOnly)) {
                    a.handled = !0;
                    var f = d.hb("ButtonIcon");
                    c.Ca("checkbox");
                    f.visible = !f.visible;
                    "function" === typeof d._doClick && d._doClick(a,
                        d);
                    c.bb("checkbox")
                }
            }
        };
        return a
    });
    fm("CheckBox", function (a) {
        a = gm(a);
        a = am("CheckBoxButton", a, {name: "Button", isActionable: !1, margin: new jc(0, 1, 0, 0)});
        var b = am(W, "Horizontal", a, {
            isActionable: !0,
            cursor: a.cursor,
            margin: 1,
            _buttonFillNormal: a._buttonFillNormal,
            _buttonStrokeNormal: a._buttonStrokeNormal,
            _buttonFillOver: a._buttonFillOver,
            _buttonStrokeOver: a._buttonStrokeOver,
            _buttonFillPressed: a._buttonFillPressed,
            _buttonStrokePressed: a._buttonStrokePressed,
            _buttonFillDisabled: a._buttonFillDisabled,
            mouseEnter: a.mouseEnter,
            mouseLeave: a.mouseLeave,
            actionDown: a.actionDown,
            actionUp: a.actionUp,
            actionCancel: a.actionCancel,
            actionMove: a.actionMove,
            click: a.click,
            _buttonClick: a.click
        });
        a.mouseEnter = null;
        a.mouseLeave = null;
        a.actionDown = null;
        a.actionUp = null;
        a.actionCancel = null;
        a.actionMove = null;
        a.click = null;
        return b
    });
    N.None = Og = new E(N, "None", 0);
    N.Default = ml = new E(N, "Default", 0);
    N.Vertical = ol = new E(N, "Vertical", 4);
    N.Horizontal = nl = new E(N, "Horizontal", 5);
    N.Fill = Jd = new E(N, "Fill", 3);
    N.Uniform = Qg = new E(N, "Uniform", 1);
    N.UniformToFill = pl = new E(N, "UniformToFill", 2);
    N.FlipVertical = ql = new E(N, "FlipVertical", 1);
    N.FlipHorizontal = rl = new E(N, "FlipHorizontal", 2);
    N.FlipBoth = sl = new E(N, "FlipBoth", 3);
    N.make = am;
    N.getBuilders = function () {
        var a = new Db, b;
        for (b in bm) if (b !== b.toLowerCase()) {
            var c = bm.K(b);
            "function" === typeof c && a.add(b, c)
        }
        a.freeze();
        return a
    };
    N.defineBuilder = fm;
    N.takeBuilderArgument = gm;

    function ul() {
        this.ho = this.cg = this.Jg = this.qn = this.tn = this.sn = this.rn = this.tg = this.ip = this.hp = this.vg = this.wg = this.yg = this.xg = this.ug = this.bg = this.fg = this.ag = null
    }

    ul.prototype.copy = function () {
        var a = new ul;
        a.ag = this.ag;
        a.fg = this.fg;
        a.bg = this.bg;
        a.ug = this.ug;
        a.xg = this.xg;
        a.yg = this.yg;
        a.wg = this.wg;
        a.vg = this.vg;
        a.hp = this.hp;
        a.ip = this.ip;
        a.tg = this.tg;
        a.rn = this.rn;
        a.sn = this.sn;
        a.tn = this.tn;
        a.qn = this.qn;
        a.Jg = this.Jg;
        a.cg = this.cg;
        a.ho = this.ho;
        return a
    };
    ul.className = "GraphObjectEventHandlers";

    function km() {
        this.Sa = [1, 0, 0, 1, 0, 0]
    }

    km.prototype.copy = function () {
        var a = new km;
        a.Sa[0] = this.Sa[0];
        a.Sa[1] = this.Sa[1];
        a.Sa[2] = this.Sa[2];
        a.Sa[3] = this.Sa[3];
        a.Sa[4] = this.Sa[4];
        a.Sa[5] = this.Sa[5];
        return a
    };
    km.prototype.translate = function (a, b) {
        this.Sa[4] += this.Sa[0] * a + this.Sa[2] * b;
        this.Sa[5] += this.Sa[1] * a + this.Sa[3] * b
    };
    km.prototype.scale = function (a, b) {
        this.Sa[0] *= a;
        this.Sa[1] *= a;
        this.Sa[2] *= b;
        this.Sa[3] *= b
    };
    km.className = "STransform";

    function lm(a) {
        this.type = a;
        this.r2 = this.y2 = this.x2 = this.r1 = this.y1 = this.x1 = 0;
        this.sy = [];
        this.pattern = null
    }

    lm.prototype.addColorStop = function (a, b) {
        this.sy.push({offset: a, color: b})
    };
    lm.className = "SGradient";

    function Rj(a, b) {
        this.ownerDocument = a = void 0 === b ? qa.document : b;
        this.cB = "http://www.w3.org/2000/svg";
        void 0 !== a && (this.La = this.Cb("svg", {
            width: "1px",
            height: "1px",
            viewBox: "0 0 1 1"
        }), this.La.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/svg"), this.La.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink"));
        this.Mq = null;
        this.context = new mm(this)
    }

    Rj.prototype.resize = function (a, b, c, d) {
        return this.width !== a || this.height !== b ? (this.style.width = c + "px", this.style.height = d + "px", this.La.setAttributeNS(null, "width", c + "px"), this.La.setAttributeNS(null, "height", d + "px"), this.La.setAttributeNS(null, "viewBox", "0 0 " + c + " " + d), this.context.nv.firstElementChild.setAttributeNS(null, "width", c + "px"), this.context.nv.firstElementChild.setAttributeNS(null, "height", d + "px"), !0) : !1
    };
    Rj.prototype.Cb = function (a, b, c) {
        a = this.ownerDocument.createElementNS(this.cB, a);
        if (Ga(b)) for (var d in b) a.setAttributeNS("href" === d ? "http://www.w3.org/1999/xlink" : "", d, b[d]);
        void 0 !== c && (a.textContent = c);
        return a
    };
    Rj.prototype.getBoundingClientRect = function () {
        return this.La.getBoundingClientRect()
    };
    Rj.prototype.focus = function () {
        this.La.focus()
    };
    Rj.prototype.yy = function () {
        this.ownerDocument = null
    };
    na.Object.defineProperties(Rj.prototype, {
        width: {
            configurable: !0, get: function () {
                return this.La.width.baseVal.value
            }, set: function (a) {
                this.La.width = a
            }
        }, height: {
            configurable: !0, get: function () {
                return this.La.height.baseVal.value
            }, set: function (a) {
                this.La.height = a
            }
        }, style: {
            configurable: !0, get: function () {
                return this.La.style
            }
        }
    });
    Rj.className = "SVGSurface";

    function mm(a) {
        this.bl = a;
        this.svg = a.La;
        this.stack = [];
        this.Gc = [];
        this.fillStyle = "#000000";
        this.font = "10px sans-serif";
        this.globalAlpha = 1;
        this.lineCap = "butt";
        this.lineDashOffset = 0;
        this.lineJoin = "miter";
        this.lineWidth = 1;
        this.miterLimit = 10;
        this.shadowBlur = 0;
        this.shadowColor = "rgba(0, 0, 0, 0)";
        this.shadowOffsetY = this.shadowOffsetX = 0;
        this.strokeStyle = "#000000";
        this.textAlign = "start";
        this.clipInsteadOfFill = !1;
        this.wf = this.gq = this.fq = 0;
        this.$q = null;
        this.path = [];
        this.ev = !1;
        this.Fh = null;
        this.Gh = 0;
        this.ge = new km;
        nm(this, 1, 0, 0, 1, 0, 0);
        var b = yb++, c = this.Cb("clipPath", {id: "mainClip" + b});
        c.appendChild(this.Cb("rect", {x: 0, y: 0, width: a.width, height: a.height}));
        this.nv = c;
        this.bl.La.appendChild(c);
        this.Gc[0].setAttributeNS(null, "clip-path", "url(#mainClip" + b + ")");
        this.eB = {}
    }

    t = mm.prototype;
    t.reset = function () {
        this.stack = [];
        this.Gc = [];
        this.fillStyle = "#000000";
        this.font = "10px sans-serif";
        this.globalAlpha = 1;
        this.lineCap = "butt";
        this.lineDashOffset = 0;
        this.lineJoin = "miter";
        this.lineWidth = 1;
        this.miterLimit = 10;
        this.shadowBlur = 0;
        this.shadowColor = "rgba(0, 0, 0, 0)";
        this.shadowOffsetY = this.shadowOffsetX = 0;
        this.strokeStyle = "#000000";
        this.textAlign = "start";
        this.clipInsteadOfFill = !1;
        this.wf = this.gq = this.fq = 0;
        this.$q = null;
        this.path = [];
        this.ge = new km;
        nm(this, 1, 0, 0, 1, 0, 0);
        var a = yb++, b = this.Cb("clipPath",
            {id: "mainClip" + a});
        b.appendChild(this.Cb("rect", {x: 0, y: 0, width: this.bl.width, height: this.bl.height}));
        this.nv = b;
        this.bl.La.appendChild(b);
        this.Gc[0].setAttributeNS(null, "clip-path", "url(#mainClip" + a + ")")
    };
    t.arc = function (a, b, c, d, e, f, g, h) {
        var k = 2 * Math.PI, l = k - 1E-6, m = c * Math.cos(d), n = c * Math.sin(d), p = a + m, r = b + n,
            q = f ? 0 : 1;
        d = f ? d - e : e - d;
        (1E-6 < Math.abs(g - p) || 1E-6 < Math.abs(h - r)) && this.path.push(["L", p, +r]);
        0 > d && (d = d % k + k);
        d > l ? (this.path.push(["A", c, c, 0, 1, q, a - m, b - n]), this.path.push(["A", c, c, 0, 1, q, p, r])) : 1E-6 < d && this.path.push(["A", c, c, 0, +(d >= Math.PI), q, a + c * Math.cos(e), b + c * Math.sin(e)])
    };
    t.beginPath = function () {
        this.path = []
    };
    t.bezierCurveTo = function (a, b, c, d, e, f) {
        this.path.push(["C", a, b, c, d, e, f])
    };
    t.clearRect = function () {
    };
    t.clip = function () {
        this.addPath("clipPath", this.path, this.ge);
        this.addPath("clipPath", this.path, new km)
    };
    t.closePath = function () {
        this.path.push(["z"])
    };
    t.createLinearGradient = function (a, b, c, d) {
        var e = new lm("linear");
        e.x1 = a;
        e.y1 = b;
        e.x2 = c;
        e.y2 = d;
        return e
    };
    t.createPattern = function (a) {
        var b = "";
        a instanceof HTMLCanvasElement && (b = a.toDataURL());
        a instanceof HTMLImageElement && (b = a.getAttribute("src"));
        var c = this.eB;
        if (c[b]) return "url(#" + c[b] + ")";
        var d = "PATTERN" + yb++, e = {x: 0, y: 0, width: a.width, height: a.height, href: b};
        a = this.Cb("pattern", {width: a.width, height: a.height, id: d, patternUnits: "userSpaceOnUse"});
        a.appendChild(this.Cb(Rk, e));
        this.svg.appendChild(a);
        c[b] = d;
        return "url(#" + d + ")"
    };
    t.createRadialGradient = function (a, b, c, d, e, f) {
        var g = new lm("radial");
        g.x1 = a;
        g.y1 = b;
        g.r1 = c;
        g.x2 = d;
        g.y2 = e;
        g.r2 = f;
        return g
    };
    t.drawImage = function (a, b, c, d, e, f, g, h, k) {
        var l = "";
        a instanceof HTMLCanvasElement && (l = a.toDataURL());
        a instanceof HTMLImageElement && (l = a.getAttribute("src"));
        var m = a instanceof HTMLImageElement ? a.naturalWidth : a.width,
            n = a instanceof HTMLImageElement ? a.naturalHeight : a.height;
        void 0 === d && (f = b, g = c, h = d = m, k = e = n);
        d = d || 0;
        e = e || 0;
        f = f || 0;
        g = g || 0;
        h = h || 0;
        k = k || 0;
        a = {x: 0, y: 0, width: m || d, height: n || e, href: l};
        K.da(d, h) && K.da(e, k) ? -1 === l.toLowerCase().indexOf(".svg") && -1 === l.toLowerCase().indexOf("data:image/svg") && (a.preserveAspectRatio =
            "xMidYMid slice") : a.preserveAspectRatio = "none";
        l = "";
        h /= d;
        k /= e;
        if (0 !== f || 0 !== g) l += " translate(" + f + ", " + g + ")";
        if (1 !== h || 1 !== k) l += " scale(" + h + ", " + k + ")";
        if (0 !== b || 0 !== c) l += " translate(" + -b + ", " + -c + ")";
        if (0 !== b || 0 !== c || d !== m || e !== n) f = "CLIP" + yb++, g = this.Cb("clipPath", {id: f}), g.appendChild(this.Cb("rect", {
            x: b,
            y: c,
            width: d,
            height: e
        })), this.svg.appendChild(g), a["clip-path"] = "url(#" + f + ")";
        om(this, Rk, a, this.ge, l);
        this.addElement(Rk, a)
    };
    t.fill = function () {
        this.addPath("fill", this.path, this.ge)
    };
    t.Se = function () {
        this.clipInsteadOfFill ? this.clip() : this.fill()
    };
    t.fillRect = function (a, b, c, d) {
        a = [a, b, c, d];
        a = {x: a[0], y: a[1], width: a[2], height: a[3]};
        om(this, "fill", a, this.ge);
        this.addElement("rect", a)
    };
    t.fillText = function (a, b, c) {
        a = [a, b, c];
        b = this.textAlign;
        "left" === b ? b = "start" : "right" === b ? b = "end" : "center" === b && (b = "middle");
        b = {x: a[1], y: a[2], style: "font: " + this.font, "text-anchor": b};
        om(this, "fill", b, this.ge);
        this.addElement("text", b, a[0])
    };
    t.lineTo = function (a, b) {
        this.path.push(["L", a, b])
    };
    t.moveTo = function (a, b) {
        this.path.push(["M", a, b])
    };
    t.quadraticCurveTo = function (a, b, c, d) {
        this.path.push(["Q", a, b, c, d])
    };
    t.rect = function (a, b, c, d) {
        this.path.push(["M", a, b], ["L", a + c, b], ["L", a + c, b + d], ["L", a, b + d], ["z"])
    };
    t.restore = function () {
        this.ge = this.stack.pop();
        this.path = this.stack.pop();
        var a = this.stack.pop();
        this.fillStyle = a.fillStyle;
        this.font = a.font;
        this.globalAlpha = a.globalAlpha;
        this.lineCap = a.lineCap;
        this.lineDashOffset = a.lineDashOffset;
        this.lineJoin = a.lineJoin;
        this.lineWidth = a.lineWidth;
        this.miterLimit = a.miterLimit;
        this.shadowBlur = a.shadowBlur;
        this.shadowColor = a.shadowColor;
        this.shadowOffsetX = a.shadowOffsetX;
        this.shadowOffsetY = a.shadowOffsetY;
        this.strokeStyle = a.strokeStyle;
        this.textAlign = a.textAlign
    };
    t.save = function () {
        this.stack.push({
            fillStyle: this.fillStyle,
            font: this.font,
            globalAlpha: this.globalAlpha,
            lineCap: this.lineCap,
            lineDashOffset: this.lineDashOffset,
            lineJoin: this.lineJoin,
            lineWidth: this.lineWidth,
            miterLimit: this.miterLimit,
            shadowBlur: this.shadowBlur,
            shadowColor: this.shadowColor,
            shadowOffsetX: this.shadowOffsetX,
            shadowOffsetY: this.shadowOffsetY,
            strokeStyle: this.strokeStyle,
            textAlign: this.textAlign
        });
        for (var a = [], b = 0; b < this.path.length; b++) a.push(this.path[b]);
        this.stack.push(a);
        this.stack.push(this.ge.copy())
    };
    t.setTransform = function (a, b, c, d, e, f) {
        1 === a && 0 === b && 0 === c && 1 === d && 0 === e && 0 === f || nm(this, a, b, c, d, e, f)
    };
    t.scale = function (a, b) {
        this.ge.scale(a, b)
    };
    t.translate = function (a, b) {
        this.ge.translate(a, b)
    };
    t.transform = function () {
    };
    t.stroke = function () {
        this.addPath("stroke", this.path, this.ge)
    };
    t.Gj = function () {
        this.clipInsteadOfFill || this.stroke()
    };
    t.Cb = function (a, b, c) {
        return this.bl.Cb(a, b, c)
    };
    t.addElement = function (a, b, c) {
        a = this.Cb(a, b, c);
        0 < this.Gc.length ? this.Gc[this.Gc.length - 1].appendChild(a) : this.svg.appendChild(a);
        return this.$q = a
    };

    function om(a, b, c, d, e) {
        1 !== a.globalAlpha && (c.opacity = a.globalAlpha);
        "fill" === b ? (a.fillStyle instanceof lm ? c.fill = pm(a, a.fillStyle) : /^rgba\(/.test(a.fillStyle) ? (a = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(a.fillStyle), c.fill = "rgb(" + a[1] + "," + a[2] + "," + a[3] + ")", c["fill-opacity"] = a[4]) : c.fill = a.fillStyle, c.stroke = "none") : "stroke" === b && (c.fill = "none", a.strokeStyle instanceof lm ? c.stroke = pm(a, a.strokeStyle) : /^rgba\(/.test(a.strokeStyle) ? (b = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(a.strokeStyle),
            c.stroke = "rgb(" + b[1] + "," + b[2] + "," + b[3] + ")", c["stroke-opacity"] = b[4]) : c.stroke = a.strokeStyle, c["stroke-width"] = a.lineWidth, c["stroke-linecap"] = a.lineCap, c["stroke-linejoin"] = a.lineJoin, c["stroke-miterlimit"] = a.miterLimit);
        d = d.Sa;
        d = "matrix(" + d[0] + ", " + d[1] + ", " + d[2] + ", " + d[3] + ", " + d[4] + ", " + d[5] + ")";
        void 0 !== e && (d += e);
        c.transform = d
    }

    function pm(a, b) {
        var c = "GRAD" + yb++;
        if ("linear" === b.type) var d = a.Cb("linearGradient", {
            x1: b.x1,
            x2: b.x2,
            y1: b.y1,
            y2: b.y2,
            id: c,
            gradientUnits: "userSpaceOnUse"
        }); else if ("radial" === b.type) d = a.Cb("radialGradient", {
            x1: b.x1,
            x2: b.x2,
            y1: b.y1,
            y2: b.y2,
            r1: b.r1,
            r2: b.r2,
            id: c
        }); else throw Error("invalid gradient");
        var e = b.sy;
        b = e.length;
        for (var f = [], g = 0; g < b; g++) {
            var h = e[g], k = h.color;
            h = {offset: h.offset, "stop-color": k};
            /^rgba\(/.test(k) && (k = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(k),
                h["stop-color"] = "rgb(" + k[1] + "," + k[2] + "," + k[3] + ")", h["stop-opacity"] = k[4]);
            f.push(h)
        }
        f.sort(function (a, b) {
            return a.offset > b.offset ? 1 : -1
        });
        for (e = 0; e < b; e++) d.appendChild(a.Cb("stop", f[e]));
        a.svg.appendChild(d);
        return "url(#" + c + ")"
    }

    t.addPath = function (a, b, c) {
        for (var d = [], e = 0; e < b.length; e++) {
            var f = Ja(b[e]), g = [f.shift()];
            if ("A" === g[0]) g.push(f.shift() + "," + f.shift(), f.shift(), f.shift() + "," + f.shift(), f.shift() + "," + f.shift()); else for (; f.length;) g.push(f.shift() + "," + f.shift());
            d.push(g.join(" "))
        }
        b = {d: d.join(" ")};
        "stroke" === a && this.ev && (b["stroke-dasharray"] = this.Fh.toString(), b["stroke-dashoffset"] = this.Gh);
        om(this, a, b, c);
        "clipPath" === a ? (a = "CLIP" + yb++, c = this.Cb("clipPath", {id: a}), c.appendChild(this.Cb("path", b)), this.svg.appendChild(c),
        0 < this.Gc.length && this.Gc[this.Gc.length - 1].setAttributeNS(null, "clip-path", "url(#" + a + ")")) : this.addElement("path", b)
    };

    function nm(a, b, c, d, e, f, g) {
        var h = new km;
        h.Sa = [b, c, d, e, f, g];
        b = {};
        om(a, "g", b, h);
        h = a.addElement("g", b);
        a.Gc.push(h)
    }

    t.tr = function () {
        if (0 !== this.shadowOffsetX || 0 !== this.shadowOffsetY || 0 !== this.shadowBlur) {
            var a = "SHADOW" + yb++,
                b = this.addElement("filter", {id: a, x: "-100%", y: "-100%", width: "300%", height: "300%"}, null);
            var c = this.Cb("feGaussianBlur", {"in": "SourceAlpha", result: "blur", LB: this.shadowBlur / 2});
            var d = this.Cb("feFlood", {"in": "blur", result: "flood", "flood-color": this.shadowColor});
            var e = this.Cb("feComposite", {"in": "flood", in2: "blur", operator: "in", result: "comp"});
            var f = this.Cb("feOffset", {
                "in": "comp", result: "offsetBlur",
                dx: this.shadowOffsetX, dy: this.shadowOffsetY
            });
            var g = this.Cb("feMerge", {});
            g.appendChild(this.Cb("feMergeNode", {"in": "offsetBlur"}));
            g.appendChild(this.Cb("feMergeNode", {"in": "SourceGraphic"}));
            b.appendChild(c);
            b.appendChild(d);
            b.appendChild(e);
            b.appendChild(f);
            b.appendChild(g);
            0 < this.Gc.length && this.Gc[this.Gc.length - 1].setAttributeNS(null, "filter", "url(#" + a + ")")
        }
    };
    t.Uw = function (a, b, c) {
        this.fq = a;
        this.gq = b;
        this.wf = c
    };

    function Kl(a) {
        a.shadowOffsetX = 0;
        a.shadowOffsetY = 0;
        a.shadowBlur = 0
    }

    function Jl(a) {
        a.shadowOffsetX = a.fq;
        a.shadowOffsetY = a.gq;
        a.shadowBlur = a.wf
    }

    t.Rt = function (a, b) {
        this.ev = !0;
        this.Fh = a;
        this.Gh = b
    };
    t.Pt = function () {
        this.ev = !1
    };
    t.Ac = function () {
    };
    t.hz = function () {
    };
    mm.prototype.rotate = function () {
    };
    mm.prototype.getImageData = function () {
        return null
    };
    mm.prototype.measureText = function () {
        return null
    };
    mm.className = "SVGContext";
    Q.prototype.ku = function (a) {
        var b = new Rj(this, qa.document);
        void 0 === a && (a = new kb);
        var c = this;
        return Pk(this, function (a, e) {
            a = Qk(c, a, "SVG", b);
            a = null !== a ? a.svg : null;
            return "function" === typeof e ? (e(a), null) : a
        }, a)
    };
    Q.prototype.makeSvg = Q.prototype.ku;
    Q.prototype.tw = function (a) {
        return this.ku(a)
    };
    Q.prototype.makeSVG = Q.prototype.tw;
    N.prototype.zy = function (a, b) {
        if (!(a instanceof mm)) return !1;
        if (!this.visible) return !0;
        var c = null, d = a.$q;
        if (this instanceof W && (this.type === W.TableRow || this.type === W.TableColumn)) return Hl(this, a, b), !0;
        var e = this.Db;
        if (0 === e.width || 0 === e.height || isNaN(e.x) || isNaN(e.y)) return !0;
        var f = this.transform, g = this.panel;
        0 !== (this.I & 4096) === !0 && Il(this);
        var h = 0 !== (this.I & 256), k = !1;
        this instanceof kh && (a.font = this.font);
        if (h) {
            k = g.le() ? g.naturalBounds : g.actualBounds;
            if (null !== this.fb) {
                var l = this.fb;
                var m = l.x;
                var n =
                    l.y;
                var p = l.width;
                l = l.height
            } else m = Math.max(e.x, k.x), n = Math.max(e.y, k.y), p = Math.min(e.right, k.right) - m, l = Math.min(e.bottom, k.bottom) - n;
            if (m > e.width + e.x || e.x > k.width + k.x || n > e.height + e.y || e.y > k.height + k.y) return !0;
            k = !0;
            nm(a, 1, 0, 0, 1, 0, 0);
            a.save();
            a.beginPath();
            a.rect(m, n, p, l);
            a.clip()
        }
        if (this.Rf() && !this.isVisible()) return !0;
        a.ge.Sa = [1, 0, 0, 1, 0, 0];
        (this instanceof kh && 1 < this.lineCount || this instanceof Zf && 1 < this.geometry.figures.length) && nm(a, 1, 0, 0, 1, 0, 0);
        m = !1;
        this.Rf() && this.isShadowed && b.Te("drawShadows") &&
        (n = this.shadowOffset, a.Uw(n.x * b.scale * b.Zb, n.y * b.scale * b.Zb, this.shadowBlur), Jl(a), a.shadowColor = this.shadowColor);
        n = !1;
        this.part && b.Te("drawShadows") && (n = this.part.isShadowed);
        !0 === this.shadowVisible ? (Jl(a), !1 === m && n && (nm(a, 1, 0, 0, 1, 0, 0), a.tr(), m = !0)) : !1 === this.shadowVisible && Kl(a);
        p = this.naturalBounds;
        null !== this.areaBackground && (Ai(this, a, this.areaBackground, !0, !0, p, e), !1 === m && n && (nm(a, 1, 0, 0, 1, 0, 0), a.tr(), m = !0), this.areaBackground instanceof Ll && this.areaBackground.type === Ml ? (a.beginPath(), a.rect(e.x,
            e.y, e.width, e.height), a.Se(this.areaBackground)) : a.fillRect(e.x, e.y, e.width, e.height));
        this instanceof W ? nm(a, f.m11, f.m12, f.m21, f.m22, f.dx, f.dy) : a.ge.Sa = [f.m11, f.m12, f.m21, f.m22, f.dx, f.dy];
        if (null !== this.background) {
            !1 === m && n && (nm(a, 1, 0, 0, 1, 0, 0), a.tr(), m = !0);
            var r = this.naturalBounds;
            l = f = 0;
            var q = r.width;
            r = r.height;
            var u = 0;
            this instanceof Zf && (r = this.geometry.bounds, f = r.x, l = r.y, q = r.width, r = r.height, u = this.strokeWidth);
            Ai(this, a, this.background, !0, !1, p, e);
            this.background instanceof Ll && this.background.type ===
            Ml ? (a.beginPath(), a.rect(f - u / 2, l - u / 2, q + u, r + u), a.Se(this.background)) : a.fillRect(f - u / 2, l - u / 2, q + u, r + u)
        }
        n && (null !== this.background || null !== this.areaBackground || null !== g && 0 !== (g.I & 512) || null !== g && (g.type === W.Auto || g.type === W.Spot) && g.wb() !== this) ? (Nl(this, !0), null === this.shadowVisible && Kl(a)) : Nl(this, !1);
        this.oj(a, b);
        n && 0 !== (this.I & 512) === !0 && Jl(a);
        this.Rf() && n && Kl(a);
        h && (a.restore(), k && a.Gc.pop());
        this instanceof W && (c = a.Gc.pop());
        !0 === m && a.Gc.pop();
        if (this instanceof kh && 1 < this.lineCount || this instanceof
            Zf && 1 < this.geometry.figures.length) c = a.Gc.pop();
        null !== a.bl.Mq && (null === c && (d === a.$q ? (nm(a, 1, 0, 0, 1, 0, 0), c = a.Gc.pop()) : c = a.$q), a.bl.Mq(this, c));
        this.svg = c;
        return !0
    };

    function Sk(a, b) {
        this.ownerDocument = b = void 0 === b ? qa.document : b;
        this.Mq = null;
        b = b.createElement("canvas");
        b.tabIndex = 0;
        this.La = b;
        this.La.innerHTML = "This text is displayed if your browser does not support the Canvas HTML element.";
        this.context = new Pl(b);
        b.B = a
    }

    Sk.prototype.resize = function (a, b, c, d) {
        return this.width !== a || this.height !== b ? (this.width = a, this.height = b, this.style.width = c + "px", this.style.height = d + "px", !0) : !1
    };
    Sk.prototype.toDataURL = function (a, b) {
        return this.La.toDataURL(a, b)
    };
    Sk.prototype.getBoundingClientRect = function () {
        return this.La.getBoundingClientRect()
    };
    Sk.prototype.focus = function () {
        this.La.focus()
    };
    Sk.prototype.yy = function () {
        this.ownerDocument = this.La.B = null
    };
    na.Object.defineProperties(Sk.prototype, {
        width: {
            configurable: !0, get: function () {
                return this.La.width
            }, set: function (a) {
                this.La.width = a
            }
        }, height: {
            configurable: !0, get: function () {
                return this.La.height
            }, set: function (a) {
                this.La.height = a
            }
        }, style: {
            configurable: !0, get: function () {
                return this.La.style
            }
        }
    });
    Sk.className = "CanvasSurface";

    function Pl(a) {
        a.getContext && a.getContext("2d") || v("Browser does not support HTML Canvas Element");
        this.aa = a.getContext("2d");
        this.Hu = this.Ju = this.Iu = "";
        this.In = !1;
        this.wf = this.gq = this.fq = 0
    }

    t = Pl.prototype;
    t.hz = function (a) {
        this.aa.imageSmoothingEnabled = a
    };
    t.arc = function (a, b, c, d, e, f) {
        this.aa.arc(a, b, c, d, e, f)
    };
    t.beginPath = function () {
        this.aa.beginPath()
    };
    t.bezierCurveTo = function (a, b, c, d, e, f) {
        this.aa.bezierCurveTo(a, b, c, d, e, f)
    };
    t.clearRect = function (a, b, c, d) {
        this.aa.clearRect(a, b, c, d)
    };
    t.clip = function () {
        this.aa.clip()
    };
    t.closePath = function () {
        this.aa.closePath()
    };
    t.createLinearGradient = function (a, b, c, d) {
        return this.aa.createLinearGradient(a, b, c, d)
    };
    t.createPattern = function (a, b) {
        return this.aa.createPattern(a, b)
    };
    t.createRadialGradient = function (a, b, c, d, e, f) {
        return this.aa.createRadialGradient(a, b, c, d, e, f)
    };
    t.drawImage = function (a, b, c, d, e, f, g, h, k) {
        void 0 === d ? this.aa.drawImage(a, b, c) : this.aa.drawImage(a, b, c, d, e, f, g, h, k)
    };
    t.fill = function () {
        this.aa.fill()
    };
    t.fillRect = function (a, b, c, d) {
        this.aa.fillRect(a, b, c, d)
    };
    t.fillText = function (a, b, c) {
        this.aa.fillText(a, b, c)
    };
    t.getImageData = function (a, b, c, d) {
        return this.aa.getImageData(a, b, c, d)
    };
    t.lineTo = function (a, b) {
        this.aa.lineTo(a, b)
    };
    t.measureText = function (a) {
        return this.aa.measureText(a)
    };
    t.moveTo = function (a, b) {
        this.aa.moveTo(a, b)
    };
    t.quadraticCurveTo = function (a, b, c, d) {
        this.aa.quadraticCurveTo(a, b, c, d)
    };
    t.rect = function (a, b, c, d) {
        this.aa.rect(a, b, c, d)
    };
    t.restore = function () {
        this.aa.restore()
    };
    Pl.prototype.rotate = function (a) {
        this.aa.rotate(a)
    };
    t = Pl.prototype;
    t.save = function () {
        this.aa.save()
    };
    t.setTransform = function (a, b, c, d, e, f) {
        this.aa.setTransform(a, b, c, d, e, f)
    };
    t.scale = function (a, b) {
        this.aa.scale(a, b)
    };
    t.stroke = function () {
        this.aa.stroke()
    };
    t.transform = function (a, b, c, d, e, f) {
        1 === a && 0 === b && 0 === c && 1 === d && 0 === e && 0 === f || this.aa.transform(a, b, c, d, e, f)
    };
    t.translate = function (a, b) {
        this.aa.translate(a, b)
    };
    t.Se = function (a) {
        if (a instanceof Ll && a.type === Ml) {
            var b = a.ql;
            a = a.Ku;
            a > b ? (this.scale(b / a, 1), this.translate((a - b) / 2, 0)) : b > a && (this.scale(1, a / b), this.translate(0, (b - a) / 2));
            this.In ? this.clip() : this.fill();
            a > b ? (this.translate(-(a - b) / 2, 0), this.scale(1 / (b / a), 1)) : b > a && (this.translate(0, -(b - a) / 2), this.scale(1, 1 / (a / b)))
        } else this.In ? this.clip() : this.fill()
    };
    t.Gj = function () {
        this.In || this.stroke()
    };
    t.Uw = function (a, b, c) {
        this.fq = a;
        this.gq = b;
        this.wf = c
    };
    t.Rt = function (a, b) {
        var c = this.aa;
        void 0 !== c.setLineDash && (c.setLineDash(a), c.lineDashOffset = b)
    };
    t.Pt = function () {
        var a = this.aa;
        void 0 !== a.setLineDash && (a.setLineDash(qm), a.lineDashOffset = 0)
    };
    t.Ac = function (a) {
        a && (this.Iu = "");
        this.Hu = this.Ju = ""
    };
    na.Object.defineProperties(Pl.prototype, {
        fillStyle: {
            configurable: !0, get: function () {
                return this.aa.fillStyle
            }, set: function (a) {
                this.Hu !== a && (this.Hu = this.aa.fillStyle = a)
            }
        }, font: {
            configurable: !0, get: function () {
                return this.aa.font
            }, set: function (a) {
                this.Iu !== a && (this.Iu = this.aa.font = a)
            }
        }, globalAlpha: {
            configurable: !0, get: function () {
                return this.aa.globalAlpha
            }, set: function (a) {
                this.aa.globalAlpha = a
            }
        }, lineCap: {
            configurable: !0, get: function () {
                return this.aa.lineCap
            },
            set: function (a) {
                this.aa.lineCap = a
            }
        }, lineDashOffset: {
            configurable: !0, get: function () {
                return this.aa.lineDashOffset
            }, set: function (a) {
                this.aa.lineDashOffset = a
            }
        }, lineJoin: {
            configurable: !0, get: function () {
                return this.aa.lineJoin
            }, set: function (a) {
                this.aa.lineJoin = a
            }
        }, lineWidth: {
            configurable: !0, get: function () {
                return this.aa.lineWidth
            }, set: function (a) {
                this.aa.lineWidth = a
            }
        }, miterLimit: {
            configurable: !0, get: function () {
                return this.aa.miterLimit
            }, set: function (a) {
                this.aa.miterLimit =
                    a
            }
        }, shadowBlur: {
            configurable: !0, get: function () {
                return this.aa.shadowBlur
            }, set: function (a) {
                this.aa.shadowBlur = a
            }
        }, shadowColor: {
            configurable: !0, get: function () {
                return this.aa.shadowColor
            }, set: function (a) {
                this.aa.shadowColor = a
            }
        }, shadowOffsetX: {
            configurable: !0, get: function () {
                return this.aa.shadowOffsetX
            }, set: function (a) {
                this.aa.shadowOffsetX = a
            }
        }, shadowOffsetY: {
            configurable: !0, get: function () {
                return this.aa.shadowOffsetY
            }, set: function (a) {
                this.aa.shadowOffsetY =
                    a
            }
        }, strokeStyle: {
            configurable: !0, get: function () {
                return this.aa.strokeStyle
            }, set: function (a) {
                this.Ju !== a && (this.Ju = this.aa.strokeStyle = a)
            }
        }, textAlign: {
            configurable: !0, get: function () {
                return this.aa.textAlign
            }, set: function (a) {
                this.aa.textAlign = a
            }
        }, imageSmoothingEnabled: {
            configurable: !0, get: function () {
                return this.aa.imageSmoothingEnabled
            }, set: function (a) {
                this.aa.imageSmoothingEnabled = a
            }
        }, clipInsteadOfFill: {
            configurable: !0, get: function () {
                return this.In
            },
            set: function (a) {
                this.In = a
            }
        }
    });
    var qm = Object.freeze([]);
    Pl.className = "CanvasSurfaceContext";

    function rm() {
        this.W = this.w = this.L = this.l = 0
    }

    rm.className = "ColorNumbers";

    function Ll(a) {
        F && 1 < arguments.length && v("Brush constructor can take at most one optional argument, the Brush type.");
        sm || (tm(), sm = !0);
        gb(this);
        this.s = !1;
        void 0 === a ? (this.sa = Ol, this.pl = "black") : "string" === typeof a ? (this.sa = Ol, F && !um(a) && v('Color "' + a + '" is not a valid color string for Brush constructor'), this.pl = a) : (F && ib(a, Ll, Ll, "constructor:type"), this.sa = a, this.pl = "black");
        var b = this.sa;
        b === Rl ? (this.Fd = Gc, this.Cl = Pc) : this.Cl = b === Ml ? this.Fd = Mc : this.Fd = Ec;
        this.ut = 0;
        this.ks = NaN;
        this.qe = this.Xs = this.pe =
            null;
        this.Ku = this.ql = 0
    }

    Ll.prototype.copy = function () {
        var a = new Ll;
        a.sa = this.sa;
        a.pl = this.pl;
        a.Fd = this.Fd.J();
        a.Cl = this.Cl.J();
        a.ut = this.ut;
        a.ks = this.ks;
        null !== this.pe && (a.pe = this.pe.copy());
        a.Xs = this.Xs;
        return a
    };
    t = Ll.prototype;
    t.freeze = function () {
        this.s = !0;
        null !== this.pe && this.pe.freeze();
        return this
    };
    t.ka = function () {
        Object.isFrozen(this) && v("cannot thaw constant: " + this);
        this.s = !1;
        null !== this.pe && this.pe.ka();
        return this
    };
    t.pb = function (a) {
        a.classType === Ll ? this.type = a : Da(this, a)
    };
    t.toString = function () {
        var a = "Brush(";
        if (this.type === Ol) a += this.color; else if (a = this.type === Rl ? a + "Linear " : this.type === Ml ? a + "Radial " : this.type === Ql ? a + "Pattern " : a + "(unknown) ", a += this.start + " " + this.end, null !== this.colorStops) for (var b = this.colorStops.iterator; b.next();) a += " " + b.key + ":" + b.value;
        return a + ")"
    };
    t.addColorStop = function (a, b) {
        this.s && va(this);
        ("number" !== typeof a || !isFinite(a) || 1 < a || 0 > a) && za(a, "0 <= loc <= 1", Ll, "addColorStop:loc");
        A(b, "string", Ll, "addColorStop:color");
        F && !um(b) && v('Color "' + b + '" is not a valid color string for Brush.addColorStop');
        null === this.pe && (this.pe = new Db);
        this.pe.add(a, b);
        this.sa === Ol && (this.type = Rl);
        this.qe = null;
        return this
    };

    function um(a) {
        if ("black" === a) return !0;
        if ("" === a) return !1;
        F && A(a, "string", Ll, "isValidColor");
        sm || (tm(), sm = !0);
        var b = vm;
        if (null === b) return !0;
        b.fillStyle = "#000000";
        var c = b.fillStyle;
        b.fillStyle = a;
        if (b.fillStyle !== c) return !0;
        b.fillStyle = "#FFFFFF";
        c = b.fillStyle;
        b.fillStyle = a;
        return b.fillStyle !== c
    }

    t.XA = function (a, b) {
        this.s && va(this);
        a = void 0 === a || "number" !== typeof a ? .2 : a;
        b = void 0 === b ? wm : b;
        if (this.type === Ol) ii(this.color), this.color = xm(a, b); else if ((this.type === Rl || this.type === Ml) && null !== this.colorStops) for (var c = this.colorStops.iterator; c.next();) ii(c.value), this.addColorStop(c.key, xm(a, b));
        return this
    };

    function ym(a, b, c) {
        b = void 0 === b || "number" !== typeof b ? .2 : b;
        c = void 0 === c ? wm : c;
        ii(a);
        return xm(b, c)
    }

    t.Xz = function (a, b) {
        this.s && va(this);
        a = void 0 === a || "number" !== typeof a ? .2 : a;
        b = void 0 === b ? wm : b;
        if (this.type === Ol) ii(this.color), this.color = xm(-a, b); else if ((this.type === Rl || this.type === Ml) && null !== this.colorStops) for (var c = this.colorStops.iterator; c.next();) ii(c.value), this.addColorStop(c.key, xm(-a, b));
        return this
    };

    function zm(a, b, c) {
        b = void 0 === b || "number" !== typeof b ? .2 : b;
        c = void 0 === c ? wm : c;
        ii(a);
        return xm(-b, c)
    }

    function Am(a, b, c) {
        ii(a);
        a = Bm.l;
        var d = Bm.L, e = Bm.w, f = Bm.W;
        ii(b);
        void 0 === c && (c = .5);
        return "rgba(" + Math.round((Bm.l - a) * c + a) + ", " + Math.round((Bm.L - d) * c + d) + ", " + Math.round((Bm.w - e) * c + e) + ", " + Math.round((Bm.W - f) * c + f) + ")"
    }

    t.Vy = function () {
        if (this.type === Ol) return Cm(this.color);
        if ((this.type === Rl || this.type === Ml) && null !== this.colorStops) {
            var a = this.colorStops;
            if (this.type === Ml) return Cm(a.first().value);
            if (null !== a.get(.5)) return Cm(a.get(.5));
            if (2 === a.count) return a = a.ta(), Cm(Am(a[0].value, a[1].value));
            for (var b = a.iterator, c = -1, d = -1, e = 1, f = 1; b.next();) {
                var g = b.key, h = Math.abs(.5 - b.key);
                e > f && h < e ? (c = g, e = h) : f >= e && h < f && (d = g, f = h)
            }
            c > d && (f = c, c = d, d = f, f = e);
            e = d - c;
            return Cm(Am(a.get(c), a.get(d), 1 - f / e))
        }
        return !1
    };

    function Cm(a) {
        if (!a) return !1;
        if (a instanceof Ll) return a.Vy();
        ii(a);
        return 128 > (299 * Bm.l + 587 * Bm.L + 114 * Bm.w) / 1E3
    }

    function xm(a, b) {
        switch (b) {
            case wm:
                b = 100 * Dm(Bm.l);
                var c = 100 * Dm(Bm.L), d = 100 * Dm(Bm.w);
                Em.l = .4124564 * b + .3575761 * c + .1804375 * d;
                Em.L = .2126729 * b + .7151522 * c + .072175 * d;
                Em.w = .0193339 * b + .119192 * c + .9503041 * d;
                Em.W = Bm.W;
                b = Fm(Em.l / Gm[0]);
                c = Fm(Em.L / Gm[1]);
                d = Fm(Em.w / Gm[2]);
                Hm.l = 116 * c - 16;
                Hm.L = 500 * (b - c);
                Hm.w = 200 * (c - d);
                Hm.W = Em.W;
                Hm.l = Math.min(100, Math.max(0, Hm.l + 100 * a));
                a = (Hm.l + 16) / 116;
                b = a - Hm.w / 200;
                Em.l = Gm[0] * Im(Hm.L / 500 + a);
                Em.L = Gm[1] * (Hm.l > Jm * Km ? Math.pow(a, 3) : Hm.l / Jm);
                Em.w = Gm[2] * Im(b);
                Em.W = Hm.W;
                a = -.969266 * Em.l + 1.8760108 *
                    Em.L + .041556 * Em.w;
                b = .0556434 * Em.l + -.2040259 * Em.L + 1.0572252 * Em.w;
                Bm.l = 255 * Lm((3.2404542 * Em.l + -1.5371385 * Em.L + -.4985314 * Em.w) / 100);
                Bm.L = 255 * Lm(a / 100);
                Bm.w = 255 * Lm(b / 100);
                Bm.W = Em.W;
                Bm.l = Math.round(Bm.l);
                255 < Bm.l ? Bm.l = 255 : 0 > Bm.l && (Bm.l = 0);
                Bm.L = Math.round(Bm.L);
                255 < Bm.L ? Bm.L = 255 : 0 > Bm.L && (Bm.L = 0);
                Bm.w = Math.round(Bm.w);
                255 < Bm.w ? Bm.w = 255 : 0 > Bm.w && (Bm.w = 0);
                return "rgba(" + Bm.l + ", " + Bm.L + ", " + Bm.w + ", " + Bm.W + ")";
            case Mm:
                return ji(), ki.w = Math.min(100, Math.max(0, ki.w + 100 * a)), "hsla(" + ki.l + ", " + ki.L + "%, " + ki.w + "%, " +
                ki.W + ")";
            default:
                return v("Unknown color space: " + b), "rgba(0, 0, 0, 1)"
        }
    }

    function ii(a) {
        sm || (tm(), sm = !0);
        var b = vm;
        if (null !== b) {
            b.clearRect(0, 0, 1, 1);
            b.fillStyle = "#000000";
            var c = b.fillStyle;
            b.fillStyle = a;
            b.fillStyle !== c ? (b.fillRect(0, 0, 1, 1), a = b.getImageData(0, 0, 1, 1).data, Bm.l = a[0], Bm.L = a[1], Bm.w = a[2], Bm.W = a[3] / 255) : (b.fillStyle = "#FFFFFF", c = b.fillStyle, b.fillStyle = a, b.fillStyle === c && F && v('Color "' + a + '" is not a valid color string for RGBA color conversion'), Bm.l = 0, Bm.L = 0, Bm.w = 0, Bm.W = 1)
        }
    }

    function ji() {
        var a = Bm.l / 255, b = Bm.L / 255, c = Bm.w / 255, d = Math.max(a, b, c), e = Math.min(a, b, c), f = d - e;
        e = (d + e) / 2;
        if (0 === f) var g = a = 0; else {
            switch (d) {
                case a:
                    g = (b - c) / f % 6;
                    break;
                case b:
                    g = (c - a) / f + 2;
                    break;
                case c:
                    g = (a - b) / f + 4
            }
            g *= 60;
            0 > g && (g += 360);
            a = f / (1 - Math.abs(2 * e - 1))
        }
        ki.l = Math.round(g);
        ki.L = Math.round(100 * a);
        ki.w = Math.round(100 * e);
        ki.W = Bm.W
    }

    function Dm(a) {
        a /= 255;
        return .04045 >= a ? a / 12.92 : Math.pow((a + .055) / 1.055, 2.4)
    }

    function Lm(a) {
        return .0031308 >= a ? 12.92 * a : 1.055 * Math.pow(a, 1 / 2.4) - .055
    }

    function Fm(a) {
        return a > Km ? Math.pow(a, 1 / 3) : (Jm * a + 16) / 116
    }

    function Im(a) {
        var b = a * a * a;
        return b > Km ? b : (116 * a - 16) / Jm
    }

    function hm(a, b) {
        "string" === typeof a ? F && !um(a) && v('Color "' + a + '" is not a valid color string for ' + b) : a instanceof Ll || v("Value for " + b + " must be a color string or a Brush, not " + a)
    }

    function tm() {
        vm = ih ? (new Sk(null)).context : null
    }

    na.Object.defineProperties(Ll.prototype, {
        type: {
            configurable: !0, get: function () {
                return this.sa
            }, set: function (a) {
                this.s && va(this, a);
                ib(a, Ll, Ll, "type");
                this.sa = a;
                this.start.Tb() && (a === Rl ? this.start = Gc : a === Ml && (this.start = Mc));
                this.end.Tb() && (a === Rl ? this.end = Pc : a === Ml && (this.end = Mc));
                this.qe = null
            }
        }, color: {
            configurable: !0, get: function () {
                return this.pl
            }, set: function (a) {
                this.s && va(this, a);
                F && !um(a) && v('Color "' + a + '" is not a valid color string for Brush.color');
                this.pl = a;
                this.qe =
                    null
            }
        }, start: {
            configurable: !0, get: function () {
                return this.Fd
            }, set: function (a) {
                this.s && va(this, a);
                w(a, M, Ll, "start");
                this.Fd = a.J();
                this.qe = null
            }
        }, end: {
            configurable: !0, get: function () {
                return this.Cl
            }, set: function (a) {
                this.s && va(this, a);
                w(a, M, Ll, "end");
                this.Cl = a.J();
                this.qe = null
            }
        }, startRadius: {
            configurable: !0, get: function () {
                return this.ut
            }, set: function (a) {
                this.s && va(this, a);
                C(a, Ll, "startRadius");
                0 > a && za(a, ">= zero", Ll, "startRadius");
                this.ut = a;
                this.qe = null
            }
        }, endRadius: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.ks
            }, set: function (a) {
                this.s && va(this, a);
                C(a, Ll, "endRadius");
                0 > a && za(a, ">= zero", Ll, "endRadius");
                this.ks = a;
                this.qe = null
            }
        }, colorStops: {
            configurable: !0, get: function () {
                return this.pe
            }, set: function (a) {
                this.s && va(this, a);
                F && w(a, Db, Ll, "colorStops");
                this.pe = a;
                this.qe = null
            }
        }, pattern: {
            configurable: !0, get: function () {
                return this.Xs
            }, set: function (a) {
                this.s && va(this, a);
                this.Xs = a;
                this.qe = null
            }
        }
    });
    Ll.prototype.isDark = Ll.prototype.Vy;
    Ll.prototype.darkenBy = Ll.prototype.Xz;
    Ll.prototype.lightenBy = Ll.prototype.XA;
    Ll.prototype.addColorStop = Ll.prototype.addColorStop;
    var Km = 216 / 24389, Jm = 24389 / 27, Gm = [95.047, 100, 108.883], vm = null, Bm = new rm, ki = new rm,
        Em = new rm, Hm = new rm, sm = !1;
    Ll.className = "Brush";
    var Ol;
    Ll.Solid = Ol = new E(Ll, "Solid", 0);
    var Rl;
    Ll.Linear = Rl = new E(Ll, "Linear", 1);
    var Ml;
    Ll.Radial = Ml = new E(Ll, "Radial", 2);
    var Ql;
    Ll.Pattern = Ql = new E(Ll, "Pattern", 4);
    var wm;
    Ll.Lab = wm = new E(Ll, "Lab", 5);
    var Mm;
    Ll.HSL = Mm = new E(Ll, "HSL", 6);
    Ll.randomColor = function (a, b) {
        void 0 === a && (a = 128);
        F && (C(a, Ll, "randomColor:min"), (0 > a || 255 < a) && za(a, "0 <= min <= 255", Ll, "randomColor:min"));
        void 0 === b && (b = Math.max(a, 255));
        F && (C(b, Ll, "randomColor:max"), (b < a || 255 < b) && za(b, "min <= max <= 255", Ll, "randomColor:max"));
        var c = Math.abs(b - a);
        b = Math.floor(a + Math.random() * c).toString(16);
        var d = Math.floor(a + Math.random() * c).toString(16);
        a = Math.floor(a + Math.random() * c).toString(16);
        2 > b.length && (b = "0" + b);
        2 > d.length && (d = "0" + d);
        2 > a.length && (a = "0" + a);
        return "#" + b + d +
            a
    };
    Ll.isValidColor = um;
    Ll.lighten = function (a) {
        return ym(a)
    };
    Ll.lightenBy = ym;
    Ll.darken = function (a) {
        return zm(a)
    };
    Ll.darkenBy = zm;
    Ll.mix = Am;
    Ll.isDark = Cm;

    function em() {
        this.name = "Base"
    }

    em.prototype.measure = function () {
    };
    em.prototype.$A = function (a, b, c, d, e) {
        a.measure(b, c, d, e)
    };
    em.prototype.arrange = function () {
    };
    em.prototype.Kz = function (a, b, c, d, e, f) {
        a.arrange(b, c, d, e, f)
    };
    em.prototype.ic = function () {
    };
    na.Object.defineProperties(em.prototype, {
        classType: {
            configurable: !0, get: function () {
                return W
            }
        }
    });
    em.prototype.arrangeElement = em.prototype.Kz;
    em.prototype.measureElement = em.prototype.$A;
    em.className = "PanelLayout";

    function Nm() {
        this.name = "Base"
    }

    ma(Nm, em);
    Nm.prototype.measure = function (a, b, c, d, e, f, g) {
        var h = d.length;
        a = Om(a);
        for (var k = 0; k < h; k++) {
            var l = d[k];
            if (l.visible || l === a) {
                var m = l.margin, n = m.right + m.left;
                m = m.top + m.bottom;
                l.measure(b, c, f, g);
                var p = l.measuredBounds;
                n = Math.max(p.width + n, 0);
                m = Math.max(p.height + m, 0);
                p = l.position.x;
                var r = l.position.y;
                isFinite(p) || (p = 0);
                isFinite(r) || (r = 0);
                l instanceof Zf && l.isGeometryPositioned && (l = l.strokeWidth / 2, p -= l, r -= l);
                oc(e, p, r, n, m)
            }
        }
    };
    Nm.prototype.arrange = function (a, b, c) {
        var d = b.length, e = a.padding;
        a = c.x - e.left;
        c = c.y - e.top;
        for (e = 0; e < d; e++) {
            var f = b[e], g = f.measuredBounds, h = f.margin, k = f.position.x, l = f.position.y;
            k = isNaN(k) ? -a : k - a;
            l = isNaN(l) ? -c : l - c;
            if (f instanceof Zf && f.isGeometryPositioned) {
                var m = f.strokeWidth / 2;
                k -= m;
                l -= m
            }
            f.visible && f.arrange(k + h.left, l + h.top, g.width, g.height)
        }
    };

    function Pm() {
        this.name = "Base"
    }

    ma(Pm, em);
    Pm.prototype.measure = function (a, b, c, d, e, f, g) {
        var h = d.length;
        b = Ma();
        f = Om(a);
        for (var k = 0; k < h; k++) {
            var l = d[k];
            if (l.visible || l === f) {
                var m = Cl(l, !1);
                if (m !== Og && m !== nl) b.push(l); else {
                    l.measure(Infinity, c, 0, g);
                    m = l.margin;
                    l = l.measuredBounds;
                    var n = Math.max(l.height + m.top + m.bottom, 0);
                    e.width += Math.max(l.width + m.right + m.left, 0);
                    e.height = Math.max(e.height, n)
                }
            }
        }
        d = b.length;
        a.desiredSize.height ? c = Math.min(a.desiredSize.height, a.maxSize.height) : 0 !== e.height && (c = Math.min(e.height, a.maxSize.height));
        for (a = 0; a < d; a++) if (k =
            b[a], k.visible || k === f) m = k.margin, h = m.right + m.left, m = m.top + m.bottom, k.measure(Infinity, c, 0, g), k = k.measuredBounds, m = Math.max(k.height + m, 0), e.width += Math.max(k.width + h, 0), e.height = Math.max(e.height, m);
        Oa(b)
    };
    Pm.prototype.arrange = function (a, b, c) {
        for (var d = b.length, e = a.padding, f = e.top, g = a.isOpposite, h = g ? c.width : e.left, k = 0; k < d; k++) {
            var l = f, m = b[k];
            if (m.visible) {
                var n = m.measuredBounds, p = m.margin, r = p.top + p.bottom, q = f + e.bottom, u = n.height,
                    x = Cl(m, !1);
                if (isNaN(m.desiredSize.height) && x === Jd || x === ol) u = Math.max(c.height - r - q, 0);
                r = u + r + q;
                q = m.alignment;
                q.Jb() && (q = a.defaultAlignment);
                q.cb() || (q = Mc);
                g && (h -= n.width + p.left + p.right);
                m.arrange(h + q.offsetX + p.left, l + q.offsetY + p.top + (c.height * q.y - r * q.y), n.width, u);
                g || (h += n.width +
                    p.left + p.right)
            }
        }
    };

    function Qm() {
        this.name = "Base"
    }

    ma(Qm, em);
    Qm.prototype.measure = function (a, b, c, d, e, f) {
        var g = d.length;
        c = Ma();
        for (var h = Om(a), k = 0; k < g; k++) {
            var l = d[k];
            if (l.visible || l === h) {
                var m = Cl(l, !1);
                if (m !== Og && m !== ol) c.push(l); else {
                    var n = l.margin;
                    m = n.right + n.left;
                    n = n.top + n.bottom;
                    l.measure(b, Infinity, f, 0);
                    l = l.measuredBounds;
                    ec(e, Math.max(e.width, Math.max(l.width + m, 0)), e.height + Math.max(l.height + n, 0))
                }
            }
        }
        d = c.length;
        if (0 !== d) {
            a.desiredSize.width ? b = Math.min(a.desiredSize.width, a.maxSize.width) : 0 !== e.width && (b = Math.min(e.width, a.maxSize.width));
            for (a = 0; a < d; a++) if (k =
                c[a], k.visible || k === h) l = k.margin, g = l.right + l.left, l = l.top + l.bottom, k.measure(b, Infinity, f, 0), k = k.measuredBounds, l = Math.max(k.height + l, 0), e.width = Math.max(e.width, Math.max(k.width + g, 0)), e.height += l;
            Oa(c)
        }
    };
    Qm.prototype.arrange = function (a, b, c) {
        for (var d = b.length, e = a.padding, f = e.left, g = a.isOpposite, h = g ? c.height : e.top, k = 0; k < d; k++) {
            var l = f, m = b[k];
            if (m.visible) {
                var n = m.measuredBounds, p = m.margin, r = p.left + p.right, q = f + e.right, u = n.width,
                    x = Cl(m, !1);
                if (isNaN(m.desiredSize.width) && x === Jd || x === nl) u = Math.max(c.width - r - q, 0);
                r = u + r + q;
                q = m.alignment;
                q.Jb() && (q = a.defaultAlignment);
                q.cb() || (q = Mc);
                g && (h -= n.height + p.bottom + p.top);
                m.arrange(l + q.offsetX + p.left + (c.width * q.x - r * q.x), h + q.offsetY + p.top, u, n.height);
                g || (h += n.height +
                    p.bottom + p.top)
            }
        }
    };

    function Rm() {
        this.name = "Base"
    }

    ma(Rm, em);
    Rm.prototype.measure = function (a, b, c, d, e, f, g) {
        var h = d.length, k = a.wb(), l = k.margin, m = l.right + l.left, n = l.top + l.bottom;
        k.measure(b, c, f, g);
        var p = k.measuredBounds;
        f = p.width;
        g = p.height;
        var r = Math.max(f + m, 0);
        var q = Math.max(g + n, 0);
        for (var u = a.isClipping, x = L.allocAt(-l.left, -l.top, r, q), y = !0, z = Om(a), B = 0; B < h; B++) {
            var D = d[B];
            if (D !== k && (D.visible || D === z)) {
                l = D.margin;
                r = l.right + l.left;
                q = l.top + l.bottom;
                p = Cl(D, !1);
                switch (p) {
                    case Jd:
                        b = f;
                        c = g;
                        break;
                    case nl:
                        b = f;
                        break;
                    case ol:
                        c = g
                }
                D.measure(b, c, 0, 0);
                p = D.measuredBounds;
                r =
                    Math.max(p.width + r, 0);
                q = Math.max(p.height + q, 0);
                var G = D.alignment;
                G.Jb() && (G = a.defaultAlignment);
                G.cb() || (G = Mc);
                var O = D.alignmentFocus;
                O.Jb() && (O = Mc);
                var U = null;
                D instanceof W && "" !== D.Yg && (D.arrange(0, 0, p.width, p.height), U = D.hb(D.Yg), U === D && (U = null));
                if (null !== U) {
                    l = U.naturalBounds;
                    p = U.margin;
                    for (l = J.allocAt(O.x * l.width - O.offsetX - p.left, O.y * l.height - O.offsetY - p.top); U !== D;) U.transform.ya(l), U = U.panel;
                    D = G.x * f + G.offsetX - l.x;
                    p = G.y * g + G.offsetY - l.y;
                    J.free(l)
                } else D = G.x * f + G.offsetX - (O.x * p.width + O.offsetX) -
                    l.left, p = G.y * g + G.offsetY - (O.y * p.height + O.offsetY) - l.top;
                y ? (y = !1, e.h(D, p, r, q)) : oc(e, D, p, r, q)
            }
        }
        y ? e.assign(x) : u ? e.nw(x.x, x.y, x.width, x.height) : oc(e, x.x, x.y, x.width, x.height);
        L.free(x);
        p = k.stretch;
        p === ml && (p = Cl(k, !1));
        switch (p) {
            case Og:
                return;
            case Jd:
                if (!isFinite(b) && !isFinite(c)) return;
                break;
            case nl:
                if (!isFinite(b)) return;
                break;
            case ol:
                if (!isFinite(c)) return
        }
        p = k.measuredBounds;
        f = p.width;
        g = p.height;
        r = Math.max(f + m, 0);
        q = Math.max(g + n, 0);
        l = k.margin;
        x = L.allocAt(-l.left, -l.top, r, q);
        for (b = 0; b < h; b++) c = d[b], c ===
        k || !c.visible && c !== z || (l = c.margin, r = l.right + l.left, q = l.top + l.bottom, p = c.measuredBounds, r = Math.max(p.width + r, 0), q = Math.max(p.height + q, 0), m = c.alignment, m.Jb() && (m = a.defaultAlignment), m.cb() || (m = Mc), c = c.alignmentFocus, c.Jb() && (c = Mc), y ? (y = !1, e.h(m.x * f + m.offsetX - (c.x * p.width + c.offsetX) - l.left, m.y * g + m.offsetY - (c.y * p.height + c.offsetY) - l.top, r, q)) : oc(e, m.x * f + m.offsetX - (c.x * p.width + c.offsetX) - l.left, m.y * g + m.offsetY - (c.y * p.height + c.offsetY) - l.top, r, q));
        y ? e.assign(x) : u ? e.nw(x.x, x.y, x.width, x.height) : oc(e, x.x,
            x.y, x.width, x.height);
        L.free(x)
    };
    Rm.prototype.arrange = function (a, b, c) {
        var d = b.length, e = a.wb(), f = e.measuredBounds, g = f.width;
        f = f.height;
        var h = a.padding, k = h.left;
        h = h.top;
        var l = k - c.x, m = h - c.y;
        e.arrange(l, m, g, f);
        for (var n = 0; n < d; n++) {
            var p = b[n];
            if (p !== e) {
                var r = p.measuredBounds, q = r.width;
                r = r.height;
                m = p.alignment;
                m.Jb() && (m = a.defaultAlignment);
                m.cb() || (m = Mc);
                var u = p.alignmentFocus;
                u.Jb() && (u = Mc);
                l = null;
                p instanceof W && "" !== p.Yg && (l = p.hb(p.Yg), l === p && (l = null));
                if (null !== l) {
                    var x = l.naturalBounds;
                    for (u = J.allocAt(u.x * x.width - u.offsetX, u.y * x.height -
                        u.offsetY); l !== p;) l.transform.ya(u), l = l.panel;
                    l = m.x * g + m.offsetX - u.x;
                    m = m.y * f + m.offsetY - u.y;
                    J.free(u)
                } else l = m.x * g + m.offsetX - (u.x * q + u.offsetX), m = m.y * f + m.offsetY - (u.y * r + u.offsetY);
                l -= c.x;
                m -= c.y;
                p.visible && p.arrange(k + l, h + m, q, r)
            }
        }
    };

    function Sm() {
        this.name = "Base"
    }

    ma(Sm, em);
    Sm.prototype.measure = function (a, b, c, d, e, f, g) {
        var h = d.length, k = a.wb(), l = k.margin, m = b, n = c, p = l.right + l.left, r = l.top + l.bottom;
        k.measure(b, c, f, g);
        l = k.measuredBounds;
        var q = 0, u = null;
        k instanceof Zf && (u = k, q = u.strokeWidth * u.scale);
        var x = Math.max(l.width + p, 0);
        l = Math.max(l.height + r, 0);
        var y = Tm(k), z = y.x * x + y.offsetX;
        y = y.y * l + y.offsetY;
        var B = Um(k), D = B.x * x + B.offsetX;
        B = B.y * l + B.offsetY;
        isFinite(b) && (m = Math.max(Math.abs(z - D) - q, 0));
        isFinite(c) && (n = Math.max(Math.abs(y - B) - q, 0));
        q = Hb.alloc();
        q.h(0, 0);
        a = Om(a);
        for (B = 0; B <
        h; B++) y = d[B], y === k || !y.visible && y !== a || (l = y.margin, x = l.right + l.left, z = l.top + l.bottom, y.measure(m, n, 0, 0), l = y.measuredBounds, x = Math.max(l.width + x, 0), l = Math.max(l.height + z, 0), q.h(Math.max(x, q.width), Math.max(l, q.height)));
        if (1 === h) e.width = x, e.height = l, Hb.free(q); else {
            y = Tm(k);
            B = Um(k);
            h = d = 0;
            B.x !== y.x && B.y !== y.y && (d = q.width / Math.abs(B.x - y.x), h = q.height / Math.abs(B.y - y.y));
            Hb.free(q);
            q = 0;
            null !== u && (q = u.strokeWidth * u.scale, Pg(u) === Qg && (d = h = Math.max(d, h)));
            d += Math.abs(y.offsetX) + Math.abs(B.offsetX) + q;
            h += Math.abs(y.offsetY) +
                Math.abs(B.offsetY) + q;
            u = k.stretch;
            u === ml && (u = Cl(k, !1));
            switch (u) {
                case Og:
                    g = f = 0;
                    break;
                case Jd:
                    isFinite(b) && (d = b);
                    isFinite(c) && (h = c);
                    break;
                case nl:
                    isFinite(b) && (d = b);
                    g = 0;
                    break;
                case ol:
                    f = 0, isFinite(c) && (h = c)
            }
            k.Pm();
            k.measure(d, h, f, g);
            e.width = k.measuredBounds.width + p;
            e.height = k.measuredBounds.height + r
        }
    };
    Sm.prototype.arrange = function (a, b) {
        var c = b.length, d = a.wb(), e = d.measuredBounds, f = L.alloc();
        f.h(0, 0, 1, 1);
        var g = d.margin, h = g.left;
        g = g.top;
        var k = a.padding, l = k.left;
        k = k.top;
        d.arrange(l + h, k + g, e.width, e.height);
        var m = Tm(d), n = Um(d), p = m.y * e.height + m.offsetY, r = n.x * e.width + n.offsetX;
        n = n.y * e.height + n.offsetY;
        f.x = m.x * e.width + m.offsetX;
        f.y = p;
        oc(f, r, n, 0, 0);
        f.x += h + l;
        f.y += g + k;
        for (e = 0; e < c; e++) h = b[e], h !== d && (l = h.measuredBounds, g = h.margin, k = Math.max(l.width + g.right + g.left, 0), m = Math.max(l.height + g.top + g.bottom, 0), p = h.alignment,
        p.Jb() && (p = a.defaultAlignment), p.cb() || (p = Mc), k = f.width * p.x + p.offsetX - k * p.x + g.left + f.x, g = f.height * p.y + p.offsetY - m * p.y + g.top + f.y, h.visible && (pc(f.x, f.y, f.width, f.height, k, g, l.width, l.height) ? h.arrange(k, g, l.width, l.height) : h.arrange(k, g, l.width, l.height, new L(f.x, f.y, f.width, f.height))));
        L.free(f)
    };

    function Vm() {
        this.name = "Base";
        this.name = "Table"
    }

    ma(Vm, em);
    Vm.prototype.measure = function (a, b, c, d, e) {
        for (var f = d.length, g = Ma(), h = Ma(), k = 0; k < f; k++) {
            var l = d[k], m = l instanceof W ? l : null;
            if (null === m || m.type !== W.TableRow && m.type !== W.TableColumn || !l.visible) g.push(l); else {
                F && (m.desiredSize.o() && v(m.toString() + " TableRow/TableColumn Panels cannot set a desiredSize: " + m.desiredSize.toString()), m.minSize.A(Tb) || v(m.toString() + " TableRow/TableColumn Panels cannot set a minSize: " + m.minSize.toString()), m.maxSize.A($b) || v(m.toString() + " TableRow/TableColumn Panels cannot set a maxSize: " +
                    m.maxSize.toString()));
                h.push(m);
                for (var n = m.$.j, p = n.length, r = 0; r < p; r++) {
                    var q = n[r];
                    m.type === W.TableRow ? q.row = l.row : m.type === W.TableColumn && (q.column = l.column);
                    g.push(q)
                }
            }
        }
        f = g.length;
        0 === f && (a.getRowDefinition(0), a.getColumnDefinition(0));
        for (var u = [], x = 0; x < f; x++) {
            var y = g[x];
            Cj(y, !0);
            Dl(y, !0);
            u[y.row] || (u[y.row] = []);
            u[y.row][y.column] || (u[y.row][y.column] = []);
            u[y.row][y.column].push(y)
        }
        Oa(g);
        var z = Ma(), B = Ma(), D = Ma(), G = {count: 0}, O = {count: 0}, U = b, R = c, fa = a.Ab;
        f = fa.length;
        for (var Y = 0; Y < f; Y++) {
            var P = fa[Y];
            void 0 !== P && (P.actual = 0)
        }
        fa = a.xb;
        f = fa.length;
        for (var ya = 0; ya < f; ya++) P = fa[ya], void 0 !== P && (P.actual = 0);
        for (var ka = u.length, Aa = 0, Ta = 0; Ta < ka; Ta++) u[Ta] && (Aa = Math.max(Aa, u[Ta].length));
        var sb = Math.min(a.topIndex, ka - 1), Xa = Math.min(a.leftIndex, Aa - 1), ab = 0;
        ka = u.length;
        for (var Rd = Om(a), mc = 0; mc < ka; mc++) if (u[mc]) {
            Aa = u[mc].length;
            var nc = a.getRowDefinition(mc);
            nc.actual = 0;
            for (var tb = nc.gc = 0; tb < Aa; tb++) if (u[mc][tb]) {
                var Sd = a.getColumnDefinition(tb);
                void 0 === z[tb] && (Sd.actual = 0, Sd.gc = 0, z[tb] = !0);
                for (var yg = u[mc][tb],
                         zg = yg.length, $e = 0; $e < zg; $e++) {
                    var Xb = yg[$e];
                    if (Xb.visible || Xb === Rd) {
                        var Nh = 1 < Xb.rowSpan || 1 < Xb.columnSpan;
                        Nh && (mc < sb || tb < Xa || B.push(Xb));
                        var Ag = Xb.margin, Oh = Ag.right + Ag.left, Ph = Ag.top + Ag.bottom;
                        var ob = Vl(Xb, nc, Sd, !1);
                        var Yi = Xb.desiredSize, yk = !isNaN(Yi.height), Bg = !isNaN(Yi.width) && yk;
                        Nh || ob === Og || Bg || mc < sb || tb < Xa || (void 0 !== G[tb] || ob !== Jd && ob !== nl || (G[tb] = -1, G.count++), void 0 !== O[mc] || ob !== Jd && ob !== ol || (O[mc] = -1, O.count++), D.push(Xb));
                        Xb.measure(Infinity, Infinity, 0, 0);
                        if (!(mc < sb || tb < Xa)) {
                            var Ad = Xb.measuredBounds,
                                Ac = Math.max(Ad.width + Oh, 0), Uf = Math.max(Ad.height + Ph, 0);
                            if (1 === Xb.rowSpan && (ob === Og || ob === nl)) {
                                P = a.getRowDefinition(mc);
                                var Ic = P.Cc();
                                ab = Math.max(Uf - P.actual, 0);
                                ab + Ic > R && (ab = Math.max(R - Ic, 0));
                                var Cg = 0 === P.na;
                                P.gc = P.gc + ab;
                                P.actual = P.na + ab;
                                R = Math.max(R - (ab + (Cg ? Ic : 0)), 0)
                            }
                            if (1 === Xb.columnSpan && (ob === Og || ob === ol)) {
                                P = a.getColumnDefinition(tb);
                                var Qh = P.Cc();
                                ab = Math.max(Ac - P.actual, 0);
                                ab + Qh > U && (ab = Math.max(U - Qh, 0));
                                var Wn = 0 === P.na;
                                P.gc = P.gc + ab;
                                P.actual = P.na + ab;
                                U = Math.max(U - (ab + (Wn ? Qh : 0)), 0)
                            }
                            Nh && Xb.Pm()
                        }
                    }
                }
            }
        }
        Oa(z);
        var $d = 0, De = 0;
        f = a.columnCount;
        for (var Dg = 0; Dg < f; Dg++) {
            var Eg = a.xb[Dg];
            void 0 !== Eg && ($d += Eg.gc, 0 !== Eg.gc && ($d += Eg.Cc()))
        }
        f = a.rowCount;
        for (var hd = 0; hd < f; hd++) {
            var Ee = a.Ab[hd];
            void 0 !== Ee && (De += Ee.gc, 0 !== Ee.gc && (De += Ee.Cc()))
        }
        U = Math.max(b - $d, 0);
        var Jc = R = Math.max(c - De, 0), zk = U;
        f = D.length;
        for (var Rh = 0; Rh < f; Rh++) {
            var id = D[Rh], Zi = a.getRowDefinition(id.row), Fe = a.getColumnDefinition(id.column),
                wf = id.measuredBounds, Td = id.margin, Ak = Td.right + Td.left, Xn = Td.top + Td.bottom;
            G[id.column] = 0 === Fe.gc && void 0 !== G[id.column] ?
                Math.max(wf.width + Ak, G[id.column]) : null;
            O[id.row] = 0 === Zi.gc && void 0 !== O[id.row] ? Math.max(wf.height + Xn, O[id.row]) : null
        }
        var Vf = 0, Yb = 0, ae;
        for (ae in O) "count" !== ae && (Vf += O[ae]);
        for (ae in G) "count" !== ae && (Yb += G[ae]);
        for (var ub = Hb.alloc(), $i = 0; $i < f; $i++) {
            var Bc = D[$i];
            if (Bc.visible || Bc === Rd) {
                var Kc = a.getRowDefinition(Bc.row), Cc = a.getColumnDefinition(Bc.column), Bd = 0;
                isFinite(Cc.width) ? Bd = Cc.width : (isFinite(U) && null !== G[Bc.column] ? 0 === Yb ? Bd = Cc.actual + U : (Bd = G[Bc.column] / Yb * zk, Bd = Math.min(Bd, U)) : null !== G[Bc.column] ?
                    Bd = U : Bd = Cc.actual || U, Bd = Math.max(0, Bd - Cc.Cc()));
                var Cd = 0;
                isFinite(Kc.height) ? Cd = Kc.height : (isFinite(R) && null !== O[Bc.row] ? 0 === Vf ? Cd = Kc.actual + R : (Cd = O[Bc.row] / Vf * Jc, Cd = Math.min(Cd, R)) : null !== O[Bc.row] ? Cd = R : Cd = Kc.actual || R, Cd = Math.max(0, Cd - Kc.Cc()));
                ub.h(Math.max(Cc.minimum, Math.min(Bd, Cc.maximum)), Math.max(Kc.minimum, Math.min(Cd, Kc.maximum)));
                ob = Vl(Bc, Kc, Cc, !1);
                switch (ob) {
                    case nl:
                        ub.height = Math.max(ub.height, Kc.actual + R);
                        break;
                    case ol:
                        ub.width = Math.max(ub.width, Cc.actual + U)
                }
                var Fg = Bc.margin, Qc = Fg.right +
                    Fg.left, Sh = Fg.top + Fg.bottom;
                Bc.Pm();
                Bc.measure(ub.width, ub.height, Cc.minimum, Kc.minimum);
                var Gg = Bc.measuredBounds, be = Math.max(Gg.width + Qc, 0), Th = Math.max(Gg.height + Sh, 0);
                isFinite(U) && (be = Math.min(be, ub.width));
                isFinite(R) && (Th = Math.min(Th, ub.height));
                var xf = 0;
                xf = Kc.actual;
                Kc.actual = Math.max(Kc.actual, Th);
                Kc.gc = Math.max(Kc.gc, Th);
                ab = Kc.actual - xf;
                R = Math.max(R - ab, 0);
                xf = Cc.actual;
                Cc.actual = Math.max(Cc.actual, be);
                Cc.gc = Math.max(Cc.gc, be);
                ab = Cc.actual - xf;
                U = Math.max(U - ab, 0)
            }
        }
        Oa(D);
        var ce = Hb.alloc(), de = Ma(),
            ee = Ma();
        f = B.length;
        if (0 !== f) for (var af = 0; af < ka; af++) if (u[af]) {
            Aa = u[af].length;
            var Uh = a.getRowDefinition(af);
            de[af] = Uh.actual;
            for (var Ge = 0; Ge < Aa; Ge++) if (u[af][Ge]) {
                var Yn = a.getColumnDefinition(Ge);
                ee[Ge] = Yn.actual
            }
        }
        for (var rc = 0; rc < f; rc++) {
            var bb = B[rc];
            if (bb.visible || bb === Rd) {
                var sc = a.getRowDefinition(bb.row), fe = a.getColumnDefinition(bb.column);
                ub.h(Math.max(fe.minimum, Math.min(b, fe.maximum)), Math.max(sc.minimum, Math.min(c, sc.maximum)));
                ob = Vl(bb, sc, fe, !1);
                switch (ob) {
                    case Jd:
                        0 !== ee[fe.index] && (ub.width =
                            Math.min(ub.width, ee[fe.index]));
                        0 !== de[sc.index] && (ub.height = Math.min(ub.height, de[sc.index]));
                        break;
                    case nl:
                        0 !== ee[fe.index] && (ub.width = Math.min(ub.width, ee[fe.index]));
                        break;
                    case ol:
                        0 !== de[sc.index] && (ub.height = Math.min(ub.height, de[sc.index]))
                }
                isFinite(fe.width) && (ub.width = fe.width);
                isFinite(sc.height) && (ub.height = sc.height);
                ce.h(0, 0);
                for (var bf = fe.minimum, Vh = sc.minimum, cf = 1; cf < bb.rowSpan && !(bb.row + cf >= a.rowCount); cf++) P = a.getRowDefinition(bb.row + cf), ab = 0, ab = ob === Jd || ob === ol ? Math.max(P.minimum,
                    0 === de[bb.row + cf] ? P.maximum : Math.min(de[bb.row + cf], P.maximum)) : Math.max(P.minimum, isNaN(P.gd) ? P.maximum : Math.min(P.gd, P.maximum)), ce.height += ab, Vh += P.minimum;
                for (var $c = 1; $c < bb.columnSpan && !(bb.column + $c >= a.columnCount); $c++) P = a.getColumnDefinition(bb.column + $c), ab = 0, ab = ob === Jd || ob === nl ? Math.max(P.minimum, 0 === ee[bb.column + $c] ? P.maximum : Math.min(ee[bb.column + $c], P.maximum)) : Math.max(P.minimum, isNaN(P.gd) ? P.maximum : Math.min(P.gd, P.maximum)), ce.width += ab, bf += P.minimum;
                ub.width += ce.width;
                ub.height += ce.height;
                var yf = bb.margin, Wh = yf.right + yf.left, Zn = yf.top + yf.bottom;
                bb.measure(ub.width, ub.height, bf, Vh);
                for (var Hg = bb.measuredBounds, Dd = Math.max(Hg.width + Wh, 0), ge = Math.max(Hg.height + Zn, 0), He = 0, Ie = 0; Ie < bb.rowSpan && !(bb.row + Ie >= a.rowCount); Ie++) P = a.getRowDefinition(bb.row + Ie), He += P.total || 0;
                if (He < ge) {
                    var he = ge - He, Je = ge - He;
                    if (null !== bb.spanAllocation) for (var Bk = bb.spanAllocation, df = 0; df < bb.rowSpan && !(0 >= he) && !(bb.row + df >= a.rowCount); df++) {
                        P = a.getRowDefinition(bb.row + df);
                        var aj = P.na || 0, bj = Bk(bb, P, Je);
                        F && "number" !==
                        typeof bj && v(bb + " spanAllocation does not return a number: " + bj);
                        P.actual = Math.min(P.maximum, aj + bj);
                        P.na !== aj && (he -= P.na - aj)
                    }
                    for (; 0 < he;) {
                        var Ed = P.na || 0;
                        isNaN(P.height) && P.maximum > Ed && (P.actual = Math.min(P.maximum, Ed + he), P.na !== Ed && (he -= P.na - Ed));
                        if (0 === P.index) break;
                        P = a.getRowDefinition(P.index - 1)
                    }
                }
                for (var Wf = 0, Xh = 0; Xh < bb.columnSpan && !(bb.column + Xh >= a.columnCount); Xh++) P = a.getColumnDefinition(bb.column + Xh), Wf += P.total || 0;
                if (Wf < Dd) {
                    var Ig = Dd - Wf, yu = Dd - Wf;
                    if (null !== bb.spanAllocation) for (var zu = bb.spanAllocation,
                                                             Ck = 0; Ck < bb.columnSpan && !(0 >= Ig) && !(bb.column + Ck >= a.columnCount); Ck++) {
                        P = a.getColumnDefinition(bb.column + Ck);
                        var $n = P.na || 0, ao = zu(bb, P, yu);
                        F && "number" !== typeof ao && v(bb + " spanAllocation does not return a number: " + ao);
                        P.actual = Math.min(P.maximum, $n + ao);
                        P.na !== $n && (Ig -= P.na - $n)
                    }
                    for (; 0 < Ig;) {
                        var Dk = P.na || 0;
                        isNaN(P.width) && P.maximum > Dk && (P.actual = Math.min(P.maximum, Dk + Ig), P.na !== Dk && (Ig -= P.na - Dk));
                        if (0 === P.index) break;
                        P = a.getColumnDefinition(P.index - 1)
                    }
                }
            }
        }
        Oa(B);
        Hb.free(ce);
        Hb.free(ub);
        void 0 !== de && Oa(de);
        void 0 !== ee && Oa(ee);
        var Jg = 0, Kg = 0, Ek = a.desiredSize, Fr = a.maxSize;
        ob = Cl(a, !0);
        var cj = De = $d = 0, dj = 0;
        f = a.columnCount;
        for (var Fk = 0; Fk < f; Fk++) void 0 !== a.xb[Fk] && (P = a.getColumnDefinition(Fk), isFinite(P.width) ? (cj += P.width, cj += P.Cc()) : Wm(P) === Xm ? (cj += P.na, cj += P.Cc()) : 0 !== P.na && ($d += P.na, $d += P.Cc()));
        isFinite(Ek.width) ? Jg = Math.min(Ek.width, Fr.width) : Jg = ob !== Og && isFinite(b) ? b : $d;
        Jg = Math.max(Jg, a.minSize.width);
        Jg = Math.max(Jg - cj, 0);
        for (var Au = 0 === $d ? 1 : Math.max(Jg / $d, 1), Hk = 0; Hk < f; Hk++) void 0 !== a.xb[Hk] && (P = a.getColumnDefinition(Hk),
        isFinite(P.width) || Wm(P) === Xm || (P.actual = P.na * Au), P.position = e.width, 0 !== P.na && (e.width += P.na, e.width += P.Cc()));
        f = a.rowCount;
        for (var Ik = 0; Ik < f; Ik++) void 0 !== a.Ab[Ik] && (P = a.getRowDefinition(Ik), isFinite(P.height) ? (dj += P.height, dj += P.Cc()) : Wm(P) === Xm ? (dj += P.na, dj += P.Cc()) : 0 !== P.na && (De += P.na, 0 !== P.na && (De += P.Cc())));
        isFinite(Ek.height) ? Kg = Math.min(Ek.height, Fr.height) : Kg = ob !== Og && isFinite(c) ? c : De;
        Kg = Math.max(Kg, a.minSize.height);
        Kg = Math.max(Kg - dj, 0);
        for (var Bu = 0 === De ? 1 : Math.max(Kg / De, 1), Jk = 0; Jk < f; Jk++) void 0 !==
        a.Ab[Jk] && (P = a.getRowDefinition(Jk), isFinite(P.height) || Wm(P) === Xm || (P.actual = P.na * Bu), P.position = e.height, 0 !== P.na && (e.height += P.na, 0 !== P.na && (e.height += P.Cc())));
        f = h.length;
        for (var bo = 0; bo < f; bo++) {
            var Fd = h[bo], co = 0, eo = 0;
            Fd.type === W.TableRow ? (co = e.width, P = a.getRowDefinition(Fd.row), eo = P.actual) : (P = a.getColumnDefinition(Fd.column), co = P.actual, eo = e.height);
            Fd.measuredBounds.h(0, 0, co, eo);
            Cj(Fd, !1);
            u[Fd.row] || (u[Fd.row] = []);
            u[Fd.row][Fd.column] || (u[Fd.row][Fd.column] = []);
            u[Fd.row][Fd.column].push(Fd)
        }
        Oa(h);
        a.Sp = u
    };
    Vm.prototype.arrange = function (a, b, c) {
        var d = b.length, e = a.padding, f = e.left;
        e = e.top;
        for (var g = a.Sp, h, k, l = g.length, m = 0, n = 0; n < l; n++) g[n] && (m = Math.max(m, g[n].length));
        for (n = Math.min(a.topIndex, l - 1); n !== l && (void 0 === a.Ab[n] || 0 === a.Ab[n].na);) n++;
        n = Math.min(n, l - 1);
        n = -a.Ab[n].position;
        for (h = Math.min(a.leftIndex, m - 1); h !== m && (void 0 === a.xb[h] || 0 === a.xb[h].na);) h++;
        h = Math.min(h, m - 1);
        for (var p = -a.xb[h].position, r = Hb.alloc(), q = 0; q < l; q++) if (g[q]) {
            m = g[q].length;
            var u = a.getRowDefinition(q);
            k = u.position + n + e;
            0 !== u.na &&
            (k += u.Tv());
            for (var x = 0; x < m; x++) if (g[q][x]) {
                var y = a.getColumnDefinition(x);
                h = y.position + p + f;
                0 !== y.na && (h += y.Tv());
                for (var z = g[q][x], B = z.length, D = 0; D < B; D++) {
                    var G = z[D], O = G.measuredBounds, U = G instanceof W ? G : null;
                    if (null === U || U.type !== W.TableRow && U.type !== W.TableColumn) {
                        r.h(0, 0);
                        for (var R = 1; R < G.rowSpan && !(q + R >= a.rowCount); R++) U = a.getRowDefinition(q + R), r.height += U.total;
                        for (R = 1; R < G.columnSpan && !(x + R >= a.columnCount); R++) U = a.getColumnDefinition(x + R), r.width += U.total;
                        var fa = y.na + r.width, Y = u.na + r.height;
                        R = h;
                        U = k;
                        var P = fa, ya = Y, ka = h, Aa = k, Ta = fa, sb = Y;
                        h + fa > c.width && (Ta = Math.max(c.width - h, 0));
                        k + Y > c.height && (sb = Math.max(c.height - k, 0));
                        var Xa = G.alignment;
                        if (Xa.Jb()) {
                            Xa = a.defaultAlignment;
                            Xa.cb() || (Xa = Mc);
                            var ab = Xa.x;
                            var Rd = Xa.y;
                            var mc = Xa.offsetX;
                            Xa = Xa.offsetY;
                            var nc = y.alignment, tb = u.alignment;
                            nc.cb() && (ab = nc.x, mc = nc.offsetX);
                            tb.cb() && (Rd = tb.y, Xa = tb.offsetY)
                        } else ab = Xa.x, Rd = Xa.y, mc = Xa.offsetX, Xa = Xa.offsetY;
                        if (isNaN(ab) || isNaN(Rd)) Rd = ab = .5, Xa = mc = 0;
                        nc = O.width;
                        tb = O.height;
                        var Sd = G.margin, yg = Sd.left + Sd.right,
                            zg = Sd.top + Sd.bottom, $e = Vl(G, u, y, !1);
                        !isNaN(G.desiredSize.width) || $e !== Jd && $e !== nl || (nc = Math.max(fa - yg, 0));
                        !isNaN(G.desiredSize.height) || $e !== Jd && $e !== ol || (tb = Math.max(Y - zg, 0));
                        fa = G.maxSize;
                        Y = G.minSize;
                        nc = Math.min(fa.width, nc);
                        tb = Math.min(fa.height, tb);
                        nc = Math.max(Y.width, nc);
                        tb = Math.max(Y.height, tb);
                        fa = tb + zg;
                        R += P * ab - (nc + yg) * ab + mc + Sd.left;
                        U += ya * Rd - fa * Rd + Xa + Sd.top;
                        G.visible && (pc(ka, Aa, Ta, sb, R, U, O.width, O.height) ? G.arrange(R, U, nc, tb) : G.arrange(R, U, nc, tb, new L(ka, Aa, Ta, sb)))
                    } else G.Rl(), G.actualBounds.ka(),
                        P = G.actualBounds, R = L.allocAt(P.x, P.y, P.width, P.height), P.x = U.type === W.TableRow ? f : h, P.y = U.type === W.TableColumn ? e : k, P.width = O.width, P.height = O.height, G.actualBounds.freeze(), Dl(G, !1), hc(R, P) || (O = G.part, null !== O && (O.Yh(), G.tp(O))), L.free(R)
                }
            }
        }
        Hb.free(r);
        for (a = 0; a < d; a++) c = b[a], f = c instanceof W ? c : null, null === f || f.type !== W.TableRow && f.type !== W.TableColumn || (f = c.actualBounds, c.naturalBounds.ka(), c.naturalBounds.h(0, 0, f.width, f.height), c.naturalBounds.freeze())
    };

    function Ym() {
        this.name = "Base"
    }

    ma(Ym, em);
    Ym.prototype.measure = function () {
    };
    Ym.prototype.arrange = function () {
    };

    function Zm() {
        this.name = "Base"
    }

    ma(Zm, em);
    Zm.prototype.measure = function () {
    };
    Zm.prototype.arrange = function () {
    };

    function $m() {
        this.name = "Base"
    }

    ma($m, em);
    $m.prototype.measure = function (a, b, c, d, e, f, g) {
        1 < d.length && v("Viewbox Panel cannot contain more than one GraphObject.");
        d = d[0];
        d.Fa = 1;
        d.Pm();
        d.measure(Infinity, Infinity, f, g);
        var h = d.measuredBounds, k = d.margin, l = k.right + k.left;
        k = k.top + k.bottom;
        if (isFinite(b) || isFinite(c)) {
            var m = d.scale, n = h.width;
            h = h.height;
            var p = Math.max(b - l, 0), r = Math.max(c - k, 0), q = 1;
            a.viewboxStretch === Qg ? 0 !== n && 0 !== h && (q = Math.min(p / n, r / h)) : 0 !== n && 0 !== h && (q = Math.max(p / n, r / h));
            0 === q && (q = 1E-4);
            d.Fa *= q;
            m !== d.scale && (Cj(d, !0), d.measure(Infinity,
                Infinity, f, g))
        }
        h = d.measuredBounds;
        e.width = isFinite(b) ? b : Math.max(h.width + l, 0);
        e.height = isFinite(c) ? c : Math.max(h.height + k, 0)
    };
    $m.prototype.arrange = function (a, b, c) {
        b = b[0];
        var d = b.measuredBounds, e = b.margin, f = Math.max(d.width + (e.right + e.left), 0);
        e = Math.max(d.height + (e.top + e.bottom), 0);
        var g = b.alignment;
        g.Jb() && (g = a.defaultAlignment);
        g.cb() || (g = Mc);
        b.arrange(c.width * g.x - f * g.x + g.offsetX, c.height * g.y - e * g.y + g.offsetY, d.width, d.height)
    };

    function an() {
        this.name = "Base"
    }

    ma(an, em);
    an.prototype.measure = function () {
    };
    an.prototype.arrange = function () {
    };
    an.prototype.ic = function (a, b, c) {
        c = a.Mf() * c.scale;
        0 >= c && (c = 1);
        var d = a.gridCellSize, e = d.width;
        d = d.height;
        var f = a.naturalBounds, g = a.actualBounds, h = f.width, k = f.height, l = Math.ceil(h / e),
            m = Math.ceil(k / d), n = a.gridOrigin;
        b.save();
        b.beginPath();
        b.rect(0, 0, h, k);
        b.clip();
        for (var p = [], r = a.$.j, q = r.length, u = 0; u < q; u++) {
            var x = r[u], y = [];
            p.push(y);
            if (x.visible) {
                var z = x.interval;
                if (!(0 > z)) {
                    x = kk(x.figure);
                    for (var B = 0; B < q; B++) if (B !== u) {
                        var D = r[B];
                        D.visible && kk(D.figure) === x && (D = D.interval, D > z && y.push(D))
                    }
                }
            }
        }
        r = a.$.j;
        q =
            r.length;
        for (u = 0; u < q; u++) {
            var G = r[u];
            if (G.visible && (y = G.interval, !(2 > e * Math.abs(y) * c))) {
                z = G.opacity;
                x = 1;
                if (1 !== z) {
                    if (0 === z) continue;
                    x = b.globalAlpha;
                    b.globalAlpha = x * z
                }
                B = p[u];
                D = !1;
                var O = G.strokeDashArray;
                null !== O && (D = !0, b.Rt(O, G.strokeDashOffset));
                if ("LineV" === G.figure && null !== G.stroke && 0 < G.strokeWidth) {
                    b.lineWidth = G.strokeWidth;
                    Ai(a, b, G.stroke, !1, !1, f, g);
                    b.beginPath();
                    for (O = G = Math.floor(-n.x / e); O <= G + l; O++) {
                        var U = O * e + n.x;
                        0 <= U && U <= h && bn(O, y, B) && (b.moveTo(U, 0), b.lineTo(U, k))
                    }
                    b.stroke()
                } else if ("LineH" ===
                    G.figure && null !== G.stroke && 0 < G.strokeWidth) {
                    b.lineWidth = G.strokeWidth;
                    Ai(a, b, G.stroke, !1, !1, f, g);
                    b.beginPath();
                    for (O = G = Math.floor(-n.y / d); O <= G + m; O++) U = O * d + n.y, 0 <= U && U <= k && bn(O, y, B) && (b.moveTo(0, U), b.lineTo(h, U));
                    b.stroke()
                } else if ("BarV" === G.figure && null !== G.fill) for (Ai(a, b, G.fill, !0, !1, f, g), G = G.width, isNaN(G) && (G = e), U = O = Math.floor(-n.x / e); U <= O + l; U++) {
                    var R = U * e + n.x;
                    0 <= R && R <= h && bn(U, y, B) && b.fillRect(R, 0, G, k)
                } else if ("BarH" === G.figure && null !== G.fill) for (Ai(a, b, G.fill, !0, !1, f, g), G = G.height, isNaN(G) &&
                (G = d), U = O = Math.floor(-n.y / d); U <= O + m; U++) R = U * d + n.y, 0 <= R && R <= k && bn(U, y, B) && b.fillRect(0, R, h, G);
                D && b.Pt();
                1 !== z && (b.globalAlpha = x)
            }
        }
        b.restore();
        b.Ac(!1)
    };

    function bn(a, b, c) {
        if (0 > b) return 0 === a % b;
        if (0 !== a % b) return !1;
        b = c.length;
        for (var d = 0; d < b; d++) if (0 === a % c[d]) return !1;
        return !0
    }

    function cn() {
        this.name = "Base"
    }

    ma(cn, em);
    cn.prototype.measure = function (a, b, c, d, e) {
        c = d.length;
        if (a instanceof Xe || a instanceof S) {
            var f = null, g = null, h = null;
            a instanceof S && (g = f = a);
            a instanceof Xe && (h = a, f = h.adornedPart);
            if (f instanceof S) {
                var k = f;
                if (0 === c) ec(a.naturalBounds, 0, 0), a.measuredBounds.h(0, 0, 0, 0); else {
                    var l = a instanceof Xe ? null : f.path, m = f.routeBounds;
                    b = a.Kg;
                    b.h(0, 0, m.width, m.height);
                    var n = k.points;
                    f = f.pointsCount;
                    null !== h ? h.Nk(!1) : null !== g && g.Nk(!1);
                    var p = m.width, r = m.height;
                    a.location.h(m.x, m.y);
                    a.l.length = 0;
                    null !== l && (dn(a, p, r, l),
                        h = l.measuredBounds, b.Yc(h), a.l.push(h));
                    h = Ib.alloc();
                    for (var q = J.alloc(), u = J.alloc(), x = 0; x < c; x++) {
                        var y = d[x];
                        if (y !== l) if (y.isPanelMain && y instanceof Zf) {
                            dn(a, p, r, y);
                            var z = y.measuredBounds;
                            b.Yc(z);
                            a.l.push(z)
                        } else if (2 > f) y.measure(Infinity, Infinity, 0, 0), z = y.measuredBounds, b.Yc(z), a.l.push(z); else {
                            var B = y.segmentIndex, D = y.segmentFraction, G = y.alignmentFocus;
                            G.Tb() && (G = Mc);
                            var O = y.segmentOrientation, U = y.segmentOffset;
                            if (isNaN(B)) {
                                var R = k.ua;
                                z = Ma();
                                R.jw(D, z);
                                var fa = J.allocAt(z[0], z[1]);
                                fa.add(k.i(0));
                                R.type === Kd ? fa.offset(-R.startX, -R.startY) : (R = R.figures.first(), fa.offset(-R.startX, -R.startY));
                                R = z[2];
                                if (O !== pg) {
                                    var Y = k.computeAngle(y, O, R);
                                    y.dc = Y
                                }
                                Y = fa.x - m.x;
                                var P = fa.y - m.y;
                                J.free(fa);
                                Oa(z)
                            } else if (B < -f || B >= f) P = k.midPoint, R = k.midAngle, O !== pg && (Y = k.computeAngle(y, O, R), y.dc = Y), Y = P.x - m.x, P = P.y - m.y; else {
                                Y = 0;
                                0 <= B ? (P = n.M(B), z = B < f - 1 ? n.M(B + 1) : P) : (Y = f + B, P = n.M(Y), z = 0 < Y ? n.M(Y - 1) : P);
                                if (P.Ta(z)) {
                                    0 <= B ? (R = 0 < B ? n.M(B - 1) : P, Y = B < f - 2 ? n.M(B + 2) : z) : (R = Y < f - 1 ? n.M(Y + 1) : P, Y = 1 < Y ? n.M(Y - 2) : z);
                                    fa = R.Re(P);
                                    var ya = z.Re(Y);
                                    R = fa > ya +
                                    10 ? 0 <= B ? R.Xa(P) : P.Xa(R) : ya > fa + 10 ? 0 <= B ? z.Xa(Y) : Y.Xa(z) : 0 <= B ? R.Xa(Y) : Y.Xa(R)
                                } else R = 0 <= B ? P.Xa(z) : z.Xa(P);
                                O !== pg && (Y = k.computeAngle(y, O, R), y.dc = Y);
                                Y = P.x + (z.x - P.x) * D - m.x;
                                P = P.y + (z.y - P.y) * D - m.y
                            }
                            y.measure(Infinity, Infinity, 0, 0);
                            z = y.measuredBounds;
                            fa = y.naturalBounds;
                            var ka = 0;
                            y instanceof Zf && (ka = y.strokeWidth);
                            ya = fa.width + ka;
                            var Aa = fa.height + ka;
                            h.reset();
                            h.translate(-z.x, -z.y);
                            h.scale(y.scale, y.scale);
                            h.rotate(O === pg ? y.angle : R, ya / 2, Aa / 2);
                            O !== en && O !== fn || h.rotate(90, ya / 2, Aa / 2);
                            O !== gn && O !== hn || h.rotate(-90,
                                ya / 2, Aa / 2);
                            O === jn && (45 < R && 135 > R || 225 < R && 315 > R) && h.rotate(-R, ya / 2, Aa / 2);
                            fa = new L(0, 0, ya, Aa);
                            q.Ej(fa, G);
                            h.ya(q);
                            G = -q.x + ka / 2 * y.scale;
                            y = -q.y + ka / 2 * y.scale;
                            u.assign(U);
                            ka = isNaN(U.x);
                            var Ta = isNaN(U.y);
                            if (ka || Ta) {
                                ya = ya / 2 + 3;
                                Aa = Aa / 2 + 3;
                                var sb = 45 <= R && 135 >= R, Xa = 225 <= R && 315 >= R;
                                O === pg && (sb || Xa) ? (u.x = Ta ? ya : U.y, u.y = ka ? Aa : U.x, sb ? 0 <= B || isNaN(B) && .5 > D || !ka || (u.y = -Aa) : Xa && ((0 <= B || isNaN(B) && .5 > D) && ka && (u.y = -Aa), Ta && (u.x = -ya))) : (ka && (u.x = 0 <= B || isNaN(B) && .5 > D ? ya : -ya), Ta && (u.y = -Aa), u.rotate(R))
                            } else u.rotate(R);
                            Y += u.x;
                            P +=
                                u.y;
                            fa.set(z);
                            fa.h(Y + G, P + y, z.width, z.height);
                            a.l.push(fa);
                            b.Yc(fa)
                        }
                    }
                    if (null !== g) for (d = g.labelNodes; d.next();) d.value.measure(Infinity, Infinity);
                    a.Kg = b;
                    a = a.location;
                    a.h(a.x + b.x, a.y + b.y);
                    ec(e, b.width || 0, b.height || 0);
                    Ib.free(h);
                    J.free(q);
                    J.free(u)
                }
            }
        }
    };
    cn.prototype.arrange = function (a, b) {
        var c = b.length;
        if (a instanceof Xe || a instanceof S) {
            var d = null, e = null, f = null;
            a instanceof S && (e = d = a);
            a instanceof Xe && (f = a, d = f.adornedPart);
            var g = a instanceof Xe ? null : d.path;
            if (0 !== a.l.length) {
                var h = a.l, k = 0;
                if (null !== g && k < a.l.length) {
                    var l = h[k];
                    k++;
                    g.arrange(l.x - a.Kg.x, l.y - a.Kg.y, l.width, l.height)
                }
                for (l = 0; l < c; l++) {
                    var m = b[l];
                    if (m !== g && k < a.l.length) {
                        var n = h[k];
                        k++;
                        m.arrange(n.x - a.Kg.x, n.y - a.Kg.y, n.width, n.height)
                    }
                }
            }
            b = d.points;
            c = b.count;
            if (2 <= c && a instanceof S) for (d =
                                                   a.labelNodes; d.next();) {
                var p = a;
                g = d.value;
                h = g.segmentIndex;
                k = g.segmentFraction;
                var r = g.alignmentFocus;
                l = g.segmentOrientation;
                m = g.segmentOffset;
                if (isNaN(h)) {
                    n = p.ua;
                    var q = Ma();
                    n.jw(k, q);
                    var u = J.allocAt(q[0], q[1]);
                    u.add(p.i(0));
                    n.type === Kd ? u.offset(-n.startX, -n.startY) : (n = n.figures.first(), u.offset(-n.startX, -n.startY));
                    n = q[2];
                    l !== pg && (p = p.computeAngle(g, l, n), g.angle = p);
                    p = u.x;
                    var x = u.y;
                    J.free(u);
                    Oa(q)
                } else if (h < -c || h >= c) x = p.midPoint, n = p.midAngle, l !== pg && (p = p.computeAngle(g, l, n), g.angle = p), p = x.x, x = x.y;
                else {
                    u = 0;
                    0 <= h ? (q = b.j[h], x = h < c - 1 ? b.j[h + 1] : q) : (u = c + h, q = b.j[u], x = 0 < u ? b.j[u - 1] : q);
                    if (q.Ta(x)) {
                        0 <= h ? (n = 0 < h ? b.j[h - 1] : q, u = h < c - 2 ? b.j[h + 2] : x) : (n = u < c - 1 ? b.j[u + 1] : q, u = 1 < u ? b.j[u - 2] : x);
                        var y = n.Re(q), z = x.Re(u);
                        n = y > z + 10 ? 0 <= h ? n.Xa(q) : q.Xa(n) : z > y + 10 ? 0 <= h ? x.Xa(u) : u.Xa(x) : 0 <= h ? n.Xa(u) : u.Xa(n)
                    } else n = 0 <= h ? q.Xa(x) : x.Xa(q);
                    l !== pg && (p = p.computeAngle(g, l, n), g.angle = p);
                    p = q.x + (x.x - q.x) * k;
                    x = q.y + (x.y - q.y) * k
                }
                if (r.Zq()) g.location = new J(p, x); else {
                    r.Tb() && (r = Mc);
                    q = Ib.alloc();
                    q.reset();
                    q.scale(g.scale, g.scale);
                    q.rotate(g.angle, 0,
                        0);
                    var B = g.naturalBounds;
                    u = L.allocAt(0, 0, B.width, B.height);
                    y = J.alloc();
                    y.Ej(u, r);
                    q.ya(y);
                    r = -y.x;
                    z = -y.y;
                    var D = B.width, G = B.height;
                    B = J.alloc();
                    B.assign(m);
                    var O = isNaN(m.x), U = isNaN(m.y);
                    if (O || U) {
                        D = D / 2 + 3;
                        G = G / 2 + 3;
                        var R = 45 <= n && 135 >= n, fa = 225 <= n && 315 >= n;
                        l === pg && (R || fa) ? (B.x = U ? D : m.y, B.y = O ? G : m.x, R ? 0 <= h || isNaN(h) && .5 > k || !O || (B.y = -G) : fa && ((0 <= h || isNaN(h) && .5 > k) && O && (B.y = -G), U && (B.x = -D))) : (O && (B.x = 0 <= h || isNaN(h) && .5 > k ? D : -D), U && (B.y = -G), B.rotate(n))
                    } else B.rotate(n);
                    p += B.x;
                    x += B.y;
                    q.ax(u);
                    r += u.x;
                    z += u.y;
                    h = J.allocAt(p +
                        r, x + z);
                    g.move(h);
                    J.free(h);
                    J.free(B);
                    J.free(y);
                    L.free(u);
                    Ib.free(q)
                }
            }
            null !== f ? f.Nk(!1) : null !== e && e.Nk(!1)
        }
    };

    function dn(a, b, c, d) {
        if (!1 !== Hj(d)) {
            var e = d.strokeWidth;
            0 === e && a instanceof Xe && a.type === W.Link && a.adornedObject instanceof Zf && (e = a.adornedObject.strokeWidth);
            e *= d.Fa;
            a instanceof S && null !== a.ua ? (a = a.ua.bounds, zl(d, a.x - e / 2, a.y - e / 2, a.width + e, a.height + e)) : a instanceof Xe && null !== a.adornedPart.ua ? (a = a.adornedPart.ua.bounds, zl(d, a.x - e / 2, a.y - e / 2, a.width + e, a.height + e)) : zl(d, -(e / 2), -(e / 2), b + e, c + e);
            Cj(d, !1)
        }
    }

    function kn() {
        this.name = "Base"
    }

    ma(kn, em);
    kn.prototype.measure = function (a, b, c, d, e, f, g) {
        var h = a.wb();
        a.ph = [];
        var k = h.margin, l = k.right + k.left, m = k.top + k.bottom;
        h.measure(b, c, f, g);
        var n = h.measuredBounds, p = new L(-k.left, -k.top, Math.max(n.width + l, 0), Math.max(n.height + m, 0));
        a.ph.push(p);
        e.assign(p);
        for (var r = h.geometry, q = h.strokeWidth, u = r.flattenedSegments, x = r.flattenedLengths, y = r.flattenedTotalLength, z = u.length, B = 0, D = 0, G = Ma(), O = 0; O < z; O++) {
            var U = u[O], R = [];
            D = B = 0;
            for (var fa = U.length, Y = 0; Y < fa; Y += 2) {
                var P = U[Y], ya = U[Y + 1];
                if (0 !== Y) {
                    var ka = 180 * Math.atan2(ya -
                        D, P - B) / Math.PI;
                    0 > ka && (ka += 360);
                    R.push(ka)
                }
                B = P;
                D = ya
            }
            G.push(R)
        }
        if (null === a.qh) {
            for (var Aa = [], Ta = a.$.j, sb = Ta.length, Xa = 0; Xa < sb; Xa++) {
                var ab = Ta[Xa], Rd = [];
                Aa.push(Rd);
                if (ab.visible) {
                    var mc = ab.interval;
                    if (!(0 > mc)) for (var nc = 0; nc < sb; nc++) if (nc !== Xa) {
                        var tb = Ta[nc];
                        if (tb.visible && ab.constructor === tb.constructor) {
                            var Sd = tb.interval;
                            Sd > mc && Rd.push(Sd)
                        }
                    }
                }
            }
            a.qh = Aa
        }
        var yg = a.qh;
        var zg = a.$.j, $e = zg.length, Xb = 0, Nh = 0, Ag = y;
        a.Wj = [];
        for (var Oh, Ph = 0; Ph < $e; Ph++) {
            var ob = zg[Ph];
            Oh = [];
            if (ob.visible && ob !== h) {
                var Yi = Math.abs(ob.interval),
                    yk = a.graduatedTickUnit;
                if (!(2 > yk * Yi * y / a.graduatedRange)) {
                    var Bg = x[0][0], Ad = 0, Ac = 0;
                    Nh = y * ob.graduatedStart - 1E-4;
                    Ag = y * ob.graduatedEnd + 1E-4;
                    var Uf = yk * Yi, Ic = a.graduatedTickBase;
                    if (Ic < a.graduatedMin) {
                        var Cg = (a.graduatedMin - Ic) / Uf;
                        Cg = 0 === Cg % 1 ? Cg : Math.floor(Cg + 1);
                        Ic += Cg * Uf
                    } else Ic > a.graduatedMin + Uf && (Ic -= Math.floor((Ic - a.graduatedMin) / Uf) * Uf);
                    for (var Qh = yg[Ph], Wn = Ic, $d = 1; Ic < a.graduatedMax + 5E-8; $d++) {
                        a:{
                            for (var De = Qh.length, Dg = 0; Dg < De; Dg++) if (K.da((Ic - a.graduatedTickBase) % (Qh[Dg] * a.graduatedTickUnit), 0)) {
                                var Eg =
                                    !1;
                                break a
                            }
                            Eg = !0
                        }
                        if (Eg && (null === ob.graduatedSkip || !ob.graduatedSkip(Ic)) && (Xb = (Ic - a.graduatedMin) * y / a.graduatedRange, Xb > y && (Xb = y), Nh <= Xb && Xb <= Ag)) {
                            for (var hd = G[Ad][Ac], Ee = x[Ad][Ac]; Ad < x.length;) {
                                for (; Xb > Bg && Ac < x[Ad].length - 1;) Ac++, hd = G[Ad][Ac], Ee = x[Ad][Ac], Bg += Ee;
                                if (Xb <= Bg) break;
                                Ad++;
                                Ac = 0;
                                hd = G[Ad][Ac];
                                Ee = x[Ad][Ac];
                                Bg += Ee
                            }
                            var Jc = u[Ad], zk = Jc[2 * Ac], Rh = Jc[2 * Ac + 1], id = (Xb - (Bg - Ee)) / Ee,
                                Zi = new J(zk + (Jc[2 * Ac + 2] - zk) * id + q / 2 - r.bounds.x, Rh + (Jc[2 * Ac + 3] - Rh) * id + q / 2 - r.bounds.y);
                            Zi.scale(h.scale, h.scale);
                            var Fe = hd,
                                wf = G[Ad];
                            1E-4 > id ? 0 < Ac ? Fe = wf[Ac - 1] : K.da(Jc[0], Jc[Jc.length - 2]) && K.da(Jc[1], Jc[Jc.length - 1]) && (Fe = wf[wf.length - 1]) : .9999 < id && (Ac + 1 < wf.length ? Fe = wf[Ac + 1] : K.da(Jc[0], Jc[Jc.length - 2]) && K.da(Jc[1], Jc[Jc.length - 1]) && (Fe = wf[0]));
                            hd !== Fe && (180 < Math.abs(hd - Fe) && (hd < Fe ? hd += 360 : Fe += 360), hd = (hd + Fe) / 2 % 360);
                            if (ob instanceof kh) {
                                var Td = "";
                                null !== ob.graduatedFunction ? (Td = ob.graduatedFunction(Ic), Td = null !== Td && void 0 !== Td ? Td.toString() : "") : Td = (+Ic.toFixed(2)).toString();
                                "" !== Td && Oh.push({Wm: Zi, angle: hd, text: Td})
                            } else Oh.push({
                                Wm: Zi,
                                angle: hd
                            })
                        }
                        Ic = Wn + $d * Uf
                    }
                }
            }
            a.Wj.push(Oh)
        }
        Oa(G);
        var Ak = a.Wj;
        if (null !== Ak) for (var Xn = d.length, Vf = 0; Vf < Xn; Vf++) {
            var Yb = d[Vf], ae = Ak[Vf];
            if (Yb.visible && Yb !== h && 0 !== ae.length) {
                if (Yb instanceof Zf) {
                    var ub = a, $i = e, Bc = Yb.alignmentFocus;
                    Bc.Tb() && (Bc = Gc);
                    var Kc = Yb.angle;
                    Yb.dc = 0;
                    Yb.measure(Infinity, Infinity, 0, 0);
                    Yb.dc = Kc;
                    var Cc = Yb.measuredBounds, Bd = Cc.width, Cd = Cc.height, Fg = L.allocAt(0, 0, Bd, Cd),
                        Qc = J.alloc();
                    Qc.Ej(Fg, Bc);
                    L.free(Fg);
                    for (var Sh = -Qc.x, Gg = -Qc.y, be = new L, Th = ae.length, xf = 0; xf < Th; xf++) for (var ce = ae[xf],
                                                                                                                 de = ce.Wm.x, ee = ce.Wm.y, af = ce.angle, Uh = 0; 4 > Uh; Uh++) {
                        switch (Uh) {
                            case 0:
                                Qc.h(Sh, Gg);
                                break;
                            case 1:
                                Qc.h(Sh + Bd, Gg);
                                break;
                            case 2:
                                Qc.h(Sh, Gg + Cd);
                                break;
                            case 3:
                                Qc.h(Sh + Bd, Gg + Cd)
                        }
                        Qc.rotate(af + Yb.angle);
                        Qc.offset(de, ee);
                        0 === xf && 0 === Uh ? be.h(Qc.x, Qc.y, 0, 0) : be.Ze(Qc);
                        Qc.offset(-de, -ee);
                        Qc.rotate(-af - Yb.angle)
                    }
                    J.free(Qc);
                    null !== ub.ph && ub.ph.push(be);
                    oc($i, be.x, be.y, be.width, be.height)
                } else if (Yb instanceof kh) {
                    var Ge = a, Yn = e;
                    null === Ge.Jh && (Ge.Jh = new kh);
                    var rc = Ge.Jh;
                    ln(rc, Yb);
                    var bb = Yb.alignmentFocus;
                    bb.Tb() && (bb =
                        Gc);
                    for (var sc = Yb.segmentOrientation, fe = Yb.segmentOffset, bf = new L, Vh = 0, cf = 0, $c = 0, yf = 0, Wh = 0, Zn = ae.length, Hg = 0; Hg < Zn; Hg++) {
                        var Dd = ae[Hg];
                        Vh = Dd.Wm.x;
                        cf = Dd.Wm.y;
                        $c = Dd.angle;
                        Wh = yf = Yb.angle;
                        sc !== pg && (Wh = sc === mn || sc === nn ? $c + Yb.angle : $c, yf = S.computeAngle(sc, Wh));
                        rc.dc = yf;
                        rc.text = Dd.text || "";
                        rc.measure(Infinity, Infinity, 0, 0);
                        var ge = rc.measuredBounds, He = rc.naturalBounds, Ie = He.width, he = He.height,
                            Je = Ib.alloc();
                        Je.reset();
                        Je.translate(-ge.x, -ge.y);
                        Je.scale(rc.scale, rc.scale);
                        Je.rotate(Wh, Ie / 2, he / 2);
                        sc !== en && sc !==
                        fn || Je.rotate(90, Ie / 2, he / 2);
                        sc !== gn && sc !== hn || Je.rotate(-90, Ie / 2, he / 2);
                        sc === jn && (45 < $c && 135 > $c || 225 < $c && 315 > $c) && Je.rotate(-$c, Ie / 2, he / 2);
                        var Bk = L.allocAt(0, 0, Ie, he), df = J.alloc();
                        df.Ej(Bk, bb);
                        Je.ya(df);
                        var aj = -df.x, bj = -df.y, Ed = J.alloc();
                        Ed.assign(fe);
                        isNaN(Ed.x) && (Ed.x = Ie / 2 + 3);
                        isNaN(Ed.y) && (Ed.y = -(he / 2 + 3));
                        Ed.rotate($c);
                        Vh += Ed.x + aj;
                        cf += Ed.y + bj;
                        var Wf = new L(Vh, cf, ge.width, ge.height), Xh = new L(ge.x, ge.y, ge.width, ge.height),
                            Ig = new L(He.x, He.y, He.width, He.height);
                        Dd.VA = yf;
                        Dd.lineCount = rc.lineCount;
                        Dd.lines =
                            [rc.zb, rc.Ni, rc.ue, rc.Ie, rc.Wb, rc.qb, rc.se];
                        Dd.actualBounds = Wf;
                        Dd.measuredBounds = Xh;
                        Dd.naturalBounds = Ig;
                        0 === Hg ? bf.assign(Wf) : bf.Yc(Wf);
                        J.free(Ed);
                        J.free(df);
                        L.free(Bk);
                        Ib.free(Je)
                    }
                    null !== Ge.ph && Ge.ph.push(bf);
                    oc(Yn, bf.x, bf.y, bf.width, bf.height)
                }
                Cj(Yb, !1)
            }
        }
    };
    kn.prototype.arrange = function (a, b, c) {
        if (null !== a.ph) {
            var d = a.wb(), e = a.Wj;
            if (null !== e) {
                var f = a.ph, g = 0, h = f[g];
                g++;
                null !== d && d.arrange(h.x - c.x, h.y - c.y, h.width, h.height);
                for (var k = b.length, l = 0; l < k; l++) {
                    var m = b[l];
                    h = e[l];
                    m.visible && m !== d && 0 !== h.length && (h = f[g], g++, m.arrange(h.x - c.x, h.y - c.y, h.width, h.height))
                }
                a.ph = null
            }
        }
    };
    kn.prototype.ic = function (a, b, c) {
        var d = c.Hi;
        c.Hi = !0;
        var e = a.naturalBounds, f = e.width;
        e = e.height;
        b.save();
        b.beginPath();
        b.rect(-1, -1, f + 1, e + 1);
        b.clip();
        f = a.wb();
        f.ic(b, c);
        e = a.Mf() * c.scale;
        0 >= e && (e = 1);
        for (var g = f.actualBounds, h = a.$.j, k = a.Wj, l = h.length, m = 0; m < l; m++) {
            var n = h[m], p = k[m], r = p.length;
            if (n.visible && n !== f && 0 !== p.length) if (n instanceof Zf) {
                if (!(2 > a.graduatedTickUnit * n.interval * f.geometry.flattenedTotalLength / a.graduatedRange * e)) {
                    var q = n.measuredBounds, u = n.strokeWidth * n.scale, x = n.alignmentFocus;
                    x.Tb() &&
                    (x = Gc);
                    for (var y = 0; y < r; y++) {
                        var z = p[y].Wm, B = p[y].angle, D = x, G = n.vb;
                        G.reset();
                        G.translate(z.x + g.x, z.y + g.y);
                        G.rotate(B + n.angle, 0, 0);
                        G.translate(-q.width * D.x + D.offsetX + u / 2, -q.height * D.y + D.offsetY + u / 2);
                        G.scale(n.scale, n.scale);
                        Sl(n, !1);
                        n.ii.set(n.vb);
                        n.Al = n.scale;
                        Tl(n, !1);
                        n.ic(b, c);
                        n.vb.reset()
                    }
                }
            } else if (n instanceof kh) for (null === a.Jh && (a.Jh = new kh), q = a.Jh, ln(q, n), n = 0; n < r; n++) u = p[n], u.actualBounds && u.measuredBounds && u.naturalBounds && (q.$b = u.text || "", q.dc = u.VA || 0, q.ed = u.lineCount || 0, x = u.lines, void 0 !==
            x && (q.zb = x[0], q.Ni = x[1], q.ue = x[2], q.Ie = x[3], q.Wb = x[4], q.qb = x[5], q.se = x[6]), u.naturalBounds && (q.wc = u.naturalBounds), u.actualBounds && (x = u.actualBounds, q.arrange(x.x, x.y, x.width, x.height)), x = u.actualBounds, q.arrange(x.x, x.y, x.width, x.height), y = u.measuredBounds, u = u.naturalBounds, z = q.vb, z.reset(), z.translate(x.x + g.x, x.y + g.y), z.translate(-y.x, -y.y), Al(q, z, u.x, u.y, u.width, u.height), Sl(q, !1), q.ii.set(q.vb), q.Al = q.scale, Tl(q, !1), q.ic(b, c))
        }
        c.Hi = d;
        b.restore();
        b.Ac(!0)
    };

    function W(a) {
        N.call(this);
        void 0 === a ? this.sa = W.Position : (w(a, em, W, "type"), this.sa = a);
        null === this.sa && v("Panel type not specified or PanelLayout not loaded: " + a);
        this.$ = new H;
        this.ob = zc;
        this.sa === W.Grid && (this.isAtomic = !0);
        this.Wn = jd;
        this.dg = ml;
        this.sa === W.Table && on(this);
        this.yq = Qg;
        this.wo = Zb;
        this.xo = Ob;
        this.to = 0;
        this.so = 100;
        this.vo = 10;
        this.uo = 0;
        this.wi = this.sb = this.qh = this.ph = this.Wj = null;
        this.Ko = NaN;
        this.ze = this.Li = null;
        this.Vl = "category";
        this.Zd = null;
        this.Kg = new L(NaN, NaN, NaN, NaN);
        this.Jh = this.Sp =
            this.dj = null;
        this.Yg = ""
    }

    ma(W, N);

    function on(a) {
        a.Pj = zc;
        a.hh = 1;
        a.Ci = null;
        a.Bi = null;
        a.gh = 1;
        a.fh = null;
        a.Ai = null;
        a.Ab = [];
        a.xb = [];
        a.nk = pn;
        a.Mj = pn;
        a.gj = 0;
        a.Pi = 0
    }

    W.prototype.cloneProtected = function (a) {
        N.prototype.cloneProtected.call(this, a);
        a.sa = this.sa;
        a.ob = this.ob.J();
        a.Wn = this.Wn.J();
        a.dg = this.dg;
        if (a.sa === W.Table) {
            a.Pj = this.Pj.J();
            a.hh = this.hh;
            a.Ci = this.Ci;
            a.Bi = this.Bi;
            a.gh = this.gh;
            a.fh = this.fh;
            a.Ai = this.Ai;
            var b = [];
            if (0 < this.Ab.length) for (var c = this.Ab, d = c.length, e = 0; e < d; e++) if (void 0 !== c[e]) {
                var f = c[e].copy();
                f.Dj(a);
                b[e] = f
            }
            a.Ab = b;
            b = [];
            if (0 < this.xb.length) for (c = this.xb, d = c.length, e = 0; e < d; e++) void 0 !== c[e] && (f = c[e].copy(), f.Dj(a), b[e] = f);
            a.xb = b;
            a.nk =
                this.nk;
            a.Mj = this.Mj;
            a.gj = this.gj;
            a.Pi = this.Pi
        }
        a.yq = this.yq;
        a.wo = this.wo.J();
        a.xo = this.xo.J();
        a.to = this.to;
        a.so = this.so;
        a.vo = this.vo;
        a.uo = this.uo;
        a.Wj = this.Wj;
        a.qh = this.qh;
        a.sb = this.sb;
        a.wi = this.wi;
        a.Ko = this.Ko;
        a.Li = this.Li;
        a.ze = this.ze;
        a.Vl = this.Vl;
        a.Kg.assign(this.Kg);
        a.Yg = this.Yg;
        null !== this.Sp && (a.Sp = this.Sp)
    };
    W.prototype.Kf = function (a) {
        N.prototype.Kf.call(this, a);
        a.$ = this.$;
        for (var b = a.$.j, c = b.length, d = 0; d < c; d++) b[d].Bg = a;
        a.dj = null
    };
    W.prototype.copy = function () {
        var a = N.prototype.copy.call(this);
        if (null !== a) {
            for (var b = this.$.j, c = b.length, d = 0; d < c; d++) {
                var e = b[d].copy();
                e.Dj(a);
                e.kk = null;
                var f = a.$, g = f.count;
                f.Bb(g, e);
                f = a.part;
                if (null !== f) {
                    f.gk = null;
                    null !== e.portId && f instanceof V && (f.Xh = !0);
                    var h = a.diagram;
                    null !== h && h.undoManager.isUndoingRedoing || f.ib(Ne, "elements", a, null, e, null, g)
                }
            }
            return a
        }
        return null
    };
    t = W.prototype;
    t.toString = function () {
        return "Panel(" + this.type + ")#" + rb(this)
    };
    t.tp = function (a) {
        N.prototype.tp.call(this, a);
        for (var b = this.$.j, c = b.length, d = 0; d < c; d++) b[d].tp(a)
    };
    t.oj = function (a, b) {
        if (this.sa === W.Grid) this.sa.ic(this, a, b); else if (this.sa === W.Graduated) this.sa.ic(this, a, b); else {
            this.sa === W.Table && (a.lineCap = "butt", qn(this, a, !0, this.Ab, !0), qn(this, a, !1, this.xb, !0), rn(this, a, !0, this.Ab), rn(this, a, !1, this.xb), qn(this, a, !0, this.Ab, !1), qn(this, a, !1, this.xb, !1));
            var c = this.isClipping && this.sa === W.Spot;
            c && a.save();
            for (var d = this.wb(), e = this.$.j, f = e.length, g = 0; g < f; g++) {
                var h = e[g];
                c && h === d && (a.clipInsteadOfFill = !0);
                h.ic(a, b);
                c && h === d && (a.clipInsteadOfFill = !1)
            }
            c && (a.restore(),
                a.Ac(!0))
        }
    };

    function rn(a, b, c, d) {
        for (var e = d.length, f = a.actualBounds, g = a.naturalBounds, h = !0, k = 0; k < e; k++) {
            var l = d[k];
            if (void 0 !== l) if (h) h = !1; else if (0 !== l.actual) {
                if (c) {
                    if (l.position > f.height) continue
                } else if (l.position > f.width) continue;
                var m = l.separatorStrokeWidth;
                isNaN(m) && (m = c ? a.hh : a.gh);
                var n = l.separatorStroke;
                null === n && (n = c ? a.Ci : a.fh);
                if (0 !== m && null !== n) {
                    Ai(a, b, n, !1, !1, g, f);
                    n = !1;
                    var p = l.separatorDashArray;
                    null === p && (p = c ? a.Bi : a.Ai);
                    null !== p && (n = !0, b.Rt(p, 0));
                    b.beginPath();
                    p = l.position + m;
                    c ? p > f.height && (m -=
                        p - f.height) : p > f.width && (m -= p - f.width);
                    l = l.position + m / 2;
                    b.lineWidth = m;
                    m = a.ob;
                    c ? (l += m.top, p = f.width - m.right, b.moveTo(m.left, l), b.lineTo(p, l)) : (l += m.left, p = f.height - m.bottom, b.moveTo(l, m.top), b.lineTo(l, p));
                    b.stroke();
                    n && b.Pt()
                }
            }
        }
    }

    function qn(a, b, c, d, e) {
        for (var f = d.length, g = a.actualBounds, h = a.naturalBounds, k = 0; k < f; k++) {
            var l = d[k];
            if (void 0 !== l && null !== l.background && l.coversSeparators !== e && 0 !== l.actual) {
                var m = c ? g.height : g.width;
                if (!(l.position > m)) {
                    var n = l.Cc(), p = l.separatorStrokeWidth;
                    isNaN(p) && (p = c ? a.hh : a.gh);
                    var r = l.separatorStroke;
                    null === r && (r = c ? a.Ci : a.fh);
                    null === r && (p = 0);
                    n -= p;
                    p = l.position + p;
                    n += l.actual;
                    p + n > m && (n = m - p);
                    0 >= n || (m = a.ob, Ai(a, b, l.background, !0, !1, h, g), c ? b.fillRect(m.left, p + m.top, g.width - (m.left + m.right), n) : b.fillRect(p +
                        m.left, m.top, n, g.height - (m.top + m.bottom)))
                }
            }
        }
    }

    function kk(a) {
        return "LineV" === a || "BarV" === a
    }

    t.Ik = function (a, b, c, d, e) {
        var f = this.le(), g = this.transform, h = 1 / (g.m11 * g.m22 - g.m12 * g.m21), k = g.m22 * h, l = -g.m12 * h,
            m = -g.m21 * h, n = g.m11 * h, p = h * (g.m21 * g.dy - g.m22 * g.dx), r = h * (g.m12 * g.dx - g.m11 * g.dy);
        if (null !== this.areaBackground) return g = this.actualBounds, K.Of(g.left, g.top, g.right, g.bottom, a, b, c, d, e);
        if (null !== this.background) return f = a * k + b * m + p, h = a * l + b * n + r, a = c * k + d * m + p, k = c * l + d * n + r, e.h(0, 0), c = this.naturalBounds, f = K.Of(0, 0, c.width, c.height, f, h, a, k, e), e.transform(g), f;
        f || (k = 1, m = l = 0, n = 1, r = p = 0);
        h = a * k + b * m + p;
        a = a * l + b *
            n + r;
        k = c * k + d * m + p;
        c = c * l + d * n + r;
        e.h(k, c);
        d = (k - h) * (k - h) + (c - a) * (c - a);
        l = !1;
        n = this.$.j;
        r = n.length;
        m = J.alloc();
        p = null;
        b = Infinity;
        var q = null, u = this.isClipping && this.sa === W.Spot;
        u && (q = J.alloc(), p = this.wb(), (l = p.Ik(h, a, k, c, q)) && (b = (h - q.x) * (h - q.x) + (a - q.y) * (a - q.y)));
        for (var x = 0; x < r; x++) {
            var y = n[x];
            y.visible && y !== p && y.Ik(h, a, k, c, m) && (l = !0, y = (h - m.x) * (h - m.x) + (a - m.y) * (a - m.y), y < d && (d = y, e.set(m)))
        }
        u && (b > d && e.set(q), J.free(q));
        J.free(m);
        f && e.transform(g);
        return l
    };
    t.v = function (a) {
        if (!0 !== Hj(this)) {
            N.prototype.v.call(this, a);
            a = null;
            if (this.sa === W.Auto || this.sa === W.Link) a = this.wb();
            for (var b = this.$.j, c = b.length, d = 0; d < c; d++) {
                var e = b[d];
                (e === a || e.isPanelMain) && e.v(!0);
                if (!e.desiredSize.o()) {
                    var f = Cl(e, !1);
                    (e instanceof Mg || e instanceof W || e instanceof kh || f !== Og) && e.v(!0)
                }
            }
        }
    };
    t.Pm = function () {
        if (!1 === Hj(this)) {
            Cj(this, !0);
            Dl(this, !0);
            for (var a = this.$.j, b = a.length, c = 0; c < b; c++) a[c].Pm()
        }
    };
    t.Rl = function () {
        if (0 !== (this.I & 2048) === !1) {
            Sl(this, !0);
            Tl(this, !0);
            for (var a = this.$.j, b = a.length, c = 0; c < b; c++) a[c].pw()
        }
    };
    t.pw = function () {
        Tl(this, !0);
        for (var a = this.$.j, b = a.length, c = 0; c < b; c++) a[c].pw()
    };
    t.Tm = function (a, b, c, d) {
        var e = this.Kg;
        e.h(0, 0, 0, 0);
        var f = this.desiredSize, g = this.minSize;
        void 0 === c && (c = g.width, d = g.height);
        c = Math.max(c, g.width);
        d = Math.max(d, g.height);
        var h = this.maxSize;
        isNaN(f.width) || (a = Math.min(f.width, h.width));
        isNaN(f.height) || (b = Math.min(f.height, h.height));
        a = Math.max(c, a);
        b = Math.max(d, b);
        var k = this.ob;
        a = Math.max(a - k.left - k.right, 0);
        b = Math.max(b - k.top - k.bottom, 0);
        var l = this.$.j;
        0 !== l.length && this.sa.measure(this, a, b, l, e, c, d);
        a = e.width + k.left + k.right;
        k = e.height + k.top + k.bottom;
        isFinite(f.width) && (a = f.width);
        isFinite(f.height) && (k = f.height);
        a = Math.min(h.width, a);
        k = Math.min(h.height, k);
        a = Math.max(g.width, a);
        k = Math.max(g.height, k);
        a = Math.max(c, a);
        k = Math.max(d, k);
        ec(e, a, k);
        ec(this.naturalBounds, a, k);
        zl(this, 0, 0, a, k)
    };
    t.wb = function () {
        if (null === this.dj) {
            var a = this.$.j, b = a.length;
            if (0 === b) return null;
            for (var c = 0; c < b; c++) {
                var d = a[c];
                if (!0 === d.isPanelMain) return this.dj = d
            }
            this.dj = a[0]
        }
        return this.dj
    };

    function Om(a) {
        return null !== a.part ? a.part.locationObject : null
    }

    t.Sh = function (a, b, c, d) {
        var e = this.$.j;
        this.actualBounds.h(a, b, c, d);
        if (0 !== e.length) {
            if (!this.desiredSize.o()) {
                a = Cl(this, !0);
                var f = this.measuredBounds;
                b = f.width;
                f = f.height;
                var g = this.vh, h = g.left + g.right;
                g = g.top + g.bottom;
                b === c && f === d && (a = Og);
                switch (a) {
                    case Og:
                        if (b > c || f > d) this.v(), this.measure(b > c ? c : b, f > d ? d : f, 0, 0);
                        break;
                    case Jd:
                        this.v(!0);
                        this.measure(c + h, d + g, 0, 0);
                        break;
                    case nl:
                        this.v(!0);
                        this.measure(c + h, f + g, 0, 0);
                        break;
                    case ol:
                        this.v(!0), this.measure(b + h, d + g, 0, 0)
                }
            }
            this.sa.arrange(this, e, this.Kg)
        }
    };
    t.Uh = function (a) {
        var b = this.naturalBounds, c = Om(this);
        if (pc(0, 0, b.width, b.height, a.x, a.y)) {
            b = this.$.j;
            for (var d = b.length, e = J.allocAt(0, 0); d--;) {
                var f = b[d];
                if (f.visible || f === c) if (Jb(e.set(a), f.transform), f.ca(e)) return J.free(e), !0
            }
            J.free(e);
            return null === this.rb && null === this.kc ? !1 : !0
        }
        return !1
    };
    t.St = function (a) {
        if (this.nl === a) return this;
        for (var b = this.$.j, c = b.length, d = 0; d < c; d++) {
            var e = b[d].St(a);
            if (null !== e) return e
        }
        return null
    };
    t.cl = function (a, b) {
        b(this, a);
        if (a instanceof W) {
            a = a.$.j;
            for (var c = a.length, d = 0; d < c; d++) this.cl(a[d], b)
        }
    };

    function Uj(a, b) {
        sn(a, a, b)
    }

    function sn(a, b, c) {
        c(b);
        b = b.$.j;
        for (var d = b.length, e = 0; e < d; e++) {
            var f = b[e];
            f instanceof W && sn(a, f, c)
        }
    }

    function tn(a, b) {
        un(a, a, b)
    }

    function un(a, b, c) {
        c(b);
        if (b instanceof W) {
            b = b.$.j;
            for (var d = b.length, e = 0; e < d; e++) un(a, b[e], c)
        }
    }

    t.Jm = function (a) {
        return vn(this, this, a)
    };

    function vn(a, b, c) {
        if (c(b)) return b;
        if (b instanceof W) {
            b = b.$.j;
            for (var d = b.length, e = 0; e < d; e++) {
                var f = vn(a, b[e], c);
                if (null !== f) return f
            }
        }
        return null
    }

    t.hb = function (a) {
        if (this.name === a) return this;
        var b = this.$.j, c = b.length;
        null === this.Li && null === this.ze || (c = wn(this));
        for (var d = 0; d < c; d++) {
            var e = b[d];
            if (e instanceof W) {
                var f = e.hb(a);
                if (null !== f) return f
            }
            if (e.name === a) return e
        }
        return null
    };

    function xn(a) {
        a = a.$.j;
        for (var b = a.length, c = 0, d = 0; d < b; d++) {
            var e = a[d];
            e instanceof W ? c = Math.max(c, xn(e)) : e instanceof Zf && (c = Math.max(c, e.Hh / 2 * e.rk * e.Mf()))
        }
        return c
    }

    t.le = function () {
        return !(this.type === W.TableRow || this.type === W.TableColumn)
    };
    t.ac = function (a, b, c) {
        if (!1 === this.pickable) return null;
        void 0 === b && (b = null);
        void 0 === c && (c = null);
        if (Ij(this)) return null;
        var d = this.naturalBounds, e = 1 / this.Mf(), f = this.le(),
            g = f ? a : Jb(J.allocAt(a.x, a.y), this.transform), h = this.diagram, k = 10, l = 5;
        null !== h && (k = h.Nm("extraTouchArea"), l = k / 2);
        if (pc(-(l * e), -(l * e), d.width + k * e, d.height + k * e, g.x, g.y)) {
            if (!this.isAtomic) {
                e = this.$.j;
                var m = e.length;
                h = J.alloc();
                l = (k = this.isClipping && this.sa === W.Spot) ? this.wb() : null;
                if (k && (l.le() ? Jb(h.set(a), l.transform) : h.set(a), !l.ca(h))) return J.free(h),
                f || J.free(g), null;
                for (var n = Om(this); m--;) {
                    var p = e[m];
                    if (p.visible || p === n) if (p.le() ? Jb(h.set(a), p.transform) : h.set(a), !k || p !== l) {
                        var r = null;
                        p instanceof W ? r = p.ac(h, b, c) : !0 === p.pickable && p.ca(h) && (r = p);
                        if (null !== r && (null !== b && (r = b(r)), null !== r && (null === c || c(r)))) return J.free(h), f || J.free(g), r
                    }
                }
                J.free(h)
            }
            if (null === this.background && null === this.areaBackground) return f || J.free(g), null;
            a = pc(0, 0, d.width, d.height, g.x, g.y) ? this : null;
            f || J.free(g);
            return a
        }
        f || J.free(g);
        return null
    };
    t.rj = function (a, b, c, d) {
        if (!1 === this.pickable) return !1;
        void 0 === b && (b = null);
        void 0 === c && (c = null);
        var e = this.naturalBounds, f = this.le(), g = f ? a : Jb(J.allocAt(a.x, a.y), this.transform),
            h = this.type === W.TableRow || this.type === W.TableColumn;
        e = pc(0, 0, e.width, e.height, g.x, g.y);
        if (h || e) {
            if (!this.isAtomic) {
                h = this.$.j;
                for (var k = h.length, l = J.alloc(), m = Om(this); k--;) {
                    var n = h[k];
                    if (n.visible || n === m) {
                        n.le() ? Jb(l.set(a), n.transform) : l.set(a);
                        var p = n;
                        n = n instanceof W ? n : null;
                        (null !== n ? n.rj(l, b, c, d) : p.ca(l)) && !1 !== p.pickable &&
                        (null !== b && (p = b(p)), null === p || null !== c && !c(p) || d.add(p))
                    }
                }
                J.free(l)
            }
            f || J.free(g);
            return e && (null !== this.background || null !== this.areaBackground)
        }
        f || J.free(g);
        return !1
    };
    t.Lf = function (a, b, c, d, e, f) {
        if (!1 === this.pickable) return !1;
        void 0 === b && (b = null);
        void 0 === c && (c = null);
        var g = f;
        void 0 === f && (g = Ib.alloc(), g.reset());
        g.multiply(this.transform);
        if (this.Th(a, g)) return yn(this, b, c, e), void 0 === f && Ib.free(g), !0;
        if (this.Sc(a, g)) {
            if (!this.isAtomic) for (var h = Om(this), k = this.$.j, l = k.length; l--;) {
                var m = k[l];
                if (m.visible || m === h) {
                    var n = m.actualBounds, p = this.naturalBounds;
                    if (!(n.x > p.width || n.y > p.height || 0 > n.x + n.width || 0 > n.y + n.height)) {
                        n = m;
                        m = m instanceof W ? m : null;
                        p = Ib.alloc();
                        p.set(g);
                        if (null !== m ? m.Lf(a, b, c, d, e, p) : Bl(n, a, d, p)) null !== b && (n = b(n)), null === n || null !== c && !c(n) || e.add(n);
                        Ib.free(p)
                    }
                }
            }
            void 0 === f && Ib.free(g);
            return d
        }
        void 0 === f && Ib.free(g);
        return !1
    };

    function yn(a, b, c, d) {
        for (var e = a.$.j, f = e.length; f--;) {
            var g = e[f];
            if (g.visible) {
                var h = g.actualBounds, k = a.naturalBounds;
                h.x > k.width || h.y > k.height || 0 > h.x + h.width || 0 > h.y + h.height || (g instanceof W && yn(g, b, c, d), null !== b && (g = b(g)), null === g || null !== c && !c(g) || d.add(g))
            }
        }
    }

    t.Rg = function (a, b, c, d, e, f) {
        if (!1 === this.pickable) return !1;
        void 0 === c && (c = null);
        void 0 === d && (d = null);
        var g = this.naturalBounds, h = this.le(), k = h ? a : Jb(J.allocAt(a.x, a.y), this.transform),
            l = h ? b : Jb(J.allocAt(b.x, b.y), this.transform), m = k.Re(l),
            n = 0 < k.x && k.x < g.width && 0 < k.y && k.y < g.height || Kb(k.x, k.y, 0, 0, 0, g.height) <= m || Kb(k.x, k.y, 0, g.height, g.width, g.height) <= m || Kb(k.x, k.y, g.width, g.height, g.width, 0) <= m || Kb(k.x, k.y, g.width, 0, 0, 0) <= m;
        g = k.ud(0, 0) <= m && k.ud(0, g.height) <= m && k.ud(g.width, 0) <= m && k.ud(g.width, g.height) <=
            m;
        h || (J.free(k), J.free(l));
        if (n) {
            if (!this.isAtomic) {
                k = J.alloc();
                l = J.alloc();
                m = Om(this);
                for (var p = this.$.j, r = p.length; r--;) {
                    var q = p[r];
                    if (q.visible || q === m) {
                        var u = q.actualBounds, x = this.naturalBounds;
                        if (!h || !(u.x > x.width || u.y > x.height || 0 > u.x + u.width || 0 > u.y + u.height)) if (q.le() ? (u = q.transform, Jb(k.set(a), u), Jb(l.set(b), u)) : (k.set(a), l.set(b)), u = q, q = q instanceof W ? q : null, null !== q ? q.Rg(k, l, c, d, e, f) : u.Gy(k, l, e)) null !== c && (u = c(u)), null === u || null !== d && !d(u) || f.add(u)
                    }
                }
                J.free(k);
                J.free(l)
            }
            return e ? n : g
        }
        return !1
    };

    function Tm(a) {
        var b = null;
        a instanceof Zf && (b = a.spot1, b === jd && (b = null), a = a.geometry, null !== a && null === b && (b = a.spot1));
        null === b && (b = Fc);
        return b
    }

    function Um(a) {
        var b = null;
        a instanceof Zf && (b = a.spot2, b === jd && (b = null), a = a.geometry, null !== a && null === b && (b = a.spot2));
        null === b && (b = Rc);
        return b
    }

    t.add = function (a) {
        w(a, N, W, "add:element");
        this.Bb(this.$.count, a)
    };
    t.M = function (a) {
        return this.$.M(a)
    };
    t.Bb = function (a, b) {
        b instanceof T && v("Cannot add a Part to a Panel: " + b + "; use a Panel instead");
        if (this === b || this.Tg(b)) this === b && v("Cannot make a Panel contain itself: " + this.toString()), v("Cannot make a Panel indirectly contain itself: " + this.toString() + " already contains " + b.toString());
        var c = b.panel;
        null !== c && c !== this && v("Cannot add a GraphObject that already belongs to another Panel to this Panel: " + b.toString() + ", already contained by " + c.toString() + ", cannot be shared by this Panel: " + this.toString());
        this.sa !== W.Grid || b instanceof Zf || v("Can only add Shapes to a Grid Panel, not: " + b);
        this.sa !== W.Graduated || b instanceof Zf || b instanceof kh || v("Can only add Shapes or TextBlocks to a Graduated Panel, not: " + b);
        b.Dj(this);
        b.kk = null;
        if (null !== this.itemArray) {
            var d = b.data;
            null !== d && "object" === typeof d && (null === this.Zd && (this.Zd = new Db), this.Zd.add(d, b))
        }
        var e = this.$;
        d = -1;
        if (c === this) {
            for (var f = -1, g = this.$.j, h = g.length, k = 0; k < h; k++) if (g[k] === b) {
                f = k;
                break
            }
            if (-1 !== f) {
                if (f === a || f + 1 >= e.count && a >= e.count) return;
                e.jb(f);
                d = f
            } else v("element " + b.toString() + " has panel " + c.toString() + " but is not contained by it.")
        }
        if (0 > a || a > e.count) a = e.count;
        e.Bb(a, b);
        if (0 === a || b.isPanelMain) this.dj = null;
        Hj(this) || this.v();
        b.v(!1);
        null !== b.portId ? this.Xh = !0 : b instanceof W && !0 === b.Xh && (this.Xh = !0);
        this.qh = null;
        c = this.part;
        null !== c && (c.gk = null, c.wh = NaN, this.Xh && c instanceof V && (c.Xh = !0), c.Xh && c instanceof V && (c.zc = null), e = this.diagram, null !== e && e.undoManager.isUndoingRedoing || (-1 !== d && c.ib(Oe, "elements", this, b, null, d, null), c.ib(Ne,
            "elements", this, null, b, null, a), this.Ug() || zn(this, b, !1)))
    };

    function An(a, b) {
        a.I = b ? a.I | 16777216 : a.I & -16777217
    }

    t.remove = function (a) {
        w(a, N, W, "remove:element");
        for (var b = this.$.j, c = b.length, d = -1, e = 0; e < c; e++) if (b[e] === a) {
            d = e;
            break
        }
        -1 !== d && this.Rc(d, !0)
    };
    t.jb = function (a) {
        F && C(a, W, "removeAt:idx");
        0 <= a && this.Rc(a, !0)
    };
    t.Rc = function (a, b) {
        var c = this.$, d = c.M(a);
        d.kk = null;
        d.Dj(null);
        if (null !== this.Zd) {
            var e = d.data;
            "object" === typeof e && this.Zd.remove(e)
        }
        c.jb(a);
        Cj(this, !1);
        this.v();
        this.dj === d && (this.dj = null);
        this.qh = null;
        var f = this.part;
        null !== f && (f.gk = null, f.wh = NaN, f.Sb(), f instanceof V && (d instanceof W ? d.cl(d, function (a, c) {
            im(f, c, b)
        }) : im(f, d, b)), c = this.diagram, null !== c && c.undoManager.isUndoingRedoing || f.ib(Oe, "elements", this, d, null, a, null))
    };
    W.prototype.getRowDefinition = function (a) {
        F && C(a, W, "getRowDefinition:idx");
        0 > a && za(a, ">= 0", W, "getRowDefinition:idx");
        a = Math.round(a);
        var b = this.Ab;
        if (void 0 === b) return null;
        if (void 0 === b[a]) {
            var c = new ik;
            c.Dj(this);
            c.isRow = !0;
            c.index = a;
            b[a] = c
        }
        return b[a]
    };
    W.prototype.Gw = function (a) {
        F && C(a, W, "removeRowDefinition:idx");
        0 > a && za(a, ">= 0", W, "removeRowDefinition:idx");
        a = Math.round(a);
        var b = this.Ab;
        void 0 !== b && (this.ib(Oe, "coldefs", this, b[a], null, a, null), b[a] && delete b[a], this.v())
    };
    W.prototype.getColumnDefinition = function (a) {
        F && C(a, W, "getColumnDefinition:idx");
        0 > a && za(a, ">= 0", W, "getColumnDefinition:idx");
        a = Math.round(a);
        var b = this.xb;
        if (void 0 === b) return null;
        if (void 0 === b[a]) {
            var c = new ik;
            c.Dj(this);
            c.isRow = !1;
            c.index = a;
            b[a] = c
        }
        return b[a]
    };
    t = W.prototype;
    t.Ew = function (a) {
        F && C(a, W, "removeColumnDefinition:idx");
        0 > a && za(a, ">= 0", W, "removeColumnDefinition:idx");
        a = Math.round(a);
        var b = this.xb;
        void 0 !== b && (this.ib(Oe, "coldefs", this, b[a], null, a, null), b[a] && delete b[a], this.v())
    };
    t.sA = function (a) {
        if (0 > a || this.type !== W.Table) return -1;
        for (var b = 0, c = this.Ab, d = c.length, e = this.gj; e < d; e++) {
            var f = c[e];
            if (void 0 !== f && (b += f.total, a < b)) break
        }
        return e
    };
    t.kA = function (a) {
        if (0 > a || this.type !== W.Table) return -1;
        for (var b = 0, c = this.xb, d = c.length, e = this.Pi; e < d; e++) {
            var f = c[e];
            if (void 0 !== f && (b += f.total, a < b)) break
        }
        return e
    };
    t.IA = function (a, b) {
        void 0 === b && (b = new J(NaN, NaN));
        if (this.type !== W.Graduated) return b.h(NaN, NaN), b;
        a = Math.min(Math.max(a, this.graduatedMin), this.graduatedMax);
        var c = this.wb();
        c.geometry.iw((a - this.graduatedMin) / this.graduatedRange, b);
        return c.transform.ya(b)
    };
    t.JA = function (a) {
        if (this.type !== W.Graduated) return NaN;
        var b = this.wb();
        b.transform.Kd(a);
        return b.geometry.Ky(a) * this.graduatedRange + this.graduatedMin
    };

    function $l(a) {
        a = a.wi;
        return null !== a && a.s
    }

    function Ng(a) {
        var b = a.wi;
        if (null === b) null !== a.data && v("Template cannot have .data be non-null: " + a), a.wi = b = new H; else if (b.s) return;
        var c = new H;
        An(a, !1);
        a.cl(a, function (a, d) {
            var e = d.lb;
            if (null !== e) for (Xl(d, !1), e = e.iterator; e.next();) {
                var f = e.value;
                f.mode === Bn && Xl(d, !0);
                var g = f.sourceName;
                null !== g && ("/" === g && An(a, !0), g = yl(f, a, d), null !== g && (c.add(g), null === g.sm && (g.sm = new H), g.sm.add(f)));
                b.add(f)
            }
            if (d instanceof W && d.type === W.Table) {
                if (0 < d.Ab.length) for (a = d.Ab, e = a.length, f = 0; f < e; f++) if (g = a[f], void 0 !==
                g && null !== g.lb) for (var h = g.lb.iterator; h.next();) {
                    var k = h.value;
                    k.td = g;
                    k.qq = 2;
                    k.ym = g.index;
                    b.add(k)
                }
                if (0 < d.xb.length) for (d = d.xb, a = d.length, e = 0; e < a; e++) if (f = d[e], void 0 !== f && null !== f.lb) for (g = f.lb.iterator; g.next();) h = g.value, h.td = f, h.qq = 1, h.ym = f.index, b.add(h)
            }
        });
        for (var d = c.iterator; d.next();) {
            var e = d.value;
            if (null !== e.sm) {
                Xl(e, !0);
                for (var f = e.sm.iterator; f.next();) {
                    var g = f.value;
                    null === e.lb && (e.lb = new H);
                    e.lb.add(g)
                }
            }
            e.sm = null
        }
        for (var h = b.iterator; h.next();) if (d = h.value, e = d.td, null !== e) {
            d.td = null;
            g = d.targetProperty;
            var k = g.indexOf(".");
            0 < k && e instanceof W && (f = g.substring(0, k), g = g.substr(k + 1), k = e.hb(f), null !== k ? (e = k, d.targetProperty = g) : Ea('Warning: unable to find GraphObject named "' + f + '" for Binding: ' + d.toString()));
            e instanceof ik ? (f = rb(e.panel), d.Hj = void 0 === f ? -1 : f, e.panel.nl = d.Hj) : e instanceof N ? (f = rb(e), d.Hj = void 0 === f ? -1 : f, e.nl = d.Hj) : v("Unknown type of binding target: " + e)
        }
        b.freeze();
        a instanceof T && (a.Tc() && a.Ya(), F && !Cn && a.cl(a, function (a, c) {
            if (c instanceof W && (c.type === W.Auto || c.type ===
                W.Spot || c.type === W.Graduated) && 1 >= c.elements.count && !(c instanceof T)) {
                var d = !1;
                if (1 === c.elements.count && (d = null !== c.itemArray, !d)) for (h = b.iterator; h.next();) if ("itemArray" === h.value.targetProperty) {
                    d = !0;
                    break
                }
                d || (Ea("Auto, Spot, or Graduated Panel should not have zero or one elements: " + c.toString() + " in " + a.toString()), Cn = !0)
            }
        }))
    }

    t.Vz = function (a) {
        void 0 === a && (a = !1);
        var b = this.copy();
        tn(b, function (a) {
            a instanceof W && (a.wi = null, a.sb = null);
            var b = a.lb;
            null !== b && (a.lb = null, b.each(function (b) {
                a.bind(b.copy())
            }));
            b = a.Zg;
            null !== b && (a.Zg = null, b.each(function (b) {
                a.bx(b.value.copy())
            }))
        });
        a && Ng(b);
        return b
    };
    t.Ha = function (a) {
        var b = this.wi;
        if (null !== b) for (void 0 === a && (a = ""), b = b.iterator; b.next();) {
            var c = b.value, d = c.sourceProperty;
            if ("" === a || "" === d || d === a) if (d = c.targetProperty, null !== c.converter || "" !== d) {
                d = this.data;
                var e = c.sourceName;
                if (null !== e) d = "" === e ? this : "/" === e ? this : "." === e ? this : ".." === e ? this : this.hb(e); else {
                    var f = this.diagram;
                    null !== f && c.isToModel && (d = f.model.modelData)
                }
                if (null === d) F && Ea("Binding error: missing GraphObject named " + e + " in " + this.toString()); else {
                    f = this;
                    var g = c.Hj;
                    if (-1 !== g) {
                        if (f =
                            this.St(g), null === f) continue
                    } else null !== c.td && (f = c.td);
                    "/" === e ? d = f.part : "." === e ? d = f : ".." === e && (d = f.panel);
                    e = c.qq;
                    if (0 !== e) {
                        if (!(f instanceof W)) continue;
                        1 === e ? f = f.getColumnDefinition(c.ym) : 2 === e && (f = f.getRowDefinition(c.ym))
                    }
                    void 0 !== f && c.hx(f, d)
                }
            }
        }
    };

    function Dn(a, b) {
        a = a.$.j;
        for (var c = a.length, d = b.length, e = 0, f = null; e < c && !(f = a[e], f instanceof W && null !== f.data);) e++, f = a[e];
        if (c - e !== d) return !0;
        if (null === f) return 0 < d;
        for (var g = 0; e < c && g < d;) {
            f = a[e];
            if (!(f instanceof W) || f.data !== b[g]) return !0;
            e++;
            g++
        }
        return !1
    }

    function wn(a) {
        if (a.type === W.Spot || a.type === W.Auto) return Math.min(a.$.length, 1);
        if (a.type === W.Link) {
            a = a.$;
            for (var b = a.length, c = 0; c < b; c++) {
                var d = a.M(c);
                if (!(d instanceof Zf && d.isPanelMain)) break
            }
            return c
        }
        return a.type === W.Table && 0 < a.$.length && (a = a.$.M(0), a.isPanelMain && a instanceof W && (a.type === W.TableRow || a.type === W.TableColumn)) ? 1 : 0
    }

    t.pu = function () {
        for (var a = wn(this); this.$.length > a;) this.Rc(this.$.length - 1, !1);
        a = this.itemArray;
        if (null !== a) for (var b = a.length, c = 0; c < b; c++) En(this, a[c], c)
    };
    t.Fy = function (a) {
        if (void 0 === a || null === a || null === this.Zd) return null;
        A(a, "object", W, "findItemPanelForData");
        return this.Zd.K(a)
    };

    function En(a, b, c) {
        if (!(void 0 === b || null === b || 0 > c)) {
            var d = Fn(a, b), e = a.itemTemplateMap, f = null;
            null !== e && (f = e.K(d));
            null === f && (Gn || (Gn = !0, Ea('No item template Panel found for category "' + d + '" on ' + a), Ea("  Using default item template."), d = new W, e = new kh, e.bind(new Ti("text", "", Qa)), d.add(e), Hn = d), f = Hn);
            d = f;
            null !== d && (Ng(d), d = d.copy(), 0 !== (d.I & 16777216) && (e = a.sj(), null !== e && An(e, !0)), "object" === typeof b && (null === a.Zd && (a.Zd = new Db), a.Zd.add(b, d)), e = c + wn(a), a.Bb(e, d), d.sb = b, In(a, e, c), d.sb = null, d.data =
                b)
        }
    }

    function In(a, b, c) {
        for (a = a.$; b < a.length;) {
            var d = a.M(b);
            if (d instanceof W) {
                var e = b, f = c;
                d.type === W.TableRow ? d.row = e : d.type === W.TableColumn && (d.column = e);
                d.itemIndex = f
            }
            b++;
            c++
        }
    }

    function Fn(a, b) {
        if (null === b) return "";
        a = a.Vl;
        if ("function" === typeof a) a = a(b); else if ("string" === typeof a && "object" === typeof b) {
            if ("" === a) return "";
            a = Jn(b, a)
        } else return "";
        if (void 0 === a) return "";
        if ("string" === typeof a) return a;
        v("Panel.getCategoryForItemData found a non-string category for " + b + ": " + a);
        return ""
    }

    function zn(a, b, c) {
        var d = b.enabledChanged;
        null !== d && d(b, c);
        if (b instanceof W) {
            b = b.$.j;
            d = b.length;
            for (var e = 0; e < d; e++) {
                var f = b[e];
                c && f instanceof W && !f.isEnabled || zn(a, f, c)
            }
        }
    }

    function Kn(a, b) {
        b.name = a;
        dm.add(a, b)
    }

    na.Object.defineProperties(W.prototype, {
        type: {
            configurable: !0, get: function () {
                return this.sa
            }, set: function (a) {
                var b = this.sa;
                b !== a && (this.sa = a, this.sa === W.Grid ? this.isAtomic = !0 : this.sa === W.Table && on(this), this.v(), this.g("type", b, a))
            }
        }, elements: {
            configurable: !0, get: function () {
                return this.$.iterator
            }
        }, naturalBounds: {
            configurable: !0, get: function () {
                return this.wc
            }
        }, padding: {
            configurable: !0, get: function () {
                return this.ob
            }, set: function (a) {
                "number" ===
                typeof a ? (0 > a && za(a, ">= 0", W, "padding"), a = new jc(a)) : (w(a, jc, W, "padding"), 0 > a.left && za(a.left, ">= 0", W, "padding:value.left"), 0 > a.right && za(a.right, ">= 0", W, "padding:value.right"), 0 > a.top && za(a.top, ">= 0", W, "padding:value.top"), 0 > a.bottom && za(a.bottom, ">= 0", W, "padding:value.bottom"));
                var b = this.ob;
                b.A(a) || (this.ob = a = a.J(), this.v(), this.g("padding", b, a))
            }
        }, defaultAlignment: {
            configurable: !0, get: function () {
                return this.Wn
            }, set: function (a) {
                var b = this.Wn;
                b.A(a) || (F && w(a, M, W, "defaultAlignment"),
                    this.Wn = a = a.J(), this.v(), this.g("defaultAlignment", b, a))
            }
        }, defaultStretch: {
            configurable: !0, get: function () {
                return this.dg
            }, set: function (a) {
                var b = this.dg;
                b !== a && (ib(a, N, W, "defaultStretch"), this.dg = a, this.v(), this.g("defaultStretch", b, a))
            }
        }, defaultSeparatorPadding: {
            configurable: !0, get: function () {
                return void 0 === this.Pj ? zc : this.Pj
            }, set: function (a) {
                if (void 0 !== this.Pj) {
                    "number" === typeof a ? a = new jc(a) : F && w(a, jc, W, "defaultSeparatorPadding");
                    var b = this.Pj;
                    b.A(a) || (this.Pj = a = a.J(),
                        this.v(), this.g("defaultSeparatorPadding", b, a))
                }
            }
        }, defaultRowSeparatorStroke: {
            configurable: !0, get: function () {
                return void 0 === this.Ci ? null : this.Ci
            }, set: function (a) {
                var b = this.Ci;
                b !== a && (null === a || "string" === typeof a || a instanceof Ll) && (a instanceof Ll && a.freeze(), this.Ci = a, this.P(), this.g("defaultRowSeparatorStroke", b, a))
            }
        }, defaultRowSeparatorStrokeWidth: {
            configurable: !0, get: function () {
                return void 0 === this.hh ? 1 : this.hh
            }, set: function (a) {
                if (void 0 !== this.hh) {
                    var b = this.hh;
                    b !== a && isFinite(a) && 0 <= a && (this.hh = a, this.v(), this.g("defaultRowSeparatorStrokeWidth", b, a))
                }
            }
        }, defaultRowSeparatorDashArray: {
            configurable: !0, get: function () {
                return void 0 === this.Bi ? null : this.Bi
            }, set: function (a) {
                if (void 0 !== this.Bi) {
                    var b = this.Bi;
                    if (b !== a) {
                        null === a || Array.isArray(a) || xa(a, "Array", W, "defaultRowSeparatorDashArray:value");
                        if (null !== a) {
                            for (var c = a.length, d = 0, e = 0; e < c; e++) {
                                var f = a[e];
                                "number" === typeof f && 0 <= f && isFinite(f) || v("defaultRowSeparatorDashArray value " + f + " at index " +
                                    e + " must be a positive number or zero.");
                                d += f
                            }
                            if (0 === d) {
                                if (null === b) return;
                                a = null
                            }
                        }
                        this.Bi = a;
                        this.P();
                        this.g("defaultRowSeparatorDashArray", b, a)
                    }
                }
            }
        }, defaultColumnSeparatorStroke: {
            configurable: !0, get: function () {
                return void 0 === this.fh ? null : this.fh
            }, set: function (a) {
                if (void 0 !== this.fh) {
                    var b = this.fh;
                    b !== a && (null === a || "string" === typeof a || a instanceof Ll) && (a instanceof Ll && a.freeze(), this.fh = a, this.P(), this.g("defaultColumnSeparatorStroke", b, a))
                }
            }
        }, defaultColumnSeparatorStrokeWidth: {
            configurable: !0,
            enumerable: !0, get: function () {
                return void 0 === this.gh ? 1 : this.gh
            }, set: function (a) {
                if (void 0 !== this.gh) {
                    var b = this.gh;
                    b !== a && isFinite(a) && 0 <= a && (this.gh = a, this.v(), this.g("defaultColumnSeparatorStrokeWidth", b, a))
                }
            }
        }, defaultColumnSeparatorDashArray: {
            configurable: !0, get: function () {
                return void 0 === this.Ai ? null : this.Ai
            }, set: function (a) {
                if (void 0 !== this.Ai) {
                    var b = this.Ai;
                    if (b !== a) {
                        null === a || Array.isArray(a) || xa(a, "Array", W, "defaultColumnSeparatorDashArray:value");
                        if (null !== a) {
                            for (var c = a.length,
                                     d = 0, e = 0; e < c; e++) {
                                var f = a[e];
                                "number" === typeof f && 0 <= f && isFinite(f) || v("defaultColumnSeparatorDashArray value " + f + " at index " + e + " must be a positive number or zero.");
                                d += f
                            }
                            if (0 === d) {
                                if (null === b) return;
                                a = null
                            }
                        }
                        this.Ai = a;
                        this.P();
                        this.g("defaultColumnSeparatorDashArray", b, a)
                    }
                }
            }
        }, viewboxStretch: {
            configurable: !0, get: function () {
                return this.yq
            }, set: function (a) {
                var b = this.yq;
                b !== a && (ib(a, N, W, "viewboxStretch"), this.yq = a, this.v(), this.g("viewboxStretch", b, a))
            }
        }, gridCellSize: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.wo
            }, set: function (a) {
                var b = this.wo;
                if (!b.A(a)) {
                    w(a, Hb, W, "gridCellSize");
                    a.o() && 0 !== a.width && 0 !== a.height || v("Invalid Panel.gridCellSize: " + a);
                    this.wo = a.J();
                    var c = this.diagram;
                    null !== c && this === c.grid && Dj(c);
                    this.P();
                    this.g("gridCellSize", b, a)
                }
            }
        }, gridOrigin: {
            configurable: !0, get: function () {
                return this.xo
            }, set: function (a) {
                var b = this.xo;
                if (!b.A(a)) {
                    w(a, J, W, "gridOrigin");
                    a.o() || v("Invalid Panel.gridOrigin: " + a);
                    this.xo = a.J();
                    var c = this.diagram;
                    null !==
                    c && this === c.grid && Dj(c);
                    this.P();
                    this.g("gridOrigin", b, a)
                }
            }
        }, graduatedMin: {
            configurable: !0, get: function () {
                return this.to
            }, set: function (a) {
                C(a, W, "graduatedMin");
                var b = this.to;
                b !== a && (this.to = a, this.v(), this.g("graduatedMin", b, a), wl(this) && (a = this.part, null !== a && xl(this, a, "graduatedRange")))
            }
        }, graduatedMax: {
            configurable: !0, get: function () {
                return this.so
            }, set: function (a) {
                C(a, W, "graduatedMax");
                var b = this.so;
                b !== a && (this.so = a, this.v(), this.g("graduatedMax", b, a), wl(this) && (a =
                    this.part, null !== a && xl(this, a, "graduatedRange")))
            }
        }, graduatedRange: {
            configurable: !0, get: function () {
                return this.graduatedMax - this.graduatedMin
            }
        }, graduatedTickUnit: {
            configurable: !0, get: function () {
                return this.vo
            }, set: function (a) {
                C(a, W, "graduatedTickUnit");
                var b = this.vo;
                b !== a && 0 < a && (this.vo = a, this.v(), this.g("graduatedTickUnit", b, a))
            }
        }, graduatedTickBase: {
            configurable: !0, get: function () {
                return this.uo
            }, set: function (a) {
                C(a, W, "graduatedTickBase");
                var b = this.uo;
                b !==
                a && (this.uo = a, this.v(), this.g("graduatedTickBase", b, a))
            }
        }, Xh: {
            configurable: !0, get: function () {
                return 0 !== (this.I & 8388608)
            }, set: function (a) {
                0 !== (this.I & 8388608) !== a && (this.I ^= 8388608)
            }
        }, rowCount: {
            configurable: !0, get: function () {
                return void 0 === this.Ab ? 0 : this.Ab.length
            }
        }, columnCount: {
            configurable: !0, get: function () {
                return void 0 === this.xb ? 0 : this.xb.length
            }
        }, rowSizing: {
            configurable: !0, get: function () {
                return void 0 === this.nk ? pn : this.nk
            }, set: function (a) {
                if (void 0 !==
                    this.nk) {
                    var b = this.nk;
                    b !== a && (F && a !== pn && a !== Xm && v("Panel.rowSizing must be RowColumnDefinition.ProportionalExtra or RowColumnDefinition.None, not: " + a), this.nk = a, this.v(), this.g("rowSizing", b, a))
                }
            }
        }, columnSizing: {
            configurable: !0, get: function () {
                return void 0 === this.Mj ? pn : this.Mj
            }, set: function (a) {
                if (void 0 !== this.Mj) {
                    var b = this.Mj;
                    b !== a && (F && a !== pn && a !== Xm && v("Panel.columnSizing must be RowColumnDefinition.ProportionalExtra or RowColumnDefinition.None, not: " + a), this.Mj = a, this.v(), this.g("columnSizing",
                        b, a))
                }
            }
        }, topIndex: {
            configurable: !0, get: function () {
                return void 0 === this.gj ? 0 : this.gj
            }, set: function (a) {
                if (void 0 !== this.gj) {
                    var b = this.gj;
                    b !== a && ((!isFinite(a) || 0 > a) && v("Panel.topIndex must be greater than zero and a real number, not: " + a), this.gj = a, this.v(), this.g("topIndex", b, a))
                }
            }
        }, leftIndex: {
            configurable: !0, get: function () {
                return void 0 === this.Pi ? 0 : this.Pi
            }, set: function (a) {
                if (void 0 !== this.Pi) {
                    var b = this.Pi;
                    b !== a && ((!isFinite(a) || 0 > a) && v("Panel.leftIndex must be greater than zero and a real number, not: " +
                        a), this.Pi = a, this.v(), this.g("leftIndex", b, a))
                }
            }
        }, data: {
            configurable: !0, get: function () {
                return this.sb
            }, set: function (a) {
                var b = this.sb;
                if (b !== a) {
                    var c = this instanceof T && !(this instanceof Xe);
                    c && A(a, "object", W, "data");
                    Ng(this);
                    this.sb = a;
                    var d = this.diagram;
                    null !== d && (c ? (c = d.partManager, this instanceof S ? (null !== b && c.df.remove(b), null !== a && c.df.add(a, this)) : this instanceof T && (null !== b && c.ef.remove(b), null !== a && c.ef.add(a, this))) : (c = this.panel, null !== c && null !== c.Zd && (null !== b && c.Zd.remove(b),
                    null !== a && c.Zd.add(a, this))));
                    this.g("data", b, a);
                    null !== d && d.undoManager.isUndoingRedoing || null !== a && this.Ha()
                }
            }
        }, itemIndex: {
            configurable: !0, get: function () {
                return this.Ko
            }, set: function (a) {
                var b = this.Ko;
                b !== a && (this.Ko = a, this.g("itemIndex", b, a))
            }
        }, itemArray: {
            configurable: !0, get: function () {
                return this.Li
            }, set: function (a) {
                var b = this.Li;
                if (b !== a || null !== a && Dn(this, a)) {
                    F && null !== a && !Ha(a) && v("Panel.itemArray must be an Array-like object or null, not: " + a);
                    var c = this.diagram;
                    b !== a && (null !== c && null !== b && Zj(c.partManager, this, c), this.Li = a, null !== c && null !== a && Wj(c.partManager, this));
                    this.g("itemArray", b, a);
                    null !== c && c.undoManager.isUndoingRedoing || this.pu()
                }
            }
        }, itemTemplate: {
            configurable: !0, get: function () {
                return null === this.ze ? null : this.ze.K("")
            }, set: function (a) {
                if (null === this.ze) {
                    if (null === a) return;
                    this.ze = new Db
                }
                var b = this.ze.K("");
                b !== a && (w(a, W, W, "itemTemplate"), (a instanceof T || a.isPanelMain) && v("Panel.itemTemplate must not be a Part or be Panel.isPanelMain: " +
                    a), this.ze.add("", a), this.g("itemTemplate", b, a), a = this.diagram, null !== a && a.undoManager.isUndoingRedoing || this.pu())
            }
        }, itemTemplateMap: {
            configurable: !0, get: function () {
                return this.ze
            }, set: function (a) {
                var b = this.ze;
                if (b !== a) {
                    w(a, Db, W, "itemTemplateMap");
                    for (var c = a.iterator; c.next();) {
                        var d = c.value;
                        F && (d instanceof T || d.isPanelMain) && v("Template in Panel.itemTemplateMap must not be a Part or be Panel.isPanelMain: " + d)
                    }
                    this.ze = a;
                    this.g("itemTemplateMap", b, a);
                    a = this.diagram;
                    null !== a && a.undoManager.isUndoingRedoing ||
                    this.pu()
                }
            }
        }, itemCategoryProperty: {
            configurable: !0, get: function () {
                return this.Vl
            }, set: function (a) {
                var b = this.Vl;
                b !== a && ("string" !== typeof a && "function" !== typeof a && xa(a, "string or function", W, "itemCategoryProperty"), this.Vl = a, this.g("itemCategoryProperty", b, a))
            }
        }, isAtomic: {
            configurable: !0, get: function () {
                return 0 !== (this.I & 1048576)
            }, set: function (a) {
                var b = 0 !== (this.I & 1048576);
                b !== a && (A(a, "boolean", W, "isAtomic"), this.I ^= 1048576, this.g("isAtomic", b, a))
            }
        }, isClipping: {
            configurable: !0,
            enumerable: !0, get: function () {
                return 0 !== (this.I & 2097152)
            }, set: function (a) {
                var b = 0 !== (this.I & 2097152);
                b !== a && (A(a, "boolean", W, "isClipping"), !a || this.type === W.Spot || this instanceof Kf || Ea("Warning: Panel.isClipping set on non-Spot Panel: " + this.toString()), this.I ^= 2097152, this instanceof Kf && (this.fb = null), this.v(), this.g("isClipping", b, a))
            }
        }, isOpposite: {
            configurable: !0, get: function () {
                return 0 !== (this.I & 33554432)
            }, set: function (a) {
                var b = 0 !== (this.I & 33554432);
                b !== a && (A(a, "boolean", W, "isOpposite"),
                    this.I ^= 33554432, this.v(), this.g("isOpposite", b, a))
            }
        }, isEnabled: {
            configurable: !0, get: function () {
                return 0 !== (this.I & 4194304)
            }, set: function (a) {
                var b = 0 !== (this.I & 4194304);
                if (b !== a) {
                    A(a, "boolean", W, "isEnabled");
                    var c = null === this.panel || this.panel.Ug();
                    this.I ^= 4194304;
                    this.g("isEnabled", b, a);
                    b = this.diagram;
                    null !== b && b.undoManager.isUndoingRedoing || c && zn(this, this, a)
                }
            }
        }, alignmentFocusName: {
            configurable: !0, get: function () {
                return this.Yg
            }, set: function (a) {
                var b = this.Yg;
                b !== a && (F &&
                A(a, "string", W, "alignmentFocusName"), this.Yg = a, this.v(), this.g("alignmentFocusName", b, a))
            }
        }
    });
    na.Object.defineProperties(W, {
        Position: {
            configurable: !0, get: function () {
                return dm.K("Position")
            }
        }, Horizontal: {
            configurable: !0, get: function () {
                return dm.K("Horizontal")
            }
        }, Vertical: {
            configurable: !0, get: function () {
                return dm.K("Vertical")
            }
        }, Spot: {
            configurable: !0, get: function () {
                return dm.K("Spot")
            }
        }, Auto: {
            configurable: !0, get: function () {
                return dm.K("Auto")
            }
        }, Table: {
            configurable: !0, get: function () {
                return dm.K("Table")
            }
        }, Viewbox: {
            configurable: !0,
            enumerable: !0, get: function () {
                return dm.K("Viewbox")
            }
        }, TableRow: {
            configurable: !0, get: function () {
                return dm.K("TableRow")
            }
        }, TableColumn: {
            configurable: !0, get: function () {
                return dm.K("TableColumn")
            }
        }, Link: {
            configurable: !0, get: function () {
                return dm.K("Link")
            }
        }, Grid: {
            configurable: !0, get: function () {
                return dm.K("Grid")
            }
        }, Graduated: {
            configurable: !0, get: function () {
                return dm.K("Graduated")
            }
        }
    });
    W.prototype.findItemPanelForData = W.prototype.Fy;
    W.prototype.rebuildItemElements = W.prototype.pu;
    W.prototype.updateTargetBindings = W.prototype.Ha;
    W.prototype.copyTemplate = W.prototype.Vz;
    W.prototype.graduatedValueForPoint = W.prototype.JA;
    W.prototype.graduatedPointForValue = W.prototype.IA;
    W.prototype.findColumnForLocalX = W.prototype.kA;
    W.prototype.findRowForLocalY = W.prototype.sA;
    W.prototype.removeColumnDefinition = W.prototype.Ew;
    W.prototype.removeRowDefinition = W.prototype.Gw;
    W.prototype.removeAt = W.prototype.jb;
    W.prototype.remove = W.prototype.remove;
    W.prototype.insertAt = W.prototype.Bb;
    W.prototype.elt = W.prototype.M;
    W.prototype.add = W.prototype.add;
    W.prototype.findObject = W.prototype.hb;
    W.prototype.findInVisualTree = W.prototype.Jm;
    W.prototype.walkVisualTreeFrom = W.prototype.cl;
    W.prototype.findMainElement = W.prototype.wb;
    var Cn = !1, Gn = !1, Hn = null, dm = new Db;
    W.className = "Panel";
    W.definePanelLayout = Kn;
    Kn("Position", new Nm);
    Kn("Vertical", new Qm);
    Kn("Auto", new Sm);
    Kn("Link", new cn);

    function ik() {
        gb(this);
        this.Bg = null;
        this.As = !0;
        this.Va = 0;
        this.gd = NaN;
        this.zh = 0;
        this.xh = Infinity;
        this.Eb = jd;
        this.ra = this.gc = this.na = 0;
        this.lb = null;
        this.hq = Ln;
        this.Le = ml;
        this.aq = this.Fg = null;
        this.bq = NaN;
        this.rb = this.qk = null;
        this.Sn = !1
    }

    ik.prototype.copy = function () {
        var a = new ik;
        a.As = this.As;
        a.Va = this.Va;
        a.gd = this.gd;
        a.zh = this.zh;
        a.xh = this.xh;
        a.Eb = this.Eb;
        a.na = this.na;
        a.gc = this.gc;
        a.ra = this.ra;
        a.Le = this.Le;
        a.hq = this.hq;
        null === this.Fg ? a.Fg = null : a.Fg = this.Fg.J();
        a.aq = this.aq;
        a.bq = this.bq;
        a.qk = null;
        null !== this.qk && (a.separatorDashArray = Ja(this.separatorDashArray));
        a.rb = this.rb;
        a.Sn = this.Sn;
        a.lb = this.lb;
        return a
    };
    t = ik.prototype;
    t.Ot = function (a) {
        w(a, ik, ik, "copyFrom:pd");
        a.isRow ? this.height = a.height : this.width = a.width;
        this.minimum = a.minimum;
        this.maximum = a.maximum;
        this.alignment = a.alignment;
        this.stretch = a.stretch;
        this.sizing = a.sizing;
        this.Fg = null === a.separatorPadding ? null : a.separatorPadding.J();
        this.separatorStroke = a.separatorStroke;
        this.separatorStrokeWidth = a.separatorStrokeWidth;
        this.qk = null;
        a.separatorDashArray && (this.qk = Ja(a.separatorDashArray));
        this.background = a.background;
        this.coversSeparators = a.coversSeparators;
        this.lb =
            a.lb
    };
    t.pb = function (a) {
        a.classType === ik ? this.sizing = a : Da(this, a)
    };
    t.toString = function () {
        return "RowColumnDefinition " + (this.isRow ? "(Row " : "(Column ") + this.index + ") #" + rb(this)
    };
    t.Dj = function (a) {
        this.Bg = a
    };
    t.Tv = function () {
        var a = 0, b = 0, c = this.Bg, d = this.isRow;
        if (null !== c && c.type === W.Table) for (var e = d ? c.Ab.length : c.xb.length, f = 0; f < e; f++) {
            var g = d ? c.Ab[f] : c.xb[f];
            if (void 0 !== g) {
                b = g.index;
                break
            }
        }
        this.index !== b && (b = this.separatorStroke, null === b && null !== c && (b = this.isRow ? c.defaultRowSeparatorStroke : c.defaultColumnSeparatorStroke), null !== b && (a = this.separatorStrokeWidth, isNaN(a) && (null !== c ? a = this.isRow ? c.defaultRowSeparatorStrokeWidth : c.defaultColumnSeparatorStrokeWidth : a = 0)));
        b = this.Fg;
        if (null === b) if (null !== c) b =
            c.defaultSeparatorPadding; else return a;
        return a + (this.isRow ? b.top : b.left)
    };
    t.Cc = function () {
        var a = 0, b = this.Bg, c = 0, d = this.isRow;
        if (null !== b && b.type === W.Table) for (var e = d ? b.Ab.length : b.xb.length, f = 0; f < e; f++) {
            var g = d ? b.Ab[f] : b.xb[f];
            if (void 0 !== g) {
                c = g.index;
                break
            }
        }
        this.index !== c && (c = this.separatorStroke, null === c && null !== b && (c = d ? b.defaultRowSeparatorStroke : b.defaultColumnSeparatorStroke), null !== c && (a = this.separatorStrokeWidth, isNaN(a) && (null !== b ? a = d ? b.defaultRowSeparatorStrokeWidth : b.defaultColumnSeparatorStrokeWidth : a = 0)));
        d = this.Fg;
        if (null === d) if (null !== b) d = b.defaultSeparatorPadding;
        else return a;
        return a + (this.isRow ? d.top + d.bottom : d.left + d.right)
    };
    t.Hb = function (a, b, c) {
        var d = this.Bg;
        if (null !== d && (d.ib(Le, a, this, b, c, void 0, void 0), null !== this.lb && (b = d.diagram, null !== b && !b.skipsModelSourceBindings && (d = d.sj(), null !== d && (b = d.data, null !== b))))) for (c = this.lb.iterator; c.next();) c.value.yr(this, b, a, d)
    };

    function Wm(a) {
        if (a.sizing === Ln) {
            var b = a.Bg;
            return a.isRow ? b.rowSizing : b.columnSizing
        }
        return a.sizing
    }

    t.bind = function (a) {
        a.td = this;
        var b = this.panel;
        if (null !== b) {
            var c = b.sj();
            null !== c && $l(c) && v("Cannot add a Binding to a RowColumnDefinition that is already frozen: " + a + " on " + b)
        }
        null === this.lb && (this.lb = new H);
        this.lb.add(a)
    };
    na.Object.defineProperties(ik.prototype, {
        panel: {
            configurable: !0, get: function () {
                return this.Bg
            }
        }, isRow: {
            configurable: !0, get: function () {
                return this.As
            }, set: function (a) {
                this.As = a
            }
        }, index: {
            configurable: !0, get: function () {
                return this.Va
            }, set: function (a) {
                this.Va = a
            }
        }, height: {
            configurable: !0, get: function () {
                return this.gd
            }, set: function (a) {
                var b = this.gd;
                b !== a && (F && A(a, "number", ik, "height"), 0 > a && za(a, ">= 0", ik, "height"), this.gd = a, this.actual = this.na, null !==
                this.panel && this.panel.v(), this.Hb("height", b, a))
            }
        }, width: {
            configurable: !0, get: function () {
                return this.gd
            }, set: function (a) {
                var b = this.gd;
                b !== a && (F && A(a, "number", ik, "width"), 0 > a && za(a, ">= 0", ik, "width"), this.gd = a, this.actual = this.na, null !== this.panel && this.panel.v(), this.Hb("width", b, a))
            }
        }, minimum: {
            configurable: !0, get: function () {
                return this.zh
            }, set: function (a) {
                var b = this.zh;
                b !== a && (F && A(a, "number", ik, "minimum"), (0 > a || !isFinite(a)) && za(a, ">= 0", ik, "minimum"), this.zh = a, this.actual =
                    this.na, null !== this.panel && this.panel.v(), this.Hb("minimum", b, a))
            }
        }, maximum: {
            configurable: !0, get: function () {
                return this.xh
            }, set: function (a) {
                var b = this.xh;
                b !== a && (F && A(a, "number", ik, "maximum"), 0 > a && za(a, ">= 0", ik, "maximum"), this.xh = a, this.actual = this.na, null !== this.panel && this.panel.v(), this.Hb("maximum", b, a))
            }
        }, alignment: {
            configurable: !0, get: function () {
                return this.Eb
            }, set: function (a) {
                var b = this.Eb;
                b.A(a) || (F && w(a, M, ik, "alignment"), this.Eb = a.J(), null !== this.panel && this.panel.v(),
                    this.Hb("alignment", b, a))
            }
        }, stretch: {
            configurable: !0, get: function () {
                return this.Le
            }, set: function (a) {
                var b = this.Le;
                b !== a && (F && ib(a, N, ik, "stretch"), this.Le = a, null !== this.panel && this.panel.v(), this.Hb("stretch", b, a))
            }
        }, separatorPadding: {
            configurable: !0, get: function () {
                return this.Fg
            }, set: function (a) {
                "number" === typeof a ? a = new jc(a) : null !== a && F && w(a, jc, ik, "separatorPadding");
                var b = this.Fg;
                null !== a && null !== b && b.A(a) || (null !== a && (a = a.J()), this.Fg = a, null !== this.panel && this.panel.v(),
                    this.Hb("separatorPadding", b, a))
            }
        }, separatorStroke: {
            configurable: !0, get: function () {
                return this.aq
            }, set: function (a) {
                var b = this.aq;
                b !== a && (null !== a && hm(a, "RowColumnDefinition.separatorStroke"), a instanceof Ll && a.freeze(), this.aq = a, null !== this.panel && this.panel.v(), this.Hb("separatorStroke", b, a))
            }
        }, separatorStrokeWidth: {
            configurable: !0, get: function () {
                return this.bq
            }, set: function (a) {
                var b = this.bq;
                b !== a && (this.bq = a, null !== this.panel && this.panel.v(), this.Hb("separatorStrokeWidth",
                    b, a))
            }
        }, separatorDashArray: {
            configurable: !0, get: function () {
                return this.qk
            }, set: function (a) {
                var b = this.qk;
                if (b !== a) {
                    null === a || Array.isArray(a) || xa(a, "Array", ik, "separatorDashArray:value");
                    if (null !== a) {
                        for (var c = a.length, d = 0, e = 0; e < c; e++) {
                            var f = a[e];
                            "number" === typeof f && 0 <= f && isFinite(f) || v("separatorDashArray value " + f + " at index " + e + " must be a positive number or zero.");
                            d += f
                        }
                        if (0 === d) {
                            if (null === b) return;
                            a = null
                        }
                    }
                    this.qk = a;
                    null !== this.panel && this.panel.P();
                    this.Hb("separatorDashArray",
                        b, a)
                }
            }
        }, background: {
            configurable: !0, get: function () {
                return this.rb
            }, set: function (a) {
                var b = this.rb;
                b !== a && (null !== a && hm(a, "RowColumnDefinition.background"), a instanceof Ll && a.freeze(), this.rb = a, null !== this.panel && this.panel.P(), this.Hb("background", b, a))
            }
        }, coversSeparators: {
            configurable: !0, get: function () {
                return this.Sn
            }, set: function (a) {
                var b = this.Sn;
                b !== a && (A(a, "boolean", ik, "coversSeparators"), this.Sn = a, null !== this.panel && this.panel.P(), this.Hb("coversSeparators", b, a))
            }
        },
        sizing: {
            configurable: !0, get: function () {
                return this.hq
            }, set: function (a) {
                var b = this.hq;
                b !== a && (F && ib(a, ik, ik, "sizing"), this.hq = a, null !== this.panel && this.panel.v(), this.Hb("sizing", b, a))
            }
        }, actual: {
            configurable: !0, get: function () {
                return this.na
            }, set: function (a) {
                this.na = isNaN(this.gd) ? Math.max(Math.min(this.xh, a), this.zh) : Math.max(Math.min(this.xh, this.gd), this.zh)
            }
        }, measured: {
            configurable: !0, get: function () {
                return this.gc
            }, set: function (a) {
                this.gc = a
            }
        }, total: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.na + this.Cc()
            }, set: function (a) {
                this.na = isNaN(this.gd) ? Math.max(Math.min(this.xh, a), this.zh) : Math.max(Math.min(this.xh, this.gd), this.zh);
                this.na = Math.max(0, this.na - this.Cc())
            }
        }, position: {
            configurable: !0, get: function () {
                return this.ra
            }, set: function (a) {
                this.ra = a
            }
        }
    });
    ik.prototype.bind = ik.prototype.bind;
    ik.prototype.computeEffectiveSpacing = ik.prototype.Cc;
    ik.prototype.computeEffectiveSpacingTop = ik.prototype.Tv;
    var Ln = new E(ik, "Default", 0), Xm = new E(ik, "None", 1), pn = new E(ik, "ProportionalExtra", 2);
    ik.className = "RowColumnDefinition";
    ik.Default = Ln;
    ik.None = Xm;
    ik.ProportionalExtra = pn;

    function Zf() {
        N.call(this);
        this.Gd = this.ua = null;
        this.jo = "None";
        this.ro = ml;
        this.Oc = this.Dl = "black";
        this.Hh = 1;
        this.um = "butt";
        this.vm = "miter";
        this.rk = 10;
        this.Fh = null;
        this.Gh = 0;
        this.Bf = this.Af = jd;
        this.Bp = this.Ap = NaN;
        this.Co = !1;
        this.Dp = null;
        this.Fl = this.Bm = "None";
        this.Yd = 1;
        this.Wd = 0;
        this.Ud = 1;
        this.Vd = null
    }

    ma(Zf, N);
    Zf.prototype.cloneProtected = function (a) {
        N.prototype.cloneProtected.call(this, a);
        a.ua = this.ua;
        a.jo = this.jo;
        a.ro = this.ro;
        a.Gd = this.Gd;
        a.Dl = this.Dl;
        a.Oc = this.Oc;
        a.Hh = this.Hh;
        a.um = this.um;
        a.vm = this.vm;
        a.rk = this.rk;
        null !== this.Fh && (a.Fh = Ja(this.Fh));
        a.Gh = this.Gh;
        a.Af = this.Af.J();
        a.Bf = this.Bf.J();
        a.Ap = this.Ap;
        a.Bp = this.Bp;
        a.Co = this.Co;
        a.Dp = this.Dp;
        a.Bm = this.Bm;
        a.Fl = this.Fl;
        a.Yd = this.Yd;
        a.Wd = this.Wd;
        a.Ud = this.Ud;
        a.Vd = this.Vd
    };
    t = Zf.prototype;
    t.pb = function (a) {
        a === Og || a === Qg || a === pl || a === ml ? this.geometryStretch = a : N.prototype.pb.call(this, a)
    };
    t.toString = function () {
        return "Shape(" + ("None" !== this.figure ? this.figure : "None" !== this.toArrow ? this.toArrow : this.fromArrow) + ")#" + rb(this)
    };

    function Mn(a, b, c, d) {
        var e = c.length;
        if (!(4 > e)) {
            var f = d.measuredBounds, g = Math.max(1, f.width);
            f = f.height;
            for (var h = c[0], k = c[1], l, m, n, p, r, q, u = 0, x = Ma(), y = 2; y < e; y += 2) l = c[y], m = c[y + 1], n = l - h, h = m - k, 0 === n && (n = .001), p = h / n, r = Math.atan2(h, n), q = Math.sqrt(n * n + h * h), x.push([n, r, p, q]), u += q, h = l, k = m;
            h = c[0];
            k = c[1];
            n = d.measuredBounds.width;
            d instanceof Zf && (n -= d.strokeWidth);
            1 > n && (n = 1);
            e = c = n;
            l = g / 2;
            m = 0 === l ? !1 : !0;
            y = 0;
            q = x[y];
            n = q[0];
            r = q[1];
            p = q[2];
            q = q[3];
            for (var z = 0; .1 <= u;) {
                0 === z && (m ? (e = c, e -= l, u -= l, m = !1) : e = c, 0 === e && (e = 1));
                if (e > u) {
                    Oa(x);
                    return
                }
                e > q ? (z = e - q, e = q) : z = 0;
                var B = Math.sqrt(e * e / (1 + p * p));
                0 > n && (B = -B);
                h += B;
                k += p * B;
                a.translate(h, k);
                a.rotate(r);
                a.translate(-(g / 2), -(f / 2));
                0 === z && d.oj(a, b);
                a.translate(g / 2, f / 2);
                a.rotate(-r);
                a.translate(-h, -k);
                u -= e;
                q -= e;
                if (0 !== z) {
                    y++;
                    if (y === x.length) {
                        Oa(x);
                        return
                    }
                    q = x[y];
                    n = q[0];
                    r = q[1];
                    p = q[2];
                    q = q[3];
                    e = z
                }
            }
            Oa(x)
        }
    }

    t.oj = function (a, b) {
        var c = this.Oc, d = this.Dl;
        if (null !== c || null !== d) {
            var e = this.actualBounds, f = this.naturalBounds;
            null !== d && Ai(this, a, d, !0, !1, f, e);
            var g = this.part, h = this.Hh;
            null === c || 0 !== h || null === g || !this.isPanelMain && g.wb() !== this || (h = g.type === W.Link && g instanceof Xe && "Selection" === g.category && g.adornedObject instanceof Zf && g.adornedPart.wb() === g.adornedObject ? g.adornedObject.strokeWidth : 0);
            0 === h && (c = null);
            null !== c && 0 !== h && (Ai(this, a, c, !1, !1, f, e), a.lineWidth = h, a.lineJoin = this.vm, a.lineCap = this.um,
                a.miterLimit = this.rk);
            e = !1;
            g && b.Te("drawShadows") && (e = g.isShadowed);
            g = !0;
            null === c || null !== d && "transparent" !== d || (g = !1);
            f = !1;
            h = this.strokeDashArray;
            null !== h && (f = !0, a.Rt(h, this.Gh));
            var k = this.ua;
            if (null !== k) {
                if (k.type === Kd) a.beginPath(), a.moveTo(k.startX, k.startY), a.lineTo(k.endX, k.endY), null !== c && a.Gj(); else if (k.type === Od) {
                    var l = k.startX;
                    h = k.startY;
                    var m = k.endX, n = k.endY;
                    k = Math.min(l, m);
                    var p = Math.min(h, n);
                    l = Math.abs(m - l);
                    h = Math.abs(n - h);
                    a.beginPath();
                    a.rect(k, p, l, h);
                    null !== d && a.Se(d);
                    if (null !== c) {
                        g &&
                        e && Kl(a);
                        if (0 === l || 0 === h) a.beginPath(), a.rect(k, p, Math.max(l, .1), Math.max(h, .1));
                        a.Gj();
                        g && e && Jl(a)
                    }
                } else if (k.type === Pd) l = k.startX, h = k.startY, m = k.endX, n = k.endY, k = Math.abs(m - l) / 2, p = Math.abs(n - h) / 2, l = Math.min(l, m) + k, h = Math.min(h, n) + p, a.beginPath(), a.moveTo(l, h - p), a.bezierCurveTo(l + K.Xg * k, h - p, l + k, h - K.Xg * p, l + k, h), a.bezierCurveTo(l + k, h + K.Xg * p, l + K.Xg * k, h + p, l, h + p), a.bezierCurveTo(l - K.Xg * k, h + p, l - k, h + K.Xg * p, l - k, h), a.bezierCurveTo(l - k, h - K.Xg * p, l - K.Xg * k, h - p, l, h - p), a.closePath(), null !== d && a.Se(d), null !== c &&
                (g && e ? (Kl(a), a.Gj(), Jl(a)) : a.Gj()); else if (k.type === Id) for (h = k.figures, k = h.length, p = 0; p < k; p++) {
                    l = h.j[p];
                    a.beginPath();
                    a.moveTo(l.startX, l.startY);
                    m = l.segments.j;
                    n = m.length;
                    for (var r = null, q = 0; q < n; q++) {
                        var u = m[q];
                        switch (u.type) {
                            case me:
                                a.moveTo(u.endX, u.endY);
                                break;
                            case Md:
                                a.lineTo(u.endX, u.endY);
                                break;
                            case ne:
                                a.bezierCurveTo(u.point1X, u.point1Y, u.point2X, u.point2Y, u.endX, u.endY);
                                break;
                            case oe:
                                a.quadraticCurveTo(u.point1X, u.point1Y, u.endX, u.endY);
                                break;
                            case pe:
                                if (u.radiusX === u.radiusY) {
                                    var x = Math.PI /
                                        180;
                                    a.arc(u.point1X, u.point1Y, u.radiusX, u.startAngle * x, (u.startAngle + u.sweepAngle) * x, 0 > u.sweepAngle, null !== r ? r.endX : l.startX, null !== r ? r.endY : l.startY)
                                } else if (r = re(u, l), x = r.length, 0 === x) a.lineTo(u.centerX, u.centerY); else for (var y = 0; y < x; y++) {
                                    var z = r[y];
                                    0 === y && a.lineTo(z[0], z[1]);
                                    a.bezierCurveTo(z[2], z[3], z[4], z[5], z[6], z[7])
                                }
                                break;
                            case qe:
                                y = x = 0;
                                if (null !== r && r.type === pe) {
                                    r = re(r, l);
                                    z = r.length;
                                    if (0 === z) {
                                        a.lineTo(u.centerX, u.centerY);
                                        break
                                    }
                                    r = r[z - 1] || null;
                                    null !== r && (x = r[6], y = r[7])
                                } else x = null !== r ? r.endX :
                                    l.startX, y = null !== r ? r.endY : l.startY;
                                r = se(u, l, x, y);
                                x = r.length;
                                if (0 === x) {
                                    a.lineTo(u.centerX, u.centerY);
                                    break
                                }
                                for (y = 0; y < x; y++) z = r[y], a.bezierCurveTo(z[2], z[3], z[4], z[5], z[6], z[7]);
                                break;
                            default:
                                v("Segment not of valid type: " + u.type)
                        }
                        u.isClosed && a.closePath();
                        r = u
                    }
                    m = l.isFilled;
                    e ? l.isShadowed ? (!0 === m && "transparent" !== d && null !== d && a.Se(d), null !== c && (m && g && Kl(a), a.Gj(), m && g && Jl(a))) : (Kl(a), m && "transparent" !== d && null !== d && a.Se(d), null !== c && a.Gj(), Jl(a)) : (m && null !== d && a.Se(d), null !== c && a.Gj())
                }
                f && a.Pt();
                if (null !==
                    this.pathPattern) {
                    c = this.pathPattern;
                    c.measure(Infinity, Infinity);
                    d = c.measuredBounds;
                    c.arrange(0, 0, d.width, d.height);
                    e = this.geometry;
                    a.save();
                    a.beginPath();
                    d = Ma();
                    if (e.type === Kd) d.push(e.startX), d.push(e.startY), d.push(e.endX), d.push(e.endY), Mn(a, b, d, c); else if (e.type === Id) for (e = e.figures.iterator; e.next();) {
                        g = e.value;
                        d.length = 0;
                        d.push(g.startX);
                        d.push(g.startY);
                        f = g.startX;
                        h = g.startY;
                        k = f;
                        p = h;
                        l = g.segments.j;
                        m = l.length;
                        for (n = 0; n < m; n++) {
                            q = l[n];
                            switch (q.type) {
                                case me:
                                    Mn(a, b, d, c);
                                    d.length = 0;
                                    d.push(q.endX);
                                    d.push(q.endY);
                                    f = q.endX;
                                    h = q.endY;
                                    k = f;
                                    p = h;
                                    break;
                                case Md:
                                    d.push(q.endX);
                                    d.push(q.endY);
                                    f = q.endX;
                                    h = q.endY;
                                    break;
                                case ne:
                                    K.Oe(f, h, q.point1X, q.point1Y, q.point2X, q.point2Y, q.endX, q.endY, .5, d);
                                    f = q.endX;
                                    h = q.endY;
                                    break;
                                case oe:
                                    K.hr(f, h, q.point1X, q.point1Y, q.endX, q.endY, .5, d);
                                    f = q.endX;
                                    h = q.endY;
                                    break;
                                case pe:
                                    u = re(q, g);
                                    r = u.length;
                                    if (0 === r) {
                                        d.push(q.centerX);
                                        d.push(q.centerY);
                                        f = q.centerX;
                                        h = q.centerY;
                                        break
                                    }
                                    for (x = 0; x < r; x++) y = u[x], K.Oe(f, h, y[2], y[3], y[4], y[5], y[6], y[7], .5, d), f = y[6], h = y[7];
                                    break;
                                case qe:
                                    u = se(q, g,
                                        f, h);
                                    r = u.length;
                                    if (0 === r) {
                                        d.push(q.centerX);
                                        d.push(q.centerY);
                                        f = q.centerX;
                                        h = q.centerY;
                                        break
                                    }
                                    for (x = 0; x < r; x++) y = u[x], K.Oe(f, h, y[2], y[3], y[4], y[5], y[6], y[7], .5, d), f = y[6], h = y[7];
                                    break;
                                default:
                                    v("Segment not of valid type: " + q.type)
                            }
                            q.isClosed && (d.push(k), d.push(p), Mn(a, b, d, c))
                        }
                        Mn(a, b, d, c)
                    } else if (e.type === Od) d.push(e.startX), d.push(e.startY), d.push(e.endX), d.push(e.startY), d.push(e.endX), d.push(e.endY), d.push(e.startX), d.push(e.endY), d.push(e.startX), d.push(e.startY), Mn(a, b, d, c); else if (e.type === Pd) {
                        h =
                            new xe;
                        h.startX = e.endX;
                        h.startY = (e.startY + e.endY) / 2;
                        f = new ye(pe);
                        f.startAngle = 0;
                        f.sweepAngle = 360;
                        f.centerX = (e.startX + e.endX) / 2;
                        f.centerY = (e.startY + e.endY) / 2;
                        f.radiusX = Math.abs(e.startX - e.endX) / 2;
                        f.radiusY = Math.abs(e.startY - e.endY) / 2;
                        h.add(f);
                        e = re(f, h);
                        g = e.length;
                        if (0 === g) d.push(f.centerX), d.push(f.centerY); else for (f = h.startX, h = h.startY, k = 0; k < g; k++) p = e[k], K.Oe(f, h, p[2], p[3], p[4], p[5], p[6], p[7], .5, d), f = p[6], h = p[7];
                        Mn(a, b, d, c)
                    }
                    Oa(d);
                    a.restore();
                    a.Ac(!1)
                }
            }
        }
    };
    t.ja = function (a, b) {
        void 0 === b && (b = new J);
        if (a instanceof M) {
            a.Tb() && v("getDocumentPoint Spot must be a real, specific Spot, not: " + a.toString());
            var c = this.naturalBounds, d = this.strokeWidth;
            b.h(a.x * (c.width + d) - d / 2 + c.x + a.offsetX, a.y * (c.height + d) - d / 2 + c.y + a.offsetY)
        } else b.set(a);
        this.Hd.ya(b);
        return b
    };
    t.wj = function (a) {
        void 0 === a && (a = new L);
        var b = this.naturalBounds, c = this.Hd;
        b = L.allocAt(b.x, b.y, b.width, b.height);
        var d = this.strokeWidth;
        b.Pc(d / 2, d / 2);
        d = J.allocAt(b.x, b.y).transform(c);
        a.h(d.x, d.y, 0, 0);
        d.h(b.right, b.y).transform(c);
        oc(a, d.x, d.y, 0, 0);
        d.h(b.right, b.bottom).transform(c);
        oc(a, d.x, d.y, 0, 0);
        d.h(b.x, b.bottom).transform(c);
        oc(a, d.x, d.y, 0, 0);
        L.free(b);
        J.free(d);
        return a
    };
    t.Uh = function (a, b) {
        var c = this.geometry;
        if (null === c || null === this.fill && null === this.stroke) return !1;
        var d = c.bounds, e = this.strokeWidth / 2;
        c.type !== Kd || b || (e += 2);
        var f = L.alloc();
        f.assign(d);
        f.Pc(e + 2, e + 2);
        if (!f.ca(a)) return L.free(f), !1;
        d = e + 1E-4;
        if (c.type === Kd) {
            if (null === this.stroke) return !1;
            d = (c.endX - c.startX) * (a.x - c.startX) + (c.endY - c.startY) * (a.y - c.startY);
            if (0 > (c.startX - c.endX) * (a.x - c.endX) + (c.startY - c.endY) * (a.y - c.endY) || 0 > d) return !1;
            L.free(f);
            return K.Ub(c.startX, c.startY, c.endX, c.endY, e, a.x, a.y)
        }
        if (c.type ===
            Od) {
            b = c.startX;
            var g = c.startY, h = c.endX;
            c = c.endY;
            f.x = Math.min(b, h);
            f.y = Math.min(g, c);
            f.width = Math.abs(h - b);
            f.height = Math.abs(c - g);
            if (null === this.fill) {
                f.Pc(-d, -d);
                if (f.ca(a)) return L.free(f), !1;
                f.Pc(d, d)
            }
            null !== this.stroke && f.Pc(e, e);
            a = f.ca(a);
            L.free(f);
            return a
        }
        if (c.type === Pd) {
            g = c.startX;
            e = c.startY;
            h = c.endX;
            var k = c.endY;
            c = Math.min(g, h);
            b = Math.min(e, k);
            g = Math.abs(h - g) / 2;
            e = Math.abs(k - e) / 2;
            c = a.x - (c + g);
            b = a.y - (b + e);
            if (null === this.fill) {
                g -= d;
                e -= d;
                if (0 >= g || 0 >= e || 1 >= c * c / (g * g) + b * b / (e * e)) return L.free(f), !1;
                g += d;
                e += d
            }
            null !== this.stroke && (g += d, e += d);
            L.free(f);
            return 0 >= g || 0 >= e ? !1 : 1 >= c * c / (g * g) + b * b / (e * e)
        }
        if (c.type === Id) return L.free(f), null === this.fill ? ve(c, a.x, a.y, e) : te(c, a, e, 1 < this.strokeWidth, b);
        v("Unknown Geometry type: " + c.type);
        return !1
    };
    t.Tm = function (a, b, c, d) {
        var e = this.desiredSize, f = this.Hh;
        a = Math.max(a, 0);
        b = Math.max(b, 0);
        if (null !== this.Gd) var g = this.geometry.bounds; else {
            var h = this.figure, k = Nn[h];
            if (void 0 === k) {
                var l = K.me[h];
                "string" === typeof l && (l = K.me[l]);
                "function" === typeof l ? (k = l(null, 100, 100), Nn[h] = k) : v("Unsupported Figure: " + h)
            }
            g = k.bounds
        }
        h = g.width;
        k = g.height;
        l = g.width;
        var m = g.height;
        switch (Cl(this, !0)) {
            case Og:
                d = c = 0;
                break;
            case Jd:
                l = Math.max(a - f, 0);
                m = Math.max(b - f, 0);
                break;
            case nl:
                l = Math.max(a - f, 0);
                d = 0;
                break;
            case ol:
                c = 0, m =
                    Math.max(b - f, 0)
        }
        isFinite(e.width) && (l = e.width);
        isFinite(e.height) && (m = e.height);
        e = this.maxSize;
        g = this.minSize;
        c = Math.max(c - f, g.width);
        d = Math.max(d - f, g.height);
        l = Math.min(e.width, l);
        m = Math.min(e.height, m);
        l = isFinite(l) ? Math.max(c, l) : Math.max(h, c);
        m = isFinite(m) ? Math.max(d, m) : Math.max(k, d);
        c = Pg(this);
        switch (c) {
            case Og:
                break;
            case Jd:
                h = l;
                k = m;
                break;
            case Qg:
                c = Math.min(l / h, m / k);
                isFinite(c) || (c = 1);
                h *= c;
                k *= c;
                break;
            default:
                v(c + " is not a valid geometryStretch.")
        }
        null !== this.Gd ? (h = Math.max(h, .01), k = Math.max(k,
            .01), c = null !== this.Gd ? this.Gd : this.ua, e = c.bounds, d = h / e.width, e = k / e.height, isFinite(d) || (d = 1), isFinite(e) || (e = 1), c = 1 === d && 1 === e ? c : c.copy().scale(d, e), F && c.freeze(), this.ua = c) : null !== this.ua && K.da(this.ua.Pl, a - f) && K.da(this.ua.Ol, b - f) || (this.ua = Zf.makeGeometry(this, h, k));
        g = this.ua.bounds;
        Infinity === a || Infinity === b ? zl(this, g.x - f / 2, g.y - f / 2, 0 === a && 0 === h ? 0 : g.width + f, 0 === b && 0 === k ? 0 : g.height + f) : zl(this, -(f / 2), -(f / 2), l + f, m + f)
    };

    function Pg(a) {
        var b = a.geometryStretch;
        return null !== a.Gd ? b === ml ? Jd : b : b === ml ? Nn[a.figure].defaultStretch : b
    }

    t.Sh = function (a, b, c, d) {
        El(this, a, b, c, d)
    };
    t.Zt = function (a, b, c) {
        return this.Ik(a.x, a.y, b.x, b.y, c)
    };
    t.Ik = function (a, b, c, d, e) {
        var f = this.transform, g = 1 / (f.m11 * f.m22 - f.m12 * f.m21), h = f.m22 * g, k = -f.m12 * g, l = -f.m21 * g,
            m = f.m11 * g, n = g * (f.m21 * f.dy - f.m22 * f.dx), p = g * (f.m12 * f.dx - f.m11 * f.dy);
        f = a * h + b * l + n;
        g = a * k + b * m + p;
        h = c * h + d * l + n;
        k = c * k + d * m + p;
        n = this.Hh / 2;
        l = this.ua;
        null === l && (this.measure(Infinity, Infinity), l = this.ua);
        var r = l.bounds;
        m = !1;
        if (l.type === Kd) if (1.5 >= this.strokeWidth) m = K.Ve(l.startX, l.startY, l.endX, l.endY, f, g, h, k, e); else {
            l.startX === l.endX ? (d = n, m = 0) : (b = (l.endY - l.startY) / (l.endX - l.startX), m = n / Math.sqrt(1 + b * b),
                d = m * b);
            b = Ma();
            a = new J;
            K.Ve(l.startX + d, l.startY + m, l.endX + d, l.endY + m, f, g, h, k, a) && b.push(a);
            a = new J;
            K.Ve(l.startX - d, l.startY - m, l.endX - d, l.endY - m, f, g, h, k, a) && b.push(a);
            a = new J;
            K.Ve(l.startX + d, l.startY + m, l.startX - d, l.startY - m, f, g, h, k, a) && b.push(a);
            a = new J;
            K.Ve(l.endX + d, l.endY + m, l.endX - d, l.endY - m, f, g, h, k, a) && b.push(a);
            h = b.length;
            if (0 === h) return Oa(b), !1;
            m = !0;
            k = Infinity;
            for (d = 0; d < h; d++) a = b[d], c = (a.x - f) * (a.x - f) + (a.y - g) * (a.y - g), c < k && (k = c, e.x = a.x, e.y = a.y);
            Oa(b)
        } else if (l.type === Od) m = K.Of(r.x - n, r.y - n, r.x + r.width +
            n, r.y + r.height + n, f, g, h, k, e); else if (l.type === Pd) {
            b = L.allocAt(r.x, r.y, r.width, r.height).Pc(n, n);
            a:if (0 === b.width) m = K.Ve(b.x, b.y, b.x, b.y + b.height, f, g, h, k, e); else if (0 === b.height) m = K.Ve(b.x, b.y, b.x + b.width, b.y, f, g, h, k, e); else {
                a = b.width / 2;
                l = b.height / 2;
                d = b.x + a;
                m = b.y + l;
                c = 9999;
                f !== h && (c = (g - k) / (f - h));
                if (9999 > Math.abs(c)) {
                    k = g - m - c * (f - d);
                    if (0 > a * a * c * c + l * l - k * k) {
                        e.x = NaN;
                        e.y = NaN;
                        m = !1;
                        break a
                    }
                    n = Math.sqrt(a * a * c * c + l * l - k * k);
                    h = (-(a * a * c * k) + a * l * n) / (l * l + a * a * c * c) + d;
                    a = (-(a * a * c * k) - a * l * n) / (l * l + a * a * c * c) + d;
                    l = c * (h - d) + k + m;
                    k = c *
                        (a - d) + k + m;
                    Math.abs((f - h) * (f - h)) + Math.abs((g - l) * (g - l)) < Math.abs((f - a) * (f - a)) + Math.abs((g - k) * (g - k)) ? (e.x = h, e.y = l) : (e.x = a, e.y = k)
                } else {
                    h = l * l;
                    k = f - d;
                    h -= h / (a * a) * k * k;
                    if (0 > h) {
                        e.x = NaN;
                        e.y = NaN;
                        m = !1;
                        break a
                    }
                    k = Math.sqrt(h);
                    h = m + k;
                    k = m - k;
                    Math.abs(h - g) < Math.abs(k - g) ? (e.x = f, e.y = h) : (e.x = f, e.y = k)
                }
                m = !0
            }
            L.free(b)
        } else if (l.type === Id) {
            p = J.alloc();
            var q = h - f;
            var u = k - g, x = q * q + u * u, y = f, z = g;
            if (0 < x && r.contains(y, z) && (p.x = y, p.y = z, this.ca(p))) for (y -= q, z -= u; r.contains(y, z);) y -= q, z -= u;
            e.x = h;
            e.y = k;
            for (u = 0; u < l.figures.count; u++) {
                var B =
                    l.figures.j[u], D = B.isFilled ? y : f, G = B.isFilled ? z : g, O = B.segments;
                r = B.startX;
                q = B.startY;
                for (var U = r, R = q, fa = 0; fa < O.count; fa++) {
                    var Y = O.j[fa], P = Y.type;
                    var ya = Y.endX;
                    var ka = Y.endY;
                    var Aa = !1;
                    switch (P) {
                        case me:
                            U = ya;
                            R = ka;
                            break;
                        case Md:
                            Aa = On(r, q, ya, ka, D, G, h, k, p);
                            break;
                        case ne:
                            Aa = K.Fq(r, q, Y.point1X, Y.point1Y, Y.point2X, Y.point2Y, ya, ka, D, G, h, k, .6, p);
                            break;
                        case oe:
                            Aa = K.Fq(r, q, r + 2 / 3 * (Y.point1X - r), q + 2 / 3 * (Y.point1Y - q), ya + 2 / 3 * (Y.point1X - ya), ka + 2 / 3 * (Y.point1Y - ka), ya, ka, D, G, h, k, .6, p);
                            break;
                        case pe:
                        case qe:
                            P = Y.type ===
                            pe ? re(Y, B) : se(Y, B, r, q);
                            var Ta = P.length;
                            if (0 === Ta) {
                                Aa = On(r, q, Y.centerX, Y.centerY, D, G, h, k, p);
                                break
                            }
                            ka = null;
                            for (ya = 0; ya < Ta; ya++) {
                                ka = P[ya];
                                if (0 === ya && On(r, q, ka[0], ka[1], D, G, h, k, p)) {
                                    var sb = Pn(D, G, p, x, e);
                                    sb < x && (x = sb, m = !0)
                                }
                                K.Fq(ka[0], ka[1], ka[2], ka[3], ka[4], ka[5], ka[6], ka[7], D, G, h, k, .6, p) && (sb = Pn(D, G, p, x, e), sb < x && (x = sb, m = !0))
                            }
                            ya = ka[6];
                            ka = ka[7];
                            break;
                        default:
                            v("Unknown Segment type: " + P)
                    }
                    r = ya;
                    q = ka;
                    Aa && (Aa = Pn(D, G, p, x, e), Aa < x && (x = Aa, m = !0));
                    Y.isClosed && (ya = U, ka = R, On(r, q, ya, ka, D, G, h, k, p) && (Y = Pn(D, G, p, x, e), Y <
                    x && (x = Y, m = !0)))
                }
            }
            f = c - a;
            g = d - b;
            h = Math.sqrt(f * f + g * g);
            0 !== h && (f /= h, g /= h);
            e.x -= f * n;
            e.y -= g * n;
            J.free(p)
        } else v("Unknown Geometry type: " + l.type);
        if (!m) return !1;
        this.transform.ya(e);
        return !0
    };

    function Pn(a, b, c, d, e) {
        a = c.x - a;
        b = c.y - b;
        b = a * a + b * b;
        return b < d ? (e.x = c.x, e.y = c.y, b) : d
    }

    function On(a, b, c, d, e, f, g, h, k) {
        var l = !1, m = (e - g) * (b - d) - (f - h) * (a - c);
        if (0 === m) return !1;
        k.x = ((e * h - f * g) * (a - c) - (e - g) * (a * d - b * c)) / m;
        k.y = ((e * h - f * g) * (b - d) - (f - h) * (a * d - b * c)) / m;
        (a > c ? a - c : c - a) < (b > d ? b - d : d - b) ? (a = b < d ? b : d, b = b < d ? d : b, (k.y > a || K.da(k.y, a)) && (k.y < b || K.da(k.y, b)) && (l = !0)) : (b = a < c ? a : c, a = a < c ? c : a, (k.x > b || K.da(k.x, b)) && (k.x < a || K.da(k.x, a)) && (l = !0));
        return l
    }

    t.Th = function (a, b) {
        if (void 0 === b) return a.Pe(this.actualBounds);
        var c = this.ua;
        null === c && (this.measure(Infinity, Infinity), c = this.ua);
        c = c.bounds;
        var d = this.strokeWidth / 2, e = !1, f = J.alloc();
        f.h(c.x - d, c.y - d);
        a.ca(b.ya(f)) && (f.h(c.x - d, c.bottom + d), a.ca(b.ya(f)) && (f.h(c.right + d, c.bottom + d), a.ca(b.ya(f)) && (f.h(c.right + d, c.y - d), a.ca(b.ya(f)) && (e = !0))));
        J.free(f);
        return e
    };
    t.Sc = function (a, b) {
        if (this.Th(a, b) || void 0 === b && (b = this.transform, a.Pe(this.actualBounds))) return !0;
        var c = Ib.alloc();
        c.set(b);
        c.du();
        var d = a.left, e = a.right, f = a.top;
        a = a.bottom;
        var g = J.alloc();
        g.h(d, f);
        c.ya(g);
        if (this.Uh(g, !0)) return J.free(g), !0;
        g.h(e, f);
        c.ya(g);
        if (this.Uh(g, !0)) return J.free(g), !0;
        g.h(d, a);
        c.ya(g);
        if (this.Uh(g, !0)) return J.free(g), !0;
        g.h(e, a);
        c.ya(g);
        if (this.Uh(g, !0)) return J.free(g), !0;
        var h = J.alloc(), k = J.alloc();
        c.set(b);
        c.uw(this.transform);
        c.du();
        h.x = e;
        h.y = f;
        h.transform(c);
        g.x =
            d;
        g.y = f;
        g.transform(c);
        b = !1;
        Qn(this, g, h, k) ? b = !0 : (g.x = e, g.y = a, g.transform(c), Qn(this, g, h, k) ? b = !0 : (h.x = d, h.y = a, h.transform(c), Qn(this, g, h, k) ? b = !0 : (g.x = d, g.y = f, g.transform(c), Qn(this, g, h, k) && (b = !0))));
        J.free(g);
        Ib.free(c);
        J.free(h);
        J.free(k);
        return b
    };

    function Qn(a, b, c, d) {
        if (!a.Zt(b, c, d)) return !1;
        a = b.x;
        b = b.y;
        var e = c.x, f = c.y;
        c = d.x;
        d = d.y;
        if (a === e) return b < f ? (a = b, b = f) : a = f, d >= a && d <= b;
        a < e ? (d = a, a = e) : d = e;
        return c >= d && c <= a
    }

    t.Gy = function (a, b, c) {
        function d(a, b) {
            for (var c = a.length, d = 0; d < c; d += 2) if (b.ud(a[d], a[d + 1]) > e) return !0;
            return !1
        }

        if (c && null !== this.fill && this.Uh(a, !0)) return !0;
        var e = a.Re(b), f = e;
        1.5 < this.strokeWidth && (e = this.strokeWidth / 2 + Math.sqrt(e), e *= e);
        b = this.ua;
        if (null === b && (this.measure(Infinity, Infinity), b = this.ua, null === b)) return !1;
        if (!c) {
            var g = b.bounds, h = g.x, k = g.y, l = g.x + g.width;
            g = g.y + g.height;
            if (Lb(a.x, a.y, h, k) <= e && Lb(a.x, a.y, l, k) <= e && Lb(a.x, a.y, h, g) <= e && Lb(a.x, a.y, l, g) <= e) return !0
        }
        h = b.startX;
        k = b.startY;
        l =
            b.endX;
        g = b.endY;
        if (b.type === Kd) {
            if (c = Kb(a.x, a.y, h, k, l, g), b = (h - l) * (a.x - l) + (k - g) * (a.y - g), c <= (0 <= (l - h) * (a.x - h) + (g - k) * (a.y - k) && 0 <= b ? e : f)) return !0
        } else {
            if (b.type === Od) return b = !1, c && (b = Kb(a.x, a.y, h, k, h, g) <= e || Kb(a.x, a.y, h, k, l, k) <= e || Kb(a.x, a.y, l, k, l, g) <= e || Kb(a.x, a.y, h, g, l, g) <= e), b;
            if (b.type === Pd) {
                b = a.x - (h + l) / 2;
                f = a.y - (k + g) / 2;
                var m = Math.abs(l - h) / 2, n = Math.abs(g - k) / 2;
                if (0 === m || 0 === n) return Kb(a.x, a.y, h, k, l, g) <= e ? !0 : !1;
                if (c) {
                    if (a = K.aA(m, n, b, f), a * a <= e) return !0
                } else return Lb(b, f, -m, 0) >= e || Lb(b, f, 0, -n) >= e ||
                Lb(b, f, 0, n) >= e || Lb(b, f, m, 0) >= e ? !1 : !0
            } else if (b.type === Id) {
                l = b.bounds;
                f = l.x;
                h = l.y;
                k = l.x + l.width;
                l = l.y + l.height;
                if (a.x > k && a.x < f && a.y > l && a.y < h && Kb(a.x, a.y, f, h, f, l) > e && Kb(a.x, a.y, f, h, k, h) > e && Kb(a.x, a.y, k, l, f, l) > e && Kb(a.x, a.y, k, l, k, h) > e) return !1;
                f = Math.sqrt(e);
                if (c) {
                    if (null === this.fill ? ve(b, a.x, a.y, f) : te(b, a, f, !0, !1)) return !0
                } else {
                    c = b.figures;
                    for (b = 0; b < c.count; b++) {
                        f = c.j[b];
                        g = f.startX;
                        m = f.startY;
                        if (a.ud(g, m) > e) return !1;
                        h = f.segments.j;
                        k = h.length;
                        for (l = 0; l < k; l++) switch (n = h[l], n.type) {
                            case me:
                            case Md:
                                g = n.endX;
                                m = n.endY;
                                if (a.ud(g, m) > e) return !1;
                                break;
                            case ne:
                                var p = Ma();
                                K.Oe(g, m, n.point1X, n.point1Y, n.point2X, n.point2Y, n.endX, n.endY, .8, p);
                                g = d(p, a);
                                Oa(p);
                                if (g) return !1;
                                g = n.endX;
                                m = n.endY;
                                if (a.ud(g, m) > e) return !1;
                                break;
                            case oe:
                                p = Ma();
                                K.hr(g, m, n.point1X, n.point1Y, n.endX, n.endY, .8, p);
                                g = d(p, a);
                                Oa(p);
                                if (g) return !1;
                                g = n.endX;
                                m = n.endY;
                                if (a.ud(g, m) > e) return !1;
                                break;
                            case pe:
                            case qe:
                                p = n.type === pe ? re(n, f) : se(n, f, g, m);
                                var r = p.length;
                                if (0 === r) {
                                    g = n.centerX;
                                    m = n.centerY;
                                    if (a.ud(g, m) > e) return !1;
                                    break
                                }
                                n = null;
                                for (var q = Ma(), u = 0; u <
                                r; u++) if (n = p[u], q.length = 0, K.Oe(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], .8, q), d(q, a)) return Oa(q), !1;
                                Oa(q);
                                null !== n && (g = n[6], m = n[7]);
                                break;
                            default:
                                v("Unknown Segment type: " + n.type)
                        }
                    }
                    return !0
                }
            }
        }
        return !1
    };
    t.jc = function () {
        this.ua = null
    };

    function Rn(a) {
        var b = a.diagram;
        null !== b && b.undoManager.isUndoingRedoing || (a.segmentOrientation = mn, "None" !== a.Bm ? (a.segmentIndex = -1, a.alignmentFocus = qd) : "None" !== a.Fl && (a.segmentIndex = 0, a.alignmentFocus = new M(1 - qd.x, qd.y)))
    }

    Zf.makeGeometry = function (a, b, c) {
        if ("None" !== a.toArrow) var d = Sn[a.toArrow]; else "None" !== a.fromArrow ? d = Sn[a.fromArrow] : (d = K.me[a.figure], "string" === typeof d && (d = K.me[d]), void 0 === d && v("Unknown Shape.figure: " + a.figure), d = d(a, b, c), d.Pl = b, d.Ol = c);
        if (null === d) {
            var e = K.me.Rectangle;
            "function" === typeof e && (d = e(a, b, c))
        }
        F && (d.bounds.width > b + 1E-5 || d.bounds.height > c + 1E-5) && v('Geometry made with figure "' + a.figure + '" has bounds ' + d.bounds.toString() + " that are too large for the given size (" + b + "," + c + "). See documentation for Shape.defineFigureGenerator.");
        return d
    };

    function Tn(a) {
        var b = Sn[a];
        if (void 0 === b) {
            var c = a.toLowerCase();
            if ("none" === c) return "None";
            b = Sn[c];
            if (void 0 === b) {
                var d = null, e;
                for (e in K.on) if (e.toLowerCase() === c) {
                    d = e;
                    break
                }
                if (null !== d) return a = Qd(K.on[d], !1), Sn[d] = a, c !== d && (Sn[c] = d), d
            }
        }
        return "string" === typeof b ? b : b instanceof Hd ? a : null
    }

    na.Object.defineProperties(Zf.prototype, {
        geometry: {
            configurable: !0, get: function () {
                return null !== this.ua ? this.ua : this.Gd
            }, set: function (a) {
                var b = this.ua, c = this.Gd;
                if (b !== a) {
                    null !== a ? (F && w(a, Hd, Zf, "geometry"), this.Gd = this.ua = a.freeze()) : this.Gd = this.ua = null;
                    var d = this.part;
                    null !== d && (d.wh = NaN);
                    this.v();
                    this.g("geometry", b || c, a);
                    wl(this) && (a = this.part, null !== a && xl(this, a, "geometryString"))
                }
            }
        }, geometryString: {
            configurable: !0, get: function () {
                return null === this.geometry ? "" : this.geometry.toString()
            },
            set: function (a) {
                a = Qd(a);
                var b = a.normalize();
                this.geometry = a;
                this.position = a = J.allocAt(-b.x, -b.y);
                J.free(a)
            }
        }, isGeometryPositioned: {
            configurable: !0, get: function () {
                return this.Co
            }, set: function (a) {
                F && A(a, "boolean", Zf, "isGeometryPositioned");
                var b = this.Co;
                b !== a && (this.Co = a, this.v(), this.g("isGeometryPositioned", b, a))
            }
        }, fill: {
            configurable: !0, get: function () {
                return this.Dl
            }, set: function (a) {
                var b = this.Dl;
                b !== a && (null !== a && hm(a, "Shape.fill"), a instanceof Ll && a.freeze(), this.Dl =
                    a, this.P(), this.g("fill", b, a))
            }
        }, stroke: {
            configurable: !0, get: function () {
                return this.Oc
            }, set: function (a) {
                var b = this.Oc;
                b !== a && (null !== a && hm(a, "Shape.stroke"), a instanceof Ll && a.freeze(), this.Oc = a, this.P(), this.g("stroke", b, a))
            }
        }, strokeWidth: {
            configurable: !0, get: function () {
                return this.Hh
            }, set: function (a) {
                var b = this.Hh;
                if (b !== a) if (F && C(a, Zf, "strokeWidth"), 0 <= a) {
                    this.Hh = a;
                    this.v();
                    var c = this.part;
                    null !== c && (c.wh = NaN);
                    this.g("strokeWidth", b, a)
                } else za(a, "value >= 0", Zf, "strokeWidth:value")
            }
        },
        strokeCap: {
            configurable: !0, get: function () {
                return this.um
            }, set: function (a) {
                var b = this.um;
                b !== a && ("string" !== typeof a || "butt" !== a && "round" !== a && "square" !== a ? za(a, '"butt", "round", or "square"', Zf, "strokeCap") : (this.um = a, this.P(), this.g("strokeCap", b, a)))
            }
        }, strokeJoin: {
            configurable: !0, get: function () {
                return this.vm
            }, set: function (a) {
                var b = this.vm;
                b !== a && ("string" !== typeof a || "miter" !== a && "bevel" !== a && "round" !== a ? za(a, '"miter", "bevel", or "round"', Zf, "strokeJoin") : (this.vm =
                    a, this.P(), this.g("strokeJoin", b, a)))
            }
        }, strokeMiterLimit: {
            configurable: !0, get: function () {
                return this.rk
            }, set: function (a) {
                var b = this.rk;
                if (b !== a) if (F && C(a, Zf, "strokeMiterLimit"), 1 <= a) {
                    this.rk = a;
                    this.P();
                    var c = this.part;
                    null !== c && (c.wh = NaN);
                    this.g("strokeMiterLimit", b, a)
                } else F && za(a, "value >= 1", Zf, "strokeWidth:value")
            }
        }, strokeDashArray: {
            configurable: !0, get: function () {
                return this.Fh
            }, set: function (a) {
                var b = this.Fh;
                if (b !== a) {
                    null === a || Array.isArray(a) || xa(a, "Array", Zf, "strokeDashArray:value");
                    if (null !== a) {
                        for (var c = a.length, d = 0, e = 0; e < c; e++) {
                            var f = a[e];
                            (!F || "number" === typeof f) && 0 <= f && isFinite(f) || v("strokeDashArray:value " + f + " at index " + e + " must be a positive number or zero.");
                            d += f
                        }
                        if (0 === d) {
                            if (null === b) return;
                            a = null
                        }
                    }
                    this.Fh = a;
                    this.P();
                    this.g("strokeDashArray", b, a)
                }
            }
        }, strokeDashOffset: {
            configurable: !0, get: function () {
                return this.Gh
            }, set: function (a) {
                var b = this.Gh;
                b !== a && (F && C(a, Zf, "strokeDashOffset"), 0 <= a && (this.Gh = a, this.P(), this.g("strokeDashOffset", b, a)))
            }
        }, figure: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.jo
            }, set: function (a) {
                var b = this.jo;
                if (b !== a) {
                    F && A(a, "string", Zf, "figure");
                    var c = K.me[a];
                    "function" === typeof c ? c = a : (c = K.me[a.toLowerCase()]) || v("Unknown Shape.figure: " + a);
                    b !== c && (a = this.part, null !== a && (a.wh = NaN), this.jo = c, this.Gd = null, this.jc(), this.v(), this.g("figure", b, c))
                }
            }
        }, toArrow: {
            configurable: !0, get: function () {
                return this.Bm
            }, set: function (a) {
                var b = this.Bm;
                !0 === a ? a = "Standard" : !1 === a && (a = "");
                if (b !== a) {
                    F && A(a, "string", Zf, "toArrow");
                    var c = Tn(a);
                    null === c ? v("Unknown Shape.toArrow: " + a) : b !== c && (this.Bm = c, this.Gd = null, this.jc(), this.v(), Rn(this), this.g("toArrow", b, c))
                }
            }
        }, fromArrow: {
            configurable: !0, get: function () {
                return this.Fl
            }, set: function (a) {
                var b = this.Fl;
                !0 === a ? a = "Standard" : !1 === a && (a = "");
                if (b !== a) {
                    F && A(a, "string", Zf, "fromArrow");
                    var c = Tn(a);
                    null === c ? v("Unknown Shape.fromArrow: " + a) : b !== c && (this.Fl = c, this.Gd = null, this.jc(), this.v(), Rn(this), this.g("fromArrow", b, c))
                }
            }
        }, spot1: {
            configurable: !0, get: function () {
                return this.Af
            },
            set: function (a) {
                w(a, M, Zf, "spot1");
                var b = this.Af;
                b.A(a) || (this.Af = a = a.J(), this.v(), this.g("spot1", b, a))
            }
        }, spot2: {
            configurable: !0, get: function () {
                return this.Bf
            }, set: function (a) {
                w(a, M, Zf, "spot2");
                var b = this.Bf;
                b.A(a) || (this.Bf = a = a.J(), this.v(), this.g("spot2", b, a))
            }
        }, parameter1: {
            configurable: !0, get: function () {
                return this.Ap
            }, set: function (a) {
                var b = this.Ap;
                b !== a && (this.Ap = a, this.jc(), this.v(), this.g("parameter1", b, a))
            }
        }, parameter2: {
            configurable: !0, get: function () {
                return this.Bp
            },
            set: function (a) {
                var b = this.Bp;
                b !== a && (this.Bp = a, this.jc(), this.v(), this.g("parameter2", b, a))
            }
        }, naturalBounds: {
            configurable: !0, get: function () {
                if (null !== this.ua) return this.wc.assign(this.ua.bounds), this.wc;
                var a = this.desiredSize;
                return new L(0, 0, a.width, a.height)
            }
        }, pathPattern: {
            configurable: !0, get: function () {
                return this.Dp
            }, set: function (a) {
                var b = this.Dp;
                b !== a && (F && null !== a && w(a, N, Zf, "pathPattern"), this.Dp = a, this.P(), this.g("pathPattern", b, a))
            }
        }, geometryStretch: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.ro
            }, set: function (a) {
                var b = this.ro;
                b !== a && (ib(a, N, Zf, "geometryStretch"), this.ro = a, this.g("geometryStretch", b, a))
            }
        }, interval: {
            configurable: !0, get: function () {
                return this.Yd
            }, set: function (a) {
                var b = this.Yd;
                F && C(a, Zf, "interval");
                a = Math.round(a);
                if (b !== a && 0 !== a && isFinite(a)) {
                    this.Yd = a;
                    var c = this.diagram;
                    null !== c && this.panel === c.grid && Dj(c);
                    this.v();
                    c = this.panel;
                    null !== c && (c.qh = null);
                    this.g("interval", b, a)
                }
            }
        }, graduatedStart: {
            configurable: !0,
            get: function () {
                return this.Wd
            }, set: function (a) {
                var b = this.Wd;
                F && C(a, Zf, "graduatedStart");
                b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), this.Wd = a, this.v(), this.g("graduatedStart", b, a))
            }
        }, graduatedEnd: {
            configurable: !0, get: function () {
                return this.Ud
            }, set: function (a) {
                var b = this.Ud;
                F && C(a, Zf, "graduatedEnd");
                b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), this.Ud = a, this.v(), this.g("graduatedEnd", b, a))
            }
        }, graduatedSkip: {
            configurable: !0, get: function () {
                return this.Vd
            }, set: function (a) {
                var b = this.Vd;
                b !== a && (null !== a && A(a,
                    "function", Zf, "graduatedSkip"), this.Vd = a, this.v(), this.g("graduatedSkip", b, a))
            }
        }
    });
    Zf.prototype.intersectsRect = Zf.prototype.Sc;
    Zf.prototype.containedInRect = Zf.prototype.Th;
    Zf.prototype.getNearestIntersectionPoint = Zf.prototype.Zt;
    Zf.prototype.getDocumentBounds = Zf.prototype.wj;
    Zf.prototype.getDocumentPoint = Zf.prototype.ja;
    var Sn = new kb, Nn = new kb;
    Zf.className = "Shape";
    Zf.getFigureGenerators = function () {
        var a = new Db, b;
        for (b in K.me) b !== b.toLowerCase() && a.add(b, K.me[b]);
        a.freeze();
        return a
    };
    Zf.defineFigureGenerator = function (a, b) {
        A(a, "string", Zf, "defineFigureGenerator:name");
        "string" === typeof b ? !F || "" !== b && K.me[b] || v("Shape.defineFigureGenerator synonym must not be empty or None or not a defined figure name: " + b) : A(b, "function", Zf, "defineFigureGenerator:func");
        var c = a.toLowerCase();
        !F || "" !== a && a !== c || v("Shape.defineFigureGenerator name must not be empty or all-lower-case: " + a);
        var d = K.me;
        d[a] = b;
        d[c] = a
    };
    Zf.getArrowheadGeometries = function () {
        var a = new Db;
        for (d in K.on) if (void 0 === Sn[d]) {
            var b = Qd(K.on[d], !1);
            Sn[d] = b;
            b = d.toLowerCase();
            b !== d && (Sn[b] = d)
        }
        for (var c in Sn) if (c !== c.toLowerCase()) {
            var d = Sn[c];
            d instanceof Hd && a.add(c, d)
        }
        a.freeze();
        return a
    };
    Zf.defineArrowheadGeometry = function (a, b) {
        A(a, "string", Zf, "defineArrowheadGeometry:name");
        "string" === typeof b ? (A(b, "string", Zf, "defineArrowheadGeometry:pathstr"), b = Qd(b, !1)) : w(b, Hd, Zf, "defineArrowheadGeometry:pathstr");
        var c = a.toLowerCase();
        (F && "" === a || "none" === c || a === c) && v("Shape.defineArrowheadGeometry name must not be empty or None or all-lower-case: " + a);
        var d = Sn;
        d[a] = b;
        d[c] = a
    };

    function kh() {
        N.call(this);
        Un || (Vn = ih ? (new Sk(null)).context : null, Un = !0);
        this.Wx = this.$b = "";
        this.Oc = "black";
        this.te = "13px sans-serif";
        this.ej = "start";
        this.Td = Og;
        this.kj = md;
        this.Zj = !0;
        this.Ji = this.Ki = !1;
        this.zg = fo;
        this.Mg = go;
        this.Hs = this.zb = this.ed = 0;
        this.ov = this.pv = null;
        this.fo = !1;
        this.Jc = this.Hn = this.rq = this.fj = this.sq = null;
        this.zf = this.yf = 0;
        this.Ce = Infinity;
        this.Ni = 0;
        this.ue = null;
        this.Ie = 0;
        this.se = this.qb = this.Wb = null;
        this.Yd = 1;
        this.Wd = 0;
        this.Ud = 1;
        this.Vd = this.Vj = null
    }

    ma(kh, N);
    kh.prototype.cloneProtected = function (a) {
        N.prototype.cloneProtected.call(this, a);
        a.$b = this.$b;
        a.Wx = this.Wx;
        a.Oc = this.Oc;
        a.te = this.te;
        a.ej = this.ej;
        a.Td = this.Td;
        a.kj = this.kj;
        a.Zj = this.Zj;
        a.Ki = this.Ki;
        a.Ji = this.Ji;
        a.zg = this.zg;
        a.Mg = this.Mg;
        a.ed = this.ed;
        a.Hs = this.Hs;
        a.zb = this.zb;
        a.pv = this.pv;
        a.ov = this.ov;
        a.fo = this.fo;
        a.sq = this.sq;
        a.fj = this.fj;
        a.rq = this.rq;
        a.Hn = this.Hn;
        a.Jc = this.Jc;
        a.yf = this.yf;
        a.zf = this.zf;
        a.Ce = this.Ce;
        a.ue = this.ue;
        a.Ie = this.Ie;
        a.Wb = this.Wb;
        a.qb = this.qb;
        a.se = this.se;
        a.Ni = this.Ni;
        a.Yd =
            this.Yd;
        a.Wd = this.Wd;
        a.Ud = this.Ud;
        a.Vj = this.Vj;
        a.Vd = this.Vd
    };

    function ln(a, b) {
        a.I = b.I | 6144;
        a.nb = b.opacity;
        a.rb = b.background;
        a.kc = b.areaBackground;
        a.dd = b.desiredSize.J();
        a.sg = b.minSize.J();
        a.rg = b.maxSize.J();
        a.pg = b.pg.copy();
        a.Fa = b.scale;
        a.dc = b.angle;
        a.Le = b.stretch;
        a.vh = b.margin.J();
        a.Eb = b.alignment.J();
        a.jl = b.alignmentFocus.J();
        a.km = b.segmentFraction;
        a.lm = b.segmentOffset.J();
        a.mm = b.segmentOrientation;
        null !== b.fb && (a.fb = b.fb.copy());
        a.om = b.shadowVisible;
        b instanceof kh && (a.$b = b.$b, a.Oc = b.Oc, a.te = b.te, a.ej = b.ej, a.Td = b.Td, a.kj = b.kj, a.Zj = b.Zj, a.Ki = b.Ki, a.Ji = b.Ji,
            a.zg = b.zg, a.Mg = b.Mg, a.ue = null, a.yf = b.yf, a.zf = b.zf, a.Ce = b.Ce, a.Ni = b.Ni, a.Yd = b.Yd, a.Wd = b.Wd, a.Ud = b.Ud, a.Vj = b.Vj, a.Vd = b.Vd)
    }

    t = kh.prototype;
    t.pb = function (a) {
        a.classType === kh ? this.wrap = a : N.prototype.pb.call(this, a)
    };
    t.toString = function () {
        return 22 < this.$b.length ? 'TextBlock("' + this.$b.substring(0, 20) + '"...)' : 'TextBlock("' + this.$b + '")'
    };
    t.v = function () {
        N.prototype.v.call(this);
        this.ov = this.pv = null
    };

    function ho(a) {
        Un || (Vn = ih ? (new Sk(null)).context : null, Un = !0);
        if (null === Vn) return !0;
        var b = Vn.font;
        if (a === b || "10px sans-serif" === a) return !0;
        Vn.font = "10px sans-serif";
        Vn.font = a;
        var c = Vn.font;
        if ("10px sans-serif" !== c) return Vn.font = b, !0;
        Vn.font = "19px serif";
        var d = Vn.font;
        Vn.font = a;
        c = Vn.font;
        Vn.font = b;
        return c !== d
    }

    t.oj = function (a, b) {
        if (null !== this.Oc && 0 !== this.$b.length && null !== this.te) {
            var c = this.naturalBounds, d = this.actualBounds, e = c.width, f = c.height, g = io(this),
                h = a.textAlign = this.ej, k = b.Sl;
            "start" === h ? h = k ? "right" : "left" : "end" === h && (h = k ? "left" : "right");
            k = this.Ki;
            var l = this.Ji;
            Ai(this, a, this.Oc, !0, !1, c, d);
            (k || l) && Ai(this, a, this.Oc, !1, !1, c, d);
            d = 0;
            c = !1;
            var m = J.allocAt(0, 0);
            this.Hd.ya(m);
            var n = J.allocAt(0, g);
            this.Hd.ya(n);
            var p = m.Re(n);
            J.free(m);
            J.free(n);
            m = b.scale;
            8 > p * m * m && (c = !0);
            b.Nb !== a && (c = !1);
            !1 === b.Te("textGreeking") &&
            (c = !1);
            b = this.yf;
            p = this.zf;
            switch (this.flip) {
                case rl:
                    a.translate(e, 0);
                    a.scale(-1, 1);
                    break;
                case ql:
                    a.translate(0, f);
                    a.scale(1, -1);
                    break;
                case sl:
                    a.translate(e, f), a.scale(-1, -1)
            }
            m = this.ed;
            n = (b + g + p) * m;
            f > n && (d = this.kj, d = d.y * f - d.y * n + d.offsetY);
            if (1 === m && null !== this.se) p = this.zb, p > e && (p = e), this.nj(this.se, a, 0, d + b, e, g, p, c, h, k, l); else if (null !== this.Wb && null !== this.qb) for (n = 0; n < m; n++) {
                var r = this.Wb[n];
                r > e && (r = e);
                d += b;
                this.nj(this.qb[n], a, 0, d, e, g, r, c, h, k, l);
                d += g + p
            }
            switch (this.flip) {
                case rl:
                    a.scale(-1, 1);
                    a.translate(-e,
                        0);
                    break;
                case ql:
                    a.scale(1, -1);
                    a.translate(0, -f);
                    break;
                case sl:
                    a.scale(-1, -1), a.translate(-e, -f)
            }
        }
    };
    t.nj = function (a, b, c, d, e, f, g, h, k, l, m) {
        var n = 0;
        h ? ("left" === k ? n = 0 : "right" === k ? n = e - g : "center" === k && (n = (e - g) / 2), b.fillRect(c + n, d + .25 * f, g, 1)) : ("left" === k ? n = 0 : "right" === k ? n = e : "center" === k && (n = e / 2), e = null !== jo ? jo(this, f) : .75 * f, b.fillText(a, c + n, d + e), a = f / 20 | 0, 0 === a && (a = 1), "right" === k ? n -= g : "center" === k && (n -= g / 2), l && (k = null !== ko ? ko(this, f) : .8 * f, b.beginPath(), b.lineWidth = a, b.moveTo(c + n, d + k), b.lineTo(c + n + g, d + k), b.stroke()), m && (b.beginPath(), b.lineWidth = a, d = d + f - f / 2.2 | 0, 0 !== a % 2 && (d += .5), b.moveTo(c + n, d), b.lineTo(c +
            n + g, d), b.stroke()))
    };
    t.Tm = function (a, b, c, d) {
        this.Ni = a;
        var e = this.te;
        null !== Vn && lo !== e && (lo = Vn.font = e);
        this.zb = this.Ie = 0;
        this.se = this.qb = this.Wb = this.ue = null;
        var f;
        if (isNaN(this.desiredSize.width)) {
            e = this.$b.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
            if (0 === e.length) e = 0; else if (this.isMultiline) {
                for (var g = f = 0, h = !1; !h;) {
                    var k = e.indexOf("\n", g);
                    -1 === k && (k = e.length, h = !0);
                    f = Math.max(f, mo(e.substr(g, k - g).trim()));
                    g = k + 1
                }
                e = f
            } else f = e.indexOf("\n", 0), 0 <= f && (e = e.substr(0, f)), e = mo(e);
            e = Math.min(e, a / this.scale);
            e = Math.max(8, e)
        } else e =
            this.desiredSize.width;
        null !== this.panel && (e = Math.min(e, this.panel.maxSize.width));
        f = no(this, e);
        isNaN(this.desiredSize.height) ? f = Math.min(f, b / this.scale) : f = this.desiredSize.height;
        g = f;
        if (0 !== this.zb && null !== this.Wb && null !== this.qb && this.zg === oo && (b = this.te, b = this.zg === oo ? po(b) : 0, h = this.yf + this.zf, h = Math.max(0, io(this) + h), g = Math.min(this.maxLines - 1, Math.max(Math.floor(g / h + .01) - 1, 0)), !(g + 1 >= this.qb.length))) {
            h = this.qb[g];
            for (b = Math.max(1, a - b); mo(h) > b && 1 < h.length;) h = h.substr(0, h.length - 1);
            h += qo;
            b = mo(h);
            this.qb[g] = h;
            this.qb = this.qb.slice(0, g + 1);
            this.Wb[g] = b;
            this.Wb = this.Wb.slice(0, g + 1);
            this.Ie = this.qb.length;
            this.zb = Math.max(this.zb, b);
            this.ed = this.Ie;
            1 === this.ed && (this.se = this.qb[0])
        }
        if (this.wrap === ro || isNaN(this.desiredSize.width)) e = isNaN(a) ? this.zb : Math.min(a, this.zb), isNaN(this.desiredSize.width) && (e = Math.max(8, e));
        e = Math.max(c, e);
        f = Math.max(d, f);
        ec(this.wc, e, f);
        zl(this, 0, 0, e, f)
    };
    t.Sh = function (a, b, c, d) {
        El(this, a, b, c, d)
    };

    function so(a, b, c) {
        if (null === a.se) a.se = b, a.zb = c; else {
            if (null === a.qb || null === a.Wb) a.qb = [], a.Wb = [], a.qb.push(a.se), a.Wb.push(a.zb);
            a.qb.push(b);
            a.Wb.push(c)
        }
    }

    function to(a, b, c, d) {
        b = b.trim();
        var e = 0;
        var f = a.te;
        var g = a.yf + a.zf;
        g = Math.max(0, io(a) + g);
        var h = a.zg === oo ? po(f) : 0;
        if (a.ed >= a.Ce) null !== d && d.h(0, g); else {
            var k = b;
            if (a.Mg === uo) if (a.Ie = 1, f = mo(b), 0 === h || f <= c) a.zb = Math.max(a.zb, f), so(a, b, a.zb), null !== d && d.h(f, g); else {
                e = vo(a, k);
                k = k.substr(e.length);
                b = vo(a, k);
                for (f = mo(e + b); 0 < b.length && f <= c;) e += b, k = k.substr(b.length), b = vo(a, k), f = mo((e + b).trim());
                e += b.trim();
                for (c = Math.max(1, c - h); mo(e) > c && 1 < e.length;) e = e.substr(0, e.length - 1);
                e += qo;
                b = mo(e);
                a.zb = b;
                so(a, e, b);
                null !==
                d && d.h(b, g)
            } else {
                h = 0;
                0 === k.length && (h = 1, so(a, k, 0));
                for (; 0 < k.length;) {
                    var l = vo(a, k);
                    for (k = k.substr(l.length); mo(l) > c;) {
                        var m = 1;
                        f = mo(l.substr(0, m));
                        for (b = 0; f <= c;) m++, b = f, f = mo(l.substr(0, m));
                        if (1 === m) {
                            var n = f;
                            e = Math.max(e, f)
                        } else n = b, e = Math.max(e, b);
                        m--;
                        1 > m && (m = 1);
                        so(a, l.substr(0, m), n);
                        h++;
                        l = l.substr(m);
                        if (a.ed + h > a.Ce) break
                    }
                    b = vo(a, k);
                    for (f = mo(l + b); 0 < b.length && f <= c;) l += b, k = k.substr(b.length), b = vo(a, k), f = mo((l + b).trim());
                    l = l.trim();
                    if ("" !== l && ("\u00ad" === l[l.length - 1] && (l = l.substring(0, l.length - 1) + "\u2010"),
                        0 === b.length ? (m = f, e = Math.max(e, f)) : (m = b = mo(l), e = Math.max(e, b)), so(a, l, m), h++, a.ed + h > a.Ce)) break
                }
                a.Ie = Math.min(a.Ce, h);
                a.zb = Math.max(a.zb, e);
                null !== d && d.h(a.zb, g * a.Ie)
            }
        }
    }

    function vo(a, b) {
        if (a.Mg === wo) return b.substr(0, 1);
        a = b.length;
        for (var c = 0, d = xo; c < a && !d.test(b.charAt(c));) c++;
        for (; c < a && d.test(b.charAt(c));) c++;
        return c >= a ? b : b.substr(0, c)
    }

    function mo(a) {
        return null === Vn ? 8 * a.length : Vn.measureText(a).width
    }

    function io(a) {
        if (null !== a.ue) return a.ue;
        var b = a.te;
        if (null === Vn) {
            var c = 16;
            return a.ue = c
        }
        void 0 !== yo[b] && 5E3 > zo ? c = yo[b] : (c = 1.3 * Vn.measureText("M").width, yo[b] = c, zo++);
        return a.ue = c
    }

    function po(a) {
        if (null === Vn) return 6;
        if (void 0 !== Ao[a] && 5E3 > Bo) var b = Ao[a]; else b = Vn.measureText(qo).width, Ao[a] = b, Bo++;
        return b
    }

    function no(a, b) {
        var c = a.$b.replace(/\r\n/g, "\n").replace(/\r/g, "\n"), d = a.yf + a.zf;
        d = Math.max(0, io(a) + d);
        if (0 === c.length) return a.zb = 0, a.ed = 1, d;
        if (!a.isMultiline) {
            var e = c.indexOf("\n", 0);
            0 <= e && (c = c.substr(0, e))
        }
        e = 0;
        for (var f = a.ed = 0, g, h = !1; !h;) {
            g = c.indexOf("\n", f);
            -1 === g && (g = c.length, h = !0);
            if (f <= g) {
                f = c.substr(f, g - f);
                if (a.Mg !== uo) {
                    a.Ie = 0;
                    var k = Hb.alloc();
                    to(a, f, b, k);
                    e += k.height;
                    Hb.free(k);
                    a.ed += a.Ie
                } else to(a, f, b, null), e += d, a.ed++;
                a.ed === a.Ce && (h = !0)
            }
            f = g + 1
        }
        return a.Hs = e
    }

    na.Object.defineProperties(kh.prototype, {
        font: {
            configurable: !0, get: function () {
                return this.te
            }, set: function (a) {
                var b = this.te;
                b !== a && (F && (A(a, "string", kh, "font"), ho(a) || v('Not a valid font: "' + a + '"')), this.te = a, this.ue = null, this.v(), this.g("font", b, a))
            }
        }, text: {
            configurable: !0, get: function () {
                return this.$b
            }, set: function (a) {
                var b = this.$b;
                null !== a && void 0 !== a ? a = a.toString() : a = "";
                b !== a && (this.$b = a, this.v(), this.g("text", b, a))
            }
        }, textAlign: {
            configurable: !0, get: function () {
                return this.ej
            },
            set: function (a) {
                var b = this.ej;
                b !== a && (F && A(a, "string", kh, "textAlign"), "start" === a || "end" === a || "left" === a || "right" === a || "center" === a ? (this.ej = a, this.P(), this.g("textAlign", b, a)) : F && za(a, '"start", "end", "left", "right", or "center"', kh, "textAlign"))
            }
        }, flip: {
            configurable: !0, get: function () {
                return this.Td
            }, set: function (a) {
                var b = this.Td;
                b !== a && (ib(a, N, kh, "flip"), this.Td = a, this.P(), this.g("flip", b, a))
            }
        }, verticalAlignment: {
            configurable: !0, get: function () {
                return this.kj
            }, set: function (a) {
                var b =
                    this.kj;
                b.A(a) || (F && (w(a, M, kh, "verticalAlignment"), a.Tb() && v("TextBlock.verticalAlignment for " + this + " must be a real Spot, not:" + a)), this.kj = a = a.J(), Ul(this), this.g("verticalAlignment", b, a))
            }
        }, naturalBounds: {
            configurable: !0, get: function () {
                if (!this.wc.o()) {
                    var a = Hb.alloc();
                    to(this, this.$b, 999999, a);
                    var b = a.width;
                    Hb.free(a);
                    a = no(this, b);
                    var c = this.desiredSize;
                    isNaN(c.width) || (b = c.width);
                    isNaN(c.height) || (a = c.height);
                    ec(this.wc, b, a)
                }
                return this.wc
            }
        }, isMultiline: {
            configurable: !0,
            get: function () {
                return this.Zj
            }, set: function (a) {
                var b = this.Zj;
                b !== a && (F && A(a, "boolean", kh, "isMultiline"), this.Zj = a, this.v(), this.g("isMultiline", b, a))
            }
        }, isUnderline: {
            configurable: !0, get: function () {
                return this.Ki
            }, set: function (a) {
                var b = this.Ki;
                b !== a && (F && A(a, "boolean", kh, "isUnderline"), this.Ki = a, this.P(), this.g("isUnderline", b, a))
            }
        }, isStrikethrough: {
            configurable: !0, get: function () {
                return this.Ji
            }, set: function (a) {
                var b = this.Ji;
                b !== a && (F && A(a, "boolean", kh, "isStrikethrough"),
                    this.Ji = a, this.P(), this.g("isStrikethrough", b, a))
            }
        }, wrap: {
            configurable: !0, get: function () {
                return this.Mg
            }, set: function (a) {
                var b = this.Mg;
                b !== a && (F && ib(a, kh, kh, "wrap"), this.Mg = a, this.v(), this.g("wrap", b, a))
            }
        }, overflow: {
            configurable: !0, get: function () {
                return this.zg
            }, set: function (a) {
                var b = this.zg;
                b !== a && (F && ib(a, kh, kh, "overflow"), this.zg = a, this.v(), this.g("overflow", b, a))
            }
        }, stroke: {
            configurable: !0, get: function () {
                return this.Oc
            }, set: function (a) {
                var b = this.Oc;
                b !==
                a && (null !== a && hm(a, "TextBlock.stroke"), a instanceof Ll && a.freeze(), this.Oc = a, this.P(), this.g("stroke", b, a))
            }
        }, lineCount: {
            configurable: !0, get: function () {
                return this.ed
            }
        }, editable: {
            configurable: !0, get: function () {
                return this.fo
            }, set: function (a) {
                var b = this.fo;
                b !== a && (F && A(a, "boolean", kh, "editable"), this.fo = a, this.g("editable", b, a))
            }
        }, textEditor: {
            configurable: !0, get: function () {
                return this.sq
            }, set: function (a) {
                var b = this.sq;
                b !== a && (!F || a instanceof gf || v("TextBlock.textEditor must be an HTMLInfo."),
                    this.sq = a, this.g("textEditor", b, a))
            }
        }, errorFunction: {
            configurable: !0, get: function () {
                return this.Jc
            }, set: function (a) {
                var b = this.Jc;
                b !== a && (null !== a && A(a, "function", kh, "errorFunction"), this.Jc = a, this.g("errorFunction", b, a))
            }
        }, interval: {
            configurable: !0, get: function () {
                return this.Yd
            }, set: function (a) {
                var b = this.Yd;
                F && C(a, kh, "interval");
                a = Math.round(a);
                if (b !== a && 0 !== a && isFinite(a)) {
                    this.Yd = a;
                    this.v();
                    var c = this.panel;
                    null !== c && (c.qh = null);
                    this.g("interval", b, a)
                }
            }
        }, graduatedStart: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Wd
            }, set: function (a) {
                var b = this.Wd;
                F && C(a, kh, "graduatedStart");
                b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), this.Wd = a, this.v(), this.g("graduatedStart", b, a))
            }
        }, graduatedEnd: {
            configurable: !0, get: function () {
                return this.Ud
            }, set: function (a) {
                var b = this.Ud;
                F && C(a, kh, "graduatedEnd");
                b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), this.Ud = a, this.v(), this.g("graduatedEnd", b, a))
            }
        }, graduatedFunction: {
            configurable: !0, get: function () {
                return this.Vj
            }, set: function (a) {
                var b = this.Vj;
                b !==
                a && (null !== a && A(a, "function", kh, "graduatedFunction"), this.Vj = a, this.v(), this.g("graduatedFunction", b, a))
            }
        }, graduatedSkip: {
            configurable: !0, get: function () {
                return this.Vd
            }, set: function (a) {
                var b = this.Vd;
                b !== a && (null !== a && A(a, "function", kh, "graduatedSkip"), this.Vd = a, this.v(), this.g("graduatedSkip", b, a))
            }
        }, textValidation: {
            configurable: !0, get: function () {
                return this.fj
            }, set: function (a) {
                var b = this.fj;
                b !== a && (null !== a && A(a, "function", kh, "textValidation"), this.fj = a, this.g("textValidation",
                    b, a))
            }
        }, textEdited: {
            configurable: !0, get: function () {
                return this.rq
            }, set: function (a) {
                var b = this.rq;
                b !== a && (null !== a && A(a, "function", kh, "textEdited"), this.rq = a, this.g("textEdited", b, a))
            }
        }, spacingAbove: {
            configurable: !0, get: function () {
                return this.yf
            }, set: function (a) {
                var b = this.yf;
                b !== a && (F && A(a, "number", kh, "spacingAbove"), this.yf = a, this.g("spacingAbove", b, a))
            }
        }, spacingBelow: {
            configurable: !0, get: function () {
                return this.zf
            }, set: function (a) {
                var b = this.zf;
                b !== a && (F &&
                A(a, "number", kh, "spacingBelow"), this.zf = a, this.g("spacingBelow", b, a))
            }
        }, maxLines: {
            configurable: !0, get: function () {
                return this.Ce
            }, set: function (a) {
                var b = this.Ce;
                b !== a && (F && A(a, "number", kh, "maxLines"), a = Math.floor(a), 0 >= a && za(a, "> 0", kh, "maxLines"), this.Ce = a, this.g("maxLines", b, a), this.v())
            }
        }, metrics: {
            configurable: !0, get: function () {
                return {
                    arrSize: null !== this.Wb ? this.Wb : [this.zb],
                    arrText: null !== this.qb ? this.qb : [this.se],
                    maxLineWidth: this.zb,
                    fontHeight: this.ue
                }
            }
        }, choices: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Hn
            }, set: function (a) {
                var b = this.Hn;
                b !== a && (F && null !== a && !Array.isArray(a) && xa(a, "Array", kh, "choices:value"), this.Hn = a, this.g("choices", b, a))
            }
        }
    });
    var jo = null, ko = null, uo = new E(kh, "None", 0), ro = new E(kh, "WrapFit", 1),
        go = new E(kh, "WrapDesiredSize", 2), wo = new E(kh, "WrapBreakAll", 3), fo = new E(kh, "OverflowClip", 0),
        oo = new E(kh, "OverflowEllipsis", 1), xo = /[ \u200b\u00ad]/, yo = new kb, zo = 0, Ao = new kb, Bo = 0,
        qo = "...", lo = "", Vn = null, Un = !1;
    kh.className = "TextBlock";
    kh.getEllipsis = function () {
        return qo
    };
    kh.setEllipsis = function (a) {
        qo = a;
        Ao = new kb;
        Bo = 0
    };
    kh.getBaseline = function () {
        return jo
    };
    kh.setBaseline = function (a) {
        jo = a;
        a = Va();
        for (var b = a.length, c = 0; c < b; c++) a[c].We()
    };
    kh.getUnderline = function () {
        return ko
    };
    kh.setUnderline = function (a) {
        ko = a;
        a = Va();
        for (var b = a.length, c = 0; c < b; c++) a[c].We()
    };
    kh.isValidFont = ho;
    kh.None = uo;
    kh.WrapFit = ro;
    kh.WrapDesiredSize = go;
    kh.WrapBreakAll = wo;
    kh.OverflowClip = fo;
    kh.OverflowEllipsis = oo;

    function Co() {
        this.Wb = [];
        this.qb = []
    }

    Co.prototype.reset = function () {
        this.Wb = [];
        this.qb = []
    };
    Co.prototype.Ot = function (a) {
        this.Wb = Ja(a.Wb);
        this.qb = Ja(a.qb)
    };
    Co.className = "TextBlockMetrics";

    function ok() {
        N.call(this);
        this.lh = null;
        this.jq = "";
        this.Eh = vc;
        this.Kl = Jd;
        this.Cf = this.Jc = null;
        this.Jl = Mc;
        this.Td = Og;
        this.xm = null;
        this.cv = !1;
        this.El = !0;
        this.$l = !1;
        this.qm = null
    }

    ma(ok, N);
    ok.prototype.cloneProtected = function (a) {
        N.prototype.cloneProtected.call(this, a);
        a.element = this.lh;
        a.jq = this.jq;
        a.Eh = this.Eh.J();
        a.Kl = this.Kl;
        a.Td = this.Td;
        a.Jc = this.Jc;
        a.Cf = this.Cf;
        a.Jl = this.Jl.J();
        a.El = this.El;
        a.qm = this.qm
    };
    t = ok.prototype;
    t.pb = function (a) {
        a === Og || a === Qg || a === pl ? this.imageStretch = a : N.prototype.pb.call(this, a)
    };
    t.toString = function () {
        return "Picture(" + this.source + ")#" + rb(this)
    };

    function qk(a) {
        void 0 === a && (a = "");
        A(a, "string", ok, "clearCache:url");
        "" !== a ? Do[a] && (delete Do[a], Eo--) : (Do = new kb, Eo = 0)
    }

    function Fo(a, b) {
        a.ys = !0;
        a.Gl = !1;
        for (var c, d = Va(), e = d.length, f = 0; f < e; f++) {
            var g = d[f];
            c = a.getAttribute("src");
            var h = g.Zi.K(c);
            if (null !== h) for (var k = h.length, l = 0; l < k; l++) c = h[l], g.Ys.add(c), g.Kb(), void 0 === a.zv && (a.zv = b, null !== c.Cf && c.Cf(c, b))
        }
    }

    function Go(a, b) {
        a.Gl = b;
        for (var c, d = Va(), e = d.length, f = 0; f < e; f++) {
            var g = d[f], h = a.getAttribute("src");
            c = g.Zi.K(h);
            if (null !== c) {
                g = c.length;
                h = Ma();
                for (var k = 0; k < g; k++) h.push(c[k]);
                for (k = 0; k < g; k++) c = h[k], null !== c.Jc && c.Jc(c, b);
                Oa(h)
            }
        }
    }

    t.hB = function () {
        if ("" !== this.source) {
            qk(this.source);
            var a = this.source;
            this.source = "";
            this.source = a
        }
    };
    t.We = function () {
        this.P()
    };
    t.oj = function (a, b) {
        var c = this.lh;
        if (null !== c) {
            var d = c.getAttribute("src");
            if (!(c instanceof HTMLImageElement && (null === d || "" === d) || c.Gl instanceof Event && a instanceof Pl)) {
                d = this.naturalBounds;
                var e = 0, f = 0, g = this.cv, h = g ? +c.width : c.naturalWidth;
                g = g ? +c.height : c.naturalHeight;
                void 0 === h && c.videoWidth && (h = c.videoWidth);
                void 0 === g && c.videoHeight && (g = c.videoHeight);
                h = h || d.width;
                g = g || d.height;
                if (0 !== h && 0 !== g) {
                    var k = h, l = g;
                    this.sourceRect.o() && (e = this.Eh.x, f = this.Eh.y, h = this.Eh.width, g = this.Eh.height);
                    var m =
                        h, n = g, p = this.Kl, r = this.Jl;
                    switch (p) {
                        case Og:
                            if (this.sourceRect.o()) break;
                            m >= d.width && (e = e + r.offsetX + (m * r.x - d.width * r.x));
                            n >= d.height && (f = f + r.offsetY + (n * r.y - d.height * r.y));
                            h = Math.min(d.width, m);
                            g = Math.min(d.height, n);
                            break;
                        case Jd:
                            m = d.width;
                            n = d.height;
                            break;
                        case Qg:
                        case pl:
                            p === Qg ? (p = Math.min(d.height / n, d.width / m), m *= p, n *= p) : p === pl && (p = Math.max(d.height / n, d.width / m), m *= p, n *= p, m >= d.width && (e = (e + r.offsetX + (m * r.x - d.width * r.x) / m) * h), n >= d.height && (f = (f + r.offsetY + (n * r.y - d.height * r.y) / n) * g), h *= 1 / (m / d.width),
                                g *= 1 / (n / d.height), m = d.width, n = d.height)
                    }
                    p = this.Mf() * b.scale;
                    var q = m * p * n * p, u = h * g / q, x = c.__goCache;
                    p = null;
                    var y = Ho;
                    if (c.ys && void 0 !== x && 4 < q && u > y * y) for (null === x.mj && (Io(x, 4, k, l, c), Io(x, 16, k, l, c)), k = x.mj, l = k.length, q = 0; q < l; q++) if (k[q].ratio * k[q].ratio < u) p = k[q]; else break;
                    if (!b.Bl) {
                        if (null === this.xm) if (null === this.lh) this.xm = !1; else {
                            k = (new Sk(null)).context;
                            k.drawImage(this.lh, 0, 0);
                            try {
                                k.getImageData(0, 0, 1, 1).data[3] && (this.xm = !1), this.xm = !1
                            } catch (z) {
                                this.xm = !0
                            }
                        }
                        if (this.xm) return
                    }
                    k = 0;
                    m < d.width && (k = r.offsetX +
                        (d.width * r.x - m * r.x));
                    l = 0;
                    n < d.height && (l = r.offsetY + (d.height * r.y - n * r.y));
                    switch (this.flip) {
                        case rl:
                            a.translate(Math.min(d.width, m), 0);
                            a.scale(-1, 1);
                            break;
                        case ql:
                            a.translate(0, Math.min(d.height, n));
                            a.scale(1, -1);
                            break;
                        case sl:
                            a.translate(Math.min(d.width, m), Math.min(d.height, n)), a.scale(-1, -1)
                    }
                    if (b.Te("pictureRatioOptimization") && !b.Hi && void 0 !== x && null !== p && 1 !== p.ratio) {
                        a.save();
                        b = p.ratio;
                        try {
                            a.drawImage(p.source, e / b, f / b, Math.min(p.source.width, h / b), Math.min(p.source.height, g / b), k, l, Math.min(d.width,
                                m), Math.min(d.height, n))
                        } catch (z) {
                            F && this.El && Ea(z.toString()), this.El = !1
                        }
                        a.restore()
                    } else try {
                        a.drawImage(c, e, f, h, g, k, l, Math.min(d.width, m), Math.min(d.height, n))
                    } catch (z) {
                        F && this.El && Ea(z.toString()), this.El = !1
                    }
                    switch (this.flip) {
                        case rl:
                            a.scale(-1, 1);
                            a.translate(-Math.min(d.width, m), 0);
                            break;
                        case ql:
                            a.scale(1, -1);
                            a.translate(0, -Math.min(d.height, n));
                            break;
                        case sl:
                            a.scale(-1, -1), a.translate(-Math.min(d.width, m), -Math.min(d.height, n))
                    }
                }
            }
        }
    };
    t.Tm = function (a, b, c, d) {
        var e = this.desiredSize, f = Cl(this, !0), g = this.lh, h = this.cv;
        if (h || !this.$l && g && g.complete) this.$l = !0;
        null === g && (isFinite(e.width) || (a = 0), isFinite(e.height) || (b = 0));
        isFinite(e.width) || f === Jd || f === nl ? (isFinite(a) || (a = this.sourceRect.o() ? this.sourceRect.width : h ? +g.width : g.naturalWidth), c = 0) : null !== g && !1 !== this.$l && (a = this.sourceRect.o() ? this.sourceRect.width : h ? +g.width : g.naturalWidth);
        isFinite(e.height) || f === Jd || f === ol ? (isFinite(b) || (b = this.sourceRect.o() ? this.sourceRect.height : h ?
            +g.height : g.naturalHeight), d = 0) : null !== g && !1 !== this.$l && (b = this.sourceRect.o() ? this.sourceRect.height : h ? +g.height : g.naturalHeight);
        isFinite(e.width) && (a = e.width);
        isFinite(e.height) && (b = e.height);
        e = this.maxSize;
        f = this.minSize;
        c = Math.max(c, f.width);
        d = Math.max(d, f.height);
        a = Math.min(e.width, a);
        b = Math.min(e.height, b);
        a = Math.max(c, a);
        b = Math.max(d, b);
        null === g || g.complete || (isFinite(a) || (a = 0), isFinite(b) || (b = 0));
        ec(this.wc, a, b);
        zl(this, 0, 0, a, b)
    };
    t.Sh = function (a, b, c, d) {
        El(this, a, b, c, d)
    };
    na.Object.defineProperties(ok.prototype, {
        element: {
            configurable: !0, get: function () {
                return this.lh
            }, set: function (a) {
                var b = this.lh;
                if (b !== a) {
                    null === a || a instanceof HTMLImageElement || a instanceof HTMLVideoElement || a instanceof HTMLCanvasElement || v("Picture.element must be an instance of Image, Canvas, or Video, not: " + a);
                    this.cv = a instanceof HTMLCanvasElement;
                    this.lh = a;
                    if (null !== a) if (a instanceof HTMLCanvasElement || !0 === a.complete) a.Gl instanceof Event && null !== this.Jc && this.Jc(this, a.Gl),
                    !0 === a.ys && null !== this.Cf && this.Cf(this, a.zv), a.ys = !0, this.desiredSize.o() || (Cj(this, !1), this.v()); else {
                        var c = this;
                        a.Lx || (a.addEventListener("load", function (b) {
                            Fo(a, b);
                            c.desiredSize.o() || (Cj(c, !1), c.v())
                        }), a.addEventListener("error", function (b) {
                            Go(a, b)
                        }), a.Lx = !0)
                    }
                    this.g("element", b, a);
                    this.P()
                }
            }
        }, source: {
            configurable: !0, get: function () {
                return this.jq
            }, set: function (a) {
                var b = this.jq;
                if (b !== a) {
                    A(a, "string", ok, "source");
                    this.jq = a;
                    var c = Do, d = this.diagram;
                    if (ih) {
                        var e = null;
                        if (void 0 !== c[a]) e =
                            c[a]; else if ("" !== a) {
                            30 < Eo && (qk(), c = Do);
                            e = ua("img");
                            var f = this;
                            e.addEventListener("load", function (a) {
                                Fo(e, a);
                                f.desiredSize.o() || (Cj(f, !1), f.v())
                            });
                            e.addEventListener("error", function (a) {
                                Go(e, a)
                            });
                            e.Lx = !0;
                            var g = this.qm;
                            null !== g && (e.crossOrigin = g(this));
                            e.src = a;
                            c[a] = e;
                            Eo++
                        }
                        null !== d && pk(d, this);
                        this.element = e;
                        null !== d && null !== e && nk(d, this);
                        null !== e && void 0 === e.__goCache && (e.__goCache = new Jo);
                        this.v();
                        this.P()
                    }
                    this.g("source", b, a)
                }
            }
        }, sourceCrossOrigin: {
            configurable: !0, get: function () {
                return this.qm
            },
            set: function (a) {
                if (this.qm !== a && (null !== a && A(a, "function", ok, "sourceCrossOrigin"), this.qm = a, null !== this.element)) {
                    var b = this.element.getAttribute("src");
                    null === a && "string" === typeof b ? this.element.crossOrigin = null : null !== a && (this.element.crossOrigin = a(this));
                    this.element.src = b
                }
            }
        }, sourceRect: {
            configurable: !0, get: function () {
                return this.Eh
            }, set: function (a) {
                var b = this.Eh;
                b.A(a) || (w(a, L, ok, "sourceRect"), this.Eh = a = a.J(), this.P(), this.g("sourceRect", b, a))
            }
        }, imageStretch: {
            configurable: !0,
            get: function () {
                return this.Kl
            }, set: function (a) {
                var b = this.Kl;
                b !== a && (ib(a, N, ok, "imageStretch"), this.Kl = a, this.P(), this.g("imageStretch", b, a))
            }
        }, flip: {
            configurable: !0, get: function () {
                return this.Td
            }, set: function (a) {
                var b = this.Td;
                b !== a && (ib(a, N, ok, "flip"), this.Td = a, this.P(), this.g("flip", b, a))
            }
        }, imageAlignment: {
            configurable: !0, get: function () {
                return this.Jl
            }, set: function (a) {
                w(a, M, ok, "imageAlignment");
                var b = this.Jl;
                b.A(a) || (this.Jl = a = a.J(), this.v(), this.g("imageAlignment", b,
                    a))
            }
        }, errorFunction: {
            configurable: !0, get: function () {
                return this.Jc
            }, set: function (a) {
                var b = this.Jc;
                b !== a && (null !== a && A(a, "function", ok, "errorFunction"), this.Jc = a, this.g("errorFunction", b, a))
            }
        }, successFunction: {
            configurable: !0, get: function () {
                return this.Cf
            }, set: function (a) {
                var b = this.Cf;
                b !== a && (null !== a && A(a, "function", ok, "successFunction"), this.Cf = a, this.g("successFunction", b, a))
            }
        }, naturalBounds: {
            configurable: !0, get: function () {
                return this.wc
            }
        }
    });
    ok.prototype.redraw = ok.prototype.We;
    ok.prototype.reloadSource = ok.prototype.hB;
    var Do = null, Eo = 0, Ho = 4;
    ok.className = "Picture";
    Do = new kb;
    ok.clearCache = qk;

    function Jo() {
        this.mj = null
    }

    function Io(a, b, c, d, e) {
        null === a.mj && (a.mj = []);
        var f = new Sk(null), g = f.context, h = 1 / b;
        f.width = c / b;
        f.height = d / b;
        0 !== f.width && 0 !== f.height && (b = new Ko(f.La, b), c = 1, 0 < a.mj.length && (c = a.mj[a.mj.length - 1], e = c.source, c = c.ratio), g.setTransform(h * c, 0, 0, h * c, 0, 0), g.drawImage(e, 0, 0), a.mj.push(b))
    }

    Jo.className = "PictureCacheArray";

    function Ko(a, b) {
        this.source = a;
        this.ratio = b
    }

    Ko.className = "PictureCacheInstance";

    function Lo() {
        this.Wt = new Hd;
        this.oc = null
    }

    t = Lo.prototype;
    t.reset = function (a) {
        null !== a ? (a.ka(), this.Wt = a, a.figures.clear()) : this.Wt = new Hd;
        this.oc = null
    };

    function Wd(a, b, c, d, e) {
        a.oc = new xe;
        a.oc.startX = b;
        a.oc.startY = c;
        a.oc.isFilled = d;
        a.Wt.figures.add(a.oc);
        void 0 !== e && (a.oc.isShadowed = e)
    }

    function ie(a) {
        var b = a.oc.segments.length;
        0 < b && a.oc.segments.M(b - 1).close()
    }

    t.tr = function (a) {
        this.oc.isShadowed = a
    };
    t.moveTo = function (a, b, c) {
        void 0 === c && (c = !1);
        var d = new ye(me);
        d.endX = a;
        d.endY = b;
        c && d.close();
        this.oc.segments.add(d)
    };
    t.lineTo = function (a, b, c) {
        void 0 === c && (c = !1);
        var d = new ye(Md);
        d.endX = a;
        d.endY = b;
        c && d.close();
        this.oc.segments.add(d)
    };

    function Xd(a, b, c, d, e, f, g) {
        var h;
        void 0 === h && (h = !1);
        var k = new ye(ne);
        k.point1X = b;
        k.point1Y = c;
        k.point2X = d;
        k.point2Y = e;
        k.endX = f;
        k.endY = g;
        h && k.close();
        a.oc.segments.add(k)
    }

    function Yd(a, b, c, d, e) {
        var f;
        void 0 === f && (f = !1);
        var g = new ye(oe);
        g.point1X = b;
        g.point1Y = c;
        g.endX = d;
        g.endY = e;
        f && g.close();
        a.oc.segments.add(g)
    }

    t.arcTo = function (a, b, c, d, e, f, g) {
        void 0 === f && (f = 0);
        void 0 === g && (g = !1);
        var h = new ye(pe);
        h.startAngle = a;
        h.sweepAngle = b;
        h.centerX = c;
        h.centerY = d;
        h.radiusX = e;
        h.radiusY = 0 !== f ? f : e;
        g && h.close();
        this.oc.segments.add(h)
    };

    function Zd(a, b, c, d, e, f, g, h) {
        var k;
        void 0 === k && (k = !1);
        b = new ye(qe, g, h, b, c, d, e, f);
        k && b.close();
        a.oc.segments.add(b)
    }

    function Vd(a) {
        var b = je;
        if (null !== b) return je = null, b.reset(a), b;
        b = new Lo;
        b.reset(a);
        return b
    }

    var je = null;
    Lo.className = "StreamGeometryContext";

    function Mo(a, b) {
        var c = a.toLowerCase(), d = K.me;
        d[a] = b;
        d[c] = a
    }

    Mo("Rectangle", function (a, b, c) {
        a = "r" + b + "," + c;
        var d = K.di[a];
        if (void 0 !== d) return d;
        d = new Hd(Od);
        d.endX = b;
        d.endY = c;
        50 > K.ei && (K.di[a] = d, K.ei++);
        return d
    });
    Mo("Square", function (a, b, c) {
        a = "s" + b + "," + c;
        var d = K.di[a];
        if (void 0 !== d) return d;
        d = new Hd(Od);
        d.endX = b;
        d.endY = c;
        d.defaultStretch = Qg;
        50 > K.ei && (K.di[a] = d, K.ei++);
        return d
    });
    Mo("RoundedRectangle", function (a, b, c) {
        var d = a ? a.parameter1 : NaN;
        if (isNaN(d) || 0 > d) d = 5;
        d = Math.min(d, b / 3);
        d = Math.min(d, c / 3);
        a = d * K.Xg;
        b = (new Hd).add((new xe(d, 0, !0)).add(new ye(Md, b - d, 0)).add(new ye(ne, b, d, b - a, 0, b, a)).add(new ye(Md, b, c - d)).add(new ye(ne, b - d, c, b, c - a, b - a, c)).add(new ye(Md, d, c)).add(new ye(ne, 0, c - d, a, c, 0, c - a)).add(new ye(Md, 0, d)).add((new ye(ne, d, 0, 0, a, a, 0)).close()));
        1 < a && (b.spot1 = new M(0, 0, a, a), b.spot2 = new M(1, 1, -a, -a));
        return b
    });
    Mo("Border", "RoundedRectangle");
    Mo("Ellipse", function (a, b, c) {
        a = "e" + b + "," + c;
        var d = K.di[a];
        if (void 0 !== d) return d;
        d = new Hd(Pd);
        d.endX = b;
        d.endY = c;
        d.spot1 = sd;
        d.spot2 = td;
        50 > K.ei && (K.di[a] = d, K.ei++);
        return d
    });
    Mo("Circle", function (a, b, c) {
        a = "c" + b + "," + c;
        var d = K.di[a];
        if (void 0 !== d) return d;
        d = new Hd(Pd);
        d.endX = b;
        d.endY = c;
        d.spot1 = sd;
        d.spot2 = td;
        d.defaultStretch = Qg;
        50 > K.ei && (K.di[a] = d, K.ei++);
        return d
    });
    Mo("TriangleRight", function (a, b, c) {
        return (new Hd).add((new xe(0, 0)).add(new ye(Md, b, .5 * c)).add((new ye(Md, 0, c)).close())).kn(0, .25, .5, .75)
    });
    Mo("TriangleDown", function (a, b, c) {
        return (new Hd).add((new xe(0, 0)).add(new ye(Md, b, 0)).add((new ye(Md, .5 * b, c)).close())).kn(.25, 0, .75, .5)
    });
    Mo("TriangleLeft", function (a, b, c) {
        return (new Hd).add((new xe(b, c)).add(new ye(Md, 0, .5 * c)).add((new ye(Md, b, 0)).close())).kn(.5, .25, 1, .75)
    });
    Mo("TriangleUp", function (a, b, c) {
        return (new Hd).add((new xe(b, c)).add(new ye(Md, 0, c)).add((new ye(Md, .5 * b, 0)).close())).kn(.25, .5, .75, 1)
    });
    Mo("Triangle", "TriangleUp");
    Mo("Diamond", function (a, b, c) {
        return (new Hd).add((new xe(.5 * b, 0)).add(new ye(Md, 0, .5 * c)).add(new ye(Md, .5 * b, c)).add((new ye(Md, b, .5 * c)).close())).kn(.25, .25, .75, .75)
    });
    Mo("LineH", function (a, b, c) {
        a = new Hd(Kd);
        a.startX = 0;
        a.startY = c / 2;
        a.endX = b;
        a.endY = c / 2;
        return a
    });
    Mo("LineV", function (a, b, c) {
        a = new Hd(Kd);
        a.startX = b / 2;
        a.startY = 0;
        a.endX = b / 2;
        a.endY = c;
        return a
    });
    Mo("None", "Rectangle");
    Mo("BarH", "Rectangle");
    Mo("BarV", "Rectangle");
    Mo("MinusLine", "LineH");
    Mo("PlusLine", function (a, b, c) {
        return (new Hd).add((new xe(0, c / 2, !1)).add(new ye(Md, b, c / 2)).add(new ye(me, b / 2, 0)).add(new ye(Md, b / 2, c)))
    });
    Mo("XLine", function (a, b, c) {
        return (new Hd).add((new xe(0, c, !1)).add(new ye(Md, b, 0)).add(new ye(me, 0, 0)).add(new ye(Md, b, c)))
    });
    K.on = {
        "": "",
        Standard: "F1 m 0,0 l 8,4 -8,4 2,-4 z",
        Backward: "F1 m 8,0 l -2,4 2,4 -8,-4 z",
        Triangle: "F1 m 0,0 l 8,4.62 -8,4.62 z",
        BackwardTriangle: "F1 m 8,4 l 0,4 -8,-4 8,-4 0,4 z",
        Boomerang: "F1 m 0,0 l 8,4 -8,4 4,-4 -4,-4 z",
        BackwardBoomerang: "F1 m 8,0 l -8,4 8,4 -4,-4 4,-4 z",
        SidewaysV: "m 0,0 l 8,4 -8,4 0,-1 6,-3 -6,-3 0,-1 z",
        BackwardV: "m 8,0 l -8,4 8,4 0,-1 -6,-3 6,-3 0,-1 z",
        OpenTriangle: "m 0,0 l 8,4 -8,4",
        BackwardOpenTriangle: "m 8,0 l -8,4 8,4",
        OpenTriangleLine: "m 0,0 l 8,4 -8,4 m 8.5,0 l 0,-8",
        BackwardOpenTriangleLine: "m 8,0 l  -8,4 8,4 m -8.5,0 l 0,-8",
        OpenTriangleTop: "m 0,0 l 8,4 m 0,4",
        BackwardOpenTriangleTop: "m 8,0 l -8,4 m 0,4",
        OpenTriangleBottom: "m 0,8 l 8,-4",
        BackwardOpenTriangleBottom: "m 0,4 l 8,4",
        HalfTriangleTop: "F1 m 0,0 l 0,4 8,0 z m 0,8",
        BackwardHalfTriangleTop: "F1 m 8,0 l 0,4 -8,0 z m 0,8",
        HalfTriangleBottom: "F1 m 0,4 l 0,4 8,-4 z",
        BackwardHalfTriangleBottom: "F1 m 8,4 l 0,4 -8,-4 z",
        ForwardSemiCircle: "m 4,0 b 270 180 0 4 4",
        BackwardSemiCircle: "m 4,8 b 90 180 0 -4 4",
        Feather: "m 0,0 l 3,4 -3,4",
        BackwardFeather: "m 3,0 l -3,4 3,4",
        DoubleFeathers: "m 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4",
        BackwardDoubleFeathers: "m 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4",
        TripleFeathers: "m 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4 m 3,-8 l 3,4 -3,4",
        BackwardTripleFeathers: "m 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4 m 3,-8 l -3,4 3,4",
        ForwardSlash: "m 0,8 l 5,-8",
        BackSlash: "m 0,0 l 5,8",
        DoubleForwardSlash: "m 0,8 l 4,-8 m -2,8 l 4,-8",
        DoubleBackSlash: "m 0,0 l 4,8 m -2,-8 l 4,8",
        TripleForwardSlash: "m 0,8 l 4,-8 m -2,8 l 4,-8 m -2,8 l 4,-8",
        TripleBackSlash: "m 0,0 l 4,8 m -2,-8 l 4,8 m -2,-8 l 4,8",
        Fork: "m 0,4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4",
        BackwardFork: "m 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4",
        LineFork: "m 0,0 l 0,8 m 0,-4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4",
        BackwardLineFork: "m 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4 m 8,-8 l 0,8",
        CircleFork: "F1 m 6,4 b 0 360 -3 0 3 z m 0,0 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4",
        BackwardCircleFork: "F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 6,0 b 0 360 -3 0 3",
        CircleLineFork: "F1 m 6,4 b 0 360 -3 0 3 z m 1,-4 l 0,8 m 0,-4 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4",
        BackwardCircleLineFork: "F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 0,-4 l 0,8 m 7,-4 b 0 360 -3 0 3",
        Circle: "F1 m 8,4 b 0 360 -4 0 4 z",
        Block: "F1 m 0,0 l 0,8 8,0 0,-8 z",
        StretchedDiamond: "F1 m 0,3 l 5,-3 5,3 -5,3 -5,-3 z",
        Diamond: "F1 m 0,4 l 4,-4 4,4 -4,4 -4,-4 z",
        Chevron: "F1 m 0,0 l 5,0 3,4 -3,4 -5,0 3,-4 -3,-4 z",
        StretchedChevron: "F1 m 0,0 l 8,0 3,4 -3,4 -8,0 3,-4 -3,-4 z",
        NormalArrow: "F1 m 0,2 l 4,0 0,-2 4,4 -4,4 0,-2 -4,0 z",
        X: "m 0,0 l 8,8 m 0,-8 l -8,8",
        TailedNormalArrow: "F1 m 0,0 l 2,0 1,2 3,0 0,-2 2,4 -2,4 0,-2 -3,0 -1,2 -2,0 1,-4 -1,-4 z",
        DoubleTriangle: "F1 m 0,0 l 4,4 -4,4 0,-8 z  m 4,0 l 4,4 -4,4 0,-8 z",
        BigEndArrow: "F1 m 0,0 l 5,2 0,-2 3,4 -3,4 0,-2 -5,2 0,-8 z",
        ConcaveTailArrow: "F1 m 0,2 h 4 v -2 l 4,4 -4,4 v -2 h -4 l 2,-2 -2,-2 z",
        RoundedTriangle: "F1 m 0,1 a 1,1 0 0 1 1,-1 l 7,3 a 0.5,1 0 0 1 0,2 l -7,3 a 1,1 0 0 1 -1,-1 l 0,-6 z",
        SimpleArrow: "F1 m 1,2 l -1,-2 2,0 1,2 -1,2 -2,0 1,-2 5,0 0,-2 2,2 -2,2 0,-2 z",
        AccelerationArrow: "F1 m 0,0 l 0,8 0.2,0 0,-8 -0.2,0 z m 2,0 l 0,8 1,0 0,-8 -1,0 z m 3,0 l 2,0 2,4 -2,4 -2,0 0,-8 z",
        BoxArrow: "F1 m 0,0 l 4,0 0,2 2,0 0,-2 2,4 -2,4 0,-2 -2,0 0,2 -4,0 0,-8 z",
        TriangleLine: "F1 m 8,4 l -8,-4 0,8 8,-4 z m 0.5,4 l 0,-8",
        CircleEndedArrow: "F1 m 10,4 l -2,-3 0,2 -2,0 0,2 2,0 0,2 2,-3 z m -4,0 b 0 360 -3 0 3 z",
        DynamicWidthArrow: "F1 m 0,3 l 2,0 2,-1 2,-2 2,4 -2,4 -2,-2 -2,-1 -2,0 0,-2 z",
        EquilibriumArrow: "m 0,3 l 8,0 -3,-3 m 3,5 l -8,0 3,3",
        FastForward: "F1 m 0,0 l 3.5,4 0,-4 3.5,4 0,-4 1,0 0,8 -1,0 0,-4 -3.5,4 0,-4 -3.5,4 0,-8 z",
        Kite: "F1 m 0,4 l 2,-4 6,4 -6,4 -2,-4 z",
        HalfArrowTop: "F1 m 0,0 l 4,4 4,0 -8,-4 z m 0,8",
        HalfArrowBottom: "F1 m 0,8 l 4,-4 4,0 -8,4 z",
        OpposingDirectionDoubleArrow: "F1 m 0,4 l 2,-4 0,2 4,0 0,-2 2,4 -2,4 0,-2 -4,0 0,2 -2,-4 z",
        PartialDoubleTriangle: "F1 m 0,0 4,3 0,-3 4,4 -4,4 0,-3 -4,3 0,-8 z",
        LineCircle: "F1 m 0,0 l 0,8 m 7 -4 b 0 360 -3 0 3 z",
        DoubleLineCircle: "F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z",
        TripleLineCircle: "F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z",
        CircleLine: "F1 m 6 4 b 0 360 -3 0 3 z m 1,-4 l 0,8",
        DiamondCircle: "F1 m 8,4 l -4,4 -4,-4 4,-4 4,4 m 8,0 b 0 360 -4 0 4 z",
        PlusCircle: "F1 m 8,4 b 0 360 -4 0 4 l -8 0 z m -4 -4 l 0 8",
        OpenRightTriangleTop: "m 8,0 l 0,4 -8,0 m 0,4",
        OpenRightTriangleBottom: "m 8,8 l 0,-4 -8,0",
        Line: "m 0,0 l 0,8",
        DoubleLine: "m 0,0 l 0,8 m 2,0 l 0,-8",
        TripleLine: "m 0,0 l 0,8 m 2,0 l 0,-8 m 2,0 l 0,8",
        PentagonArrow: "F1 m 8,4 l -4,-4 -4,0 0,8 4,0 4,-4 z"
    };

    function T(a) {
        W.call(this, a);
        this.F = 2408959;
        this.uh = this.Zf = "";
        this.Np = this.Jp = this.Yp = this.Oo = null;
        this.$p = "";
        this.Xf = this.Ao = this.Zp = this.Dh = null;
        this.Lp = "";
        this.Kp = ac;
        this.$b = this.Op = "";
        this.Oi = this.Kn = this.xi = null;
        this.qg = (new J(NaN, NaN)).freeze();
        this.Vo = "";
        this.pf = null;
        this.Wo = Fc;
        this.Pp = jd;
        this.fp = Pb;
        this.Xo = Qb;
        this.bo = null;
        this.Po = 127;
        this.eq = Rb;
        this.cq = "gray";
        this.wf = 4;
        this.Nx = -1;
        this.Cq = NaN;
        this.vz = new L;
        this.gk = null;
        this.wh = NaN
    }

    ma(T, W);
    T.prototype.cloneProtected = function (a) {
        W.prototype.cloneProtected.call(this, a);
        a.F = this.F & -4097 | 49152;
        a.Zf = this.Zf;
        a.uh = this.uh;
        a.Oo = this.Oo;
        a.Yp = this.Yp;
        a.Jp = this.Jp;
        a.Np = this.Np;
        a.$p = this.$p;
        a.Zp = this.Zp;
        a.Ao = this.Ao;
        a.Xf = null;
        a.Lp = this.Lp;
        a.Kp = this.Kp.J();
        a.Op = this.Op;
        a.Pp = this.Pp.J();
        a.$b = this.$b;
        a.Kn = this.Kn;
        a.qg.assign(this.qg);
        a.Vo = this.Vo;
        a.Wo = this.Wo.J();
        a.fp = this.fp.J();
        a.Xo = this.Xo.J();
        a.bo = this.bo;
        a.Po = this.Po;
        a.eq = this.eq.J();
        a.cq = this.cq;
        a.wf = this.wf;
        a.Cq = this.Cq
    };
    T.prototype.Kf = function (a) {
        W.prototype.Kf.call(this, a);
        a.Yh();
        a.Dh = null;
        a.pf = null;
        a.gk = null
    };
    T.prototype.toString = function () {
        var a = Pa(this.constructor) + "#" + rb(this);
        null !== this.data && (a += "(" + Qa(this.data) + ")");
        return a
    };
    T.prototype.Zk = function (a, b, c, d, e, f, g) {
        var h = this.diagram;
        null !== h && (a === Ne && "elements" === b ? e instanceof W ? Uj(e, function (a) {
            Wj(h.partManager, a);
            Vj(h, a)
        }) : nk(h, e) : a === Oe && "elements" === b && (e instanceof W ? Uj(e, function (a) {
            Zj(h.partManager, a, h)
        }) : pk(h, e)), h.ib(a, b, c, d, e, f, g))
    };
    T.prototype.Ha = function (a) {
        W.prototype.Ha.call(this, a);
        if (null !== this.data) {
            for (var b = this.$.j, c = b.length, d = 0; d < c; d++) {
                var e = b[d];
                e instanceof W && Uj(e, function (a) {
                    null !== a.data && a.Ha()
                })
            }
            for (b = this.adornments; b.next();) b.value.Ha(a)
        }
    };
    T.prototype.updateRelationshipsFromData = function () {
        null !== this.data && this.diagram.partManager.updateRelationshipsFromData(this)
    };
    T.prototype.Gk = function (a) {
        F && A(a, "string", T, "findAdornment:category");
        var b = this.Xf;
        return null === b ? null : b.K(a)
    };
    T.prototype.Qh = function (a, b) {
        if (null !== b) {
            F && (A(a, "string", T, "addAdornment:category"), w(b, Xe, T, "addAdornment:ad"));
            var c = null, d = this.Xf;
            null !== d && (c = d.K(a));
            if (c !== b) {
                if (null !== c) {
                    var e = c.diagram;
                    null !== e && e.remove(c)
                }
                null === d && (this.Xf = d = new Db);
                b.Zf !== a && (b.category = a);
                d.add(a, b);
                a = this.diagram;
                null !== a && (a.add(b), a = b.adornedObject, null !== a && (a = a.sj(), null !== a && (b.data = a.data)))
            }
        }
    };
    T.prototype.Tf = function (a) {
        F && A(a, "string", T, "removeAdornment:category");
        var b = this.Xf;
        if (null !== b) {
            var c = b.K(a);
            if (null !== c) {
                var d = c.diagram;
                null !== d && d.remove(c)
            }
            b.remove(a);
            0 === b.count && (this.Xf = null)
        }
    };
    T.prototype.yk = function () {
        var a = this.Xf;
        if (null !== a) {
            var b = Ma();
            for (a = a.iterator; a.next();) b.push(a.key);
            a = b.length;
            for (var c = 0; c < a; c++) this.Tf(b[c]);
            Oa(b)
        }
    };
    T.prototype.updateAdornments = function () {
        var a = this.diagram;
        if (null !== a) {
            for (var b = this.adornments; b.next();) {
                var c = b.value;
                c.v();
                c.placeholder && c.placeholder.v()
            }
            a:{
                if (this.isSelected && this.selectionAdorned && (b = this.selectionObject, null !== b && this.actualBounds.o() && this.isVisible() && b.Sf() && b.actualBounds.o())) {
                    c = this.Gk("Selection");
                    if (null === c) {
                        c = this.selectionAdornmentTemplate;
                        null === c && (c = this.Zh() ? a.linkSelectionAdornmentTemplate : this instanceof Kf ? a.groupSelectionAdornmentTemplate : a.nodeSelectionAdornmentTemplate);
                        if (!(c instanceof Xe)) break a;
                        Ng(c);
                        c = c.copy();
                        null !== c && (this.Zh() && this.selectionObject === this.path && (c.type = W.Link), c.adornedObject = b)
                    }
                    if (null !== c) {
                        c.type === W.Link && c.v();
                        this.Qh("Selection", c);
                        break a
                    }
                }
                this.Tf("Selection")
            }
            No(this, a);
            for (b = this.adornments; b.next();) b.value.Ha()
        }
    };
    T.prototype.Sb = function () {
        var a = this.diagram;
        null !== a && (hj(a), 0 !== (this.F & 16384) !== !0 && (this.F |= 16384, a.Kb()))
    };

    function yi(a) {
        0 !== (a.F & 16384) !== !1 && (a.updateAdornments(), a.F &= -16385)
    }

    function No(a, b) {
        b.toolManager.mouseDownTools.each(function (b) {
            b.isEnabled && b.updateAdornments(a)
        });
        b.toolManager.updateAdornments(a)
    }

    function Oo(a) {
        if (!1 === Jj(a)) {
            Po(a, !0);
            a.Rl();
            var b = a.diagram;
            null !== b && (b.yd.add(a), b.Kb())
        }
    }

    function Qo(a) {
        a.F |= 2097152;
        if (!1 !== Jj(a)) {
            var b = a.position, c = a.location;
            c.o() && b.o() || Ro(a, b, c);
            c = a.Db;
            var d = L.alloc().assign(c);
            c.ka();
            c.x = b.x;
            c.y = b.y;
            c.freeze();
            a.Um(d, c);
            L.free(d);
            Po(a, !1)
        }
    }

    T.prototype.move = function (a, b) {
        !0 === b ? this.location = a : this.position = a
    };
    T.prototype.moveTo = function (a, b, c) {
        a = J.allocAt(a, b);
        this.move(a, c);
        J.free(a)
    };
    T.prototype.isVisible = function () {
        if (!this.visible) return !1;
        var a = this.layer;
        if (null !== a) {
            if (!a.visible) return !1;
            a = a.diagram;
            if (null !== a && a.animationManager.nu(this)) return !0
        }
        a = this.containingGroup;
        return null === a || a.isSubGraphExpanded && a.isVisible() ? !0 : !1
    };
    t = T.prototype;
    t.Vb = function (a) {
        var b = this.diagram;
        a ? (this.D(4), this.Sb(), null !== b && b.yd.add(this)) : (this.D(8), this.yk());
        this.Yh();
        null !== b && (b.Ua(), b.P())
    };
    t.hb = function (a) {
        if (this.name === a) return this;
        var b = this.gk;
        null === b && (this.gk = b = new Db);
        if (null !== b.K(a)) return b.K(a);
        var c = W.prototype.hb.call(this, a);
        if (null !== c) return b.set(a, c), c;
        b.set(a, null);
        return null
    };
    t.Pf = function (a, b, c) {
        void 0 === c && (c = new J);
        b = b.Tb() ? Mc : b;
        var d = a.naturalBounds;
        c.h(d.width * b.x + b.offsetX, d.height * b.y + b.offsetY);
        if (null === a || a === this) return c;
        a.transform.ya(c);
        for (a = a.panel; null !== a && a !== this;) a.transform.ya(c), a = a.panel;
        this.pg.ya(c);
        c.offset(-this.vc.x, -this.vc.y);
        return c
    };
    t.wj = function (a) {
        void 0 === a && (a = new L);
        return a.assign(this.actualBounds)
    };
    t.Ya = function () {
        !0 === Hj(this) && this.measure(Infinity, Infinity);
        this.arrange()
    };

    function Sj(a, b) {
        var c = a.vz;
        isNaN(a.wh) && (a.wh = xn(a));
        var d = a.wh;
        var e = 2 * d;
        if (!a.isShadowed) return c.h(b.x - 1 - d, b.y - 1 - d, b.width + 2 + e, b.height + 2 + e), c;
        d = b.x;
        e = b.y;
        var f = b.width;
        b = b.height;
        var g = a.shadowBlur;
        a = a.shadowOffset;
        f += g;
        b += g;
        d -= g / 2;
        e -= g / 2;
        0 < a.x ? f += a.x : (d += a.x, f -= a.x);
        0 < a.y ? b += a.y : (e += a.y, b -= a.y);
        c.h(d - 1, e - 1, f + 2, b + 2);
        return c
    }

    T.prototype.arrange = function () {
        if (!1 === Ij(this)) Qo(this); else {
            Dl(this, !1);
            var a = this.Db, b = L.alloc();
            b.assign(a);
            var c = Lg(this);
            this.Sh(0, 0, this.vc.width, this.vc.height);
            var d = this.position;
            Ro(this, d, this.location);
            a.ka();
            a.x = d.x;
            a.y = d.y;
            a.freeze();
            this.Um(b, a);
            b.A(a) ? this.Od(c) : !this.Tc() || K.C(b.width, a.width) && K.C(b.height, a.height) || 0 <= this.Nx && this.D(16);
            L.free(b);
            Po(this, !1)
        }
    };
    t = T.prototype;
    t.Um = function (a, b) {
        var c = this.diagram;
        if (null !== c) {
            var d = !1;
            if (!1 === c.Ei && a.o()) {
                var e = L.alloc();
                e.assign(c.documentBounds);
                e.Vw(c.padding);
                a.x > e.x && a.y > e.y && a.right < e.right && a.bottom < e.bottom && b.x > e.x && b.y > e.y && b.right < e.right && b.bottom < e.bottom && (d = !0);
                L.free(e)
            }
            0 !== (this.F & 65536) !== !0 && a.A(b) || Xj(this, d, c);
            c.P();
            hc(a, b) || (this instanceof V && !c.undoManager.isUndoingRedoing && this.wd(), this.Yh())
        }
    };
    t.Qw = function (a, b) {
        if (this.Zh() || !a.o()) return !1;
        var c = this.diagram;
        null !== c && So(this, c, a, b);
        this.ra = a;
        this.F &= -2097153;
        var d = this.qg;
        !d.o() || null !== c && !c.animationManager.isTicking && c.undoManager.isUndoingRedoing || (c = d.copy(), d.h(d.x + (a.x - b.x), d.y + (a.y - b.y)), this.g("location", c, d.copy()));
        !1 === Jj(this) && !1 === Ij(this) && (Oo(this), Qo(this));
        return !0
    };

    function So(a, b, c, d) {
        null === b || a instanceof Xe || (b = b.animationManager, b.rf && bi(b, a, d.copy(), c.copy()))
    }

    t.sr = function (a, b, c) {
        var d = this.qg, e = this.ra;
        if (c) {
            if (d.x === a && d.y === b) return;
            Jj(this) || Ij(this) ? e.h(NaN, NaN) : e.h(e.x + a - d.x, e.y + b - d.y);
            d.h(a, b)
        } else {
            if (e.x === a && e.y === b) return;
            Jj(this) || Ij(this) ? this.wu() : d.h(d.x + a - e.x, d.y + b - e.y);
            e.h(a, b)
        }
        Oo(this)
    };
    t.wu = function () {
        this.F &= -2097153;
        Oo(this)
    };

    function Ro(a, b, c) {
        var d = J.alloc(), e = a.locationSpot, f = a.locationObject;
        e.Tb() && v("determineOffset: Part's locationSpot must be real: " + e.toString());
        var g = f.naturalBounds, h = f instanceof Zf ? f.strokeWidth : 0;
        d.al(0, 0, g.width + h, g.height + h, e);
        if (f !== a) for (d.offset(-h / 2, -h / 2), f.transform.ya(d), e = f.panel; null !== e && e !== a;) e.transform.ya(d), e = e.panel;
        a.pg.ya(d);
        d.offset(-a.vc.x, -a.vc.y);
        e = a.diagram;
        f = c.o();
        g = b.o();
        f && g ? 0 !== (a.F & 2097152) ? To(a, b, c, e, d) : Uo(a, b, c, e, d) : f ? To(a, b, c, e, d) : g && Uo(a, b, c, e, d);
        a.F |= 2097152;
        J.free(d);
        a.Rl()
    }

    function To(a, b, c, d, e) {
        var f = b.x, g = b.y;
        b.h(c.x - e.x, c.y - e.y);
        null !== d && (c = d.animationManager, (d = c.isAnimating) || !c.rf || a instanceof Xe || bi(c, a, new J(f, g), b), d || b.x === f && b.y === g || a.g("position", new J(f, g), b.copy()))
    }

    function Uo(a, b, c, d, e) {
        var f = c.copy();
        c.h(b.x + e.x, b.y + e.y);
        c.A(f) || null === d || a.g("location", f, c.copy())
    }

    function Xj(a, b, c) {
        Fl(a, !1);
        a instanceof V && Nk(c, a);
        a.layer.isTemporary || b || c.Ua();
        b = a.Db;
        var d = c.viewportBounds;
        d.o() ? Lg(a) ? (lc(b, d) || a.Od(!1), a.updateAdornments()) : b.Sc(d) ? (a.Od(!0), a.updateAdornments()) : a.Sb() : c.Gi = !0
    }

    t.Cj = function () {
        return !0
    };
    t.Tc = function () {
        return !0
    };
    t.Zh = function () {
        return !1
    };
    t.Rf = function () {
        return !0
    };

    function Vo(a, b, c, d) {
        b.constructor === a.constructor || Wo || (Wo = !0, Ea('Should not change the class of the Part when changing category from "' + c + '" to "' + d + '"'), Ea("  Old class: " + Pa(a.constructor) + ", new class: " + Pa(b.constructor) + ", part: " + a.toString()));
        a.yk();
        var e = a.data;
        c = a.layerName;
        var f = a.isSelected, g = a.isHighlighted, h = !0, k = !0, l = !1;
        a instanceof V && (h = a.isTreeLeaf, k = a.isTreeExpanded, l = a.wasTreeExpanded);
        b.Kf(a);
        b.cloneProtected(a);
        a.Zf = d;
        a.v();
        a.P();
        b = a.diagram;
        d = !0;
        null !== b && (d = b.skipsUndoManager,
            b.skipsUndoManager = !0);
        a.sb = e;
        a.F = f ? a.F | 4096 : a.F & -4097;
        a.F = g ? a.F | 524288 : a.F & -524289;
        a instanceof V && (a.T = h ? a.T | 4 : a.T & -5, a.T = k ? a.T | 1 : a.T & -2, a.T = l ? a.T | 2 : a.T & -3);
        null !== e && a.Ha();
        e = a.layerName;
        e !== c && (a.uh = c, a.layerName = e);
        null !== b && (b.skipsUndoManager = d);
        a.Tc() && a.D(64)
    }

    T.prototype.canCopy = function () {
        if (!this.copyable) return !1;
        var a = this.layer;
        if (null === a) return !0;
        if (!a.allowCopy) return !1;
        a = a.diagram;
        return null === a ? !0 : a.allowCopy ? !0 : !1
    };
    T.prototype.canDelete = function () {
        if (!this.deletable) return !1;
        var a = this.layer;
        if (null === a) return !0;
        if (!a.allowDelete) return !1;
        a = a.diagram;
        return null === a ? !0 : a.allowDelete ? !0 : !1
    };
    T.prototype.canEdit = function () {
        if (!this.textEditable) return !1;
        var a = this.layer;
        if (null === a) return !0;
        if (!a.allowTextEdit) return !1;
        a = a.diagram;
        return null === a ? !0 : a.allowTextEdit ? !0 : !1
    };
    T.prototype.canGroup = function () {
        if (!this.groupable) return !1;
        var a = this.layer;
        if (null === a) return !0;
        if (!a.allowGroup) return !1;
        a = a.diagram;
        return null === a ? !0 : a.allowGroup ? !0 : !1
    };
    T.prototype.canMove = function () {
        if (!this.movable) return !1;
        var a = this.layer;
        if (null === a) return !0;
        if (!a.allowMove) return !1;
        a = a.diagram;
        return null === a ? !0 : a.allowMove ? !0 : !1
    };
    T.prototype.canReshape = function () {
        if (!this.reshapable) return !1;
        var a = this.layer;
        if (null === a) return !0;
        if (!a.allowReshape) return !1;
        a = a.diagram;
        return null === a ? !0 : a.allowReshape ? !0 : !1
    };
    T.prototype.canResize = function () {
        if (!this.resizable) return !1;
        var a = this.layer;
        if (null === a) return !0;
        if (!a.allowResize) return !1;
        a = a.diagram;
        return null === a ? !0 : a.allowResize ? !0 : !1
    };
    T.prototype.canRotate = function () {
        if (!this.rotatable) return !1;
        var a = this.layer;
        if (null === a) return !0;
        if (!a.allowRotate) return !1;
        a = a.diagram;
        return null === a ? !0 : a.allowRotate ? !0 : !1
    };
    T.prototype.canSelect = function () {
        if (!this.selectable) return !1;
        var a = this.layer;
        if (null === a) return !0;
        if (!a.allowSelect) return !1;
        a = a.diagram;
        return null === a ? !0 : a.allowSelect ? !0 : !1
    };

    function Jj(a) {
        return 0 !== (a.F & 32768)
    }

    function Po(a, b) {
        a.F = b ? a.F | 32768 : a.F & -32769
    }

    function Fl(a, b) {
        a.F = b ? a.F | 65536 : a.F & -65537
    }

    function Lg(a) {
        return 0 !== (a.F & 131072)
    }

    t = T.prototype;
    t.Od = function (a) {
        this.F = a ? this.F | 131072 : this.F & -131073
    };

    function Xo(a, b) {
        a.F = b ? a.F | 1048576 : a.F & -1048577
    }

    t.Yh = function () {
        var a = this.containingGroup;
        null !== a && (a.v(), null !== a.placeholder && a.placeholder.v(), a.wd())
    };
    t.P = function () {
        var a = this.diagram;
        null !== a && !Ij(this) && !Jj(this) && this.isVisible() && this.Db.o() && a.P(Sj(this, this.Db))
    };
    t.v = function () {
        W.prototype.v.call(this);
        var a = this.diagram;
        null !== a && (a.yd.add(this), this instanceof V && null !== this.labeledLink && Ul(this.labeledLink), a.Kb(!0))
    };
    t.Vq = function (a) {
        a || (a = this.xi, null !== a && Yo(a, this))
    };
    t.Wq = function (a) {
        a || (a = this.xi, null !== a && Zo(a, this))
    };
    t.Ek = function () {
        var a = this.data;
        if (null !== a) {
            var b = this.diagram;
            null !== b && (b = b.model, null !== b && b.Zm(a))
        }
    };
    t.tA = function () {
        return $o(this, this)
    };

    function $o(a, b) {
        var c = b.containingGroup;
        return null !== c ? 1 + $o(a, c) : b instanceof V && (b = b.labeledLink, null !== b) ? $o(a, b) : 0
    }

    t.wA = function () {
        return ap(this, this)
    };

    function ap(a, b) {
        var c = b.containingGroup;
        return null !== c || b instanceof V && (c = b.labeledLink, null !== c) ? ap(a, c) : b
    }

    t.Ld = function (a) {
        return a instanceof Kf ? bp(this, this, a) : !1
    };

    function bp(a, b, c) {
        if (b === c || null === c) return !1;
        var d = b.containingGroup;
        return null === d || d !== c && !bp(a, d, c) ? b instanceof V && (b = b.labeledLink, null !== b) ? bp(a, b, c) : !1 : !0
    }

    t.Dy = function (a) {
        if (null === a) return null;
        F && w(a, T, T, "findCommonContainingGroup:other");
        if (this === a) return this.containingGroup;
        for (var b = this; null !== b;) {
            b instanceof Kf && Xo(b, !0);
            if (b instanceof V) {
                var c = b.labeledLink;
                null !== c && (b = c)
            }
            b = b.containingGroup
        }
        c = null;
        for (b = a; null !== b;) {
            if (0 !== (b.F & 1048576)) {
                c = b;
                break
            }
            b instanceof V && (a = b.labeledLink, null !== a && (b = a));
            b = b.containingGroup
        }
        for (b = this; null !== b;) b instanceof Kf && Xo(b, !1), b instanceof V && (a = b.labeledLink, null !== a && (b = a)), b = b.containingGroup;
        return c
    };
    T.prototype.canLayout = function () {
        if (!this.isLayoutPositioned || !this.isVisible()) return !1;
        var a = this.layer;
        return null !== a && a.isTemporary || this instanceof V && this.isLinkLabel ? !1 : !0
    };
    T.prototype.D = function (a) {
        void 0 === a && (a = 16777215);
        if (this.isLayoutPositioned && 0 !== (a & this.layoutConditions)) {
            var b = this.layer;
            null !== b && b.isTemporary || this instanceof V && this.isLinkLabel ? b = !1 : (b = this.diagram, b = null !== b && b.undoManager.isUndoingRedoing ? !1 : !0)
        } else b = !1;
        if (b) if (b = this.xi, null !== b) {
            var c = b.layout;
            null !== c ? c.D() : b.D(a)
        } else a = this.diagram, null !== a && (a = a.layout, null !== a && a.D())
    };

    function Yj(a) {
        if (!a.isVisible()) return !1;
        a = a.layer;
        return null !== a && a.isTemporary ? !1 : !0
    }

    function jl(a, b, c, d, e, f) {
        void 0 === f && (f = null);
        if (!(a.contains(b) || null !== f && !f(b) || b instanceof Xe)) if (a.add(b), b instanceof V) {
            if (c && b instanceof Kf) for (var g = b.memberParts; g.next();) jl(a, g.value, c, d, e, f);
            if (!1 !== e) for (g = b.linksConnected; g.next();) {
                var h = g.value;
                if (!a.contains(h)) {
                    var k = h.fromNode, l = h.toNode;
                    k = null === k || a.contains(k);
                    l = null === l || a.contains(l);
                    (e ? k && l : k || l) && jl(a, h, c, d, e, f)
                }
            }
            if (1 < d) for (b = b.hw(); b.next();) jl(a, b.value, c, d - 1, e, f)
        } else if (b instanceof S) for (b = b.labelNodes; b.next();) jl(a,
            b.value, c, d, e, f)
    }

    na.Object.defineProperties(T.prototype, {
        key: {
            configurable: !0, get: function () {
                var a = this.diagram;
                if (null !== a) return a.model.pa(this.data)
            }
        }, adornments: {
            configurable: !0, get: function () {
                return null === this.Xf ? mb : this.Xf.iteratorValues
            }
        }, layer: {
            configurable: !0, get: function () {
                return this.Oi
            }
        }, diagram: {
            configurable: !0, get: function () {
                var a = this.Oi;
                return null !== a ? a.diagram : null
            }
        }, layerName: {
            configurable: !0, get: function () {
                return this.uh
            }, set: function (a) {
                var b =
                    this.uh;
                if (b !== a) {
                    A(a, "string", T, "layerName");
                    var c = this.diagram;
                    if (null === c || null !== c.Km(a) && !c.partManager.addsToTemporaryLayer) if (this.uh = a, null !== c && c.Ua(), this.g("layerName", b, a), b = this.layer, null !== b && b.name !== a && (c = b.diagram, null !== c && (a = c.Km(a), null !== a && a !== b))) {
                        var d = b.Rc(-1, this, !0);
                        0 <= d && c.ib(Oe, "parts", b, this, null, d, !0);
                        d = a.yj(99999999, this, !0);
                        b.visible !== a.visible && this.Vb(a.visible);
                        0 <= d && c.ib(Ne, "parts", a, null, this, !0, d);
                        d = this.layerChanged;
                        if (null !== d) {
                            var e = c.ba;
                            c.ba = !0;
                            d(this,
                                b, a);
                            c.ba = e
                        }
                    }
                }
            }
        }, layerChanged: {
            configurable: !0, get: function () {
                return this.Oo
            }, set: function (a) {
                var b = this.Oo;
                b !== a && (null !== a && A(a, "function", T, "layerChanged"), this.Oo = a, this.g("layerChanged", b, a))
            }
        }, zOrder: {
            configurable: !0, get: function () {
                return this.Cq
            }, set: function (a) {
                var b = this.Cq;
                if (b !== a) {
                    A(a, "number", T, "zOrder");
                    this.Cq = a;
                    var c = this.layer;
                    null !== c && Bi(c, -1, this);
                    this.g("zOrder", b, a);
                    a = this.diagram;
                    null !== a && a.P()
                }
            }
        }, locationObject: {
            configurable: !0, get: function () {
                if (null ===
                    this.pf) {
                    var a = this.locationObjectName;
                    "" !== a ? (a = this.hb(a), null !== a ? this.pf = a : this.pf = this) : this instanceof Xe ? this.type !== W.Link && null !== this.placeholder ? this.pf = this.placeholder : this.pf = this : this.pf = this
                }
                return this.pf.visible ? this.pf : this
            }
        }, minLocation: {
            configurable: !0, get: function () {
                return this.fp
            }, set: function (a) {
                var b = this.fp;
                b.A(a) || (F && w(a, J, T, "minLocation"), this.fp = a = a.J(), this.g("minLocation", b, a))
            }
        }, maxLocation: {
            configurable: !0, get: function () {
                return this.Xo
            },
            set: function (a) {
                var b = this.Xo;
                b.A(a) || (F && w(a, J, T, "maxLocation"), this.Xo = a = a.J(), this.g("maxLocation", b, a))
            }
        }, locationObjectName: {
            configurable: !0, get: function () {
                return this.Vo
            }, set: function (a) {
                var b = this.Vo;
                b !== a && (F && A(a, "string", T, "locationObjectName"), this.Vo = a, this.pf = null, this.v(), this.g("locationObjectName", b, a))
            }
        }, locationSpot: {
            configurable: !0, get: function () {
                return this.Wo
            }, set: function (a) {
                var b = this.Wo;
                b.A(a) || (F && (w(a, M, T, "locationSpot"), a.cb() || v("Part.locationSpot must be a specific Spot value, not: " +
                    a)), this.Wo = a = a.J(), this.v(), this.g("locationSpot", b, a))
            }
        }, location: {
            configurable: !0, get: function () {
                return this.qg
            }, set: function (a) {
                F && w(a, J, T, "location");
                var b = a.x, c = a.y, d = this.qg, e = d.x, f = d.y;
                (e === b || isNaN(e) && isNaN(b)) && (f === c || isNaN(f) && isNaN(c)) || (a = a.copy(), b = a, this.Zh() ? b = !1 : (this.qg = b, this.F |= 2097152, !1 === Ij(this) && (Oo(this), c = this.ra, c.o() && (e = this.diagram, null === e || e.animationManager.isTicking || !e.undoManager.isUndoingRedoing)) && (f = c.copy(), c.h(c.x + (b.x - d.x), c.y + (b.y - d.y)),
                    So(this, e, c, f), this.g("position", f, c.copy())), b = !0), b && this.g("location", d.copy(), a.copy()))
            }
        }, category: {
            configurable: !0, get: function () {
                return this.Zf
            }, set: function (a) {
                var b = this.Zf;
                if (b !== a) {
                    A(a, "string", T, "category");
                    var c = this.diagram, d = this.data, e = null;
                    if (null !== c && null !== d && !(this instanceof Xe)) {
                        var f = c.model.undoManager;
                        f.isEnabled && !f.isUndoingRedoing && (e = this.clone(), e.$.addAll(this.$))
                    }
                    this.Zf = a;
                    this.g("category", b, a);
                    null === c || null === d || this instanceof Xe ? this instanceof Xe &&
                        (e = this.adornedPart, null !== e && (a = e.Xf, null !== a && a.remove(b), e.Qh(this.category, this))) : (f = c.model, f.undoManager.isUndoingRedoing || (this.Zh() ? (c.partManager.setLinkCategoryForData(d, a), c = c.partManager.findLinkTemplateForCategory(a), null !== c && (Ng(c), c = c.copy(), null !== c && Vo(this, c, b, a))) : (null !== f && f.fn(d, a), c = cp(c.partManager, d, a), null !== c && (Ng(c), c = c.copy(), null === c || c instanceof S || (d = this.location.copy(), Vo(this, c, b, a), this.location.o() || (this.location = d)))), null !== e && (b = this.clone(), b.$.addAll(this.$),
                        this.g("self", e, b))))
                }
            }
        }, self: {
            configurable: !0, get: function () {
                return this
            }, set: function (a) {
                Vo(this, a, this.category, a.category)
            }
        }, copyable: {
            configurable: !0, get: function () {
                return 0 !== (this.F & 1)
            }, set: function (a) {
                var b = 0 !== (this.F & 1);
                b !== a && (F && A(a, "boolean", T, "copyable"), this.F ^= 1, this.g("copyable", b, a))
            }
        }, deletable: {
            configurable: !0, get: function () {
                return 0 !== (this.F & 2)
            }, set: function (a) {
                var b = 0 !== (this.F & 2);
                b !== a && (F && A(a, "boolean", T, "deletable"), this.F ^= 2, this.g("deletable",
                    b, a))
            }
        }, textEditable: {
            configurable: !0, get: function () {
                return 0 !== (this.F & 4)
            }, set: function (a) {
                var b = 0 !== (this.F & 4);
                b !== a && (F && A(a, "boolean", T, "textEditable"), this.F ^= 4, this.g("textEditable", b, a), this.Sb())
            }
        }, groupable: {
            configurable: !0, get: function () {
                return 0 !== (this.F & 8)
            }, set: function (a) {
                var b = 0 !== (this.F & 8);
                b !== a && (F && A(a, "boolean", T, "groupable"), this.F ^= 8, this.g("groupable", b, a))
            }
        }, movable: {
            configurable: !0, get: function () {
                return 0 !== (this.F & 16)
            }, set: function (a) {
                var b =
                    0 !== (this.F & 16);
                b !== a && (F && A(a, "boolean", T, "movable"), this.F ^= 16, this.g("movable", b, a))
            }
        }, selectionAdorned: {
            configurable: !0, get: function () {
                return 0 !== (this.F & 32)
            }, set: function (a) {
                var b = 0 !== (this.F & 32);
                b !== a && (F && A(a, "boolean", T, "selectionAdorned"), this.F ^= 32, this.g("selectionAdorned", b, a), this.Sb())
            }
        }, isInDocumentBounds: {
            configurable: !0, get: function () {
                return 0 !== (this.F & 64)
            }, set: function (a) {
                var b = 0 !== (this.F & 64);
                if (b !== a) {
                    F && A(a, "boolean", T, "isInDocumentBounds");
                    this.F ^=
                        64;
                    var c = this.diagram;
                    null !== c && c.Ua();
                    this.g("isInDocumentBounds", b, a)
                }
            }
        }, isLayoutPositioned: {
            configurable: !0, get: function () {
                return 0 !== (this.F & 128)
            }, set: function (a) {
                var b = 0 !== (this.F & 128);
                b !== a && (F && A(a, "boolean", T, "isLayoutPositioned"), this.F ^= 128, this.g("isLayoutPositioned", b, a), this.D(a ? 4 : 8))
            }
        }, selectable: {
            configurable: !0, get: function () {
                return 0 !== (this.F & 256)
            }, set: function (a) {
                var b = 0 !== (this.F & 256);
                b !== a && (F && A(a, "boolean", T, "selectable"), this.F ^= 256, this.g("selectable",
                    b, a), this.Sb())
            }
        }, reshapable: {
            configurable: !0, get: function () {
                return 0 !== (this.F & 512)
            }, set: function (a) {
                var b = 0 !== (this.F & 512);
                b !== a && (F && A(a, "boolean", T, "reshapable"), this.F ^= 512, this.g("reshapable", b, a), this.Sb())
            }
        }, resizable: {
            configurable: !0, get: function () {
                return 0 !== (this.F & 1024)
            }, set: function (a) {
                var b = 0 !== (this.F & 1024);
                b !== a && (F && A(a, "boolean", T, "resizable"), this.F ^= 1024, this.g("resizable", b, a), this.Sb())
            }
        }, rotatable: {
            configurable: !0, get: function () {
                return 0 !==
                    (this.F & 2048)
            }, set: function (a) {
                var b = 0 !== (this.F & 2048);
                b !== a && (F && A(a, "boolean", T, "rotatable"), this.F ^= 2048, this.g("rotatable", b, a), this.Sb())
            }
        }, isSelected: {
            configurable: !0, get: function () {
                return 0 !== (this.F & 4096)
            }, set: function (a) {
                var b = 0 !== (this.F & 4096);
                if (b !== a) {
                    F && A(a, "boolean", T, "isSelected");
                    var c = this.diagram;
                    if (!a || this.canSelect() && !(null !== c && c.selection.count >= c.maxSelectionCount)) {
                        this.F ^= 4096;
                        var d = !1;
                        if (null !== c) {
                            d = c.skipsUndoManager;
                            c.skipsUndoManager = !0;
                            var e = c.selection;
                            e.ka();
                            a ? e.add(this) : e.remove(this);
                            e.freeze()
                        }
                        this.g("isSelected", b, a);
                        this.Sb();
                        a = this.selectionChanged;
                        null !== a && a(this);
                        null !== c && (c.Kb(), c.skipsUndoManager = d)
                    }
                }
            }
        }, isHighlighted: {
            configurable: !0, get: function () {
                return 0 !== (this.F & 524288)
            }, set: function (a) {
                var b = 0 !== (this.F & 524288);
                if (b !== a) {
                    F && A(a, "boolean", T, "isHighlighted");
                    this.F ^= 524288;
                    var c = this.diagram;
                    null !== c && (c = c.highlighteds, c.ka(), a ? c.add(this) : c.remove(this), c.freeze());
                    this.g("isHighlighted", b, a);
                    this.P();
                    a = this.highlightedChanged;
                    null !== a && a(this)
                }
            }
        }, isShadowed: {
            configurable: !0, get: function () {
                return 0 !== (this.F & 8192)
            }, set: function (a) {
                var b = 0 !== (this.F & 8192);
                b !== a && (F && A(a, "boolean", T, "isShadowed"), this.F ^= 8192, this.g("isShadowed", b, a), this.P())
            }
        }, isAnimated: {
            configurable: !0, get: function () {
                return 0 !== (this.F & 262144)
            }, set: function (a) {
                var b = 0 !== (this.F & 262144);
                b !== a && (F && A(a, "boolean", T, "isAnimated"), this.F ^= 262144, this.g("isAnimated", b, a))
            }
        }, highlightedChanged: {
            configurable: !0, get: function () {
                return this.Ao
            },
            set: function (a) {
                var b = this.Ao;
                b !== a && (null !== a && A(a, "function", T, "highlightedChanged"), this.Ao = a, this.g("highlightedChanged", b, a))
            }
        }, selectionObjectName: {
            configurable: !0, get: function () {
                return this.$p
            }, set: function (a) {
                var b = this.$p;
                b !== a && (F && A(a, "string", T, "selectionObjectName"), this.$p = a, this.Dh = null, this.g("selectionObjectName", b, a))
            }
        }, selectionAdornmentTemplate: {
            configurable: !0, get: function () {
                return this.Yp
            }, set: function (a) {
                var b = this.Yp;
                b !== a && (F && w(a, Xe, T, "selectionAdornmentTemplate"),
                    this.Yp = a, this.g("selectionAdornmentTemplate", b, a))
            }
        }, selectionObject: {
            configurable: !0, get: function () {
                if (null === this.Dh) {
                    var a = this.selectionObjectName;
                    null !== a && "" !== a ? (a = this.hb(a), null !== a ? this.Dh = a : this.Dh = this) : this instanceof S ? (a = this.path, null !== a ? this.Dh = a : this.Dh = this) : this.Dh = this
                }
                return this.Dh
            }
        }, selectionChanged: {
            configurable: !0, get: function () {
                return this.Zp
            }, set: function (a) {
                var b = this.Zp;
                b !== a && (null !== a && A(a, "function", T, "selectionChanged"), this.Zp = a, this.g("selectionChanged",
                    b, a))
            }
        }, resizeAdornmentTemplate: {
            configurable: !0, get: function () {
                return this.Jp
            }, set: function (a) {
                var b = this.Jp;
                b !== a && (F && w(a, Xe, T, "resizeAdornmentTemplate"), this.Jp = a, this.g("resizeAdornmentTemplate", b, a))
            }
        }, resizeObjectName: {
            configurable: !0, get: function () {
                return this.Lp
            }, set: function (a) {
                var b = this.Lp;
                b !== a && (F && A(a, "string", T, "resizeObjectName"), this.Lp = a, this.g("resizeObjectName", b, a))
            }
        }, resizeObject: {
            configurable: !0, get: function () {
                var a = this.resizeObjectName;
                return "" !== a && (a = this.hb(a), null !== a) ? a : this
            }
        }, resizeCellSize: {
            configurable: !0, get: function () {
                return this.Kp
            }, set: function (a) {
                var b = this.Kp;
                b.A(a) || (F && w(a, Hb, T, "resizeCellSize"), this.Kp = a = a.J(), this.g("resizeCellSize", b, a))
            }
        }, rotateAdornmentTemplate: {
            configurable: !0, get: function () {
                return this.Np
            }, set: function (a) {
                var b = this.Np;
                b !== a && (F && w(a, Xe, T, "rotateAdornmentTemplate"), this.Np = a, this.g("rotateAdornmentTemplate", b, a))
            }
        }, rotateObjectName: {
            configurable: !0,
            get: function () {
                return this.Op
            }, set: function (a) {
                var b = this.Op;
                b !== a && (F && A(a, "string", T, "rotateObjectName"), this.Op = a, this.g("rotateObjectName", b, a))
            }
        }, rotateObject: {
            configurable: !0, get: function () {
                var a = this.rotateObjectName;
                return "" !== a && (a = this.hb(a), null !== a) ? a : this
            }
        }, rotationSpot: {
            configurable: !0, get: function () {
                return this.Pp
            }, set: function (a) {
                var b = this.Pp;
                b.A(a) || (F && (w(a, M, T, "rotationSpot"), a === jd || a.cb() || v("Part.rotationSpot must be a specific Spot value or Spot.Default, not: " +
                    a)), this.Pp = a = a.J(), this.g("rotationSpot", b, a))
            }
        }, text: {
            configurable: !0, get: function () {
                return this.$b
            }, set: function (a) {
                var b = this.$b;
                b !== a && (F && A(a, "string", T, "text"), this.$b = a, this.g("text", b, a))
            }
        }, containingGroup: {
            configurable: !0, get: function () {
                return this.xi
            }, set: function (a) {
                if (this.Tc()) {
                    var b = this.xi;
                    if (b !== a) {
                        F && null !== a && w(a, Kf, T, "containingGroup");
                        null === a || this !== a && !a.Ld(this) || (this === a && v("Cannot make a Group a member of itself: " + this.toString()), v("Cannot make a Group indirectly contain itself: " +
                            this.toString() + " already contains " + a.toString()));
                        this.D(2);
                        var c = this.diagram;
                        null !== b ? Zo(b, this) : this instanceof Kf && null !== c && c.Nh.remove(this);
                        this.xi = a;
                        null !== a ? Yo(a, this) : this instanceof Kf && null !== c && c.Nh.add(this);
                        this.D(1);
                        if (null !== c && c.ba) {
                            var d = this.data, e = c.model;
                            if (null !== d && e.zj()) {
                                var f = e.pa(null !== a ? a.data : null);
                                e.rr(d, f)
                            }
                        }
                        d = this.containingGroupChanged;
                        null !== d && (e = !0, null !== c && (e = c.ba, c.ba = !0), d(this, b, a), null !== c && (c.ba = e));
                        if (this instanceof Kf) for (c = new I, jl(c, this, !0, 0, !0),
                                                         c = c.iterator; c.next();) if (d = c.value, d instanceof V) for (d = d.linksConnected; d.next();) dp(d.value);
                        if (this instanceof V) {
                            for (c = this.linksConnected; c.next();) dp(c.value);
                            c = this.labeledLink;
                            null !== c && dp(c)
                        }
                        this.g("containingGroup", b, a);
                        null !== a && (b = a.layer, null !== b && Bi(b, -1, a))
                    }
                } else v("cannot set the Part.containingGroup of a Link or Adornment")
            }
        }, containingGroupChanged: {
            configurable: !0, get: function () {
                return this.Kn
            }, set: function (a) {
                var b = this.Kn;
                b !== a && (null !== a && A(a, "function", T, "containingGroupChanged"),
                    this.Kn = a, this.g("containingGroupChanged", b, a))
            }
        }, isTopLevel: {
            configurable: !0, get: function () {
                return null !== this.containingGroup || this instanceof V && null !== this.labeledLink ? !1 : !0
            }
        }, layoutConditions: {
            configurable: !0, get: function () {
                return this.Po
            }, set: function (a) {
                var b = this.Po;
                b !== a && (F && A(a, "number", T, "layoutConditions"), this.Po = a, this.g("layoutConditions", b, a))
            }
        }, dragComputation: {
            configurable: !0, get: function () {
                return this.bo
            }, set: function (a) {
                var b = this.bo;
                b !== a && (null !== a && A(a, "function", T, "dragComputation"), this.bo = a, this.g("dragComputation", b, a))
            }
        }, shadowOffset: {
            configurable: !0, get: function () {
                return this.eq
            }, set: function (a) {
                var b = this.eq;
                b.A(a) || (F && w(a, J, T, "shadowOffset"), this.eq = a = a.J(), this.P(), this.g("shadowOffset", b, a))
            }
        }, shadowColor: {
            configurable: !0, get: function () {
                return this.cq
            }, set: function (a) {
                var b = this.cq;
                b !== a && (F && A(a, "string", T, "shadowColor"), this.cq = a, this.P(), this.g("shadowColor", b, a))
            }
        }, shadowBlur: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.wf
            }, set: function (a) {
                var b = this.wf;
                b !== a && (F && A(a, "number", T, "shadowBlur"), this.wf = a, this.P(), this.g("shadowBlur", b, a))
            }
        }
    });
    T.prototype.invalidateLayout = T.prototype.D;
    T.prototype.findCommonContainingGroup = T.prototype.Dy;
    T.prototype.isMemberOf = T.prototype.Ld;
    T.prototype.findTopLevelPart = T.prototype.wA;
    T.prototype.findSubGraphLevel = T.prototype.tA;
    T.prototype.ensureBounds = T.prototype.Ya;
    T.prototype.getDocumentBounds = T.prototype.wj;
    T.prototype.getRelativePoint = T.prototype.Pf;
    T.prototype.findObject = T.prototype.hb;
    T.prototype.moveTo = T.prototype.moveTo;
    T.prototype.invalidateAdornments = T.prototype.Sb;
    T.prototype.clearAdornments = T.prototype.yk;
    T.prototype.removeAdornment = T.prototype.Tf;
    T.prototype.addAdornment = T.prototype.Qh;
    T.prototype.findAdornment = T.prototype.Gk;
    T.prototype.updateTargetBindings = T.prototype.Ha;
    var Wo = !1;
    T.className = "Part";
    T.LayoutNone = 0;
    T.LayoutAdded = 1;
    T.LayoutRemoved = 2;
    T.LayoutShown = 4;
    T.LayoutHidden = 8;
    T.LayoutNodeSized = 16;
    T.LayoutGroupLayout = 32;
    T.LayoutNodeReplaced = 64;
    T.LayoutStandard = 127;
    T.LayoutAll = 16777215;

    function Xe(a) {
        T.call(this, a);
        this.F &= -257;
        this.uh = "Adornment";
        this.ne = null;
        this.Rx = 0;
        this.hy = !1;
        this.l = [];
        this.Ra = null
    }

    ma(Xe, T);
    Xe.prototype.toString = function () {
        var a = this.adornedPart;
        return "Adornment(" + this.category + ")" + (null !== a ? a.toString() : "")
    };
    Xe.prototype.updateRelationshipsFromData = function () {
    };
    Xe.prototype.Nk = function (a) {
        var b = this.adornedObject.part;
        if (b instanceof S && this.adornedObject instanceof Zf) {
            var c = b.path;
            b.Nk(a);
            a = c.geometry;
            b = this.$.j;
            c = b.length;
            for (var d = 0; d < c; d++) {
                var e = b[d];
                e.isPanelMain && e instanceof Zf && (e.ua = a)
            }
        }
    };
    Xe.prototype.Cj = function () {
        var a = this.ne;
        if (null === a) return !0;
        a = a.part;
        return null === a || !Ij(a)
    };
    Xe.prototype.Tc = function () {
        return !1
    };
    Xe.prototype.Zk = function (a, b, c, d, e, f, g) {
        if (a === Ne && "elements" === b) if (e instanceof Mg) null === this.Ra ? this.Ra = e : F && this.Ra !== e && v("Cannot insert a second Placeholder into the visual tree of an Adornment."); else {
            if (e instanceof W) {
                var h = e.Jm(function (a) {
                    return a instanceof Mg
                });
                h instanceof Mg && (null === this.Ra ? this.Ra = h : F && this.Ra !== h && v("Cannot insert a second Placeholder into the visual tree of an Adornment."))
            }
        } else a === Oe && "elements" === b && null !== this.Ra && (d === this.Ra ? this.Ra = null : d instanceof W &&
            this.Ra.Tg(d) && (this.Ra = null));
        T.prototype.Zk.call(this, a, b, c, d, e, f, g)
    };
    Xe.prototype.updateAdornments = function () {
    };
    Xe.prototype.Ek = function () {
    };
    na.Object.defineProperties(Xe.prototype, {
        placeholder: {
            configurable: !0, get: function () {
                return this.Ra
            }
        }, adornedObject: {
            configurable: !0, get: function () {
                return this.ne
            }, set: function (a) {
                F && null !== a && w(a, N, T, "adornedObject:value");
                var b = this.adornedPart, c = null;
                null !== a && (c = a.part);
                null === b || null !== a && b === c || b.Tf(this.category);
                this.ne = a;
                null !== c && c.Qh(this.category, this)
            }
        }, adornedPart: {
            configurable: !0, get: function () {
                var a = this.ne;
                return null !== a ? a.part : null
            }
        }, containingGroup: {
            configurable: !0,
            enumerable: !0, get: function () {
                return null
            }
        }
    });
    Xe.className = "Adornment";

    function V(a) {
        T.call(this, a);
        this.T = 13;
        this.gb = new H;
        this.wq = this.Wl = this.Ri = this.Ro = this.Qo = null;
        this.ml = Dc;
        this.zc = this.cf = null;
        this.Gp = ep;
        this.Oh = !1
    }

    ma(V, T);
    V.prototype.cloneProtected = function (a) {
        T.prototype.cloneProtected.call(this, a);
        a.T = this.T;
        a.T = this.T & -17;
        a.Qo = this.Qo;
        a.Ro = this.Ro;
        a.Ri = this.Ri;
        a.wq = this.wq;
        a.ml = this.ml.J();
        a.Gp = this.Gp
    };
    t = V.prototype;
    t.Kf = function (a) {
        T.prototype.Kf.call(this, a);
        a.wd();
        a.cf = this.cf;
        a.zc = null
    };

    function fp(a, b) {
        null !== b && (null === a.cf && (a.cf = new I), a.cf.add(b))
    }

    function gp(a, b, c, d) {
        if (null === b || null === a.cf) return null;
        for (var e = a.cf.iterator; e.next();) {
            var f = e.value;
            if (f.lu === a && f.vw === b && f.bz === c && f.cz === d || f.lu === b && f.vw === a && f.bz === d && f.cz === c) return f
        }
        return null
    }

    t.PA = function (a, b, c) {
        if (void 0 === b || null === b) b = "";
        if (void 0 === c || null === c) c = "";
        a = gp(this, a, b, c);
        null !== a && a.Om()
    };
    t.Zk = function (a, b, c, d, e, f, g) {
        a === Ne && "elements" === b ? this.zc = null : a === Oe && "elements" === b && (this.zc = null);
        T.prototype.Zk.call(this, a, b, c, d, e, f, g)
    };
    t.wd = function (a) {
        void 0 === a && (a = null);
        for (var b = this.linksConnected; b.next();) {
            var c = b.value;
            null !== a && a.contains(c) || (hp(c.fromPort), hp(c.toPort), c.Za())
        }
    };

    function Gl(a, b) {
        for (a = a.linksConnected; a.next();) {
            var c = a.value;
            if (c.fromPort === b || c.toPort === b) hp(c.fromPort), hp(c.toPort), c.Za()
        }
    }

    function hp(a) {
        if (null !== a) {
            var b = a.Fp;
            null !== b && b.Om();
            a = a.part;
            b = a.containingGroup;
            null === b || a.isVisible() || hp(b.port)
        }
    }

    t.Cj = function () {
        return !0
    };
    V.prototype.getAvoidableRect = function (a) {
        a.set(this.actualBounds);
        a.Dq(this.ml);
        return a
    };
    V.prototype.findVisibleNode = function () {
        for (var a = this; null !== a && !a.isVisible();) a = a.containingGroup;
        return a
    };
    V.prototype.isVisible = function () {
        if (!T.prototype.isVisible.call(this)) return !1;
        var a = !0, b = Gi, c = this.diagram;
        if (null !== c) {
            if (c.animationManager.nu(this)) return !0;
            a = c.isTreePathToChildren;
            b = c.treeCollapsePolicy
        }
        if (b === Gi) {
            if (a = this.Sg(), null !== a && !a.isTreeExpanded) return !1
        } else if (b === Vk) {
            if (a = a ? this.ew() : this.fw(), 0 < a.count && a.all(function (a) {
                return !a.isTreeExpanded
            })) return !1
        } else if (b === Wk && (a = a ? this.ew() : this.fw(), 0 < a.count && a.any(function (a) {
            return !a.isTreeExpanded
        }))) return !1;
        a = this.labeledLink;
        return null !== a ? a.isVisible() : !0
    };
    V.prototype.Vb = function (a) {
        T.prototype.Vb.call(this, a);
        for (var b = this.linksConnected; b.next();) {
            var c = b.value;
            if (a && null !== this.containingGroup) {
                var d = c.Tq(this);
                null === d || d.Ld(this.containingGroup) || c.Za()
            }
            c.Vb(a)
        }
    };
    V.prototype.Ey = function () {
        var a = new I, b = new I;
        ip(this, this, a, b);
        return b.iterator
    };

    function ip(a, b, c, d) {
        if (null !== b && !c.has(b)) {
            c.add(b);
            var e = !0, f = a.diagram;
            null !== f && (e = f.isTreePathToChildren);
            b.linksConnected.each(function (f) {
                f.isTreeLink ? (e ? f.fromNode === b : f.toNode === b) && ip(a, e ? f.toNode : f.fromNode, c, d) : d.add(f)
            })
        }
    }

    V.prototype.findLinksConnected = function (a) {
        void 0 === a && (a = null);
        if (null === a) return this.gb.iterator;
        F && A(a, "string", V, "findLinksConnected:pid");
        var b = new pb(this.gb), c = this;
        b.predicate = function (b) {
            return b.fromNode === c && b.fromPortId === a || b.toNode === c && b.toPortId === a
        };
        return b
    };
    t = V.prototype;
    t.Oq = function (a) {
        void 0 === a && (a = null);
        F && null !== a && A(a, "string", V, "findLinksOutOf:pid");
        var b = new pb(this.gb), c = this;
        b.predicate = function (b) {
            return b.fromNode !== c ? !1 : null === a ? !0 : b.fromPortId === a
        };
        return b
    };
    t.Jd = function (a) {
        void 0 === a && (a = null);
        F && null !== a && A(a, "string", V, "findLinksInto:pid");
        var b = new pb(this.gb), c = this;
        b.predicate = function (b) {
            return b.toNode !== c ? !1 : null === a ? !0 : b.toPortId === a
        };
        return b
    };
    t.dw = function (a) {
        void 0 === a && (a = null);
        F && null !== a && A(a, "string", V, "findNodesConnected:pid");
        for (var b = null, c = null, d = this.gb.iterator; d.next();) {
            var e = d.value;
            if (e.fromNode === this) {
                if (null === a || e.fromPortId === a) e = e.toNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new I, b.add(c), b.add(e)) : c = e
            } else e.toNode !== this || null !== a && e.toPortId !== a || (e = e.fromNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new I, b.add(c), b.add(e)) : c = e)
        }
        return null !== b ? b.iterator : null !== c ? new nb(c) : mb
    };
    t.fw = function (a) {
        void 0 === a && (a = null);
        F && null !== a && A(a, "string", V, "findNodesOutOf:pid");
        for (var b = null, c = null, d = this.gb.iterator; d.next();) {
            var e = d.value;
            e.fromNode !== this || null !== a && e.fromPortId !== a || (e = e.toNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new I, b.add(c), b.add(e)) : c = e)
        }
        return null !== b ? b.iterator : null !== c ? new nb(c) : mb
    };
    t.ew = function (a) {
        void 0 === a && (a = null);
        F && null !== a && A(a, "string", V, "findNodesInto:pid");
        for (var b = null, c = null, d = this.gb.iterator; d.next();) {
            var e = d.value;
            e.toNode !== this || null !== a && e.toPortId !== a || (e = e.fromNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new I, b.add(c), b.add(e)) : c = e)
        }
        return null !== b ? b.iterator : null !== c ? new nb(c) : mb
    };
    t.oA = function (a, b, c) {
        void 0 === b && (b = null);
        void 0 === c && (c = null);
        F && (w(a, V, V, "findLinksBetween:othernode"), null !== b && A(b, "string", V, "findLinksBetween:pid"), null !== c && A(c, "string", V, "findLinksBetween:otherpid"));
        var d = new pb(this.gb), e = this;
        d.predicate = function (d) {
            return (d.fromNode !== e || d.toNode !== a || null !== b && d.fromPortId !== b || null !== c && d.toPortId !== c) && (d.fromNode !== a || d.toNode !== e || null !== c && d.fromPortId !== c || null !== b && d.toPortId !== b) ? !1 : !0
        };
        return d
    };
    t.pA = function (a, b, c) {
        void 0 === b && (b = null);
        void 0 === c && (c = null);
        F && (w(a, V, V, "findLinksTo:othernode"), null !== b && A(b, "string", V, "findLinksTo:pid"), null !== c && A(c, "string", V, "findLinksTo:otherpid"));
        var d = new pb(this.gb), e = this;
        d.predicate = function (d) {
            return d.fromNode !== e || d.toNode !== a || null !== b && d.fromPortId !== b || null !== c && d.toPortId !== c ? !1 : !0
        };
        return d
    };

    function jp(a, b, c) {
        hp(c);
        var d = a.gb.contains(b);
        d || a.gb.add(b);
        if (!d || b.fromNode === b.toNode) {
            var e = a.linkConnected;
            if (null !== e) {
                var f = !0, g = a.diagram;
                null !== g && (f = g.ba, g.ba = !0);
                e(a, b, c);
                null !== g && (g.ba = f)
            }
        }
        !d && b.isTreeLink && (c = b.fromNode, b = b.toNode, null !== c && null !== b && c !== b && (d = !0, a = a.diagram, null !== a && (d = a.isTreePathToChildren), e = d ? b : c, f = d ? c : b, e.Oh || (e.Oh = f), !f.isTreeLeaf || null !== a && a.undoManager.isUndoingRedoing || (d ? c === f && (f.isTreeLeaf = !1) : b === f && (f.isTreeLeaf = !1))))
    }

    function kp(a, b, c) {
        hp(c);
        var d = a.gb.remove(b), e = null;
        if (d || b.toNode === b.fromNode) {
            var f = a.linkDisconnected;
            e = a.diagram;
            if (null !== f) {
                var g = !0;
                null !== e && (g = e.ba, e.ba = !0);
                f(a, b, c);
                null !== e && (e.ba = g)
            }
        }
        d && b.isTreeLink && (c = !0, null !== e && (c = e.isTreePathToChildren), a = c ? b.toNode : b.fromNode, b = c ? b.fromNode : b.toNode, null !== a && (a.Oh = !1), null === b || b.isTreeLeaf || (0 === b.gb.count ? (b.Oh = null, null !== e && e.undoManager.isUndoingRedoing || (b.isTreeLeaf = !0)) : Uk(b)))
    }

    function Uk(a) {
        a.Oh = !1;
        if (0 !== a.gb.count) {
            var b = !0, c = a.diagram;
            if (null === c || !c.undoManager.isUndoingRedoing) {
                null !== c && (b = c.isTreePathToChildren);
                for (c = a.gb.iterator; c.next();) {
                    var d = c.value;
                    if (d.isTreeLink) if (b) {
                        if (d.fromNode === a) {
                            a.isTreeLeaf = !1;
                            return
                        }
                    } else if (d.toNode === a) {
                        a.isTreeLeaf = !1;
                        return
                    }
                }
                a.isTreeLeaf = !0
            }
        }
    }

    V.prototype.updateRelationshipsFromData = function () {
        var a = this.diagram;
        null !== a && a.partManager.updateRelationshipsFromData(this)
    };
    t = V.prototype;
    t.Vq = function (a) {
        T.prototype.Vq.call(this, a);
        a || (Uk(this), a = this.Wl, null !== a && lp(a, this))
    };
    t.Wq = function (a) {
        T.prototype.Wq.call(this, a);
        a || (a = this.Wl, null !== a && null !== a.rd && (a.rd.remove(this), a.v()))
    };
    t.Ek = function () {
        if (0 < this.gb.count) {
            var a = this.diagram;
            if (null !== a) for (var b = null !== a.commandHandler ? a.commandHandler.deletesConnectedLinks : !0, c = this.gb.copy().iterator; c.next();) {
                var d = c.value;
                b ? a.remove(d) : (d.fromNode === this && (d.fromNode = null), d.toNode === this && (d.toNode = null))
            }
        }
        this.labeledLink = null;
        T.prototype.Ek.call(this)
    };
    t.Vt = function (a) {
        F && A(a, "string", V, "findPort:pid");
        if (null === this.zc) {
            if ("" === a && !1 === this.Xh) return this;
            mp(this)
        }
        var b = this.zc.K(a);
        return null !== b || "" !== a && (b = this.zc.K(""), null !== b) ? b : this
    };

    function mp(a) {
        null === a.zc ? a.zc = new Db : a.zc.clear();
        a.cl(a, function (a, c) {
            jm(a, c)
        });
        0 === a.zc.count && a.zc.add("", a)
    }

    function jm(a, b) {
        var c = b.portId;
        null !== c && null !== a.zc && a.zc.add(c, b)
    }

    function im(a, b, c) {
        var d = b.portId;
        if (null !== d && (null !== a.zc && a.zc.remove(d), b = a.diagram, null !== b && c)) {
            c = null;
            for (a = a.findLinksConnected(d); a.next();) d = a.value, null === c && (c = Ma()), c.push(d);
            if (null !== c) {
                for (a = 0; a < c.length; a++) b.remove(c[a]);
                Oa(c)
            }
        }
    }

    t.RA = function (a) {
        if (null === a || a === this) return !1;
        var b = !0, c = this.diagram;
        null !== c && (b = c.isTreePathToChildren);
        c = this;
        if (b) for (; c !== a;) {
            b = null;
            for (var d = c.gb.iterator; d.next();) {
                var e = d.value;
                if (e.isTreeLink && (b = e.fromNode, b !== c && b !== this)) break
            }
            if (b === this || null === b || b === c) return !1;
            c = b
        } else for (; c !== a;) {
            b = null;
            for (d = c.gb.iterator; d.next() && (e = d.value, !e.isTreeLink || (b = e.toNode, b === c || b === this));) ;
            if (b === this || null === b || b === c) return !1;
            c = b
        }
        return !0
    };
    t.AA = function () {
        var a = !0, b = this.diagram;
        null !== b && (a = b.isTreePathToChildren);
        b = this;
        if (a) for (; ;) {
            a = null;
            for (var c = b.gb.iterator; c.next();) {
                var d = c.value;
                if (d.isTreeLink && (a = d.fromNode, a !== b && a !== this)) break
            }
            if (a === this) return this;
            if (null === a || a === b) return b;
            b = a
        } else for (; ;) {
            a = null;
            for (c = b.gb.iterator; c.next() && (d = c.value, !d.isTreeLink || (a = d.toNode, a === b || a === this));) ;
            if (a === this) return this;
            if (null === a || a === b) return b;
            b = a
        }
    };
    t.lA = function (a) {
        if (null === a) return null;
        F && w(a, V, V, "findCommonTreeParent:other");
        if (this === a) return this;
        for (var b = this; null !== b;) Xo(b, !0), b = b.Sg();
        var c = null;
        for (b = a; null !== b;) {
            if (0 !== (b.F & 1048576)) {
                c = b;
                break
            }
            b = b.Sg()
        }
        for (b = this; null !== b;) Xo(b, !1), b = b.Sg();
        return c
    };
    t.tj = function () {
        var a = !0, b = this.diagram;
        null !== b && (a = b.isTreePathToChildren);
        b = this.gb.iterator;
        if (a) for (; b.next();) {
            if (a = b.value, a.isTreeLink && a.fromNode !== this) return a
        } else for (; b.next();) if (a = b.value, a.isTreeLink && a.toNode !== this) return a;
        return null
    };
    t.Sg = function () {
        var a = this.Oh;
        if (null === a) return null;
        if (a instanceof V) return a;
        var b = !0;
        a = this.diagram;
        null !== a && (b = a.isTreePathToChildren);
        a = this.gb.iterator;
        if (b) for (; a.next();) {
            if (b = a.value, b.isTreeLink && (b = b.fromNode, b !== this)) return this.Oh = b
        } else for (; a.next();) if (b = a.value, b.isTreeLink && (b = b.toNode, b !== this)) return this.Oh = b;
        return this.Oh = null
    };
    t.yA = function () {
        function a(b, d) {
            if (null !== b) {
                d.add(b);
                var c = b.tj();
                null !== c && (d.add(c), a(b.Sg(), d))
            }
        }

        var b = new I;
        a(this, b);
        return b
    };
    t.xA = function () {
        return np(this, this)
    };

    function np(a, b) {
        b = b.Sg();
        return null === b ? 0 : 1 + np(a, b)
    }

    t.Qq = function () {
        var a = !0, b = this.diagram;
        null !== b && (a = b.isTreePathToChildren);
        b = new pb(this.gb);
        var c = this;
        b.predicate = a ? function (a) {
            return a.isTreeLink && a.fromNode === c ? !0 : !1
        } : function (a) {
            return a.isTreeLink && a.toNode === c ? !0 : !1
        };
        return b
    };
    t.hw = function () {
        var a = !0, b = this.diagram;
        null !== b && (a = b.isTreePathToChildren);
        var c = b = null, d = this.gb.iterator;
        if (a) for (; d.next();) a = d.value, a.isTreeLink && a.fromNode === this && (a = a.toNode, null !== b ? b.add(a) : null !== c && c !== a ? (b = new H, b.add(c), b.add(a)) : c = a); else for (; d.next();) a = d.value, a.isTreeLink && a.toNode === this && (a = a.fromNode, null !== b ? b.add(a) : null !== c && c !== a ? (b = new H, b.add(c), b.add(a)) : c = a);
        return null !== b ? b.iterator : null !== c ? new nb(c) : mb
    };
    t.zA = function (a) {
        void 0 === a && (a = Infinity);
        A(a, "number", V, "findTreeParts:level");
        var b = new I;
        jl(b, this, !1, a, !0);
        return b
    };
    V.prototype.collapseTree = function (a) {
        void 0 === a && (a = 1);
        C(a, V, "collapseTree:level");
        1 > a && (a = 1);
        var b = this.diagram;
        if (null !== b && !b.Ue) {
            b.Ue = !0;
            var c = new I;
            c.add(this);
            op(this, c, b.isTreePathToChildren, a, b, this, b.treeCollapsePolicy === Gi);
            b.Ue = !1
        }
    };

    function op(a, b, c, d, e, f, g) {
        if (1 < d) for (var h = c ? a.Oq() : a.Jd(); h.next();) {
            var k = h.value;
            k.isTreeLink && (k = k.Tq(a), null === k || k === a || b.contains(k) || (b.add(k), op(k, b, c, d - 1, e, f, g)))
        } else pp(a, b, c, e, f, g)
    }

    function pp(a, b, c, d, e, f) {
        for (var g = e === a ? !0 : a.isTreeExpanded, h = c ? a.Oq() : a.Jd(); h.next();) {
            var k = h.value;
            if (k.isTreeLink && (k = k.Tq(a), null !== k && k !== a)) {
                var l = b.contains(k);
                l || b.add(k);
                g && (f && d.uk(k, e), k.Yh(), k.Vb(!1));
                k.isTreeExpanded && (k.wasTreeExpanded = k.isTreeExpanded, l || pp(k, b, c, d, e, f))
            }
        }
        a.isTreeExpanded = !1
    }

    V.prototype.expandTree = function (a) {
        void 0 === a && (a = 2);
        C(a, V, "expandTree:level");
        2 > a && (a = 2);
        var b = this.diagram;
        if (null !== b && !b.Ue) {
            b.Ue = !0;
            var c = new I;
            c.add(this);
            qp(this, c, b.isTreePathToChildren, a, b, this, b.treeCollapsePolicy === Gi);
            b.Ue = !1
        }
    };

    function qp(a, b, c, d, e, f, g) {
        for (var h = f === a ? !1 : a.isTreeExpanded, k = c ? a.Oq() : a.Jd(); k.next();) {
            var l = k.value;
            l.isTreeLink && (h || l.nd || l.Za(), l = l.Tq(a), null !== l && l !== a && !b.contains(l) && (b.add(l), h || (l.Vb(!0), l.Yh(), g && e.wk(l, f)), 2 < d || l.wasTreeExpanded)) && (l.wasTreeExpanded = !1, qp(l, b, c, d - 1, e, f, g))
        }
        a.isTreeExpanded = !0
    }

    na.Object.defineProperties(V.prototype, {
        portSpreading: {
            configurable: !0, get: function () {
                return this.Gp
            }, set: function (a) {
                var b = this.Gp;
                b !== a && (F && a !== rp && a !== ep && a !== sp && v("Node.portSpreading can only be set to Node.SpreadingNone, Node.SpreadingEvenly, or Node.SpreadingPacked, not: " + a), this.Gp = a, this.g("portSpreading", b, a), a = this.diagram, null !== a && a.undoManager.isUndoingRedoing || this.wd())
            }
        }, avoidable: {
            configurable: !0, get: function () {
                return 0 !== (this.T & 8)
            }, set: function (a) {
                var b =
                    0 !== (this.T & 8);
                if (b !== a) {
                    F && A(a, "boolean", V, "avoidable");
                    this.T ^= 8;
                    var c = this.diagram;
                    null !== c && Nk(c, this);
                    this.g("avoidable", b, a)
                }
            }
        }, avoidableMargin: {
            configurable: !0, get: function () {
                return this.ml
            }, set: function (a) {
                "number" === typeof a ? a = new jc(a) : w(a, jc, V, "avoidableMargin");
                var b = this.ml;
                if (!b.A(a)) {
                    this.ml = a = a.J();
                    var c = this.diagram;
                    null !== c && Nk(c, this);
                    this.g("avoidableMargin", b, a)
                }
            }
        }, linksConnected: {
            configurable: !0, get: function () {
                return this.gb.iterator
            }
        }, linkConnected: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Qo
            }, set: function (a) {
                var b = this.Qo;
                b !== a && (null !== a && A(a, "function", V, "linkConnected"), this.Qo = a, this.g("linkConnected", b, a))
            }
        }, linkDisconnected: {
            configurable: !0, get: function () {
                return this.Ro
            }, set: function (a) {
                var b = this.Ro;
                b !== a && (null !== a && A(a, "function", V, "linkDisconnected"), this.Ro = a, this.g("linkDisconnected", b, a))
            }
        }, linkValidation: {
            configurable: !0, get: function () {
                return this.Ri
            }, set: function (a) {
                var b = this.Ri;
                b !== a && (null !== a &&
                A(a, "function", V, "linkValidation"), this.Ri = a, this.g("linkValidation", b, a))
            }
        }, isLinkLabel: {
            configurable: !0, get: function () {
                return null !== this.Wl
            }
        }, labeledLink: {
            configurable: !0, get: function () {
                return this.Wl
            }, set: function (a) {
                var b = this.Wl;
                if (b !== a) {
                    F && null !== a && w(a, S, V, "labeledLink");
                    var c = this.diagram, d = this.data;
                    if (null !== b) {
                        null !== b.rd && (b.rd.remove(this), b.v());
                        if (null !== c && null !== d && !c.undoManager.isUndoingRedoing) {
                            var e = b.data, f = c.model;
                            if (null !== e && f.Bj()) {
                                var g = f.pa(d);
                                void 0 !== g && f.dz(e, g)
                            }
                        }
                        this.containingGroup = null
                    }
                    this.Wl = a;
                    null !== a && (lp(a, this), null === c || null === d || c.undoManager.isUndoingRedoing || (e = a.data, c = c.model, null !== e && c.Bj() && (d = c.pa(d), void 0 !== d && c.Ov(e, d))), this.containingGroup = a.containingGroup);
                    Ul(this);
                    this.g("labeledLink", b, a)
                }
            }
        }, port: {
            configurable: !0, get: function () {
                return this.Vt("")
            }
        }, ports: {
            configurable: !0, get: function () {
                null === this.zc && mp(this);
                return this.zc.iteratorValues
            }
        }, isTreeExpanded: {
            configurable: !0,
            get: function () {
                return 0 !== (this.T & 1)
            }, set: function (a) {
                var b = 0 !== (this.T & 1);
                if (b !== a) {
                    F && A(a, "boolean", V, "isTreeExpanded");
                    this.T ^= 1;
                    var c = this.diagram;
                    this.g("isTreeExpanded", b, a);
                    b = this.treeExpandedChanged;
                    if (null !== b) {
                        var d = !0;
                        null !== c && (d = c.ba, c.ba = !0);
                        b(this);
                        null !== c && (c.ba = d)
                    }
                    null !== c && c.undoManager.isUndoingRedoing ? this.Vb(a) : a ? this.expandTree() : this.collapseTree()
                }
            }
        }, wasTreeExpanded: {
            configurable: !0, get: function () {
                return 0 !== (this.T & 2)
            }, set: function (a) {
                var b = 0 !== (this.T & 2);
                b !==
                a && (F && A(a, "boolean", V, "wasTreeExpanded"), this.T ^= 2, this.g("wasTreeExpanded", b, a))
            }
        }, treeExpandedChanged: {
            configurable: !0, get: function () {
                return this.wq
            }, set: function (a) {
                var b = this.wq;
                b !== a && (null !== a && A(a, "function", V, "treeExpandedChanged"), this.wq = a, this.g("treeExpandedChanged", b, a))
            }
        }, isTreeLeaf: {
            configurable: !0, get: function () {
                return 0 !== (this.T & 4)
            }, set: function (a) {
                var b = 0 !== (this.T & 4);
                b !== a && (F && A(a, "boolean", V, "isTreeLeaf"), this.T ^= 4, this.g("isTreeLeaf", b, a))
            }
        }
    });
    V.prototype.expandTree = V.prototype.expandTree;
    V.prototype.collapseTree = V.prototype.collapseTree;
    V.prototype.findTreeParts = V.prototype.zA;
    V.prototype.findTreeChildrenNodes = V.prototype.hw;
    V.prototype.findTreeChildrenLinks = V.prototype.Qq;
    V.prototype.findTreeLevel = V.prototype.xA;
    V.prototype.findTreeParentChain = V.prototype.yA;
    V.prototype.findTreeParentNode = V.prototype.Sg;
    V.prototype.findTreeParentLink = V.prototype.tj;
    V.prototype.findCommonTreeParent = V.prototype.lA;
    V.prototype.findTreeRoot = V.prototype.AA;
    V.prototype.isInTreeOf = V.prototype.RA;
    V.prototype.findPort = V.prototype.Vt;
    V.prototype.findLinksTo = V.prototype.pA;
    V.prototype.findLinksBetween = V.prototype.oA;
    V.prototype.findNodesInto = V.prototype.ew;
    V.prototype.findNodesOutOf = V.prototype.fw;
    V.prototype.findNodesConnected = V.prototype.dw;
    V.prototype.findLinksInto = V.prototype.Jd;
    V.prototype.findLinksOutOf = V.prototype.Oq;
    V.prototype.findExternalTreeLinksConnected = V.prototype.Ey;
    V.prototype.invalidateConnectedLinks = V.prototype.wd;
    V.prototype.invalidateLinkBundle = V.prototype.PA;
    var rp = new E(V, "SpreadingNone", 10), ep = new E(V, "SpreadingEvenly", 11), sp = new E(V, "SpreadingPacked", 12);
    V.className = "Node";
    V.SpreadingNone = rp;
    V.SpreadingEvenly = ep;
    V.SpreadingPacked = sp;

    function Kf(a) {
        V.call(this, a);
        this.T |= 4608;
        this.bp = new I;
        this.dm = new I;
        this.Ra = this.nq = this.Ti = this.cp = this.ap = this.fb = null;
        this.rc = new Ni;
        this.rc.group = this
    }

    ma(Kf, V);
    Kf.prototype.cloneProtected = function (a) {
        V.prototype.cloneProtected.call(this, a);
        this.T = this.T & -32769;
        null !== this.fb && (a.fb = this.fb.copy());
        a.ap = this.ap;
        a.cp = this.cp;
        a.Ti = this.Ti;
        a.nq = this.nq;
        var b = a.Jm(function (a) {
            return a instanceof Mg
        });
        b instanceof Mg ? a.Ra = b : a.Ra = null;
        null !== this.rc ? (a.rc = this.rc.copy(), a.rc.group = a) : (null !== a.rc && (a.rc.group = null), a.rc = null)
    };
    t = Kf.prototype;
    t.Kf = function (a) {
        V.prototype.Kf.call(this, a);
        var b = a.Hk();
        for (a = a.memberParts; a.next();) {
            var c = a.value;
            c.v();
            c.D(8);
            c.yk();
            if (c instanceof V) c.wd(b); else if (c instanceof S) for (c = c.labelNodes; c.next();) c.value.wd(b)
        }
    };
    t.Zk = function (a, b, c, d, e, f, g) {
        if (a === Ne && "elements" === b) if (e instanceof Mg) null === this.Ra ? this.Ra = e : this.Ra !== e && v("Cannot insert a second Placeholder into the visual tree of a Group."); else {
            if (e instanceof W) {
                var h = e.Jm(function (a) {
                    return a instanceof Mg
                });
                h instanceof Mg && (null === this.Ra ? this.Ra = h : this.Ra !== h && v("Cannot insert a second Placeholder into the visual tree of a Group."))
            }
        } else a === Oe && "elements" === b && null !== this.Ra && (d === this.Ra ? this.Ra = null : d instanceof W && this.Ra.Tg(d) && (this.Ra = null));
        V.prototype.Zk.call(this, a, b, c, d, e, f, g)
    };
    t.Um = function (a, b) {
        V.prototype.Um.call(this, a, b);
        this.isClipping && this.type !== W.Spot && (a = this.resizeObject, a instanceof W && (a = a.wb()), null === this.fb && (this.fb = new L), a.wj(this.fb), a instanceof Zf && this.fb.Pc(-a.strokeWidth, -a.strokeWidth))
    };
    t.Sh = function (a, b, c, d) {
        this.pf = this.Ra;
        V.prototype.Sh.call(this, a, b, c, d)
    };
    t.Ya = function () {
        var a = this;
        a.isSubGraphExpanded && this.memberParts.each(function (b) {
            !a.computesBoundsIncludingLinks && b instanceof S || b.Ya()
        });
        V.prototype.Ya.call(this)
    };
    t.Cj = function () {
        if (!V.prototype.Cj.call(this)) return !1;
        for (var a = this.memberParts; a.next();) {
            var b = a.value;
            if (b instanceof V) {
                if (b.isVisible() && Ij(b)) return !1
            } else if (b instanceof S && b.isVisible() && Ij(b) && b.fromNode !== this && b.toNode !== this) return !1
        }
        return !0
    };

    function Yo(a, b) {
        if (a.bp.add(b)) {
            b instanceof Kf && a.dm.add(b);
            var c = a.memberAdded;
            if (null !== c) {
                var d = !0, e = a.diagram;
                null !== e && (d = e.ba, e.ba = !0);
                c(a, b);
                null !== e && (e.ba = d)
            }
            a.isVisible() && a.isSubGraphExpanded || b.Vb(!1)
        }
        b instanceof S && !a.computesBoundsIncludingLinks || (b = a.Ra, null === b && (b = a), b.v())
    }

    function Zo(a, b) {
        if (a.bp.remove(b)) {
            b instanceof Kf && a.dm.remove(b);
            var c = a.memberRemoved;
            if (null !== c) {
                var d = !0, e = a.diagram;
                null !== e && (d = e.ba, e.ba = !0);
                c(a, b);
                null !== e && (e.ba = d)
            }
            a.isVisible() && a.isSubGraphExpanded || b.Vb(!0)
        }
        b instanceof S && !a.computesBoundsIncludingLinks || (b = a.Ra, null === b && (b = a), b.v())
    }

    t.Ek = function () {
        if (0 < this.bp.count) {
            var a = this.diagram;
            if (null !== a) for (var b = this.bp.copy().iterator; b.next();) a.remove(b.value)
        }
        V.prototype.Ek.call(this)
    };
    Kf.prototype.canAddMembers = function (a) {
        var b = this.diagram;
        if (null === b) return !1;
        b = b.commandHandler;
        for (a = ll(a).iterator; a.next();) if (!b.isValidMember(this, a.value)) return !1;
        return !0
    };
    Kf.prototype.addMembers = function (a, b) {
        var c = this.diagram;
        if (null === c) return !1;
        c = c.commandHandler;
        var d = !0;
        for (a = ll(a).iterator; a.next();) {
            var e = a.value;
            !b || c.isValidMember(this, e) ? e.containingGroup = this : d = !1
        }
        return d
    };
    Kf.prototype.canUngroup = function () {
        if (!this.ungroupable) return !1;
        var a = this.layer;
        if (null !== a && !a.allowUngroup) return !1;
        a = a.diagram;
        return null === a || a.allowUngroup ? !0 : !1
    };
    t = Kf.prototype;
    t.wd = function (a) {
        void 0 === a && (a = null);
        var b = 0 !== (this.T & 65536);
        V.prototype.wd.call(this, a);
        if (!b) for (0 !== (this.T & 65536) !== !0 && (this.T = this.T ^ 65536), b = this.cw(); b.next();) {
            var c = b.value;
            if (null === a || !a.contains(c)) {
                var d = c.fromNode;
                null !== d && d !== this && d.Ld(this) && !d.isVisible() ? (hp(c.fromPort), hp(c.toPort), c.Za()) : (d = c.toNode, null !== d && d !== this && d.Ld(this) && !d.isVisible() && (hp(c.fromPort), hp(c.toPort), c.Za()))
            }
        }
    };
    t.cw = function () {
        var a = this.Hk();
        a.add(this);
        for (var b = new I, c = a.iterator; c.next();) {
            var d = c.value;
            if (d instanceof V) for (d = d.linksConnected; d.next();) {
                var e = d.value;
                a.contains(e) || b.add(e)
            }
        }
        return b.iterator
    };
    t.nA = function () {
        var a = this.Hk();
        a.add(this);
        for (var b = new I, c = a.iterator; c.next();) {
            var d = c.value;
            if (d instanceof V) for (d = d.linksConnected; d.next();) {
                var e = d.value, f = e.fromNode;
                null === f || a.contains(f) && f !== this || b.add(f);
                e = e.toNode;
                null === e || a.contains(e) && e !== this || b.add(e)
            }
        }
        return b.iterator
    };
    t.mA = function () {
        function a(b, d) {
            null !== b && (d.add(b), a(b.containingGroup, d))
        }

        var b = new I;
        a(this, b);
        return b
    };
    t.Hk = function () {
        var a = new I;
        jl(a, this, !0, 0, !0);
        a.remove(this);
        return a
    };
    t.Vb = function (a) {
        V.prototype.Vb.call(this, a);
        for (var b = this.memberParts; b.next();) b.value.Vb(a)
    };
    Kf.prototype.collapseSubGraph = function () {
        var a = this.diagram;
        if (null !== a && !a.Ue) {
            a.Ue = !0;
            var b = this.Hk();
            tp(this, b, a, this);
            a.Ue = !1
        }
    };

    function tp(a, b, c, d) {
        for (var e = a.memberParts; e.next();) {
            var f = e.value;
            f.Vb(!1);
            f instanceof Kf && f.isSubGraphExpanded && (f.wasSubGraphExpanded = f.isSubGraphExpanded, tp(f, b, c, d));
            if (f instanceof V) f.wd(b), c.uk(f, d); else if (f instanceof S) for (f = f.labelNodes; f.next();) f.value.wd(b)
        }
        a.isSubGraphExpanded = !1
    }

    Kf.prototype.expandSubGraph = function () {
        var a = this.diagram;
        if (null !== a && !a.Ue) {
            a.Ue = !0;
            var b = this.Hk();
            up(this, b, a, this);
            a.Ue = !1
        }
    };

    function up(a, b, c, d) {
        for (var e = a.memberParts; e.next();) {
            var f = e.value;
            f.Vb(!0);
            f instanceof Kf && f.wasSubGraphExpanded && (f.wasSubGraphExpanded = !1, up(f, b, c, d));
            if (f instanceof V) f.wd(b), c.wk(f, d); else if (f instanceof S) for (f = f.labelNodes; f.next();) f.value.wd(b)
        }
        a.isSubGraphExpanded = !0
    }

    Kf.prototype.move = function (a, b) {
        void 0 === b && (b = !1);
        var c = b ? this.location : this.position, d = c.x;
        c = c.y;
        var e = a.x, f = a.y;
        if (!(d === e || isNaN(d) && isNaN(e)) || !(c === f || isNaN(c) && isNaN(f))) {
            d = e - (isNaN(d) ? 0 : d);
            c = f - (isNaN(c) ? 0 : c);
            f = J.alloc();
            V.prototype.move.call(this, a, b);
            a = new I;
            for (b = this.Hk().iterator; b.next();) if (e = b.value, e instanceof S && (e.suspendsRouting && a.add(e), e.nd || e.fromNode !== this && e.toNode !== this)) e.suspendsRouting = !0;
            for (b.reset(); b.next();) if (e = b.value, !(e.Zh() || e instanceof V && e.isLinkLabel)) {
                var g =
                    e.position, h = e.location;
                g.o() ? (f.x = g.x + d, f.y = g.y + c, e.position = f) : h.o() && (f.x = h.x + d, f.y = h.y + c, e.location = f)
            }
            for (b.reset(); b.next();) if (e = b.value, e instanceof S && (e.suspendsRouting = a.contains(e), e.nd || e.fromNode !== this && e.toNode !== this)) g = e.position, f.x = g.x + d, f.y = g.y + c, f.o() ? e.move(f) : e.Za(), fk(e) && e.Za();
            J.free(f)
        }
    };
    na.Object.defineProperties(Kf.prototype, {
        placeholder: {
            configurable: !0, get: function () {
                return this.Ra
            }
        }, computesBoundsAfterDrag: {
            configurable: !0, get: function () {
                return 0 !== (this.T & 2048)
            }, set: function (a) {
                var b = 0 !== (this.T & 2048);
                b !== a && (A(a, "boolean", Kf, "computesBoundsAfterDrag"), this.T ^= 2048, this.g("computesBoundsAfterDrag", b, a))
            }
        }, computesBoundsIncludingLinks: {
            configurable: !0, get: function () {
                return 0 !== (this.T & 4096)
            }, set: function (a) {
                A(a, "boolean", Kf, "computesBoundsIncludingLinks");
                var b = 0 !== (this.T & 4096);
                b !== a && (this.T ^= 4096, this.g("computesBoundsIncludingLinks", b, a))
            }
        }, computesBoundsIncludingLocation: {
            configurable: !0, get: function () {
                return 0 !== (this.T & 8192)
            }, set: function (a) {
                A(a, "boolean", Kf, "computesBoundsIncludingLocation");
                var b = 0 !== (this.T & 8192);
                b !== a && (this.T ^= 8192, this.g("computesBoundsIncludingLocation", b, a))
            }
        }, handlesDragDropForMembers: {
            configurable: !0, get: function () {
                return 0 !== (this.T & 16384)
            }, set: function (a) {
                A(a, "boolean", Kf, "handlesDragDropForMembers");
                var b = 0 !== (this.T & 16384);
                b !== a && (this.T ^= 16384, this.g("handlesDragDropForMembers", b, a))
            }
        }, memberParts: {
            configurable: !0, get: function () {
                return this.bp.iterator
            }
        }, layout: {
            configurable: !0, get: function () {
                return this.rc
            }, set: function (a) {
                var b = this.rc;
                if (b !== a) {
                    null !== a && w(a, Ni, Kf, "layout");
                    null !== b && (b.diagram = null, b.group = null);
                    this.rc = a;
                    var c = this.diagram;
                    null !== a && (a.diagram = c, a.group = this);
                    null !== c && (c.$g = !0);
                    this.g("layout", b, a);
                    null !== c && c.Kb()
                }
            }
        }, memberAdded: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.ap
            }, set: function (a) {
                var b = this.ap;
                b !== a && (null !== a && A(a, "function", Kf, "memberAdded"), this.ap = a, this.g("memberAdded", b, a))
            }
        }, memberRemoved: {
            configurable: !0, get: function () {
                return this.cp
            }, set: function (a) {
                var b = this.cp;
                b !== a && (null !== a && A(a, "function", Kf, "memberRemoved"), this.cp = a, this.g("memberRemoved", b, a))
            }
        }, memberValidation: {
            configurable: !0, get: function () {
                return this.Ti
            }, set: function (a) {
                var b = this.Ti;
                b !== a && (null !== a && A(a, "function",
                    Kf, "memberValidation"), this.Ti = a, this.g("memberValidation", b, a))
            }
        }, ungroupable: {
            configurable: !0, get: function () {
                return 0 !== (this.T & 256)
            }, set: function (a) {
                var b = 0 !== (this.T & 256);
                b !== a && (A(a, "boolean", Kf, "ungroupable"), this.T ^= 256, this.g("ungroupable", b, a))
            }
        }, isSubGraphExpanded: {
            configurable: !0, get: function () {
                return 0 !== (this.T & 512)
            }, set: function (a) {
                var b = 0 !== (this.T & 512);
                if (b !== a) {
                    A(a, "boolean", Kf, "isSubGraphExpanded");
                    this.T ^= 512;
                    var c = this.diagram;
                    this.g("isSubGraphExpanded",
                        b, a);
                    b = this.subGraphExpandedChanged;
                    if (null !== b) {
                        var d = !0;
                        null !== c && (d = c.ba, c.ba = !0);
                        b(this);
                        null !== c && (c.ba = d)
                    }
                    null !== c && c.undoManager.isUndoingRedoing ? (null !== this.Ra && this.Ra.v(), this.memberParts.each(function (a) {
                        a.updateAdornments()
                    })) : a ? this.expandSubGraph() : this.collapseSubGraph()
                }
            }
        }, wasSubGraphExpanded: {
            configurable: !0, get: function () {
                return 0 !== (this.T & 1024)
            }, set: function (a) {
                var b = 0 !== (this.T & 1024);
                b !== a && (A(a, "boolean", Kf, "wasSubGraphExpanded"), this.T ^= 1024, this.g("wasSubGraphExpanded",
                    b, a))
            }
        }, subGraphExpandedChanged: {
            configurable: !0, get: function () {
                return this.nq
            }, set: function (a) {
                var b = this.nq;
                b !== a && (null !== a && A(a, "function", Kf, "subGraphExpandedChanged"), this.nq = a, this.g("subGraphExpandedChanged", b, a))
            }
        }, ai: {
            configurable: !0, get: function () {
                return 0 !== (this.T & 32768)
            }, set: function (a) {
                0 !== (this.T & 32768) !== a && (this.T ^= 32768)
            }
        }
    });
    Kf.prototype.expandSubGraph = Kf.prototype.expandSubGraph;
    Kf.prototype.collapseSubGraph = Kf.prototype.collapseSubGraph;
    Kf.prototype.findSubGraphParts = Kf.prototype.Hk;
    Kf.prototype.findContainingGroupChain = Kf.prototype.mA;
    Kf.prototype.findExternalNodesConnected = Kf.prototype.nA;
    Kf.prototype.findExternalLinksConnected = Kf.prototype.cw;
    Kf.prototype.ensureBounds = Kf.prototype.Ya;
    Kf.className = "Group";

    function Mg() {
        N.call(this);
        this.ob = zc;
        this.Up = new L(NaN, NaN, NaN, NaN)
    }

    ma(Mg, N);
    Mg.prototype.cloneProtected = function (a) {
        N.prototype.cloneProtected.call(this, a);
        a.ob = this.ob.J();
        a.Up = this.Up.copy()
    };
    Mg.prototype.Uh = function (a) {
        if (null === this.background && null === this.areaBackground) return !1;
        var b = this.naturalBounds;
        return pc(0, 0, b.width, b.height, a.x, a.y)
    };
    Mg.prototype.Tm = function () {
        var a = this.part;
        null !== a && (a instanceof Kf || a instanceof Xe) || v("Placeholder is not inside a Group or Adornment.");
        if (a instanceof Kf) {
            var b = this.computeBorder(this.Up), c = this.minSize, d = this.wc;
            ec(d, (isFinite(c.width) ? Math.max(c.width, b.width) : b.width) || 0, (isFinite(c.height) ? Math.max(c.height, b.height) : b.height) || 0);
            zl(this, 0, 0, d.width, d.height);
            d = a.memberParts;
            for (c = !1; d.next();) if (d.value.isVisible()) {
                c = !0;
                break
            }
            d = a.diagram;
            !c || null === d || d.animationManager.qw(a) || isNaN(b.x) ||
            isNaN(b.y) || (c = J.alloc(), c.Ej(b, a.locationSpot), c.A(a.location) || (a.location = new J(c.x, c.y)), J.free(c))
        } else {
            b = this.wc;
            c = this.ob;
            d = c.left + c.right;
            var e = c.top + c.bottom, f = a.adornedObject;
            a.angle = f.vj();
            var g = 0;
            f instanceof Zf && (g = f.strokeWidth);
            var h = f.Mf(), k = f.naturalBounds, l = (k.width + g) * h;
            g = (k.height + g) * h;
            a.type !== W.Link && (f = f.ja("Selection" === a.category ? Fc : a.locationSpot, J.alloc()), a.location = f, J.free(f));
            isNaN(l) || isNaN(g) ? (a = a.adornedObject, l = a.ja(Fc, J.alloc()), f = L.allocAt(l.x, l.y, 0, 0), f.Ze(a.ja(Rc,
                l)), f.Ze(a.ja(Hc, l)), f.Ze(a.ja(Oc, l)), ec(b, f.width + d || 0, f.height + e || 0), zl(this, -c.left, -c.top, b.width, b.height), J.free(l), L.free(f)) : (ec(b, l + d || 0, g + e || 0), zl(this, -c.left, -c.top, b.width, b.height))
        }
    };
    Mg.prototype.Sh = function (a, b, c, d) {
        this.actualBounds.h(a, b, c, d)
    };
    Mg.prototype.computeBorder = function (a) {
        var b = this.part, c = b.diagram;
        if (null !== c && b instanceof Kf && !b.layer.isTemporary && b.computesBoundsAfterDrag && this.Up.o()) {
            var d = c.toolManager.findTool("Dragging");
            if (d === c.currentTool && (c = d.computeBorder(b, this.Up, a), null !== c)) return c
        }
        c = L.alloc();
        d = this.computeMemberBounds(c);
        var e = this.ob;
        b instanceof Kf && !b.isSubGraphExpanded ? a.h(d.x - e.left, d.y - e.top, 0, 0) : a.h(d.x - e.left, d.y - e.top, Math.max(d.width + e.left + e.right, 0), Math.max(d.height + e.top + e.bottom, 0));
        L.free(c);
        b instanceof Kf && b.computesBoundsIncludingLocation && b.location.o() && a.Ze(b.location);
        return a
    };
    Mg.prototype.computeMemberBounds = function (a) {
        if (!(this.part instanceof Kf)) return a.h(0, 0, 0, 0), a;
        for (var b = this.part, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = b.memberParts; g.next();) {
            var h = g.value;
            if (h.isVisible()) {
                if (h instanceof S) {
                    if (!b.computesBoundsIncludingLinks) continue;
                    if (Hj(h)) continue;
                    if (h.fromNode === b || h.toNode === b) continue
                }
                h = h.actualBounds;
                h.left < c && (c = h.left);
                h.top < d && (d = h.top);
                h.right > e && (e = h.right);
                h.bottom > f && (f = h.bottom)
            }
        }
        isFinite(c) && isFinite(d) ? a.h(c, d, e - c, f - d) : (b = b.location,
            a.h(b.x, b.y, 0, 0));
        return a
    };
    na.Object.defineProperties(Mg.prototype, {
        padding: {
            configurable: !0, get: function () {
                return this.ob
            }, set: function (a) {
                "number" === typeof a ? a = new jc(a) : w(a, jc, Mg, "padding");
                var b = this.ob;
                b.A(a) || (this.ob = a = a.J(), this.g("padding", b, a), this.v())
            }
        }
    });
    Mg.className = "Placeholder";

    function S() {
        T.call(this, W.Link);
        this.Ka = 8;
        this.gf = null;
        this.hf = "";
        this.Df = this.qo = null;
        this.Ef = "";
        this.vq = null;
        this.hl = pg;
        this.Rn = 0;
        this.Tn = pg;
        this.Un = NaN;
        this.mk = vp;
        this.iq = .5;
        this.rd = null;
        this.Gb = (new H).freeze();
        this.Dg = this.Mc = null;
        this.im = new L;
        this.ua = new Hd;
        this.L = this.w = this.Yf = this.gg = null;
        this.l = [];
        this.Gv = new J;
        this.os = this.$x = this.Zx = null;
        this.$u = NaN;
        this.S = null
    }

    ma(S, T);
    S.prototype.cloneProtected = function (a) {
        T.prototype.cloneProtected.call(this, a);
        a.Ka = this.Ka & -113;
        a.hf = this.hf;
        a.qo = this.qo;
        a.Ef = this.Ef;
        a.vq = this.vq;
        a.hl = this.hl;
        a.Rn = this.Rn;
        a.Tn = this.Tn;
        a.Un = this.Un;
        a.mk = this.mk;
        a.iq = this.iq;
        null !== this.S && (a.S = this.S.copy())
    };
    t = S.prototype;
    t.Kf = function (a) {
        T.prototype.Kf.call(this, a);
        this.hf = a.hf;
        this.Ef = a.Ef;
        a.Mc = null;
        a.Za();
        a.Yf = this.Yf;
        var b = a.fromPort;
        null !== b && hp(b);
        a = a.toPort;
        null !== a && hp(a)
    };
    t.pb = function (a) {
        a.classType === S ? 2 === (a.value & 2) ? this.routing = a : a === sg || a === og || a === ng ? this.curve = a : a === wp || a === xp || a === yp ? this.adjusting = a : a !== vp && a !== pg && v("Unknown Link enum value for a Link property: " + a) : T.prototype.pb.call(this, a)
    };
    t.Qc = function () {
        null === this.S && (this.S = new vl)
    };
    t.Cj = function () {
        var a = this.fromNode;
        if (null !== a) {
            var b = a.findVisibleNode();
            null !== b && (a = b);
            if (Ij(a) || Jj(a)) return !1
        }
        a = this.toNode;
        return null !== a && (b = a.findVisibleNode(), null !== b && (a = b), Ij(a) || Jj(a)) ? !1 : !0
    };
    t.Qw = function () {
        return !1
    };
    t.wu = function () {
    };
    t.Tc = function () {
        return !1
    };
    S.prototype.computeAngle = function (a, b, c) {
        return S.computeAngle(b, c)
    };
    S.computeAngle = function (a, b) {
        switch (a) {
            default:
            case pg:
                a = 0;
                break;
            case mn:
                a = b;
                break;
            case en:
                a = b + 90;
                break;
            case gn:
                a = b - 90;
                break;
            case zp:
                a = b + 180;
                break;
            case nn:
                a = K.er(b);
                90 < a && 270 > a && (a -= 180);
                break;
            case fn:
                a = K.er(b + 90);
                90 < a && 270 > a && (a -= 180);
                break;
            case hn:
                a = K.er(b - 90);
                90 < a && 270 > a && (a -= 180);
                break;
            case jn:
                a = K.er(b);
                if (45 < a && 135 > a || 225 < a && 315 > a) return 0;
                90 < a && 270 > a && (a -= 180)
        }
        return K.er(a)
    };

    function dp(a) {
        var b = a.fromNode, c = a.toNode, d = null;
        null !== b ? d = null !== c ? b.Dy(c) : b.containingGroup : null !== c ? d = c.containingGroup : d = null;
        b = d;
        c = a.xi;
        if (c !== b) {
            null !== c && Zo(c, a);
            a.xi = b;
            null !== b && Yo(b, a);
            var e = a.containingGroupChanged;
            if (null !== e) {
                var f = !0, g = a.diagram;
                null !== g && (f = g.ba, g.ba = !0);
                e(a, c, b);
                null !== g && (g.ba = f)
            }
            !a.nd || a.Zx !== c && a.$x !== c || a.Za()
        }
        if (a.isLabeledLink) for (a = a.labelNodes; a.next();) a.value.containingGroup = d
    }

    t = S.prototype;
    t.Yh = function () {
        var a = this.containingGroup;
        null !== a && this.fromNode !== a && this.toNode !== a && a.computesBoundsIncludingLinks && T.prototype.Yh.call(this)
    };
    t.Tq = function (a) {
        F && w(a, V, S, "getOtherNode:node");
        var b = this.fromNode;
        return a === b ? this.toNode : b
    };
    t.FA = function (a) {
        F && w(a, N, S, "getOtherPort:port");
        var b = this.fromPort;
        return a === b ? this.toPort : b
    };

    function lp(a, b) {
        null === a.rd && (a.rd = new I);
        a.rd.add(b);
        a.v()
    }

    t.Vq = function (a) {
        T.prototype.Vq.call(this, a);
        Ap(this) && this.Yq(this.actualBounds);
        if (!a) {
            a = this.gf;
            var b = null;
            null !== a && (b = this.fromPort, jp(a, this, b));
            var c = this.Df;
            if (null !== c) {
                var d = this.toPort;
                c === a && d === b || jp(c, this, d)
            }
            Bp(this)
        }
    };
    t.Wq = function (a) {
        T.prototype.Wq.call(this, a);
        Ap(this) && this.Yq(this.actualBounds);
        if (!a) {
            a = this.gf;
            var b = null;
            null !== a && (b = this.fromPort, kp(a, this, b));
            var c = this.Df;
            if (null !== c) {
                var d = this.toPort;
                c === a && d === b || kp(c, this, d)
            }
            Cp(this)
        }
    };
    t.Ek = function () {
        this.nd = !0;
        if (null !== this.rd) {
            var a = this.diagram;
            if (null !== a) for (var b = this.rd.copy().iterator; b.next();) a.remove(b.value)
        }
        null !== this.data && (a = this.diagram, null !== a && a.partManager.removeDataForLink(this))
    };
    S.prototype.updateRelationshipsFromData = function () {
        if (null !== this.data) {
            var a = this.diagram;
            null !== a && a.partManager.updateRelationshipsFromData(this)
        }
    };
    S.prototype.move = function (a, b) {
        var c = b ? this.location : this.position, d = c.x;
        isNaN(d) && (d = 0);
        var e = c.y;
        isNaN(e) && (e = 0);
        d = a.x - d;
        e = a.y - e;
        !0 === b ? T.prototype.move.call(this, a, !1) : (a = J.allocAt(c.x + d, c.y + e), T.prototype.move.call(this, a, !1), J.free(a));
        Ff(this, d, e);
        for (a = this.labelNodes; a.next();) b = a.value, c = b.position, b.moveTo(c.x + d, c.y + e)
    };
    S.prototype.canRelinkFrom = function () {
        if (!this.relinkableFrom) return !1;
        var a = this.layer;
        if (null === a) return !0;
        if (!a.allowRelink) return !1;
        a = a.diagram;
        return null === a || a.allowRelink ? !0 : !1
    };
    S.prototype.canRelinkTo = function () {
        if (!this.relinkableTo) return !1;
        var a = this.layer;
        if (null === a) return !0;
        if (!a.allowRelink) return !1;
        a = a.diagram;
        return null === a || a.allowRelink ? !0 : !1
    };
    S.prototype.computeMidPoint = function (a) {
        var b = this.pointsCount;
        if (0 === b) return a.assign(Sb), a;
        if (1 === b) return a.assign(this.i(0)), a;
        if (2 === b) {
            var c = this.i(0), d = this.i(1);
            a.h((c.x + d.x) / 2, (c.y + d.y) / 2);
            return a
        }
        if (this.isOrthogonal && (15 <= this.computeCorner() || this.computeCurve() === sg)) return this.ua.iw(.5, a), a.add(this.i(0)), c = this.ua.figures.first(), a.offset(-c.startX, -c.startY), a;
        if (this.computeCurve() === sg) {
            if (3 === b) return this.i(1);
            d = (b - 1) / 3 | 0;
            c = 3 * (d / 2 | 0);
            if (1 === d % 2) {
                d = this.i(c);
                var e = this.i(c + 1),
                    f = this.i(c + 2);
                c = this.i(c + 3);
                K.Nz(d.x, d.y, e.x, e.y, f.x, f.y, c.x, c.y, a)
            } else a.assign(this.i(c));
            return a
        }
        var g = this.flattenedLengths;
        c = this.flattenedTotalLength;
        for (e = f = d = 0; d < c / 2 && f < b;) {
            e = g[f];
            if (d + e > c / 2) break;
            d += e;
            f++
        }
        b = this.i(f);
        f = this.i(f + 1);
        1 > Math.abs(b.x - f.x) ? b.y > f.y ? a.h(b.x, b.y - (c / 2 - d)) : a.h(b.x, b.y + (c / 2 - d)) : 1 > Math.abs(b.y - f.y) ? b.x > f.x ? a.h(b.x - (c / 2 - d), b.y) : a.h(b.x + (c / 2 - d), b.y) : (c = (c / 2 - d) / e, a.h(b.x + c * (f.x - b.x), b.y + c * (f.y - b.y)));
        return a
    };
    S.prototype.computeMidAngle = function () {
        var a = this.pointsCount;
        if (2 > a) return NaN;
        if (2 === a) return this.i(0).Xa(this.i(1));
        if (this.isOrthogonal && (15 <= this.computeCorner() || this.computeCurve() === sg)) return this.ua.Jy(.5);
        if (this.computeCurve() === sg && 4 <= a) {
            var b = (a - 1) / 3 | 0, c = 3 * (b / 2 | 0);
            if (1 === b % 2) {
                c = Math.floor(c);
                a = this.i(c);
                b = this.i(c + 1);
                var d = this.i(c + 2);
                c = this.i(c + 3);
                return K.Mz(a.x, a.y, b.x, b.y, d.x, d.y, c.x, c.y)
            }
            if (0 < c && c + 1 < a) return this.i(c - 1).Xa(this.i(c + 1))
        }
        b = this.flattenedLengths;
        d = this.flattenedTotalLength;
        var e = 0;
        c = 0;
        for (var f; e < d / 2 && c < a;) {
            f = b[c];
            if (e + f > d / 2) break;
            e += f;
            c++
        }
        b = this.i(c);
        d = this.i(c + 1);
        if (1 > Math.abs(b.x - d.x) && 1 > Math.abs(b.y - d.y)) {
            if (0 < c && c + 2 < a) return this.i(c - 1).Xa(this.i(c + 2))
        } else {
            if (1 > Math.abs(b.x - d.x)) return b.y > d.y ? 270 : 90;
            if (1 > Math.abs(b.y - d.y)) return b.x > d.x ? 180 : 0
        }
        return b.Xa(d)
    };
    t = S.prototype;
    t.i = function (a) {
        return this.Gb.j[a]
    };
    t.Wc = function (a, b) {
        F && (w(b, J, S, "setPoint"), b.o() || v("Link.setPoint called with a Point that does not have real numbers: " + b.toString()));
        F && null === this.Mc && v("Call Link.startRoute before modifying the points of the route.");
        this.Gb.Vc(a, b)
    };
    t.O = function (a, b, c) {
        F && (C(b, S, "setPointAt:x"), C(c, S, "setPointAt:y"));
        F && null === this.Mc && v("Call Link.startRoute before modifying the points of the route.");
        this.Gb.Vc(a, new J(b, c))
    };
    t.OA = function (a, b) {
        F && (w(b, J, S, "insertPoint"), b.o() || v("Link.insertPoint called with a Point that does not have real numbers: " + b.toString()));
        F && null === this.Mc && v("Call Link.startRoute before modifying the points of the route.");
        this.Gb.Bb(a, b)
    };
    t.m = function (a, b, c) {
        F && (C(b, S, "insertPointAt:x"), C(c, S, "insertPointAt:y"));
        F && null === this.Mc && v("Call Link.startRoute before modifying the points of the route.");
        this.Gb.Bb(a, new J(b, c))
    };
    t.fe = function (a) {
        F && (w(a, J, S, "addPoint"), a.o() || v("Link.addPoint called with a Point that does not have real numbers: " + a.toString()));
        F && null === this.Mc && v("Call Link.startRoute before modifying the points of the route.");
        this.Gb.add(a)
    };
    t.Hf = function (a, b) {
        F && (C(a, S, "insertPointAt:x"), C(b, S, "insertPointAt:y"));
        F && null === this.Mc && v("Call Link.startRoute before modifying the points of the route.");
        this.Gb.add(new J(a, b))
    };
    t.Fw = function (a) {
        F && null === this.Mc && v("Call Link.startRoute before modifying the points of the route.");
        this.Gb.jb(a)
    };
    t.zk = function () {
        F && null === this.Mc && v("Call Link.startRoute before modifying the points of the route.");
        this.Gb.clear()
    };

    function Ff(a, b, c) {
        if (0 !== b || 0 !== c) {
            for (var d = a.nd, e = new H, f = a.Gb.iterator; f.next();) {
                var g = f.value;
                e.add((new J(g.x + b, g.y + c)).freeze())
            }
            e.freeze();
            f = a.Gb;
            a.Gb = e;
            g = a.diagram;
            isNaN(b) || isNaN(c) || null !== g && g.animationManager.yc ? a.v() : (a.qg.h(a.qg.x + b, a.qg.y + c), a.ra.h(a.ra.x + b, a.ra.y + c), Ul(a));
            d ? Dp(a) : (a.defaultFromPoint && (a.defaultFromPoint = a.i(0)), a.defaultToPoint && (a.defaultToPoint = a.i(a.pointsCount - 1)));
            null !== g && g.animationManager.yc && (a.Dg = e);
            a.g("points", f, e)
        }
    }

    t.ci = function () {
        null === this.Mc && (this.Mc = this.Gb, this.Gb = this.Gb.copy())
    };
    t.Jf = function () {
        if (null !== this.Mc) {
            for (var a = this.Mc, b = this.Gb, c = Infinity, d = Infinity, e = a.j, f = e.length, g = 0; g < f; g++) {
                var h = e[g];
                c = Math.min(h.x, c);
                d = Math.min(h.y, d)
            }
            h = g = Infinity;
            for (var k = b.j, l = k.length, m = 0; m < l; m++) {
                var n = k[m];
                g = Math.min(n.x, g);
                h = Math.min(n.y, h);
                n.freeze()
            }
            b.freeze();
            if (l === f) for (f = 0; f < l; f++) {
                if (m = e[f], n = k[f], m.x - c !== n.x - g || m.y - d !== n.y - h) {
                    this.jc();
                    break
                }
            } else this.jc();
            this.Mc = null;
            c = this.diagram;
            null !== c && c.animationManager.yc && (this.Dg = b);
            Dp(this);
            this.g("points", a, b)
        }
    };
    t.Kw = function () {
        null !== this.Mc && (this.Gb = this.Mc, this.Mc = null)
    };

    function Dp(a) {
        0 === a.Gb.count ? a.nd = !1 : (a.nd = !0, a.os = null, a.$u = NaN, a.defaultFromPoint = a.i(0), a.defaultToPoint = a.i(a.pointsCount - 1), Ep(a, !1))
    }

    t.Za = function () {
        if (!this.suspendsRouting) {
            var a = this.diagram;
            if (a) {
                if (a.iu.contains(this) || a.undoManager.isUndoingRedoing) return;
                a = a.animationManager;
                if (a.isTicking && !a.isAnimating) return;
                null !== this.Dg && !a.isTicking && a.isAnimating && (this.Dg = null)
            }
            a = this.path;
            null !== a && (this.nd = !1, this.v(), a.v())
        }
    };
    t.Ij = function () {
        if (!this.nd && !this.Nt) {
            var a = !0;
            try {
                this.Nt = !0, this.ci(), a = this.computePoints()
            } catch (b) {
                this.Nt = !1, this.Kw()
            } finally {
                this.Nt = !1, a ? this.Jf() : this.Kw()
            }
        }
    };
    S.prototype.computePoints = function () {
        if (null === this.diagram) return !1;
        var a = this.fromNode, b = null;
        null === a ? (Fp || (Fp = new V, Fp.desiredSize = Tb, Fp.Ya()), this.defaultFromPoint && (Fp.location = this.defaultFromPoint, Fp.Ya(), b = a = Fp)) : b = this.fromPort;
        if (null !== b && !a.isVisible()) {
            var c = a.findVisibleNode();
            null !== c && c !== a ? (a = c, b = c.port) : a = c
        }
        this.Zx = a;
        if (null === a || !a.location.o()) return !1;
        for (; !(null === b || b.actualBounds.o() && b.Sf());) b = b.panel;
        if (null === b) return !1;
        var d = this.toNode, e = null;
        null === d ? (Gp || (Gp = new V,
            Gp.desiredSize = Tb, Gp.Ya()), this.defaultToPoint && (Gp.location = this.defaultToPoint, Gp.Ya(), e = d = Gp)) : e = this.toPort;
        null === e || d.isVisible() || (c = d.findVisibleNode(), null !== c && c !== d ? (d = c, e = c.port) : d = c);
        this.$x = d;
        if (null === d || !d.location.o()) return !1;
        for (; !(null === e || e.actualBounds.o() && e.Sf());) e = e.panel;
        if (null === e) return !1;
        var f = this.pointsCount, g = this.computeSpot(!0, b);
        c = this.computeSpot(!1, e);
        var h = Hp(g), k = Hp(c), l = b === e && null !== b, m = this.isOrthogonal, n = this.curve === sg;
        this.gg = l && !m ? n = !0 : !1;
        var p = this.computeAdjusting() ===
            pg || l;
        if (!m && !l && h && k) {
            if (h = !1, !p && 3 <= f && (p = this.getLinkPoint(a, b, g, !0, !1, d, e), k = this.getLinkPoint(d, e, c, !1, !1, a, b), h = this.adjustPoints(0, p, f - 1, k)) && (p = this.getLinkPoint(a, b, g, !0, !1, d, e), k = this.getLinkPoint(d, e, c, !1, !1, a, b), this.adjustPoints(0, p, f - 1, k)), !h) if (this.zk(), n) {
                f = this.getLinkPoint(a, b, g, !0, !1, d, e);
                p = this.getLinkPoint(d, e, c, !1, !1, a, b);
                h = p.x - f.x;
                k = p.y - f.y;
                l = this.computeCurviness();
                n = m = 0;
                var r = f.x + h / 3, q = f.y + k / 3, u = r, x = q;
                K.C(k, 0) ? x = 0 < h ? x - l : x + l : (m = -h / k, n = Math.sqrt(l * l / (m * m + 1)), 0 > l && (n = -n), u =
                    (0 > k ? -1 : 1) * n + r, x = m * (u - r) + q);
                r = f.x + 2 * h / 3;
                q = f.y + 2 * k / 3;
                var y = r, z = q;
                K.C(k, 0) ? z = 0 < h ? z - l : z + l : (y = (0 > k ? -1 : 1) * n + r, z = m * (y - r) + q);
                this.zk();
                this.fe(f);
                this.Hf(u, x);
                this.Hf(y, z);
                this.fe(p);
                this.Wc(0, this.getLinkPoint(a, b, g, !0, !1, d, e));
                this.Wc(3, this.getLinkPoint(d, e, c, !1, !1, a, b))
            } else if (f = d, p = e, d = this.getLinkPoint(a, b, g, !0, !1, f, p), e = this.getLinkPoint(f, p, c, !1, !1, a, b), this.hasCurviness()) p = e.x - d.x, c = e.y - d.y, g = this.computeCurviness(), a = d.x + p / 2, b = d.y + c / 2, f = a, h = b, K.C(c, 0) ? h = 0 < p ? h - g : h + g : (p = -p / c, f = Math.sqrt(g * g / (p *
                p + 1)), 0 > g && (f = -f), f = (0 > c ? -1 : 1) * f + a, h = p * (f - a) + b), this.fe(d), this.Hf(f, h), this.fe(e); else {
                this.fe(d);
                this.fe(e);
                h = L.alloc();
                b.wj(h);
                k = h.ca(e);
                p.wj(h);
                l = h.ca(d);
                if (k || l) g = b.ja(Ip(g), new J), this.Wc(0, this.getLinkPointFromPoint(a, b, g, e, !0, g)), c = p.ja(Ip(c), new J), this.Wc(1, this.getLinkPointFromPoint(f, p, c, d, !1, c));
                L.free(h)
            }
        } else {
            n = this.isAvoiding;
            p && (m && n || l) && this.zk();
            var B = l ? this.computeCurviness() : 0;
            n = this.getLinkPoint(a, b, g, !0, m, d, e);
            r = u = q = 0;
            if (m || !h || l) x = this.computeEndSegmentLength(a, b, g, !0), r =
                this.getLinkDirection(a, b, n, g, !0, m, d, e), l && (h || g.A(c) || !m && 1 === g.x + c.x && 1 === g.y + c.y) && (r -= m ? 90 : 30, 0 > B && (r -= 180)), 0 > r ? r += 360 : 360 <= r && (r -= 360), l && (x += Math.abs(B) * (m ? 1 : 2)), 0 === r ? q = x : 90 === r ? u = x : 180 === r ? q = -x : 270 === r ? u = -x : (q = x * Math.cos(r * Math.PI / 180), u = x * Math.sin(r * Math.PI / 180)), g.Tb() && l && (x = b.ja(Mc, J.alloc()), y = J.allocAt(x.x + 1E3 * q, x.y + 1E3 * u), this.getLinkPointFromPoint(a, b, x, y, !0, n), J.free(x), J.free(y));
            x = this.getLinkPoint(d, e, c, !1, m, a, b);
            var D = z = y = 0;
            if (m || !k || l) {
                var G = this.computeEndSegmentLength(d, e,
                    c, !1);
                D = this.getLinkDirection(d, e, x, c, !1, m, a, b);
                l && (k || g.A(c) || !m && 1 === g.x + c.x && 1 === g.y + c.y) && (D += m ? 0 : 30, 0 > B && (D += 180));
                0 > D ? D += 360 : 360 <= D && (D -= 360);
                l && (G += Math.abs(B) * (m ? 1 : 2));
                0 === D ? y = G : 90 === D ? z = G : 180 === D ? y = -G : 270 === D ? z = -G : (y = G * Math.cos(D * Math.PI / 180), z = G * Math.sin(D * Math.PI / 180));
                c.Tb() && l && (c = e.ja(Mc, J.alloc()), g = J.allocAt(c.x + 1E3 * y, c.y + 1E3 * z), this.getLinkPointFromPoint(d, e, c, g, !1, x), J.free(c), J.free(g))
            }
            c = n;
            if (m || !h || l) c = new J(n.x + q, n.y + u);
            g = x;
            if (m || !k || l) g = new J(x.x + y, x.y + z);
            !p && !m && h && 3 < f && this.adjustPoints(0,
                n, f - 2, g) ? this.Wc(f - 1, x) : !p && !m && k && 3 < f && this.adjustPoints(1, c, f - 1, x) ? this.Wc(0, n) : !p && (m ? 6 <= f : 4 < f) && this.adjustPoints(1, c, f - 2, g) ? (this.Wc(0, n), this.Wc(f - 1, x)) : (this.zk(), this.fe(n), (m || !h || l) && this.fe(c), m && this.addOrthoPoints(c, r, g, D, a, d), (m || !k || l) && this.fe(g), this.fe(x))
        }
        return !0
    };

    function Jp(a, b) {
        Math.abs(b.x - a.x) > Math.abs(b.y - a.y) ? (b.x >= a.x ? b.x = a.x + 9E9 : b.x = a.x - 9E9, b.y = a.y) : (b.y >= a.y ? b.y = a.y + 9E9 : b.y = a.y - 9E9, b.x = a.x);
        return b
    }

    S.prototype.getLinkPointFromPoint = function (a, b, c, d, e, f) {
        void 0 === f && (f = new J);
        if (null === a || null === b) return f.assign(c), f;
        a.isVisible() || (e = a.findVisibleNode(), null !== e && e !== a && (b = e.port));
        a = null;
        e = b.panel;
        null === e || e.le() || (e = e.panel);
        if (null === e) {
            e = d.x;
            d = d.y;
            var g = c.x;
            c = c.y
        } else {
            a = e.Hd;
            e = 1 / (a.m11 * a.m22 - a.m12 * a.m21);
            g = a.m22 * e;
            var h = -a.m12 * e, k = -a.m21 * e, l = a.m11 * e, m = e * (a.m21 * a.dy - a.m22 * a.dx),
                n = e * (a.m12 * a.dx - a.m11 * a.dy);
            e = d.x * g + d.y * k + m;
            d = d.x * h + d.y * l + n;
            g = c.x * g + c.y * k + m;
            c = c.x * h + c.y * l + n
        }
        b.Ik(e, d, g, c, f);
        null !==
        a && f.transform(a);
        return f
    };

    function Kp(a, b) {
        var c = b.Fp;
        null === c && (c = new Lp, c.port = b, c.node = b.part, b.Fp = c);
        return Mp(c, a)
    }

    S.prototype.getLinkPoint = function (a, b, c, d, e, f, g, h) {
        void 0 === h && (h = new J);
        if (c.cb() && !Hp(c)) return b.ja(c, h), h;
        if (c.Uc()) {
            var k = Kp(this, b);
            if (null !== k) {
                h.assign(k.br);
                if (e && this.routing === Np) {
                    var l = Kp(this, g);
                    if (null !== l && k.Hm < l.Hm) {
                        k = J.alloc();
                        l = J.alloc();
                        var m = new L(b.ja(Fc, k), b.ja(Rc, l)), n = this.computeSpot(!d, g);
                        a = this.getLinkPoint(f, g, n, !d, e, a, b, l);
                        (c.Qf(Tc) || c.Qf(Uc)) && a.y >= m.y && a.y <= m.y + m.height ? h.y = a.y : (c.Qf(Sc) || c.Qf(Vc)) && a.x >= m.x && a.x <= m.x + m.width && (h.x = a.x);
                        J.free(k);
                        J.free(l)
                    }
                }
                return h
            }
        }
        c =
            b.ja(Ip(c), J.alloc());
        this.pointsCount > (e ? 6 : 2) ? (g = d ? this.i(1) : this.i(this.pointsCount - 2), e && (g = Jp(c, g.copy()))) : (k = this.computeSpot(!d, g), f = J.alloc(), g = g.ja(Ip(k), f), e && (g = Jp(c, g)), J.free(f));
        this.getLinkPointFromPoint(a, b, c, g, d, h);
        J.free(c);
        return h
    };
    S.prototype.getLinkDirection = function (a, b, c, d, e, f, g, h) {
        a:if (d.cb()) var k = d.x > d.y ? d.x > 1 - d.y ? 0 : d.x < 1 - d.y ? 270 : 315 : d.x < d.y ? d.x > 1 - d.y ? 90 : d.x < 1 - d.y ? 180 : 135 : .5 > d.x ? 225 : .5 < d.x ? 45 : 0; else {
            if (d.Uc() && (k = Kp(this, b), null !== k)) switch (k.Hc) {
                case 1:
                    k = 270;
                    break a;
                case 2:
                    k = 180;
                    break a;
                default:
                case 4:
                    k = 0;
                    break a;
                case 8:
                    k = 90;
                    break a
            }
            k = b.ja(Mc, J.alloc());
            this.pointsCount > (f ? 6 : 2) ? (h = e ? this.i(1) : this.i(this.pointsCount - 2), h = f ? Jp(k, h.copy()) : c) : (c = J.alloc(), h = h.ja(Mc, c), J.free(c));
            c = Math.abs(h.x - k.x) > Math.abs(h.y - k.y) ? h.x >=
            k.x ? 0 : 180 : h.y >= k.y ? 90 : 270;
            J.free(k);
            k = c
        }
        d.Tb() && g.Ld(a) && (k += 180, 360 <= k && (k -= 360));
        if (Hp(d)) return k;
        a = b.vj();
        if (0 === a) return k;
        45 <= a && 135 > a ? k += 90 : 135 <= a && 225 > a ? k += 180 : 225 <= a && 315 > a && (k += 270);
        360 <= k && (k -= 360);
        return k
    };
    S.prototype.computeEndSegmentLength = function (a, b, c, d) {
        if (null !== b && c.Uc() && (a = Kp(this, b), null !== a)) return a.aw;
        a = d ? this.fromEndSegmentLength : this.toEndSegmentLength;
        null !== b && isNaN(a) && (a = d ? b.fromEndSegmentLength : b.toEndSegmentLength);
        isNaN(a) && (a = 10);
        return a
    };
    S.prototype.computeSpot = function (a, b) {
        void 0 === b && (b = null);
        a ? (a = b ? b : this.fromPort, null === a ? a = Mc : (b = this.fromSpot, b.Jb() && (b = a.fromSpot), a = b === jd ? Ec : b)) : (a = b ? b : this.toPort, null === a ? a = Mc : (b = this.toSpot, b.Jb() && (b = a.toSpot), a = b === jd ? Ec : b));
        return a
    };

    function Hp(a) {
        return a === Ec || .5 === a.x && .5 === a.y
    }

    function Ip(a) {
        return .5 === a.x && .5 === a.y ? a : Mc
    }

    S.prototype.computeOtherPoint = function (a, b) {
        if (this.computeAdjusting() !== pg && 4 < this.pointsCount) return this.computeMidPoint(new J);
        a = b.ja(Mc);
        b = b.Fp;
        b = null !== b ? Mp(b, this) : null;
        null !== b && (a = b.br);
        return a
    };
    S.prototype.computeShortLength = function (a) {
        if (a) {
            a = this.fromShortLength;
            if (isNaN(a)) {
                var b = this.fromPort;
                null !== b && (a = b.fromShortLength)
            }
            return isNaN(a) ? 0 : a
        }
        a = this.toShortLength;
        isNaN(a) && (b = this.toPort, null !== b && (a = b.toShortLength));
        return isNaN(a) ? 0 : a
    };
    S.prototype.Lf = function (a, b, c, d, e, f) {
        if (!1 === this.pickable) return !1;
        void 0 === b && (b = null);
        void 0 === c && (c = null);
        var g = f;
        void 0 === f && (g = Ib.alloc(), g.reset());
        g.multiply(this.transform);
        if (this.Th(a, g)) return yn(this, b, c, e), void 0 === f && Ib.free(g), !0;
        if (this.Sc(a, g)) {
            var h = !1;
            if (!this.isAtomic) for (var k = this.$.j, l = k.length; l--;) {
                var m = k[l];
                if (m.visible || m === this.locationObject) {
                    var n = m.actualBounds, p = this.naturalBounds;
                    if (!(n.x > p.width || n.y > p.height || 0 > n.x + n.width || 0 > n.y + n.height)) {
                        n = Ib.alloc();
                        n.set(g);
                        if (m instanceof W) h = m.Lf(a, b, c, d, e, n); else if (this.path === m) {
                            if (m instanceof Zf) if (h = a, p = d, !1 === m.pickable) h = !1; else if (n.multiply(m.transform), p) b:{
                                var r = h, q = n;
                                if (m.Th(r, q)) h = !0; else {
                                    if (void 0 === q && (q = m.transform, r.Pe(m.actualBounds))) {
                                        h = !0;
                                        break b
                                    }
                                    h = r.left;
                                    p = r.right;
                                    var u = r.top;
                                    r = r.bottom;
                                    var x = J.alloc(), y = J.alloc(), z = J.alloc(), B = Ib.alloc();
                                    B.set(q);
                                    B.uw(m.transform);
                                    B.du();
                                    y.x = p;
                                    y.y = u;
                                    y.transform(B);
                                    x.x = h;
                                    x.y = u;
                                    x.transform(B);
                                    q = !1;
                                    Qn(m, x, y, z) ? q = !0 : (x.x = p, x.y = r, x.transform(B), Qn(m, x, y, z) ? q = !0 : (y.x =
                                        h, y.y = r, y.transform(B), Qn(m, x, y, z) ? q = !0 : (x.x = h, x.y = u, x.transform(B), Qn(m, x, y, z) && (q = !0))));
                                    Ib.free(B);
                                    J.free(x);
                                    J.free(y);
                                    J.free(z);
                                    h = q
                                }
                            } else h = m.Th(h, n)
                        } else h = Bl(m, a, d, n);
                        h && (p = m, null !== b && (p = b(m)), p && (null === c || c(p)) && e.add(p));
                        Ib.free(n)
                    }
                }
            }
            void 0 === f && Ib.free(g);
            return h || null !== this.background || null !== this.areaBackground
        }
        void 0 === f && Ib.free(g);
        return !1
    };
    S.prototype.computeCurve = function () {
        if (null === this.gg) {
            var a = this.fromPort, b = this.isOrthogonal;
            this.gg = null !== a && a === this.toPort && !b
        }
        return this.gg ? sg : this.curve
    };
    S.prototype.computeCorner = function () {
        if (this.curve === sg) return 0;
        var a = this.corner;
        if (isNaN(a) || 0 > a) a = 10;
        return a
    };
    S.prototype.findMidLabel = function () {
        for (var a = this.path, b = this.$.j, c = b.length, d = 0; d < c; d++) {
            var e = b[d];
            if (e !== a && !e.isPanelMain && (-Infinity === e.segmentIndex || isNaN(e.segmentIndex))) return e
        }
        for (a = this.labelNodes; a.next();) if (b = a.value, -Infinity === b.segmentIndex || isNaN(b.segmentIndex)) return b;
        return null
    };
    S.prototype.computeSpacing = function () {
        if (!this.isVisible()) return 0;
        var a = Op;
        a = Math.max(a, this.computeThickness());
        var b = this.fromPort, c = this.toPort;
        if (null !== b && null !== c) {
            var d = this.findMidLabel();
            if (null !== d) {
                var e = d.naturalBounds, f = d.margin, g = isNaN(e.width) ? 30 : e.width * d.scale + f.left + f.right;
                e = isNaN(e.height) ? 14 : e.height * d.scale + f.top + f.bottom;
                d = d.segmentOrientation;
                d === mn || d === nn || d === zp ? a = Math.max(a, e) : d === gn || d === hn || d === en || d === fn ? a = Math.max(a, g) : (b = b.ja(Mc).Xa(c.ja(Mc)) / 180 * Math.PI, a = Math.max(a,
                    Math.abs(Math.sin(b) * g) + Math.abs(Math.cos(b) * e) + 1));
                this.curve === sg && (a *= 1.333)
            }
        }
        return a
    };
    S.prototype.arrangeBundledLinks = function (a, b) {
        if (b) for (b = 0; b < a.length; b++) {
            var c = a[b];
            c.computeAdjusting() === pg && c.Za()
        }
    };
    S.prototype.computeCurviness = function () {
        var a = this.curviness;
        if (isNaN(a)) {
            a = Pp;
            var b = this.Yf;
            if (null !== b) {
                for (var c = Ma(), d = 0, e = b.links, f = 0; f < e.length; f++) {
                    var g = e[f].computeSpacing();
                    c.push(g);
                    d += g
                }
                d = -d / 2;
                for (f = 0; f < e.length; f++) {
                    if (e[f] === this) {
                        a = d + c[f] / 2;
                        break
                    }
                    d += c[f]
                }
                b.lu === this.fromNode && (a = -a);
                Oa(c)
            }
        }
        return a
    };
    S.prototype.computeThickness = function () {
        if (!this.isVisible()) return 0;
        var a = this.path;
        return null !== a ? Math.max(a.strokeWidth, 1) : 1
    };
    S.prototype.hasCurviness = function () {
        return !isNaN(this.curviness) || null !== this.Yf
    };
    S.prototype.adjustPoints = function (a, b, c, d) {
        var e = this.computeAdjusting();
        if (this.isOrthogonal) {
            if (e === xp) return !1;
            e === yp && (e = wp)
        }
        switch (e) {
            case xp:
                var f = this.i(a), g = this.i(c);
                if (!f.Ta(b) || !g.Ta(d)) {
                    e = f.x;
                    f = f.y;
                    var h = g.x - e, k = g.y - f, l = Math.sqrt(h * h + k * k);
                    if (!K.da(l, 0)) {
                        if (K.da(h, 0)) var m = 0 > k ? -Math.PI / 2 : Math.PI / 2; else m = Math.atan(k / Math.abs(h)), 0 > h && (m = Math.PI - m);
                        g = b.x;
                        var n = b.y;
                        h = d.x - g;
                        var p = d.y - n;
                        k = Math.sqrt(h * h + p * p);
                        K.da(h, 0) ? p = 0 > p ? -Math.PI / 2 : Math.PI / 2 : (p = Math.atan(p / Math.abs(h)), 0 > h && (p = Math.PI - p));
                        l = k / l;
                        m = p - m;
                        this.Wc(a, b);
                        for (a += 1; a < c; a++) b = this.i(a), h = b.x - e, k = b.y - f, b = Math.sqrt(h * h + k * k), K.da(b, 0) || (K.da(h, 0) ? k = 0 > k ? -Math.PI / 2 : Math.PI / 2 : (k = Math.atan(k / Math.abs(h)), 0 > h && (k = Math.PI - k)), h = k + m, b *= l, this.O(a, g + b * Math.cos(h), n + b * Math.sin(h)));
                        this.Wc(c, d)
                    }
                }
                return !0;
            case yp:
                f = this.i(a);
                n = this.i(c);
                if (!f.Ta(b) || !n.Ta(d)) {
                    e = f.x;
                    f = f.y;
                    g = n.x;
                    n = n.y;
                    l = (g - e) * (g - e) + (n - f) * (n - f);
                    h = b.x;
                    m = b.y;
                    k = d.x;
                    p = d.y;
                    var r = 1;
                    if (0 !== k - h) {
                        var q = (p - m) / (k - h);
                        r = Math.sqrt(1 + 1 / (q * q))
                    } else q = 9E9;
                    this.Wc(a, b);
                    for (a += 1; a < c; a++) {
                        b = this.i(a);
                        var u = b.x, x = b.y, y = .5;
                        0 !== l && (y = ((e - u) * (e - g) + (f - x) * (f - n)) / l);
                        var z = e + y * (g - e), B = f + y * (n - f);
                        b = Math.sqrt((u - z) * (u - z) + (x - B) * (x - B));
                        x < q * (u - z) + B && (b = -b);
                        0 < q && (b = -b);
                        u = h + y * (k - h);
                        y = m + y * (p - m);
                        0 !== q ? (b = u + b / r, this.O(a, b, y - (b - u) / q)) : this.O(a, u, y + b)
                    }
                    this.Wc(c, d)
                }
                return !0;
            case wp:
                a:{
                    if (this.isOrthogonal && (e = this.i(a), f = this.i(a + 1), g = this.i(a + 2), h = f.x, m = f.y, n = h, l = m, K.C(e.y, f.y) ? K.C(f.x, g.x) ? m = b.y : K.C(f.y, g.y) && (h = b.x) : K.C(e.x, f.x) && (K.C(f.y, g.y) ? h = b.x : K.C(f.x, g.x) && (m = b.y)), this.O(a + 1, h, m), e = this.i(c), f = this.i(c -
                        1), g = this.i(c - 2), h = f.x, m = f.y, k = h, p = m, K.C(e.y, f.y) ? K.C(f.x, g.x) ? m = d.y : K.C(f.y, g.y) && (h = d.x) : K.C(e.x, f.x) && (K.C(f.y, g.y) ? h = d.x : K.C(f.x, g.x) && (m = d.y)), this.O(c - 1, h, m), fk(this))) {
                        this.O(a + 1, n, l);
                        this.O(c - 1, k, p);
                        c = !1;
                        break a
                    }
                    this.Wc(a, b);
                    this.Wc(c, d);
                    c = !0
                }
                return c;
            default:
                return !1
        }
    };
    S.prototype.addOrthoPoints = function (a, b, c, d, e, f) {
        b = -45 <= b && 45 > b ? 0 : 45 <= b && 135 > b ? 90 : 135 <= b && 225 > b ? 180 : 270;
        d = -45 <= d && 45 > d ? 0 : 45 <= d && 135 > d ? 90 : 135 <= d && 225 > d ? 180 : 270;
        var g = e.actualBounds.copy(), h = f.actualBounds.copy();
        if (g.o() && h.o()) {
            g.Pc(Qp, Qp);
            h.Pc(Qp, Qp);
            g.Ze(a);
            h.Ze(c);
            if (0 === b) if (c.x > a.x || 270 === d && c.y < a.y && h.right > a.x || 90 === d && c.y > a.y && h.right > a.x) {
                var k = new J(c.x, a.y);
                var l = new J(c.x, (a.y + c.y) / 2);
                180 === d ? (k.x = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1), l.x = k.x, l.y = c.y) : 270 === d && c.y < a.y || 90 ===
                d && c.y > a.y ? (k.x = a.x < h.left ? this.computeMidOrthoPosition(a.x, a.y, h.left, c.y, !1) : a.x < h.right && (270 === d && a.y < h.top || 90 === d && a.y > h.bottom) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1) : h.right, l.x = k.x, l.y = c.y) : 0 === d && a.x < h.left && a.y > h.top && a.y < h.bottom && (k.x = a.x, k.y = a.y < c.y ? Math.min(c.y, h.top) : Math.max(c.y, h.bottom), l.y = k.y)
            } else {
                k = new J(a.x, c.y);
                l = new J((a.x + c.x) / 2, c.y);
                if (180 === d || 90 === d && c.y < g.top || 270 === d && c.y > g.bottom) 180 === d && (h.ca(a) || g.ca(c)) ? k.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y,
                    !0) : c.y < a.y && (180 === d || 90 === d) ? k.y = this.computeMidOrthoPosition(a.x, g.top, c.x, Math.max(c.y, h.bottom), !0) : c.y > a.y && (180 === d || 270 === d) && (k.y = this.computeMidOrthoPosition(a.x, g.bottom, c.x, Math.min(c.y, h.top), !0)), l.x = c.x, l.y = k.y;
                if (k.y > g.top && k.y < g.bottom) if (c.x >= g.left && c.x <= a.x || a.x <= h.right && a.x >= c.x) {
                    if (90 === d || 270 === d) k = new J(Math.max((a.x + c.x) / 2, a.x), a.y), l = new J(k.x, c.y)
                } else k.y = 270 === d || (0 === d || 180 === d) && c.y < a.y ? Math.min(c.y, 0 === d ? g.top : Math.min(g.top, h.top)) : Math.max(c.y, 0 === d ? g.bottom : Math.max(g.bottom,
                    h.bottom)), l.x = c.x, l.y = k.y
            } else if (180 === b) if (c.x < a.x || 270 === d && c.y < a.y && h.left < a.x || 90 === d && c.y > a.y && h.left < a.x) k = new J(c.x, a.y), l = new J(c.x, (a.y + c.y) / 2), 0 === d ? (k.x = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1), l.x = k.x, l.y = c.y) : 270 === d && c.y < a.y || 90 === d && c.y > a.y ? (k.x = a.x > h.right ? this.computeMidOrthoPosition(a.x, a.y, h.right, c.y, !1) : a.x > h.left && (270 === d && a.y < h.top || 90 === d && a.y > h.bottom) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1) : h.left, l.x = k.x, l.y = c.y) : 180 === d && a.x > h.right && a.y > h.top && a.y <
                h.bottom && (k.x = a.x, k.y = a.y < c.y ? Math.min(c.y, h.top) : Math.max(c.y, h.bottom), l.y = k.y); else {
                k = new J(a.x, c.y);
                l = new J((a.x + c.x) / 2, c.y);
                if (0 === d || 90 === d && c.y < g.top || 270 === d && c.y > g.bottom) 0 === d && (h.ca(a) || g.ca(c)) ? k.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0) : c.y < a.y && (0 === d || 90 === d) ? k.y = this.computeMidOrthoPosition(a.x, g.top, c.x, Math.max(c.y, h.bottom), !0) : c.y > a.y && (0 === d || 270 === d) && (k.y = this.computeMidOrthoPosition(a.x, g.bottom, c.x, Math.min(c.y, h.top), !0)), l.x = c.x, l.y = k.y;
                if (k.y > g.top && k.y < g.bottom) if (c.x <=
                    g.right && c.x >= a.x || a.x >= h.left && a.x <= c.x) {
                    if (90 === d || 270 === d) k = new J(Math.min((a.x + c.x) / 2, a.x), a.y), l = new J(k.x, c.y)
                } else k.y = 270 === d || (0 === d || 180 === d) && c.y < a.y ? Math.min(c.y, 180 === d ? g.top : Math.min(g.top, h.top)) : Math.max(c.y, 180 === d ? g.bottom : Math.max(g.bottom, h.bottom)), l.x = c.x, l.y = k.y
            } else if (90 === b) if (c.y > a.y || 180 === d && c.x < a.x && h.bottom > a.y || 0 === d && c.x > a.x && h.bottom > a.y) k = new J(a.x, c.y), l = new J((a.x + c.x) / 2, c.y), 270 === d ? (k.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0), l.x = c.x, l.y = k.y) : 180 ===
            d && c.x < a.x || 0 === d && c.x > a.x ? (k.y = a.y < h.top ? this.computeMidOrthoPosition(a.x, a.y, c.x, h.top, !0) : a.y < h.bottom && (180 === d && a.x < h.left || 0 === d && a.x > h.right) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0) : h.bottom, l.x = c.x, l.y = k.y) : 90 === d && a.y < h.top && a.x > h.left && a.x < h.right && (k.x = a.x < c.x ? Math.min(c.x, h.left) : Math.max(c.x, h.right), k.y = a.y, l.x = k.x); else {
                k = new J(c.x, a.y);
                l = new J(c.x, (a.y + c.y) / 2);
                if (270 === d || 0 === d && c.x < g.left || 180 === d && c.x > g.right) 270 === d && (h.ca(a) || g.ca(c)) ? k.x = this.computeMidOrthoPosition(a.x,
                    a.y, c.x, c.y, !1) : c.x < a.x && (270 === d || 0 === d) ? k.x = this.computeMidOrthoPosition(g.left, a.y, Math.max(c.x, h.right), c.y, !1) : c.x > a.x && (270 === d || 180 === d) && (k.x = this.computeMidOrthoPosition(g.right, a.y, Math.min(c.x, h.left), c.y, !1)), l.x = k.x, l.y = c.y;
                if (k.x > g.left && k.x < g.right) if (c.y >= g.top && c.y <= a.y || a.y <= h.bottom && a.y >= c.y) {
                    if (0 === d || 180 === d) k = new J(a.x, Math.max((a.y + c.y) / 2, a.y)), l = new J(c.x, k.y)
                } else k.x = 180 === d || (90 === d || 270 === d) && c.x < a.x ? Math.min(c.x, 90 === d ? g.left : Math.min(g.left, h.left)) : Math.max(c.x, 90 ===
                d ? g.right : Math.max(g.right, h.right)), l.x = k.x, l.y = c.y
            } else if (c.y < a.y || 180 === d && c.x < a.x && h.top < a.y || 0 === d && c.x > a.x && h.top < a.y) k = new J(a.x, c.y), l = new J((a.x + c.x) / 2, c.y), 90 === d ? (k.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0), l.x = c.x, l.y = k.y) : 180 === d && c.x < a.x || 0 === d && c.x >= a.x ? (k.y = a.y > h.bottom ? this.computeMidOrthoPosition(a.x, a.y, c.x, h.bottom, !0) : a.y > h.top && (180 === d && a.x < h.left || 0 === d && a.x > h.right) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0) : h.top, l.x = c.x, l.y = k.y) : 270 === d && a.y > h.bottom && a.x >
                h.left && a.x < h.right && (k.x = a.x < c.x ? Math.min(c.x, h.left) : Math.max(c.x, h.right), k.y = a.y, l.x = k.x); else {
                k = new J(c.x, a.y);
                l = new J(c.x, (a.y + c.y) / 2);
                if (90 === d || 0 === d && c.x < g.left || 180 === d && c.x > g.right) 90 === d && (h.ca(a) || g.ca(c)) ? k.x = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1) : c.x < a.x && (90 === d || 0 === d) ? k.x = this.computeMidOrthoPosition(g.left, a.y, Math.max(c.x, h.right), c.y, !1) : c.x > a.x && (90 === d || 180 === d) && (k.x = this.computeMidOrthoPosition(g.right, a.y, Math.min(c.x, h.left), c.y, !1)), l.x = k.x, l.y = c.y;
                if (k.x > g.left &&
                    k.x < g.right) if (c.y <= g.bottom && c.y >= a.y || a.y >= h.top && a.y <= c.y) {
                    if (0 === d || 180 === d) k = new J(a.x, Math.min((a.y + c.y) / 2, a.y)), l = new J(c.x, k.y)
                } else k.x = 180 === d || (90 === d || 270 === d) && c.x < a.x ? Math.min(c.x, 270 === d ? g.left : Math.min(g.left, h.left)) : Math.max(c.x, 270 === d ? g.right : Math.max(g.right, h.right)), l.x = k.x, l.y = c.y
            }
            var m = k, n = l, p = c;
            if (this.isAvoiding) {
                var r = this.diagram;
                if (null === r || !vk(r) || g.ca(p) && !f.Ld(e) || h.ca(a) && !e.Ld(f) || e === f || this.layer.isTemporary) b = !1; else {
                    var q = wk(r, !0, this.containingGroup, null);
                    if (17 !== this.segmentIndex && q.Lk(Math.min(a.x, m.x), Math.min(a.y, m.y), Math.abs(a.x - m.x), Math.abs(a.y - m.y)) && q.Lk(Math.min(m.x, n.x), Math.min(m.y, n.y), Math.abs(m.x - n.x), Math.abs(m.y - n.y)) && q.Lk(Math.min(n.x, p.x), Math.min(n.y, p.y), Math.abs(n.x - p.x), Math.abs(n.y - p.y))) b = !1; else {
                        e = a;
                        f = p;
                        var u = c = null;
                        if (r.isVirtualized) {
                            r = q.bounds.copy();
                            r.Pc(-q.Iq, -q.Hq);
                            var x = J.alloc();
                            Lk(q, a.x, a.y) || (K.Of(r.x, r.y, r.x + r.width, r.y + r.height, a.x, a.y, m.x, m.y, x) ? (c = a = x.copy(), b = x.Xa(m)) : K.Of(r.x, r.y, r.x + r.width, r.y + r.height,
                                m.x, m.y, n.x, n.y, x) ? (c = a = x.copy(), b = x.Xa(n)) : K.Of(r.x, r.y, r.x + r.width, r.y + r.height, n.x, n.y, p.x, p.y, x) && (c = a = x.copy(), b = x.Xa(p)));
                            Lk(q, p.x, p.y) || (K.Of(r.x, r.y, r.x + r.width, r.y + r.height, p.x, p.y, n.x, n.y, x) ? (u = p = x.copy(), d = n.Xa(x)) : K.Of(r.x, r.y, r.x + r.width, r.y + r.height, n.x, n.y, m.x, m.y, x) ? (u = p = x.copy(), d = m.Xa(x)) : K.Of(r.x, r.y, r.x + r.width, r.y + r.height, m.x, m.y, a.x, a.y, x) && (u = p = x.copy(), d = a.Xa(x)));
                            J.free(x)
                        }
                        g = g.copy().Yc(h);
                        g.Pc(q.Iq * q.lz, q.Hq * q.lz);
                        Rp(q, a, b, p, d, g, !0);
                        h = Sp(q, p.x, p.y);
                        !q.abort && h >= Tp && (Kk(q),
                            g.Pc(q.Iq * q.Wy, q.Hq * q.Wy), Rp(q, a, b, p, d, g, !1), h = Sp(q, p.x, p.y));
                        if (!q.abort && h < Tp && Sp(q, p.x, p.y) !== Mk) {
                            Up(this, q, p.x, p.y, d, !0);
                            h = this.i(2);
                            if (4 > this.pointsCount) 0 === b || 180 === b ? (h.x = a.x, h.y = p.y) : (h.x = p.x, h.y = a.y), this.O(2, h.x, h.y), this.m(3, h.x, h.y); else if (g = this.i(3), 0 === b || 180 === b) K.C(h.x, g.x) ? (h = 0 === b ? Math.max(h.x, a.x) : Math.min(h.x, a.x), this.O(2, h, a.y), this.O(3, h, g.y)) : K.C(h.y, g.y) ? (Math.abs(a.y - h.y) <= q.Hq / 2 && (this.O(2, h.x, a.y), this.O(3, g.x, a.y)), this.m(2, h.x, a.y)) : this.O(2, a.x, h.y); else if (90 ===
                                b || 270 === b) K.C(h.y, g.y) ? (h = 90 === b ? Math.max(h.y, a.y) : Math.min(h.y, a.y), this.O(2, a.x, h), this.O(3, g.x, h)) : K.C(h.x, g.x) ? (Math.abs(a.x - h.x) <= q.Iq / 2 && (this.O(2, a.x, h.y), this.O(3, a.x, g.y)), this.m(2, a.x, h.y)) : this.O(2, h.x, a.y);
                            null !== c && (a = this.i(1), g = this.i(2), a.x !== g.x && a.y !== g.y ? 0 === b || 180 === b ? this.m(2, a.x, g.y) : this.m(2, g.x, a.y) : 0 === b || 180 === b ? this.m(2, e.x, c.y) : this.m(2, c.x, e.y));
                            null !== u && (0 === d || 180 === d ? this.Hf(f.x, u.y) : this.Hf(u.x, f.y));
                            b = !0
                        } else b = !1
                    }
                }
            } else b = !1;
            b || (this.fe(k), this.fe(l))
        }
    };
    S.prototype.computeMidOrthoPosition = function (a, b, c, d, e) {
        var f = 0;
        !this.hasCurviness() || this.computeSpot(!0, this.fromPort).Uc() || this.computeSpot(!1, this.toPort).Uc() || (f = this.computeCurviness());
        return e ? (b + d) / 2 + f : (a + c) / 2 + f
    };

    function fk(a) {
        if (null === a.diagram || !a.isAvoiding || !vk(a.diagram)) return !1;
        var b = a.points.j, c = b.length;
        if (4 > c) return !1;
        a = wk(a.diagram, !0, a.containingGroup, null);
        for (var d = 1; d < c - 2; d++) {
            var e = b[d], f = b[d + 1];
            if (!a.Lk(Math.min(e.x, f.x), Math.min(e.y, f.y), Math.abs(e.x - f.x), Math.abs(e.y - f.y))) return !0
        }
        return !1
    }

    function Up(a, b, c, d, e, f) {
        var g = b.Iq, h = b.Hq, k = Sp(b, c, d), l = c, m = d;
        for (0 === e ? l += g : 90 === e ? m += h : 180 === e ? l -= g : m -= h; k > Vp && Sp(b, l, m) === k - 1;) c = l, d = m, 0 === e ? l += g : 90 === e ? m += h : 180 === e ? l -= g : m -= h, --k;
        if (f) {
            if (k > Vp) if (180 === e || 0 === e) c = Math.floor(c / g) * g + g / 2; else if (90 === e || 270 === e) d = Math.floor(d / h) * h + h / 2
        } else c = Math.floor(c / g) * g + g / 2, d = Math.floor(d / h) * h + h / 2;
        k > Vp && (f = e, l = c, m = d, 0 === e ? (f = 90, m += h) : 90 === e ? (f = 180, l -= g) : 180 === e ? (f = 270, m -= h) : 270 === e && (f = 0, l += g), Sp(b, l, m) === k - 1 ? Up(a, b, l, m, f, !1) : (l = c, m = d, 0 === e ? (f = 270, m -= h) : 90 ===
        e ? (f = 0, l += g) : 180 === e ? (f = 90, m += h) : 270 === e && (f = 180, l -= g), Sp(b, l, m) === k - 1 && Up(a, b, l, m, f, !1)));
        a.Hf(c, d)
    }

    S.prototype.jA = function (a) {
        F && w(a, J, S, "findClosestSegment:p");
        var b = a.x;
        a = a.y;
        for (var c = this.i(0), d = this.i(1), e = Kb(b, a, c.x, c.y, d.x, d.y), f = 0, g = 1; g < this.pointsCount - 1; g++) {
            c = this.i(g + 1);
            var h = Kb(b, a, d.x, d.y, c.x, c.y);
            d = c;
            h < e && (f = g, e = h)
        }
        return f
    };
    S.prototype.jc = function () {
        this.ln = !1;
        this.v()
    };
    S.prototype.Nk = function (a) {
        if (!a) {
            if (!1 === this.nd) return;
            a = this.wb();
            if (this.ln && (null === a || null !== a.geometry)) return
        }
        this.ua = this.makeGeometry();
        a = this.path;
        if (null !== a) {
            a.ua = this.ua;
            for (var b = this.$.j, c = b.length, d = 0; d < c; d++) {
                var e = b[d];
                e !== a && e.isPanelMain && e instanceof Zf && (e.ua = this.ua)
            }
        }
    };
    S.prototype.makeGeometry = function () {
        var a = this.ua, b = this.pointsCount;
        if (2 > b) return a.type = Kd, this.ln = !0, a;
        var c = !1, d = this.diagram;
        null !== d && Ap(this) && d.ih.contains(this) && (0 !== this.im.width || 0 !== this.im.height) && (c = !0);
        var e = this.i(0).copy(), f = e.copy();
        d = this.Gb.j;
        var g = this.computeCurve();
        if (g === sg && 3 <= b && !K.da(this.smoothness, 0)) if (3 === b) {
            var h = this.i(1);
            d = Math.min(e.x, h.x);
            var k = Math.min(e.y, h.y);
            h = this.i(2);
            d = Math.min(d, h.x);
            k = Math.min(k, h.y)
        } else {
            if (this.isOrthogonal) for (k = 0; k < b; k++) h = d[k], f.x =
                Math.min(h.x, f.x), f.y = Math.min(h.y, f.y); else for (d = 3; d < b; d += 3) d + 3 >= b && (d = b - 1), k = this.i(d), f.x = Math.min(k.x, f.x), f.y = Math.min(k.y, f.y);
            d = f.x;
            k = f.y
        } else {
            for (k = 0; k < b; k++) h = d[k], f.x = Math.min(h.x, f.x), f.y = Math.min(h.y, f.y);
            d = f.x;
            k = f.y
        }
        d -= this.Gv.x;
        k -= this.Gv.y;
        e.x -= d;
        e.y -= k;
        if (2 !== b || Ap(this)) {
            a.type = Id;
            h = Vd(a);
            0 !== this.computeShortLength(!0) && (e = Wp(this, e, !0, f));
            Wd(h, e.x, e.y, !1);
            if (g === sg && 3 <= b && !K.da(this.smoothness, 0)) if (3 === b) c = this.i(1), b = c.x - d, c = c.y - k, e = this.i(2).copy(), e.x -= d, e.y -= k, 0 !== this.computeShortLength(!1) &&
            (e = Wp(this, e, !1, f)), Xd(h, b, c, b, c, e.x, e.y); else if (this.isOrthogonal) {
                f = new J(d, k);
                e = this.i(1).copy();
                g = new J(d, k);
                b = new J(d, k);
                c = this.i(0);
                for (var l, m = this.smoothness / 3, n = 1; n < this.pointsCount - 1; n++) {
                    l = this.i(n);
                    var p = c, r = l, q = this.i(Xp(this, l, n, !1));
                    if (!K.da(p.x, r.x) || !K.da(r.x, q.x)) if (!K.da(p.y, r.y) || !K.da(r.y, q.y)) {
                        var u = m;
                        isNaN(u) && (u = this.smoothness / 3);
                        var x = p.x;
                        p = p.y;
                        var y = r.x;
                        r = r.y;
                        var z = q.x;
                        q = q.y;
                        var B = u * Yp(x, p, y, r);
                        u *= Yp(y, r, z, q);
                        K.da(p, r) && K.da(y, z) && (y > x ? q > r ? (g.x = y - B, g.y = r - B, b.x = y + u, b.y =
                            r + u) : (g.x = y - B, g.y = r + B, b.x = y + u, b.y = r - u) : q > r ? (g.x = y + B, g.y = r - B, b.x = y - u, b.y = r + u) : (g.x = y + B, g.y = r + B, b.x = y - u, b.y = r - u));
                        K.da(x, y) && K.da(r, q) && (r > p ? (z > y ? (g.x = y - B, g.y = r - B, b.x = y + u) : (g.x = y + B, g.y = r - B, b.x = y - u), b.y = r + u) : (z > y ? (g.x = y - B, g.y = r + B, b.x = y + u) : (g.x = y + B, g.y = r + B, b.x = y - u), b.y = r - u));
                        if (K.da(x, y) && K.da(y, z) || K.da(p, r) && K.da(r, q)) x = .5 * (x + z), p = .5 * (p + q), g.x = x, g.y = p, b.x = x, b.y = p;
                        1 === n ? (e.x = .5 * (c.x + l.x), e.y = .5 * (c.y + l.y)) : 2 === n && K.da(c.x, this.i(0).x) && K.da(c.y, this.i(0).y) && (e.x = .5 * (c.x + l.x), e.y = .5 * (c.y + l.y));
                        Xd(h, e.x -
                            d, e.y - k, g.x - d, g.y - k, l.x - d, l.y - k);
                        f.set(g);
                        e.set(b);
                        c = l
                    }
                }
                f = c.x;
                c = c.y;
                e = this.i(this.pointsCount - 1);
                0 !== this.computeShortLength(!1) && (e = Wp(this, e.copy(), !1, Ob));
                f = .5 * (f + e.x);
                c = .5 * (c + e.y);
                Xd(h, b.x - d, b.y - k, f - d, c - k, e.x - d, e.y - k)
            } else for (c = 3; c < b; c += 3) f = this.i(c - 2), c + 3 >= b && (c = b - 1), e = this.i(c - 1), g = this.i(c), c === b - 1 && 0 !== this.computeShortLength(!1) && (g = Wp(this, g.copy(), !1, Ob)), Xd(h, f.x - d, f.y - k, e.x - d, e.y - k, g.x - d, g.y - k); else {
                f = J.alloc();
                f.assign(this.i(0));
                e = J.alloc();
                e.assign(f);
                g = this.computeCorner();
                n = 1;
                for (l =
                         0; n < b;) {
                    n = Xp(this, f, n, 1 < n);
                    m = this.i(n);
                    if (n >= b - 1) {
                        if (!f.A(m)) 0 !== this.computeShortLength(!1) && (m = Wp(this, m.copy(), !1, Ob)), Zp(this, h, -d, -k, f, m, c); else if (0 === l) for (n = 1; n < b;) e.assign(f), m = this.i(n++), Zp(this, h, -d, -k, f, m, c), f.assign(m);
                        break
                    }
                    l = Xp(this, m, n + 1, n < b - 3);
                    n = -d;
                    x = -k;
                    p = m;
                    u = this.i(l);
                    y = c;
                    if (K.C(f.y, p.y) && K.C(p.x, u.x)) if (r = Math.min(g, Math.abs(p.x - e.x) / 2), r = z = Math.min(r, Math.abs(u.y - p.y) / 2), K.C(r, 0)) Zp(this, h, n, x, f, p, y), f.assign(p); else {
                        q = p.x;
                        B = p.y;
                        var D = q, G = B;
                        p.x > f.x ? q = p.x - r : q = p.x + r;
                        u.y > p.y ? G = p.y +
                            z : G = p.y - z;
                        Zp(this, h, n, x, f, new J(q, B), y);
                        Yd(h, p.x + n, p.y + x, D + n, G + x);
                        f.h(D, G)
                    } else K.C(f.x, p.x) && K.C(p.y, u.y) ? (r = Math.min(g, Math.abs(p.y - e.y) / 2), r = z = Math.min(r, Math.abs(u.x - p.x) / 2), K.C(z, 0) ? (Zp(this, h, n, x, f, p, y), f.assign(p)) : (q = p.x, B = p.y, D = q, G = B, p.y > f.y ? B = p.y - r : B = p.y + r, u.x > p.x ? D = p.x + z : D = p.x - z, Zp(this, h, n, x, f, new J(q, B), y), Yd(h, p.x + n, p.y + x, D + n, G + x), f.h(D, G))) : (Zp(this, h, n, x, f, p, y), f.assign(p));
                    e.assign(m);
                    n = l
                }
                J.free(f)
            }
            je = h
        } else h = this.i(1).copy(), h.x -= d, h.y -= k, 0 !== this.computeShortLength(!0) && (e = Wp(this,
            e, !0, f)), 0 !== this.computeShortLength(!1) && (h = Wp(this, h, !1, f)), a.type = Kd, a.startX = e.x, a.startY = e.y, a.endX = h.x, a.endY = h.y;
        this.ln = !0;
        return a
    };

    function Yp(a, b, c, d) {
        a = c - a;
        if (isNaN(a) || Infinity === a || -Infinity === a) return NaN;
        0 > a && (a = -a);
        b = d - b;
        if (isNaN(b) || Infinity === b || -Infinity === b) return NaN;
        0 > b && (b = -b);
        return K.da(a, 0) ? b : K.da(b, 0) ? a : Math.sqrt(a * a + b * b)
    }

    function Wp(a, b, c, d) {
        var e = a.pointsCount;
        if (2 > e) return b;
        if (c) {
            var f = a.i(1);
            c = f.x - d.x;
            f = f.y - d.y;
            d = Yp(b.x, b.y, c, f);
            if (0 === d) return b;
            e = 2 === e ? .5 * d : d;
            a = a.computeShortLength(!0);
            a > e && (a = e);
            e = a * (f - b.y) / d;
            b.x += a * (c - b.x) / d;
            b.y += e
        } else {
            f = a.i(e - 2);
            c = f.x - d.x;
            f = f.y - d.y;
            d = Yp(b.x, b.y, c, f);
            if (0 === d) return b;
            e = 2 === e ? .5 * d : d;
            a = a.computeShortLength(!1);
            a > e && (a = e);
            e = a * (b.y - f) / d;
            b.x -= a * (b.x - c) / d;
            b.y -= e
        }
        return b
    }

    function Xp(a, b, c, d) {
        for (var e = a.pointsCount, f = b; K.da(b.x, f.x) && K.da(b.y, f.y);) {
            if (c >= e) return e - 1;
            f = a.i(c++)
        }
        if (!K.da(b.x, f.x) && !K.da(b.y, f.y)) return c - 1;
        for (var g = f; K.da(b.x, f.x) && K.da(f.x, g.x) && (!d || (b.y >= f.y ? f.y >= g.y : f.y <= g.y)) || K.da(b.y, f.y) && K.da(f.y, g.y) && (!d || (b.x >= f.x ? f.x >= g.x : f.x <= g.x));) {
            if (c >= e) return e - 1;
            g = a.i(c++)
        }
        return c - 2
    }

    function Zp(a, b, c, d, e, f, g) {
        if (!g && Ap(a)) {
            g = [];
            var h = 0;
            a.isVisible() && (h = $p(a, e, f, g));
            if (0 < h) if (K.C(e.y, f.y)) if (e.x < f.x) for (var k = 0; k < h;) {
                var l = Math.max(e.x, Math.min(g[k++] - 5, f.x - 10));
                b.lineTo(l + c, f.y + d);
                var m = l + c;
                for (var n = Math.min(l + 10, f.x); k < h;) if (l = g[k], l < n + 10) k++, n = Math.min(l + 5, f.x); else break;
                l = f.y - 10 + d;
                n += c;
                var p = f.y + d;
                a.curve === og ? Wd(b, n, p, !1) : Xd(b, m, l, n, l, n, p)
            } else for (--h; 0 <= h;) {
                k = Math.min(e.x, Math.max(g[h--] + 5, f.x + 10));
                b.lineTo(k + c, f.y + d);
                m = k + c;
                for (l = Math.max(k - 10, f.x); 0 <= h;) if (k = g[h], k >
                l - 10) h--, l = Math.max(k - 5, f.x); else break;
                k = f.y - 10 + d;
                l += c;
                n = f.y + d;
                a.curve === og ? Wd(b, l, n, !1) : Xd(b, m, k, l, k, l, n)
            } else if (K.C(e.x, f.x)) if (e.y < f.y) for (k = 0; k < h;) {
                l = Math.max(e.y, Math.min(g[k++] - 5, f.y - 10));
                b.lineTo(f.x + c, l + d);
                m = l + d;
                for (l = Math.min(l + 10, f.y); k < h;) if (n = g[k], n < l + 10) k++, l = Math.min(n + 5, f.y); else break;
                n = f.x - 10 + c;
                p = f.x + c;
                l += d;
                a.curve === og ? Wd(b, p, l, !1) : Xd(b, n, m, n, l, p, l)
            } else for (--h; 0 <= h;) {
                k = Math.min(e.y, Math.max(g[h--] + 5, f.y + 10));
                b.lineTo(f.x + c, k + d);
                m = k + d;
                for (k = Math.max(k - 10, f.y); 0 <= h;) if (l = g[h],
                l > k - 10) h--, k = Math.max(l - 5, f.y); else break;
                l = f.x - 10 + c;
                n = f.x + c;
                k += d;
                a.curve === og ? Wd(b, n, k, !1) : Xd(b, l, m, l, k, n, k)
            }
        }
        b.lineTo(f.x + c, f.y + d)
    }

    function $p(a, b, c, d) {
        var e = a.diagram;
        if (null === e || b.A(c)) return 0;
        for (e = e.layers; e.next();) {
            var f = e.value;
            if (null !== f && f.visible) {
                f = f.Ia.j;
                for (var g = f.length, h = 0; h < g; h++) {
                    var k = f[h];
                    if (k instanceof S) {
                        if (k === a) return 0 < d.length && d.sort(function (a, b) {
                            return a - b
                        }), d.length;
                        if (k.isVisible() && Ap(k)) {
                            var l = k.routeBounds;
                            l.o() && a.routeBounds.Sc(l) && !a.usesSamePort(k) && (l = k.path, null !== l && l.Sf() && aq(b, c, d, k))
                        }
                    }
                }
            }
        }
        0 < d.length && d.sort(function (a, b) {
            return a - b
        });
        return d.length
    }

    function aq(a, b, c, d) {
        for (var e = K.C(a.y, b.y), f = d.pointsCount, g = d.i(0), h = J.alloc(), k = 1; k < f; k++) {
            var l = d.i(k);
            if (k < f - 1) {
                var m = d.i(k + 1);
                if (g.y === l.y && l.y === m.y) {
                    if (l.x > g.x && m.x >= l.x || l.x < g.x && m.x <= l.x) continue
                } else if (g.x === l.x && l.x === m.x && (l.y > g.y && m.y >= l.y || l.y < g.y && m.y <= l.y)) continue
            }
            a:{
                m = a.x;
                var n = a.y, p = b.x, r = b.y, q = g.x;
                g = g.y;
                var u = l.x, x = l.y;
                if (!K.C(m, p)) {
                    if (K.C(n, r) && K.C(q, u) && Math.min(m, p) < q && Math.max(m, p) > q && Math.min(g, x) < n && Math.max(g, x) > n && !K.C(g, x)) {
                        h.x = q;
                        h.y = n;
                        m = !0;
                        break a
                    }
                } else if (!K.C(n, r) &&
                    K.C(g, x) && Math.min(n, r) < g && Math.max(n, r) > g && Math.min(q, u) < m && Math.max(q, u) > m && !K.C(q, u)) {
                    h.x = m;
                    h.y = g;
                    m = !0;
                    break a
                }
                h.x = 0;
                h.y = 0;
                m = !1
            }
            m && (e ? c.push(h.x) : c.push(h.y));
            g = l
        }
        J.free(h)
    }

    function Ap(a) {
        a = a.curve;
        return a === ng || a === og
    }

    function Ep(a, b) {
        if (b || Ap(a)) b = a.diagram, null === b || b.animationManager.isTicking || b.ih.contains(a) || 0 === a.im.width && 0 === a.im.height || b.ih.add(a, a.im.copy())
    }

    S.prototype.Yq = function (a) {
        var b = this.layer;
        if (null !== b && b.visible && !b.isTemporary) {
            var c = b.diagram;
            if (null !== c && !c.animationManager.isTicking) {
                var d = !1;
                for (c = c.layers; c.next();) {
                    var e = c.value;
                    if (e.visible) if (e === b) {
                        d = !0;
                        var f = !1;
                        e = e.Ia.j;
                        for (var g = e.length, h = 0; h < g; h++) {
                            var k = e[h];
                            k instanceof S && (k === this ? f = !0 : f && bq(this, k, a))
                        }
                    } else if (d) for (f = e.Ia.j, e = f.length, g = 0; g < e; g++) h = f[g], h instanceof S && bq(this, h, a)
                }
            }
        }
    };

    function bq(a, b, c) {
        if (null !== b && b.ln && b.nd && Ap(b)) {
            var d = b.routeBounds;
            d.o() && (a.routeBounds.Sc(d) || c.Sc(d)) && (a.usesSamePort(b) || b.jc())
        }
    }

    S.prototype.usesSamePort = function (a) {
        var b = this.pointsCount, c = a.pointsCount;
        if (0 < b && 0 < c) {
            var d = this.i(0), e = a.i(0);
            if (d.Ta(e)) return !0;
            b = this.i(b - 1);
            a = a.i(c - 1);
            if (b.Ta(a) || d.Ta(a) || b.Ta(e)) return !0
        } else if (this.fromNode === a.fromNode || this.toNode === a.toNode || this.fromNode === a.toNode || this.toNode === a.fromNode) return !0;
        return !1
    };
    S.prototype.isVisible = function () {
        if (!T.prototype.isVisible.call(this)) return !1;
        var a = this.containingGroup, b = !0, c = this.diagram;
        null !== c && (b = c.isTreePathToChildren);
        c = this.fromNode;
        if (null !== c) {
            if (this.isTreeLink && b && !c.isTreeExpanded) return !1;
            if (c === a) return !0;
            for (var d = c; null !== d;) {
                if (d.labeledLink === this) return !0;
                d = d.containingGroup
            }
            c = c.findVisibleNode();
            if (null === c || c === a) return !1
        }
        c = this.toNode;
        if (null !== c) {
            if (this.isTreeLink && !b && !c.isTreeExpanded) return !1;
            if (c === a) return !0;
            for (b = c; null !== b;) {
                if (b.labeledLink ===
                    this) return !0;
                b = b.containingGroup
            }
            b = c.findVisibleNode();
            if (null === b || b === a) return !1
        }
        return !0
    };
    S.prototype.Vb = function (a) {
        T.prototype.Vb.call(this, a);
        null !== this.Yf && this.Yf.Om();
        if (null !== this.rd) for (var b = this.rd.iterator; b.next();) b.value.Vb(a)
    };
    S.prototype.computeAdjusting = function () {
        return this.isAvoiding && null !== this.diagram && this.diagram.animationManager.isAnimating ? wp : this.hl
    };

    function Bp(a) {
        var b = a.gf;
        if (null !== b) {
            var c = a.Df;
            if (null !== c && isNaN(a.curviness)) {
                for (var d = a.hf, e = a.Ef, f = a = null, g = b.gb.j, h = g.length, k = 0; k < h; k++) {
                    var l = g[k];
                    if (l.gf === b && l.hf === d && l.Df === c && l.Ef === e || l.gf === c && l.hf === e && l.Df === b && l.Ef === d) null === f ? f = l : (null === a && (a = [], a.push(f)), a.push(l))
                }
                if (null !== a) {
                    f = gp(b, c, d, e);
                    null === f && (f = new cq(b, d, c, e), fp(b, f), fp(c, f));
                    f.links = a;
                    for (b = 0; b < a.length; b++) a[b].Yf = f;
                    f.Om()
                }
            }
        }
    }

    function Cp(a) {
        var b = a.Yf;
        null !== b && isNaN(a.curviness) && (a.Yf = null, a = b.links.indexOf(a), 0 <= a && (La(b.links, a), b.Om()))
    }

    S.prototype.Zh = function () {
        return !0
    };
    na.Object.defineProperties(S.prototype, {
        fromNode: {
            configurable: !0, get: function () {
                return this.gf
            }, set: function (a) {
                var b = this.gf;
                if (b !== a) {
                    F && null !== a && w(a, V, S, "fromNode");
                    var c = this.fromPort;
                    null !== b && (this.Df !== b && kp(b, this, c), Cp(this), this.D(2));
                    this.gf = a;
                    null !== a && this.Vb(a.isVisible());
                    this.gg = null;
                    this.Za();
                    var d = this.diagram;
                    null !== d && d.ba && d.partManager.setFromNodeForLink(this, a, b);
                    var e = this.fromPort, f = this.fromPortChanged;
                    if (null !== f) {
                        var g = !0;
                        null !== d && (g = d.ba, d.ba = !0);
                        f(this,
                            c, e);
                        null !== d && (d.ba = g)
                    }
                    null !== a && (this.Df !== a && jp(a, this, e), Bp(this), this.D(1));
                    this.g("fromNode", b, a);
                    dp(this)
                }
            }
        }, fromPortId: {
            configurable: !0, get: function () {
                return this.hf
            }, set: function (a) {
                var b = this.hf;
                if (b !== a) {
                    F && A(a, "string", S, "fromPortId");
                    var c = this.fromPort;
                    null !== c && hp(c);
                    Cp(this);
                    this.hf = a;
                    var d = this.fromPort;
                    null !== d && hp(d);
                    var e = this.diagram;
                    if (null !== e) {
                        var f = this.data, g = e.model;
                        null !== f && g.Bj() && g.Ow(f, a)
                    }
                    c !== d && (this.gg = null, this.Za(), f = this.fromPortChanged, null !== f &&
                    (g = !0, null !== e && (g = e.ba, e.ba = !0), f(this, c, d), null !== e && (e.ba = g)));
                    Bp(this);
                    this.g("fromPortId", b, a)
                }
            }
        }, fromPort: {
            configurable: !0, get: function () {
                var a = this.gf;
                return null === a ? null : a.Vt(this.hf)
            }
        }, fromPortChanged: {
            configurable: !0, get: function () {
                return this.qo
            }, set: function (a) {
                var b = this.qo;
                b !== a && (null !== a && A(a, "function", S, "fromPortChanged"), this.qo = a, this.g("fromPortChanged", b, a))
            }
        }, toNode: {
            configurable: !0, get: function () {
                return this.Df
            }, set: function (a) {
                var b =
                    this.Df;
                if (b !== a) {
                    F && null !== a && w(a, V, S, "toNode");
                    var c = this.toPort;
                    null !== b && (this.gf !== b && kp(b, this, c), Cp(this), this.D(2));
                    this.Df = a;
                    null !== a && this.Vb(a.isVisible());
                    this.gg = null;
                    this.Za();
                    var d = this.diagram;
                    null !== d && d.ba && d.partManager.setToNodeForLink(this, a, b);
                    var e = this.toPort, f = this.toPortChanged;
                    if (null !== f) {
                        var g = !0;
                        null !== d && (g = d.ba, d.ba = !0);
                        f(this, c, e);
                        null !== d && (d.ba = g)
                    }
                    null !== a && (this.gf !== a && jp(a, this, e), Bp(this), this.D(1));
                    this.g("toNode", b, a);
                    dp(this)
                }
            }
        }, toPortId: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Ef
            }, set: function (a) {
                var b = this.Ef;
                if (b !== a) {
                    F && A(a, "string", S, "toPortId");
                    var c = this.toPort;
                    null !== c && hp(c);
                    Cp(this);
                    this.Ef = a;
                    var d = this.toPort;
                    null !== d && hp(d);
                    var e = this.diagram;
                    if (null !== e) {
                        var f = this.data, g = e.model;
                        null !== f && g.Bj() && g.Tw(f, a)
                    }
                    c !== d && (this.gg = null, this.Za(), f = this.toPortChanged, null !== f && (g = !0, null !== e && (g = e.ba, e.ba = !0), f(this, c, d), null !== e && (e.ba = g)));
                    Bp(this);
                    this.g("toPortId", b, a)
                }
            }
        }, toPort: {
            configurable: !0, get: function () {
                var a =
                    this.Df;
                return null === a ? null : a.Vt(this.Ef)
            }
        }, toPortChanged: {
            configurable: !0, get: function () {
                return this.vq
            }, set: function (a) {
                var b = this.vq;
                b !== a && (null !== a && A(a, "function", S, "toPortChanged"), this.vq = a, this.g("toPortChanged", b, a))
            }
        }, fromSpot: {
            configurable: !0, get: function () {
                return null !== this.S ? this.S.oh : jd
            }, set: function (a) {
                this.Qc();
                var b = this.S.oh;
                b.A(a) || (F && w(a, M, S, "fromSpot"), a = a.J(), this.S.oh = a, this.g("fromSpot", b, a), (b.Uc() || a.Uc()) && null !== this.fromNode && hp(this.fromPort),
                    this.Za())
            }
        }, fromEndSegmentLength: {
            configurable: !0, get: function () {
                return null !== this.S ? this.S.mh : NaN
            }, set: function (a) {
                this.Qc();
                var b = this.S.mh;
                b !== a && (F && A(a, "number", S, "fromEndSegmentLength"), 0 > a && za(a, ">= 0", S, "fromEndSegmentLength"), this.S.mh = a, this.g("fromEndSegmentLength", b, a), this.Za())
            }
        }, fromShortLength: {
            configurable: !0, get: function () {
                return null !== this.S ? this.S.nh : NaN
            }, set: function (a) {
                this.Qc();
                var b = this.S.nh;
                b !== a && (F && A(a, "number", S, "fromShortLength"), this.S.nh =
                    a, this.jc(), this.g("fromShortLength", b, a))
            }
        }, toSpot: {
            configurable: !0, get: function () {
                return null !== this.S ? this.S.Mh : jd
            }, set: function (a) {
                this.Qc();
                var b = this.S.Mh;
                b.A(a) || (F && w(a, M, S, "toSpot"), a = a.J(), this.S.Mh = a, this.g("toSpot", b, a), (b.Uc() || a.Uc()) && null !== this.toNode && hp(this.toPort), this.Za())
            }
        }, toEndSegmentLength: {
            configurable: !0, get: function () {
                return null !== this.S ? this.S.Kh : NaN
            }, set: function (a) {
                this.Qc();
                var b = this.S.Kh;
                b !== a && (F && A(a, "number", S, "toEndSegmentLength"),
                0 > a && za(a, ">= 0", S, "toEndSegmentLength"), this.S.Kh = a, this.g("toEndSegmentLength", b, a), this.Za())
            }
        }, toShortLength: {
            configurable: !0, get: function () {
                return null !== this.S ? this.S.Lh : NaN
            }, set: function (a) {
                this.Qc();
                var b = this.S.Lh;
                b !== a && (F && A(a, "number", S, "toShortLength"), this.S.Lh = a, this.jc(), this.g("toShortLength", b, a))
            }
        }, isLabeledLink: {
            configurable: !0, get: function () {
                return null === this.rd ? !1 : 0 < this.rd.count
            }
        }, labelNodes: {
            configurable: !0, get: function () {
                return null ===
                this.rd ? mb : this.rd.iterator
            }
        }, relinkableFrom: {
            configurable: !0, get: function () {
                return 0 !== (this.Ka & 1)
            }, set: function (a) {
                var b = 0 !== (this.Ka & 1);
                b !== a && (F && A(a, "boolean", S, "relinkableFrom"), this.Ka ^= 1, this.g("relinkableFrom", b, a), this.Sb())
            }
        }, relinkableTo: {
            configurable: !0, get: function () {
                return 0 !== (this.Ka & 2)
            }, set: function (a) {
                var b = 0 !== (this.Ka & 2);
                b !== a && (F && A(a, "boolean", S, "relinkableTo"), this.Ka ^= 2, this.g("relinkableTo", b, a), this.Sb())
            }
        }, resegmentable: {
            configurable: !0,
            get: function () {
                return 0 !== (this.Ka & 4)
            }, set: function (a) {
                var b = 0 !== (this.Ka & 4);
                b !== a && (F && A(a, "boolean", S, "resegmentable"), this.Ka ^= 4, this.g("resegmentable", b, a), this.Sb())
            }
        }, isTreeLink: {
            configurable: !0, get: function () {
                return 0 !== (this.Ka & 8)
            }, set: function (a) {
                var b = 0 !== (this.Ka & 8);
                b !== a && (F && A(a, "boolean", S, "isTreeLink"), this.Ka ^= 8, this.g("isTreeLink", b, a), null !== this.fromNode && Uk(this.fromNode), null !== this.toNode && Uk(this.toNode))
            }
        }, path: {
            configurable: !0, get: function () {
                var a =
                    this.wb();
                return a instanceof Zf ? a : null
            }
        }, routeBounds: {
            configurable: !0, get: function () {
                this.Ij();
                var a = this.im, b = Infinity, c = Infinity, d = this.pointsCount;
                if (0 === d) a.h(NaN, NaN, 0, 0); else {
                    if (1 === d) d = this.i(0), b = Math.min(d.x, b), c = Math.min(d.y, c), a.h(d.x, d.y, 0, 0); else if (2 === d) {
                        d = this.i(0);
                        var e = this.i(1);
                        b = Math.min(d.x, e.x);
                        c = Math.min(d.y, e.y);
                        a.h(d.x, d.y, 0, 0);
                        a.Ze(e)
                    } else if (this.computeCurve() === sg && 3 <= d && !this.isOrthogonal) if (e = this.i(0), b = e.x, c = e.y, a.h(b, c, 0, 0), 3 === d) {
                        d = this.i(1);
                        b = Math.min(d.x,
                            b);
                        c = Math.min(d.y, c);
                        var f = this.i(2);
                        b = Math.min(f.x, b);
                        c = Math.min(f.y, c);
                        K.Fm(e.x, e.y, d.x, d.y, d.x, d.y, f.x, f.y, .5, a)
                    } else for (f = 3; f < d; f += 3) {
                        var g = this.i(f - 2);
                        f + 3 >= d && (f = d - 1);
                        var h = this.i(f - 1), k = this.i(f);
                        K.Fm(e.x, e.y, g.x, g.y, h.x, h.y, k.x, k.y, .5, a);
                        b = Math.min(k.x, b);
                        c = Math.min(k.y, c);
                        e = k
                    } else for (e = this.i(0), f = this.i(1), b = Math.min(e.x, f.x), c = Math.min(e.y, f.y), a.h(e.x, e.y, 0, 0), a.Ze(f), e = 2; e < d; e++) f = this.i(e), b = Math.min(f.x, b), c = Math.min(f.y, c), a.Ze(f);
                    this.Gv.h(b - a.x, c - a.y)
                }
                return a
            }
        }, midPoint: {
            configurable: !0,
            enumerable: !0, get: function () {
                this.Ij();
                return this.computeMidPoint(new J)
            }
        }, midAngle: {
            configurable: !0, get: function () {
                this.Ij();
                return this.computeMidAngle()
            }
        }, flattenedLengths: {
            configurable: !0, get: function () {
                if (null === this.os) {
                    this.nd || Dp(this);
                    for (var a = this.os = [], b = this.pointsCount, c = 0; c < b - 1; c++) {
                        var d = this.i(c);
                        var e = this.i(c + 1);
                        K.da(d.x, e.x) ? (d = e.y - d.y, 0 > d && (d = -d)) : K.da(d.y, e.y) ? (d = e.x - d.x, 0 > d && (d = -d)) : d = Math.sqrt(d.Re(e));
                        a.push(d)
                    }
                }
                return this.os
            }
        }, flattenedTotalLength: {
            configurable: !0,
            enumerable: !0, get: function () {
                var a = this.$u;
                if (isNaN(a)) {
                    for (var b = this.flattenedLengths, c = b.length, d = a = 0; d < c; d++) a += b[d];
                    this.$u = a
                }
                return a
            }
        }, points: {
            configurable: !0, get: function () {
                return this.Gb
            }, set: function (a) {
                var b = this.Gb;
                if (b !== a) {
                    var c = null;
                    if (Array.isArray(a)) {
                        var d = 0 === a.length % 2;
                        if (d) for (var e = 0; e < a.length; e++) if ("number" !== typeof a[e] || isNaN(a[e])) {
                            d = !1;
                            break
                        }
                        if (d) for (c = new H, d = 0; d < a.length / 2; d++) e = (new J(a[2 * d], a[2 * d + 1])).freeze(), c.add(e); else {
                            d = !0;
                            for (e = 0; e < a.length; e++) {
                                var f =
                                    a[e];
                                if (!Ga(f) || "number" !== typeof f.x || isNaN(f.x) || "number" !== typeof f.y || isNaN(f.y)) {
                                    d = !1;
                                    break
                                }
                            }
                            if (d) for (c = new H, d = 0; d < a.length; d++) e = a[d], c.add((new J(e.x, e.y)).freeze()); else F && v("Link.points array must contain only an even number of numbers or objects with x and y properties, not: " + a)
                        }
                    } else if (a instanceof H) for (c = a.copy(), a = c.iterator; a.next();) a.value.freeze(); else v("Link.points value is not an instance of List or Array: " + a);
                    c.freeze();
                    this.Gb = c;
                    this.jc();
                    Dp(this);
                    a = this.diagram;
                    null !==
                    a && (a.Aj || a.undoManager.isUndoingRedoing || a.iu.add(this), a.animationManager.yc && (this.Dg = c));
                    this.g("points", b, c)
                }
            }
        }, pointsCount: {
            configurable: !0, get: function () {
                return this.Gb.count
            }
        }, nd: {
            configurable: !0, get: function () {
                return 0 !== (this.Ka & 16)
            }, set: function (a) {
                0 !== (this.Ka & 16) !== a && (this.Ka ^= 16)
            }
        }, suspendsRouting: {
            configurable: !0, get: function () {
                return 0 !== (this.Ka & 32)
            }, set: function (a) {
                0 !== (this.Ka & 32) !== a && (this.Ka ^= 32)
            }
        }, Nt: {
            configurable: !0,
            get: function () {
                return 0 !== (this.Ka & 64)
            }, set: function (a) {
                0 !== (this.Ka & 64) !== a && (this.Ka ^= 64)
            }
        }, defaultFromPoint: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                this.w = a.copy()
            }
        }, defaultToPoint: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                this.L = a.copy()
            }
        }, isOrthogonal: {
            configurable: !0, get: function () {
                return 2 === (this.mk.value & 2)
            }
        }, isAvoiding: {
            configurable: !0, get: function () {
                return 4 === (this.mk.value & 4)
            }
        }, ln: {
            configurable: !0,
            enumerable: !0, get: function () {
                return 0 !== (this.Ka & 128)
            }, set: function (a) {
                0 !== (this.Ka & 128) !== a && (this.Ka ^= 128)
            }
        }, geometry: {
            configurable: !0, get: function () {
                this.ln || (this.Ij(), this.ua = this.makeGeometry());
                return this.ua
            }
        }, firstPickIndex: {
            configurable: !0, get: function () {
                return 2 >= this.pointsCount ? 0 : this.isOrthogonal || !Hp(this.computeSpot(!0)) ? 1 : 0
            }
        }, lastPickIndex: {
            configurable: !0, get: function () {
                var a = this.pointsCount;
                return 0 === a ? 0 : 2 >= a ? a - 1 : this.isOrthogonal || !Hp(this.computeSpot(!1)) ?
                    a - 2 : a - 1
            }
        }, adjusting: {
            configurable: !0, get: function () {
                return this.hl
            }, set: function (a) {
                var b = this.hl;
                b !== a && (F && a !== pg && a !== wp && a !== xp && a !== yp && v("Link.adjusting can only be set to Link.None, Link.End, LInk.Scale, or Link.Stretch, not: " + a), this.hl = a, this.g("adjusting", b, a))
            }
        }, corner: {
            configurable: !0, get: function () {
                return this.Rn
            }, set: function (a) {
                var b = this.Rn;
                b !== a && (F && A(a, "number", S, "corner"), this.Rn = a, this.jc(), this.g("corner", b, a))
            }
        }, curve: {
            configurable: !0,
            get: function () {
                return this.Tn
            }, set: function (a) {
                var b = this.Tn;
                b !== a && (F && a !== pg && a !== sg && a !== og && a !== ng && v("Link.curve can only be set to Link.None, Link.Bezier, LInk.JumpGap, or Link.JumpOver, not: " + a), this.Tn = a, this.Za(), this.jc(), Ep(this, b === og || b === ng || a === og || a === ng), this.g("curve", b, a))
            }
        }, curviness: {
            configurable: !0, get: function () {
                return this.Un
            }, set: function (a) {
                var b = this.Un;
                b !== a && (F && A(a, "number", S, "curviness"), this.Un = a, this.Za(), this.jc(), this.g("curviness", b, a))
            }
        }, routing: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.mk
            }, set: function (a) {
                var b = this.mk;
                b !== a && (F && a !== vp && a !== dq && a !== eq && a !== Np && v("Link.routing can only be set to Link.Normal, Link.Orthogonal, LInk.AvoidsNodes, not: " + a), this.mk = a, this.gg = null, this.Za(), Ep(this, 2 === (b.value & 2) || 2 === (a.value & 2)), this.g("routing", b, a))
            }
        }, smoothness: {
            configurable: !0, get: function () {
                return this.iq
            }, set: function (a) {
                var b = this.iq;
                b !== a && (F && A(a, "number", S, "smoothness"), this.iq = a, this.jc(), this.g("smoothness", b, a))
            }
        },
        key: {
            configurable: !0, get: function () {
                var a = this.diagram;
                if (null !== a && a.model.Bj()) return a.model.bc(this.data)
            }
        }
    });
    S.prototype.invalidateOtherJumpOvers = S.prototype.Yq;
    S.prototype.findClosestSegment = S.prototype.jA;
    S.prototype.updateRoute = S.prototype.Ij;
    S.prototype.invalidateRoute = S.prototype.Za;
    S.prototype.rollbackRoute = S.prototype.Kw;
    S.prototype.commitRoute = S.prototype.Jf;
    S.prototype.startRoute = S.prototype.ci;
    S.prototype.clearPoints = S.prototype.zk;
    S.prototype.removePoint = S.prototype.Fw;
    S.prototype.addPointAt = S.prototype.Hf;
    S.prototype.addPoint = S.prototype.fe;
    S.prototype.insertPointAt = S.prototype.m;
    S.prototype.insertPoint = S.prototype.OA;
    S.prototype.setPointAt = S.prototype.O;
    S.prototype.setPoint = S.prototype.Wc;
    S.prototype.getPoint = S.prototype.i;
    S.prototype.getOtherPort = S.prototype.FA;
    S.prototype.getOtherNode = S.prototype.Tq;
    var Fp = null, Gp = null, vp = new E(S, "Normal", 1), dq = new E(S, "Orthogonal", 2),
        eq = new E(S, "AvoidsNodes", 6), Np = new E(S, "AvoidsNodesStraight", 7), pg = new E(S, "None", 0),
        sg = new E(S, "Bezier", 9), og = new E(S, "JumpGap", 10), ng = new E(S, "JumpOver", 11),
        wp = new E(S, "End", 17), xp = new E(S, "Scale", 18), yp = new E(S, "Stretch", 19),
        mn = new E(S, "OrientAlong", 21), en = new E(S, "OrientPlus90", 22), gn = new E(S, "OrientMinus90", 23),
        zp = new E(S, "OrientOpposite", 24), nn = new E(S, "OrientUpright", 25),
        fn = new E(S, "OrientPlus90Upright", 26), hn = new E(S, "OrientMinus90Upright",
        27), jn = new E(S, "OrientUpright45", 28), Pp = 16, Op = 14, Qp = 8;
    S.className = "Link";
    S.Normal = vp;
    S.Orthogonal = dq;
    S.AvoidsNodes = eq;
    S.AvoidsNodesStraight = Np;
    S.None = pg;
    S.Bezier = sg;
    S.JumpGap = og;
    S.JumpOver = ng;
    S.End = wp;
    S.Scale = xp;
    S.Stretch = yp;
    S.OrientAlong = mn;
    S.OrientPlus90 = en;
    S.OrientMinus90 = gn;
    S.OrientOpposite = zp;
    S.OrientUpright = nn;
    S.OrientPlus90Upright = fn;
    S.OrientMinus90Upright = hn;
    S.OrientUpright45 = jn;
    S.EndSegmentStep = 8;
    S.CurvinessStart = Pp;
    S.SpacingMin = Op;
    S.OrthoShortCut = Qp;
    S.AvoidanceCell = 8;
    S.AvoidanceLimit = 999;

    function cq(a, b, c, d) {
        gb(this);
        this.ye = this.vs = !1;
        this.lu = a;
        this.bz = b;
        this.vw = c;
        this.cz = d;
        this.links = []
    }

    cq.prototype.Om = function () {
        if (!this.vs) {
            var a = this.links;
            0 < a.length && (a = a[0].diagram, null !== a && (a.bv.add(this), this.ye = a.undoManager.isUndoingRedoing))
        }
        this.vs = !0
    };
    cq.prototype.jx = function () {
        if (this.vs) {
            this.vs = !1;
            var a = this.links;
            if (0 < a.length) {
                var b = a[0], c = b.diagram;
                c = null === c || c.Aj && !this.ye;
                this.ye = !1;
                b.arrangeBundledLinks(a, c);
                1 === a.length && (b.Yf = null, a.length = 0)
            }
            0 === a.length && (a = this.lu, null !== this && null !== a.cf && a.cf.remove(this), a = this.vw, null !== this && null !== a.cf && a.cf.remove(this))
        }
    };
    cq.className = "LinkBundle";

    function xk() {
        gb(this);
        this.kz = this.group = null;
        this.cu = !0;
        this.abort = !1;
        this.Dd = this.Cd = 1;
        this.Zo = this.Yo = -1;
        this.mc = this.lc = 8;
        this.Xb = null;
        this.jj = this.ij = 0;
        this.lz = 11;
        this.Wy = 124
    }

    xk.prototype.initialize = function (a) {
        if (!(0 >= a.width || 0 >= a.height)) {
            var b = a.y, c = a.x + a.width, d = a.y + a.height;
            this.Cd = Math.floor((a.x - this.lc) / this.lc) * this.lc;
            this.Dd = Math.floor((b - this.mc) / this.mc) * this.mc;
            this.Yo = Math.ceil((c + 2 * this.lc) / this.lc) * this.lc;
            this.Zo = Math.ceil((d + 2 * this.mc) / this.mc) * this.mc;
            a = 1 + (Math.ceil((this.Yo - this.Cd) / this.lc) | 0);
            b = 1 + (Math.ceil((this.Zo - this.Dd) / this.mc) | 0);
            if (null === this.Xb || this.ij < a - 1 || this.jj < b - 1) {
                c = [];
                for (d = 0; d <= a; d++) c[d] = new Uint32Array(b);
                this.Xb = c;
                this.ij =
                    a - 1;
                this.jj = b - 1
            }
            a = fq;
            if (null !== this.Xb) for (b = 0; b <= this.ij; b++) if (c = this.Xb[b], c.fill) c.fill(a); else for (d = 0; d <= this.jj; d++) c[d] = a
        }
    };

    function Lk(a, b, c) {
        return a.Cd <= b && b <= a.Yo && a.Dd <= c && c <= a.Zo
    }

    function Sp(a, b, c) {
        if (!Lk(a, b, c)) return fq;
        b -= a.Cd;
        b /= a.lc;
        c -= a.Dd;
        c /= a.mc;
        return a.Xb[b | 0][c | 0]
    }

    function Kk(a) {
        if (null !== a.Xb) for (var b = 0; b <= a.ij; b++) for (var c = a.Xb[b], d = 0; d <= a.jj; d++) c[d] >= Vp && (c[d] = fq)
    }

    xk.prototype.Lk = function (a, b, c, d) {
        if (a > this.Yo || a + c < this.Cd || b > this.Zo || b + d < this.Dd) return !0;
        a = (a - this.Cd) / this.lc | 0;
        b = (b - this.Dd) / this.mc | 0;
        c = Math.max(0, c) / this.lc + 1 | 0;
        var e = Math.max(0, d) / this.mc + 1 | 0;
        0 > a && (c += a, a = 0);
        0 > b && (e += b, b = 0);
        if (0 > c || 0 > e) return !0;
        d = Math.min(a + c - 1, this.ij) | 0;
        for (c = Math.min(b + e - 1, this.jj) | 0; a <= d; a++) {
            e = this.Xb[a];
            for (var f = b; f <= c; f++) if (e[f] === Mk) return !1
        }
        return !0
    };

    function gq(a, b, c, d, e, f, g, h, k) {
        if (!(b < f || b > g || c < h || c > k)) {
            var l = b | 0;
            var m = c | 0;
            var n = a.Xb[l][m];
            if (n >= Vp && n < Tp) for (e ? m += d : l += d, n += 1; f <= l && l <= g && h <= m && m <= k && !(n >= a.Xb[l][m]);) a.Xb[l][m] = n, n += 1, e ? m += d : l += d;
            l = e ? m : l;
            if (e) if (0 < d) for (c += d; c < l; c += d) gq(a, b, c, 1, !e, f, g, h, k), gq(a, b, c, -1, !e, f, g, h, k); else for (c += d; c > l; c += d) gq(a, b, c, 1, !e, f, g, h, k), gq(a, b, c, -1, !e, f, g, h, k); else if (0 < d) for (b += d; b < l; b += d) gq(a, b, c, 1, !e, f, g, h, k), gq(a, b, c, -1, !e, f, g, h, k); else for (b += d; b > l; b += d) gq(a, b, c, 1, !e, f, g, h, k), gq(a, b, c, -1, !e, f, g, h,
                k)
        }
    }

    function hq(a, b, c, d, e, f, g, h, k) {
        b |= 0;
        c |= 0;
        var l = Mk, m = Vp;
        for (a.Xb[b][c] = m; l === Mk && b > f && b < g && c > h && c < k;) m += 1, a.Xb[b][c] = m, e ? c += d : b += d, l = a.Xb[b][c]
    }

    function iq(a, b, c, d, e, f, g, h, k) {
        b |= 0;
        c |= 0;
        var l = Mk, m = Tp;
        for (a.Xb[b][c] = m; l === Mk && b > f && b < g && c > h && c < k;) a.Xb[b][c] = m, e ? c += d : b += d, l = a.Xb[b][c]
    }

    function Rp(a, b, c, d, e, f, g) {
        if (null !== a.Xb) {
            a.abort = !1;
            var h = b.x, k = b.y;
            if (Lk(a, h, k)) {
                h -= a.Cd;
                h /= a.lc;
                k -= a.Dd;
                k /= a.mc;
                var l = d.x, m = d.y;
                if (Lk(a, l, m)) if (l -= a.Cd, l /= a.lc, m -= a.Dd, m /= a.mc, 1 >= Math.abs(h - l) && 1 >= Math.abs(k - m)) a.abort = !0; else {
                    var n = f.x;
                    d = f.y;
                    b = f.x + f.width;
                    var p = f.y + f.height;
                    n -= a.Cd;
                    n /= a.lc;
                    d -= a.Dd;
                    d /= a.mc;
                    b -= a.Cd;
                    b /= a.lc;
                    p -= a.Dd;
                    p /= a.mc;
                    f = Math.max(0, Math.min(a.ij, n | 0));
                    b = Math.min(a.ij, Math.max(0, b | 0));
                    n = Math.max(0, Math.min(a.jj, d | 0));
                    p = Math.min(a.jj, Math.max(0, p | 0));
                    d = a.Xb;
                    h |= 0;
                    k |= 0;
                    l |= 0;
                    m |=
                        0;
                    var r = 0 === c || 90 === c ? 1 : -1;
                    c = 90 === c || 270 === c;
                    d[h][k] === Mk ? (hq(a, h, k, r, c, f, b, n, p), hq(a, h, k, 1, !c, f, b, n, p), hq(a, h, k, -1, !c, f, b, n, p)) : hq(a, h, k, r, c, h, k, h, k);
                    d[l][m] === Mk ? (iq(a, l, m, 0 === e || 90 === e ? 1 : -1, 90 === e || 270 === e, f, b, n, p), iq(a, l, m, 1, !(90 === e || 270 === e), f, b, n, p), iq(a, l, m, -1, !(90 === e || 270 === e), f, b, n, p)) : iq(a, l, m, r, c, l, m, l, m);
                    c = Ma();
                    if (g && jq(a, l, m, e, h, k, c)) {
                        if (c[0] !== l || c[1] !== m) c.unshift(m), c.unshift(l);
                        if (c[c.length - 2] !== h || c[c.length - 1] !== k) c.push(h), c.push(k);
                        a = Vp;
                        e = c[c.length - 2];
                        g = c[c.length - 1];
                        d[e][g] =
                            a++;
                        for (f = c.length - 4; 0 <= f; f -= 2) for (e = c[f + 2], g = c[f + 3], b = c[f], l = c[f + 1]; b > e ? e++ : b < e ? e-- : l > g ? g++ : l < g && g--, d[e][g] = a++, e !== b || g !== l;) ;
                    } else gq(a, h, k, 1, !1, f, b, n, p), gq(a, h, k, -1, !1, f, b, n, p), gq(a, h, k, 1, !0, f, b, n, p), gq(a, h, k, -1, !0, f, b, n, p);
                    Oa(c)
                }
            }
        }
    }

    function jq(a, b, c, d, e, f, g) {
        for (var h = a.Xb, k = b, l = c; ;) {
            if (k === e && l === f) return !0;
            var m = k, n = l;
            if (0 === d) if (m < e) m++; else break; else if (90 === d) if (n < f) n++; else break; else if (180 === d) if (m > e) m--; else break; else if (n > f) n--; else break;
            var p = h[m][n];
            if (0 === p || p === kq) break;
            k = m;
            l = n
        }
        for (; ;) {
            m = d;
            n = k;
            p = l;
            0 === d ? p < f ? (m = 90, p++) : p > f && (m = 270, p--) : 90 === d ? n < e ? (m = 0, n++) : n > e && (m = 180, n--) : 180 === d ? p < f ? (m = 90, p++) : p > f && (m = 270, p--) : n < e ? (m = 0, n++) : n > e && (m = 180, n--);
            n = h[n][p];
            if (m !== d && 0 !== n && n !== kq) {
                g.push(k);
                g.push(l);
                if (jq(a, k, l,
                    m, e, f, g)) return !0;
                g.pop();
                g.pop()
            }
            h[k][l] = kq;
            if (0 === d) {
                if (k === b) return !1;
                k--
            } else if (90 === d) {
                if (l === c) return !1;
                l--
            } else if (180 === d) {
                if (k === b) return !1;
                k++
            } else {
                if (l === c) return !1;
                l++
            }
        }
    }

    na.Object.defineProperties(xk.prototype, {
        bounds: {
            configurable: !0, get: function () {
                return new L(this.Cd, this.Dd, this.Yo - this.Cd, this.Zo - this.Dd)
            }
        }, Iq: {
            configurable: !0, get: function () {
                return this.lc
            }, set: function (a) {
                0 < a && a !== this.lc && (this.lc = a, this.initialize(this.bounds))
            }
        }, Hq: {
            configurable: !0, get: function () {
                return this.mc
            }, set: function (a) {
                0 < a && a !== this.mc && (this.mc = a, this.initialize(this.bounds))
            }
        }
    });
    var Mk = 0, Vp = 1, Tp = 999999, fq = Tp + 1, kq = Tp + 2;
    xk.className = "PositionArray";

    function Lp() {
        gb(this);
        this.port = this.node = null;
        this.he = [];
        this.dr = !1
    }

    Lp.prototype.toString = function () {
        for (var a = this.he, b = this.node.toString() + " " + a.length.toString() + ":", c = 0; c < a.length; c++) {
            var d = a[c];
            null !== d && (b += "\n  " + d.toString())
        }
        return b
    };

    function lq(a, b, c, d) {
        b = b.offsetY;
        switch (b) {
            case 8:
                return 90;
            case 2:
                return 180;
            case 1:
                return 270;
            case 4:
                return 0
        }
        switch (b) {
            case 9:
                return 180 < c ? 270 : 90;
            case 6:
                return 90 < c && 270 >= c ? 180 : 0
        }
        a = 180 * Math.atan2(a.height, a.width) / Math.PI;
        switch (b) {
            case 3:
                return c > a && c <= 180 + a ? 180 : 270;
            case 5:
                return c > 180 - a && c <= 360 - a ? 270 : 0;
            case 12:
                return c > a && c <= 180 + a ? 90 : 0;
            case 10:
                return c > 180 - a && c <= 360 - a ? 180 : 90;
            case 7:
                return 90 < c && c <= 180 + a ? 180 : c > 180 + a && c <= 360 - a ? 270 : 0;
            case 13:
                return 180 < c && c <= 360 - a ? 270 : c > a && 180 >= c ? 90 : 0;
            case 14:
                return c >
                a && c <= 180 - a ? 90 : c > 180 - a && 270 >= c ? 180 : 0;
            case 11:
                return c > 180 - a && c <= 180 + a ? 180 : c > 180 + a ? 270 : 90
        }
        d && 15 !== b && (c -= 15, 0 > c && (c += 360));
        return c > a && c < 180 - a ? 90 : c >= 180 - a && c <= 180 + a ? 180 : c > 180 + a && c < 360 - a ? 270 : 0
    }

    Lp.prototype.Om = function () {
        this.he.length = 0
    };

    function Mp(a, b) {
        var c = a.he;
        if (0 === c.length) {
            a:if (!a.dr) {
                c = a.dr;
                a.dr = !0;
                var d = null, e = a.node, f = e instanceof Kf ? e : null;
                if (null === f || f.isSubGraphExpanded) var g = e.isTreeExpanded ? e.findLinksConnected(a.port.portId) : e.Ey(); else {
                    if (!f.actualBounds.o()) {
                        a.dr = c;
                        break a
                    }
                    d = f;
                    g = d.cw()
                }
                f = a.he.length = 0;
                var h = a.port.ja(Fc, J.alloc()), k = a.port.ja(Rc, J.alloc());
                e = L.allocAt(h.x, h.y, 0, 0);
                e.Ze(k);
                J.free(h);
                J.free(k);
                h = J.allocAt(e.x + e.width / 2, e.y + e.height / 2);
                k = a.port.vj();
                for (g = g.iterator; g.next();) {
                    var l = g.value;
                    if (l.isVisible() &&
                        l.fromPort !== l.toPort) {
                        var m = l.fromPort === a.port || null !== l.fromNode && l.fromNode.Ld(d),
                            n = l.computeSpot(m, a.port);
                        if (n.Uc() && (m = m ? l.toPort : l.fromPort, null !== m)) {
                            var p = m.part;
                            if (null !== p) {
                                var r = p.findVisibleNode();
                                null !== r && r !== p && (p = r, m = p.port);
                                m = l.computeOtherPoint(p, m);
                                p = h.Xa(m);
                                p -= k;
                                0 > p ? p += 360 : 360 <= p && (p -= 360);
                                n = lq(e, n, p, l.isOrthogonal);
                                0 === n ? (n = 4, 180 < p && (p -= 360)) : 90 === n ? (n = 8, 270 < p && (p -= 360)) : 180 === n ? n = 2 : (n = 1, 90 > p && (p += 360));
                                r = a.he[f];
                                void 0 === r ? (r = new mq(l, p, n), a.he[f] = r) : (r.link = l, r.angle = p, r.Hc =
                                    n);
                                r.yw.set(m);
                                f++
                            }
                        }
                    }
                }
                J.free(h);
                a.he.sort(Lp.prototype.l);
                k = a.he.length;
                d = -1;
                for (f = h = 0; f < k; f++) g = a.he[f], void 0 !== g && (g.Hc !== d && (d = g.Hc, h = 0), g.Uq = h, h++);
                d = -1;
                h = 0;
                for (f = k - 1; 0 <= f; f--) k = a.he[f], void 0 !== k && (k.Hc !== d && (d = k.Hc, h = k.Uq + 1), k.Hm = h);
                f = a.he;
                n = a.port;
                d = a.node.portSpreading;
                h = J.alloc();
                k = J.alloc();
                g = J.alloc();
                l = J.alloc();
                n.ja(Fc, h);
                n.ja(Hc, k);
                n.ja(Rc, g);
                n.ja(Oc, l);
                r = p = m = n = 0;
                if (d === sp) for (var q = 0; q < f.length; q++) {
                    var u = f[q];
                    if (null !== u) {
                        var x = u.link.computeThickness();
                        switch (u.Hc) {
                            case 8:
                                p += x;
                                break;
                            case 2:
                                r += x;
                                break;
                            case 1:
                                n += x;
                                break;
                            default:
                            case 4:
                                m += x
                        }
                    }
                }
                var y = q = 0, z = 1, B = u = 0;
                for (x = 0; x < f.length; x++) {
                    var D = f[x];
                    if (null !== D) {
                        if (q !== D.Hc) {
                            q = D.Hc;
                            switch (q) {
                                case 8:
                                    var G = g;
                                    y = l;
                                    break;
                                case 2:
                                    G = l;
                                    y = h;
                                    break;
                                case 1:
                                    G = h;
                                    y = k;
                                    break;
                                default:
                                case 4:
                                    G = k, y = g
                            }
                            u = y.x - G.x;
                            B = y.y - G.y;
                            switch (q) {
                                case 8:
                                    p > Math.abs(u) ? (z = Math.abs(u) / p, p = Math.abs(u)) : z = 1;
                                    break;
                                case 2:
                                    r > Math.abs(B) ? (z = Math.abs(B) / r, r = Math.abs(B)) : z = 1;
                                    break;
                                case 1:
                                    n > Math.abs(u) ? (z = Math.abs(u) / n, n = Math.abs(u)) : z = 1;
                                    break;
                                default:
                                case 4:
                                    m > Math.abs(B) ? (z = Math.abs(B) /
                                        m, m = Math.abs(B)) : z = 1
                            }
                            y = 0
                        }
                        var O = D.br;
                        if (d === sp) {
                            D = D.link.computeThickness();
                            D *= z;
                            O.set(G);
                            switch (q) {
                                case 8:
                                    O.x = G.x + u / 2 + p / 2 - y - D / 2;
                                    break;
                                case 2:
                                    O.y = G.y + B / 2 + r / 2 - y - D / 2;
                                    break;
                                case 1:
                                    O.x = G.x + u / 2 - n / 2 + y + D / 2;
                                    break;
                                default:
                                case 4:
                                    O.y = G.y + B / 2 - m / 2 + y + D / 2
                            }
                            y += D
                        } else {
                            var U = .5;
                            d === ep && (U = (D.Uq + 1) / (D.Hm + 1));
                            O.x = G.x + u * U;
                            O.y = G.y + B * U
                        }
                    }
                }
                J.free(h);
                J.free(k);
                J.free(g);
                J.free(l);
                G = a.he;
                for (f = 0; f < G.length; f++) d = G[f], null !== d && (d.aw = a.computeEndSegmentLength(d));
                a.dr = c;
                L.free(e)
            }
            c = a.he
        }
        for (a = 0; a < c.length; a++) if (e = c[a], null !==
        e && e.link === b) return e;
        return null
    }

    Lp.prototype.l = function (a, b) {
        return a === b ? 0 : null === a ? -1 : null === b ? 1 : a.Hc < b.Hc ? -1 : a.Hc > b.Hc ? 1 : a.angle < b.angle ? -1 : a.angle > b.angle ? 1 : 0
    };
    Lp.prototype.computeEndSegmentLength = function (a) {
        var b = a.link, c = b.computeEndSegmentLength(this.node, this.port, Ec, b.fromPort === this.port), d = a.Uq;
        if (0 > d) return c;
        var e = a.Hm;
        if (1 >= e || !b.isOrthogonal) return c;
        b = a.yw;
        var f = a.br;
        if (2 === a.Hc || 8 === a.Hc) d = e - 1 - d;
        return ((a = 2 === a.Hc || 4 === a.Hc) ? b.y < f.y : b.x < f.x) ? c + 8 * d : (a ? b.y === f.y : b.x === f.x) ? c : c + 8 * (e - 1 - d)
    };
    Lp.className = "Knot";

    function mq(a, b, c) {
        this.link = a;
        this.angle = b;
        this.Hc = c;
        this.yw = new J;
        this.Hm = this.Uq = 0;
        this.br = new J;
        this.aw = 0
    }

    mq.prototype.toString = function () {
        return this.link.toString() + " " + this.angle.toString() + " " + this.Hc.toString() + ":" + this.Uq.toString() + "/" + this.Hm.toString() + " " + this.br.toString() + " " + this.aw.toString() + " " + this.yw.toString()
    };
    mq.className = "LinkInfo";

    function vl() {
        this.Mh = this.oh = jd;
        this.Lh = this.nh = this.Kh = this.mh = NaN;
        this.tq = this.oo = null;
        this.uq = this.po = Infinity
    }

    vl.prototype.copy = function () {
        var a = new vl;
        a.oh = this.oh.J();
        a.Mh = this.Mh.J();
        a.mh = this.mh;
        a.Kh = this.Kh;
        a.nh = this.nh;
        a.Lh = this.Lh;
        a.oo = this.oo;
        a.tq = this.tq;
        a.po = this.po;
        a.uq = this.uq;
        return a
    };
    vl.className = "LinkSettings";

    function Ni() {
        0 < arguments.length && Ba(Ni);
        gb(this);
        this.w = this.B = null;
        this.Ii = this.Eo = !0;
        this.Jo = !1;
        this.xn = (new J(0, 0)).freeze();
        this.Go = !0;
        this.Fn = this.Fo = null;
        this.Io = !1;
        this.l = null;
        this.L = 0;
        this.$o = this.zq = null;
        this.Ht = !1;
        this.Lg = this.pk = null;
        this.wt = !1
    }

    Ni.prototype.cloneProtected = function (a) {
        a.Eo = this.Eo;
        a.Ii = this.Ii;
        a.Jo = this.Jo;
        a.xn.assign(this.xn);
        a.Go = this.Go;
        a.Fo = this.Fo;
        a.Fn = this.Fn;
        a.Io = !0;
        a.$o = this.$o;
        a.zq = this.zq
    };
    Ni.prototype.copy = function () {
        var a = new this.constructor;
        this.cloneProtected(a);
        return a
    };
    Ni.prototype.serializeLayoutProperties = function (a) {
        a.arrangementOrigin = {x: this.arrangementOrigin.x, y: this.arrangementOrigin.y};
        a.isRouting = this.isRouting
    };
    Ni.prototype.deserializeLayoutProperties = function (a) {
        null !== a && (this.arrangementOrigin = new J(a.arrangementOrigin.x, a.arrangementOrigin.y), this.isRouting = a.isRouting)
    };
    Ni.prototype.pb = function (a) {
        Da(this, a)
    };
    Ni.prototype.toString = function () {
        var a = Pa(this.constructor);
        a += "(";
        null !== this.group && (a += " in " + this.group);
        null !== this.diagram && (a += " for " + this.diagram);
        return a + ")"
    };
    Ni.prototype.D = function () {
        if (this.isValidLayout) {
            var a = this.diagram;
            if (null !== a && !a.undoManager.isUndoingRedoing) {
                var b = a.animationManager;
                !b.isTicking && (b.defaultAnimation.isAnimating && b.Xc(), this.isOngoing && a.Aj || this.isInitial && !a.Aj) && (this.isValidLayout = !1, a.Kb())
            }
        }
    };
    Ni.prototype.createNetwork = function () {
        return new nq(this)
    };
    Ni.prototype.makeNetwork = function (a) {
        var b = this.createNetwork();
        a instanceof Q ? (b.Ng(a.nodes, !0), b.Ng(a.links, !0)) : a instanceof Kf ? b.Ng(a.memberParts) : b.Ng(a.iterator);
        return b
    };
    Ni.prototype.updateParts = function () {
        this.isValidLayout = !0;
        if (!this.workerLayout()) {
            var a = this.diagram;
            if (null === a && null !== this.network) for (var b = this.network.vertexes.iterator; b.next();) {
                var c = b.value.node;
                if (null !== c && (a = c.diagram, null !== a)) break
            }
            try {
                null !== a && a.Ca("Layout"), this.commitLayout()
            } finally {
                null !== a && a.bb("Layout")
            }
        }
    };
    Ni.prototype.commitLayout = function () {
        if (null !== this.network) {
            for (var a = this.network.vertexes.iterator; a.next();) a.value.commit();
            if (this.isRouting) for (a = this.network.edges.iterator; a.next();) a.value.commit()
        }
    };
    Ni.prototype.doLayout = function (a) {
        F && null === a && v("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts");
        var b = new I;
        a instanceof Q ? (oq(this, b, a.nodes, !0, this.ai, !0, !1, !0), oq(this, b, a.parts, !0, this.ai, !0, !1, !0)) : a instanceof Kf ? oq(this, b, a.memberParts, !1, this.ai, !0, !1, !0) : b.addAll(a.iterator);
        0 < b.count && (a = this.diagram, null !== a && a.Ca("Layout"), this.doMinimalNoNetworkLayout(b), null !== a && a.bb("Layout"));
        this.isValidLayout = !0
    };
    Ni.prototype.doMinimalNoNetworkLayout = function (a) {
        var b = Math.ceil(Math.sqrt(a.count));
        this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
        var c = this.arrangementOrigin.x, d = c, e = this.arrangementOrigin.y, f = 0, g = 0;
        for (a = a.iterator; a.next();) {
            var h = a.value;
            pq(h);
            var k = h.measuredBounds, l = k.width;
            k = k.height;
            h.moveTo(d, e);
            h instanceof Kf && (h.ai = !1);
            d += Math.max(l, 50) + 20;
            g = Math.max(g, Math.max(k, 50));
            f >= b - 1 ? (f = 0, d = c, e += g + 20, g = 0) : f++
        }
    };
    Ni.prototype.doMinimalNetworkLayout = function () {
        var a = Math.ceil(Math.sqrt(this.network.vertexes.count));
        this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
        for (var b = this.arrangementOrigin.x, c = b, d = this.arrangementOrigin.y, e = 0, f = 0, g = this.network.vertexes.iterator; g.next();) {
            var h = g.value.node;
            if (!(null === h || h instanceof S) && (pq(h), this.ai(h))) {
                var k = h.measuredBounds, l = k.width;
                k = k.height;
                h.moveTo(c, d);
                h instanceof Kf && (h.ai = !1);
                c += Math.max(l, 50) + 20;
                f = Math.max(f, Math.max(k, 50));
                e >= a - 1 ? (e =
                    0, c = b, d += f + 20, f = 0) : e++
            }
        }
    };
    Ni.prototype.ai = function (a) {
        return !a.location.o() || a instanceof Kf && a.ai ? !0 : !1
    };

    function oq(a, b, c, d, e, f, g, h) {
        for (c = c.iterator; c.next();) {
            var k = c.value;
            d && !k.isTopLevel || null !== e && !e(k) || !k.canLayout() || (f && k instanceof V ? k.isLinkLabel || (k instanceof Kf ? null === k.layout ? oq(a, b, k.memberParts, !1, e, f, g, h) : (pq(k), b.add(k)) : (pq(k), b.add(k))) : g && k instanceof S ? b.add(k) : !h || !k.Tc() || k instanceof V || (pq(k), b.add(k)))
        }
    }

    function pq(a) {
        var b = a.actualBounds;
        (0 === b.width || 0 === b.height || isNaN(b.width) || isNaN(b.height)) && a.Ya()
    }

    Ni.prototype.xj = function (a, b) {
        var c = this.boundsComputation;
        if (null !== c) return b || (b = new L), c(a, this, b);
        if (!b) return a.actualBounds;
        b.set(a.actualBounds);
        return b
    };
    Ni.prototype.qy = function (a) {
        var b = new I;
        a instanceof Q ? (oq(this, b, a.nodes, !0, null, !0, !0, !0), oq(this, b, a.links, !0, null, !0, !0, !0), oq(this, b, a.parts, !0, null, !0, !0, !0)) : a instanceof Kf ? oq(this, b, a.memberParts, !1, null, !0, !0, !0) : oq(this, b, a.iterator, !1, null, !0, !0, !0);
        return b
    };
    Ni.prototype.initialOrigin = function (a) {
        var b = this.group;
        if (null !== b) {
            var c = b.position.copy();
            (isNaN(c.x) || isNaN(c.y)) && c.set(a);
            b = b.placeholder;
            null !== b && (c = b.ja(Fc), (isNaN(c.x) || isNaN(c.y)) && c.set(a), a = b.padding, c.x += a.left, c.y += a.top);
            return c
        }
        return a
    };
    Ni.prototype.mayUseWorker = function () {
        return this.mayUseWorkerFunction ? this.mayUseWorkerFunction(this) : !1
    };
    Ni.prototype.workerLayout = function () {
        return !1
    };

    function qq(a, b) {
        if (null !== a.workerStateChanged) {
            var c = {key: a.group ? a.group.key : null};
            void 0 !== b && (c.time = b);
            null !== a.pk && (c.running = rq(a.pk));
            null !== a.Lg && (c.waiting = rq(a.Lg));
            a.workerStateChanged(c, a)
        }
    }

    function rq(a) {
        return {vertexes: a.vertexes.count, edges: a.edges.count}
    }

    Ni.prototype.Oz = function () {
        var a = sq(this.constructor);
        a && (null !== a.$e && a.$e.terminate(), a.$e = null, a.Rm.iteratorValues.each(function (a) {
            a.Ht = !1;
            a.pk = null;
            a.Lg = null;
            a.wt = !1;
            qq(a)
        }), a.Rm.clear())
    };

    function tq(a, b) {
        var c = sq(a);
        if (c) {
            if (b) for (var d in b) c[d] = b[d]
        } else throw Error("Unknown Layout class: " + a);
    }

    function sq(a) {
        var b = null;
        if ("function" === typeof a) {
            if (b = uq.get(a), !b) {
                var c = Pa(a);
                b = uq.get(c);
                b || (b = new vq, b.Vv = a, b.name = c, b.l = a.name, b.Qy = wq, uq.set(c, b), uq.set(a, b), uq.set(a.name, b))
            }
        } else "string" === typeof a && (b = uq.get(a));
        return b
    }

    Ni.prototype.ix = function () {
        if ("undefined" === typeof Worker || !xq || "undefined" === typeof self || "undefined" !== typeof self.DedicatedWorkerGlobalScope) return !1;
        if (!this.mayUseWorker()) return this.Ht && (this.wt = !0, this.Lg = this.pk = null, qq(this)), !1;
        var a = sq(this.constructor);
        if (null === a) return !1;
        null === a.$e && (a.$e = new Worker(xq), a.$e.onerror = function (a) {
            a.preventDefault();
            Ea("Worker Error at: " + a.filename + " " + a.lineno + " " + a.colno + "\n  " + a.message)
        }, a.$e.l = function (a) {
            Ea("Worker serialization error: " + a)
        }, a.$e.onmessage =
            function (b) {
                var c = b.data;
                if ("_GoJS" === c._GoJS) if (c.version) Ea("GoJS v" + Q.version + "  Worker v" + c.version); else if (b = a.Rm.get(c.id)) {
                    a.Rm.remove(c.id);
                    b.Ht = !1;
                    b.pk = null;
                    if (b.wt) b.wt = !1, b.Lg = null; else {
                        var d = yq(b, c, !1);
                        b.network = d;
                        b.updateParts();
                        b.network = null;
                        b.isValidLayout = !0
                    }
                    qq(b, c.time);
                    c = b.Lg;
                    if (null !== c) b.Lg = null; else for (d = a.Rm.iteratorValues; d.next();) {
                        var e = d.value;
                        c = e.Lg;
                        if (null !== c) {
                            e.Lg = null;
                            break
                        }
                    }
                    null !== c && zq(b, c)
                }
            }, a.$e.postMessage({_GoJS: "_GoJS", url: a.Qy}), Array.isArray(a.scripts) &&
        a.scripts.forEach(function (b) {
            a.$e.postMessage({_GoJS: "_GoJS", url: b})
        }), a.$e.postMessage({_GoJS: "_GoJS", version: -1}));
        null !== this.pk ? this.Lg = this.network : zq(this, this.network);
        qq(this);
        this.doMinimalNetworkLayout();
        this.network = null;
        return this.isValidLayout = !0
    };

    function zq(a, b) {
        a.Ht = !0;
        var c = sq(a.constructor), d = Aq(a, b, !0);
        d._GoJS = "_GoJS";
        c.$e.postMessage(d);
        c.Rm.set(rb(a), a);
        a.pk = b
    }

    function Aq(a, b, c) {
        a.onNetworkSerialization(1, c, b, null);
        var d = {};
        a.serializeLayoutProperties(d, c);
        var e = [];
        b.vertexes.each(function (a) {
            var b = {};
            a.serializeVertexProperties(b, c);
            e.push(b)
        });
        var f = [];
        b.edges.each(function (a) {
            var b = {};
            a.serializeEdgeProperties(b, c);
            f.push(b)
        });
        d = {id: c ? rb(a) : a.id, layout: Pa(a.constructor), p: d, yB: e, hA: f};
        a.onNetworkSerialization(2, c, b, d);
        return d
    }

    function yq(a, b, c) {
        c && (a.id = b.id);
        var d = a.diagram, e = a.createNetwork();
        a.onNetworkSerialization(3, c, e, b);
        var f = b.yB, g = new Db;
        f && f.forEach(function (a) {
            var b = null;
            null === a.key || null === d || c || (b = d.Ib(a.key));
            null !== b ? b = e.xk(b) : (b = e.createVertex(), null !== a.key && (b.data = b), e.Og(b));
            c && null !== b.data && (b.data.Mi = a.key);
            g.set(a.id, b)
        });
        var h = b.hA, k = new Db;
        h && h.forEach(function (a) {
            var b = null;
            null === a.key || null === d || c || (b = d.findLinkForKey(a.key));
            null !== b ? b = e.ky(b) : (b = e.createEdge(), null !== a.key && (b.data = b),
                e.Dm(b));
            c && null !== b.data && (b.data.Mi = a.key);
            k.set(a.id, b)
        });
        a.deserializeLayoutProperties(b.p, g, k, c);
        f && f.forEach(function (a) {
            var b = g.get(a.id);
            b && b.Lq(a, g, k, c)
        });
        h && h.forEach(function (a) {
            var b = k.get(a.id);
            b && b.deserializeEdgeProperties(a, g, k, c)
        });
        a.onNetworkSerialization(4, c, e, b);
        return e
    }

    Ni.prototype.onNetworkSerialization = function () {
    };
    na.Object.defineProperties(Ni.prototype, {
        diagram: {
            configurable: !0, get: function () {
                return this.B
            }, set: function (a) {
                null !== a && w(a, Q, Ni, "diagram");
                this.B = a
            }
        }, group: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                this.w !== a && (null !== a && w(a, Kf, Ni, "group"), this.w = a, null !== a && (this.B = a.diagram))
            }
        }, isOngoing: {
            configurable: !0, get: function () {
                return this.Eo
            }, set: function (a) {
                this.Eo !== a && (A(a, "boolean", Ni, "isOngoing"), this.Eo = a)
            }
        }, isInitial: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Ii
            }, set: function (a) {
                A(a, "boolean", Ni, "isInitial");
                this.Ii = a;
                a || (this.Io = !0)
            }
        }, isViewportSized: {
            configurable: !0, get: function () {
                return this.Jo
            }, set: function (a) {
                this.Jo !== a && (A(a, "boolean", Ni, "isViewportSized"), (this.Jo = a) && this.D())
            }
        }, isRouting: {
            configurable: !0, get: function () {
                return this.Go
            }, set: function (a) {
                this.Go !== a && (A(a, "boolean", Ni, "isRouting"), this.Go = a)
            }
        }, isRealtime: {
            configurable: !0, get: function () {
                return this.Fo
            },
            set: function (a) {
                this.Fo !== a && (null !== a && A(a, "boolean", Ni, "isRealtime"), this.Fo = a)
            }
        }, isValidLayout: {
            configurable: !0, get: function () {
                return this.Io
            }, set: function (a) {
                this.Io !== a && (A(a, "boolean", Ni, "isValidLayout"), this.Io = a, a || (a = this.diagram, null !== a && (a.$g = !0)))
            }
        }, network: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                this.l !== a && (null !== a && w(a, nq, Ni, "network"), this.l = a, null !== a && (a.layout = this))
            }
        }, boundsComputation: {
            configurable: !0, get: function () {
                return this.Fn
            },
            set: function (a) {
                this.Fn !== a && (null !== a && A(a, "function", Ni, "boundsComputation"), this.Fn = a, this.D())
            }
        }, arrangementOrigin: {
            configurable: !0, get: function () {
                return this.xn
            }, set: function (a) {
                w(a, J, Ni, "arrangementOrigin");
                this.xn.A(a) || (this.xn.assign(a), this.D())
            }
        }, id: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                this.L = a
            }
        }, mayUseWorkerFunction: {
            configurable: !0, get: function () {
                return this.$o
            }, set: function (a) {
                this.$o !== a && (null !== a && A(a, "function",
                    Ni, "mayUseWorkerFunction"), this.$o = a)
            }
        }, workerStateChanged: {
            configurable: !0, get: function () {
                return this.zq
            }, set: function (a) {
                this.zq !== a && (null !== a && A(a, "function", Ni, "workerStateChanged"), this.zq = a)
            }
        }
    });
    Ni.prototype.useWorker = Ni.prototype.ix;
    Ni.declareWorkerLayout = tq;
    Ni.prototype.cancelWorker = Ni.prototype.Oz;
    Ni.prototype.collectParts = Ni.prototype.qy;
    Ni.prototype.getLayoutBounds = Ni.prototype.xj;
    Ni.prototype.invalidateLayout = Ni.prototype.D;
    var uq = new Db,
        wq = "object" === typeof qa.document && qa.document.currentScript ? qa.document.currentScript.src : "",
        xq = "undefined" !== typeof URL && "function" === typeof URL.createObjectURL && "function" === typeof Blob ? URL.createObjectURL(new Blob(["self.onmessage=function(e){if(e.data.url){\nimportScripts(e.data.url);}}"], {type: "text/javascript"})) : "";
    Ni.className = "Layout";
    Ni.GoJSScriptURL = wq;
    Ni.declareWorkerLayout = tq;
    "undefined" !== typeof self && "undefined" !== typeof self.DedicatedWorkerGlobalScope && "undefined" !== typeof self && "undefined" !== typeof self.DedicatedWorkerGlobalScope && (self.onmessage = function (a) {
        a = a.data;
        if ("_GoJS" === a._GoJS) if (a.url) importScripts(a.url); else if (a.version) self.postMessage({
            _GoJS: "_GoJS",
            version: Q.version
        }, void 0); else {
            var b = performance.now(), c = null;
            a.layout && (c = sq(a.layout));
            var d = null;
            c && c.Vv && (d = new c.Vv);
            if (!d) throw Error("no registered Worker Layout: " + a.layout);
            d.network = yq(d, a, !0);
            d.workerLayout = function () {
                var a = Aq(d, d.network, !1);
                a._GoJS = "_GoJS";
                a.time = performance.now() - b;
                self.postMessage(a, void 0);
                return !0
            };
            d.doLayout(new H)
        }
    });

    function vq() {
        this.Vv = null;
        this.Qy = this.l = this.name = "";
        this.scripts = [];
        this.$e = null;
        this.Rm = new Db
    }

    function nq(a) {
        gb(this);
        F && !a && v("LayoutNetwork constructor requires non-null Layout argument");
        this.rc = a;
        this.Ff = new I;
        this.re = new I;
        this.mu = new Db;
        this.hu = new Db
    }

    nq.prototype.clear = function () {
        if (this.Ff) for (var a = this.Ff.iterator; a.next();) a.value.clear();
        if (this.re) for (a = this.re.iterator; a.next();) a.value.clear();
        this.Ff = new I;
        this.re = new I;
        this.mu = new Db;
        this.hu = new Db
    };
    nq.prototype.toString = function (a) {
        void 0 === a && (a = 0);
        var b = "LayoutNetwork" + (null !== this.layout ? "(" + this.layout.toString() + ")" : "");
        if (0 >= a) return b;
        b += " vertexes: " + this.Ff.count + " edges: " + this.re.count;
        if (1 < a) {
            for (var c = this.Ff.iterator; c.next();) b += "\n    " + c.value.toString(a - 1);
            for (c = this.re.iterator; c.next();) b += "\n    " + c.value.toString(a - 1)
        }
        return b
    };
    nq.prototype.createVertex = function () {
        return new Bq(this)
    };
    nq.prototype.createEdge = function () {
        return new Cq(this)
    };
    nq.prototype.Ng = function (a, b, c) {
        if (null !== a) {
            void 0 === b && (b = !1);
            A(b, "boolean", nq, "addParts:toplevelonly");
            void 0 === c && (c = null);
            null === c && (c = function (a) {
                if (a instanceof V) return !a.isLinkLabel;
                if (a instanceof S) {
                    var b = a.fromNode;
                    if (null === b || b.isLinkLabel) return !1;
                    a = a.toNode;
                    return null === a || a.isLinkLabel ? !1 : !0
                }
                return !1
            });
            for (a = a.iterator; a.next();) {
                var d = a.value;
                if (d instanceof V && (!b || d.isTopLevel) && d.canLayout() && c(d)) if (d instanceof Kf && null === d.layout) this.Ng(d.memberParts, !1); else if (null === this.uj(d)) {
                    var e =
                        this.createVertex();
                    e.node = d;
                    this.Og(e)
                }
            }
            for (a.reset(); a.next();) if (d = a.value, d instanceof S && (!b || d.isTopLevel) && d.canLayout() && c(d) && null === this.Nq(d)) {
                var f = d.fromNode;
                e = d.toNode;
                null !== f && null !== e && f !== e && (f = this.findGroupVertex(f), e = this.findGroupVertex(e), null !== f && null !== e && this.Mk(f, e, d))
            }
        }
    };
    nq.prototype.findGroupVertex = function (a) {
        if (null === a) return null;
        var b = a.findVisibleNode();
        if (null === b) return null;
        a = this.uj(b);
        if (null !== a) return a;
        for (b = b.containingGroup; null !== b;) {
            a = this.uj(b);
            if (null !== a) return a;
            b = b.containingGroup
        }
        return null
    };
    t = nq.prototype;
    t.Og = function (a) {
        if (null !== a) {
            F && w(a, Bq, nq, "addVertex:vertex");
            this.Ff.add(a);
            var b = a.node;
            null !== b && this.mu.add(b, a);
            a.network = this
        }
    };
    t.xk = function (a) {
        if (null === a) return null;
        F && w(a, V, nq, "addNode:node");
        var b = this.uj(a);
        null === b && (b = this.createVertex(), b.node = a, this.Og(b));
        return b
    };
    t.Yv = function (a) {
        if (null !== a && (F && w(a, Bq, nq, "deleteVertex:vertex"), Dq(this, a))) {
            for (var b = a.Ye, c = b.count - 1; 0 <= c; c--) {
                var d = b.M(c);
                this.Fk(d)
            }
            b = a.Qe;
            for (a = b.count - 1; 0 <= a; a--) c = b.M(a), this.Fk(c)
        }
    };

    function Dq(a, b) {
        if (null === b) return !1;
        var c = a.Ff.remove(b);
        c && (b = b.node, null !== b && a.mu.remove(b));
        return c
    }

    t.$z = function (a) {
        null !== a && (F && w(a, V, nq, "deleteNode:node"), a = this.uj(a), null !== a && this.Yv(a))
    };
    t.uj = function (a) {
        if (null === a) return null;
        F && w(a, V, nq, "findVertex:node");
        return this.mu.K(a)
    };
    t.Dm = function (a) {
        if (null !== a) {
            F && w(a, Cq, nq, "addEdge:edge");
            Eq(this, a);
            var b = a.toVertex;
            null !== b && b.Pv(a);
            b = a.fromVertex;
            null !== b && b.Nv(a)
        }
    };

    function Eq(a, b) {
        if (null !== b) {
            a.re.add(b);
            var c = b.link;
            null !== c && null === a.Nq(c) && a.hu.add(c, b);
            b.network = a
        }
    }

    t.ky = function (a) {
        if (null === a) return null;
        F && w(a, S, nq, "addLink:link");
        var b = a.fromNode, c = a.toNode, d = this.Nq(a);
        null === d ? (d = this.createEdge(), d.link = a, null !== b && (d.fromVertex = this.xk(b)), null !== c && (d.toVertex = this.xk(c)), this.Dm(d)) : (null !== b ? d.fromVertex = this.xk(b) : d.fromVertex = null, null !== c ? d.toVertex = this.xk(c) : d.toVertex = null);
        return d
    };
    t.Fk = function (a) {
        if (null !== a) {
            F && w(a, Cq, nq, "deleteEdge:edge");
            var b = a.toVertex;
            null !== b && b.Xv(a);
            b = a.fromVertex;
            null !== b && b.Wv(a);
            Fq(this, a)
        }
    };

    function Fq(a, b) {
        null !== b && a.re.remove(b) && (b = b.link, null !== b && a.hu.remove(b))
    }

    t.Zz = function (a) {
        null !== a && (F && w(a, S, nq, "deleteLink:link"), a = this.Nq(a), null !== a && this.Fk(a))
    };
    t.Nq = function (a) {
        if (null === a) return null;
        F && w(a, S, nq, "findEdge:link");
        return this.hu.K(a)
    };
    t.Mk = function (a, b, c) {
        if (null === a || null === b) return null;
        F && (w(a, Bq, nq, "linkVertexes:fromVertex"), w(b, Bq, nq, "linkVertexes:toVertex"), null !== c && w(c, S, nq, "linkVertexes:link"));
        if (a.network === this && b.network === this) {
            var d = this.createEdge();
            d.link = c;
            d.fromVertex = a;
            d.toVertex = b;
            this.Dm(d);
            return d
        }
        return null
    };
    t.cn = function (a) {
        if (null !== a) {
            F && w(a, Cq, nq, "reverseEdge:edge");
            var b = a.fromVertex, c = a.toVertex;
            null !== b && null !== c && (b.Wv(a), c.Xv(a), a.cn(), b.Pv(a), c.Nv(a))
        }
    };
    t.Kq = function () {
        for (var a = Ma(), b = this.re.iterator; b.next();) {
            var c = b.value;
            c.fromVertex === c.toVertex && a.push(c)
        }
        b = a.length;
        for (c = 0; c < b; c++) this.Fk(a[c]);
        Oa(a)
    };
    nq.prototype.deleteArtificialVertexes = function () {
        for (var a = Ma(), b = this.Ff.iterator; b.next();) {
            var c = b.value;
            null === c.node && null === c.data && a.push(c)
        }
        c = a.length;
        for (b = 0; b < c; b++) this.Yv(a[b]);
        b = Ma();
        for (c = this.re.iterator; c.next();) {
            var d = c.value;
            null === d.link && null === d.data && b.push(d)
        }
        c = b.length;
        for (d = 0; d < c; d++) this.Fk(b[d]);
        Oa(a);
        Oa(b)
    };

    function Gq(a) {
        for (var b = Ma(), c = a.re.iterator; c.next();) {
            var d = c.value;
            null !== d.fromVertex && null !== d.toVertex || b.push(d)
        }
        c = b.length;
        for (d = 0; d < c; d++) a.Fk(b[d]);
        Oa(b)
    }

    nq.prototype.mz = function (a) {
        void 0 === a && (a = !0);
        a && (this.deleteArtificialVertexes(), Gq(this), this.Kq());
        a = new H;
        for (var b = !0; b;) {
            b = !1;
            for (var c = this.Ff.iterator; c.next();) {
                var d = c.value;
                if (0 < d.Ye.count || 0 < d.Qe.count) {
                    b = this.layout.createNetwork();
                    a.add(b);
                    Hq(this, b, d);
                    b = !0;
                    break
                }
            }
        }
        a.sort(function (a, b) {
            return null === a || null === b || a === b ? 0 : b.vertexes.count - a.vertexes.count
        });
        return a
    };

    function Hq(a, b, c) {
        if (null !== c && c.network !== b) {
            Dq(a, c);
            b.Og(c);
            for (var d = c.sourceEdges; d.next();) {
                var e = d.value;
                e.network !== b && (Fq(a, e), Eq(b, e), Hq(a, b, e.fromVertex))
            }
            for (d = c.destinationEdges; d.next();) c = d.value, c.network !== b && (Fq(a, c), Eq(b, c), Hq(a, b, c.toVertex))
        }
    }

    nq.prototype.iA = function () {
        for (var a = new I, b = this.Ff.iterator; b.next();) a.add(b.value.node);
        for (b = this.re.iterator; b.next();) a.add(b.value.link);
        return a
    };
    na.Object.defineProperties(nq.prototype, {
        layout: {
            configurable: !0, get: function () {
                return this.rc
            }, set: function (a) {
                null !== a && (this.rc = a)
            }
        }, vertexes: {
            configurable: !0, get: function () {
                return this.Ff
            }
        }, edges: {
            configurable: !0, get: function () {
                return this.re
            }
        }
    });
    nq.prototype.findAllParts = nq.prototype.iA;
    nq.prototype.splitIntoSubNetworks = nq.prototype.mz;
    nq.prototype.deleteSelfEdges = nq.prototype.Kq;
    nq.prototype.reverseEdge = nq.prototype.cn;
    nq.prototype.linkVertexes = nq.prototype.Mk;
    nq.prototype.findEdge = nq.prototype.Nq;
    nq.prototype.deleteLink = nq.prototype.Zz;
    nq.prototype.deleteEdge = nq.prototype.Fk;
    nq.prototype.addLink = nq.prototype.ky;
    nq.prototype.addEdge = nq.prototype.Dm;
    nq.prototype.findVertex = nq.prototype.uj;
    nq.prototype.deleteNode = nq.prototype.$z;
    nq.prototype.deleteVertex = nq.prototype.Yv;
    nq.prototype.addNode = nq.prototype.xk;
    nq.prototype.addVertex = nq.prototype.Og;
    nq.prototype.addParts = nq.prototype.Ng;
    nq.className = "LayoutNetwork";

    function Bq(a) {
        gb(this);
        F && !a && v("LayoutVertex constructor requires non-null LayoutNetwork argument");
        this.$c = a;
        this.l = (new L(0, 0, 10, 10)).freeze();
        this.w = (new J(5, 5)).freeze();
        this.Vi = this.sb = null;
        this.Ye = new H;
        this.Qe = new H
    }

    Bq.prototype.serializeVertexProperties = function (a) {
        a.id = rb(this);
        a.key = this.node ? this.node.key : this.data ? this.data.Mi : void 0;
        void 0 === a.key && (a.key = null);
        a.x = this.bounds.x;
        a.y = this.bounds.y;
        a.zB = this.bounds.width;
        a.LA = this.bounds.height;
        a.fx = this.focus.x;
        a.fy = this.focus.y;
        var b = [];
        this.Ye.each(function (a) {
            b.push(rb(a))
        });
        a.jz = b;
        var c = [];
        this.Qe.each(function (a) {
            c.push(rb(a))
        });
        a.xy = c
    };
    Bq.prototype.Lq = function (a, b, c) {
        if (null !== a) {
            this.x = a.x;
            this.y = a.y;
            this.width = a.zB;
            this.height = a.LA;
            this.focusX = a.fx;
            this.focusY = a.fy;
            var d = this;
            a.jz && a.jz.forEach(function (a) {
                (a = c.get(a)) && d.Ye.add(a)
            });
            a.xy && a.xy.forEach(function (a) {
                (a = c.get(a)) && d.Qe.add(a)
            })
        }
    };
    Bq.prototype.clear = function () {
        this.Vi = this.sb = null;
        this.Ye = new H;
        this.Qe = new H
    };
    Bq.prototype.toString = function (a) {
        void 0 === a && (a = 0);
        var b = "LayoutVertex#" + rb(this);
        if (0 < a && (b += null !== this.node ? "(" + this.node.toString() + ")" : "", 1 < a)) {
            a = "";
            for (var c = !0, d = this.Ye.iterator; d.next();) {
                var e = d.value;
                c ? c = !1 : a += ",";
                a += e.toString(0)
            }
            e = "";
            c = !0;
            for (d = this.Qe.iterator; d.next();) {
                var f = d.value;
                c ? c = !1 : e += ",";
                e += f.toString(0)
            }
            b += " sources: " + a + " destinations: " + e
        }
        return b
    };
    Bq.prototype.commit = function () {
        var a = this.sb;
        if (null !== a) {
            var b = this.bounds, c = a.bounds;
            Ga(c) ? (c.x = b.x, c.y = b.y, c.width = b.width, c.height = b.height) : a.bounds = b.copy()
        } else if (a = this.node, null !== a) {
            b = this.bounds;
            if (!(a instanceof Kf)) {
                c = L.alloc();
                var d = this.network.layout.xj(a, c), e = a.locationObject.ja(Mc);
                if (d.o() && e.o()) {
                    a.moveTo(b.x + this.focusX - (e.x - d.x), b.y + this.focusY - (e.y - d.y));
                    L.free(c);
                    return
                }
                L.free(c)
            }
            a.moveTo(b.x, b.y)
        }
    };
    Bq.prototype.Pv = function (a) {
        null !== a && (F && w(a, Cq, Bq, "addSourceEdge:edge"), this.Ye.contains(a) || this.Ye.add(a))
    };
    Bq.prototype.Xv = function (a) {
        null !== a && (F && w(a, Cq, Bq, "deleteSourceEdge:edge"), this.Ye.remove(a))
    };
    Bq.prototype.Nv = function (a) {
        null !== a && (F && w(a, Cq, Bq, "addDestinationEdge:edge"), this.Qe.contains(a) || this.Qe.add(a))
    };
    Bq.prototype.Wv = function (a) {
        null !== a && (F && w(a, Cq, Bq, "deleteDestinationEdge:edge"), this.Qe.remove(a))
    };

    function Iq(a, b) {
        F && w(a, Bq, Bq, "standardComparer:m");
        F && w(b, Bq, Bq, "standardComparer:n");
        a = a.Vi;
        b = b.Vi;
        return a ? b ? (a = a.text, b = b.text, a < b ? -1 : a > b ? 1 : 0) : 1 : null !== b ? -1 : 0
    }

    na.Object.defineProperties(Bq.prototype, {
        sourceEdgesArrayAccess: {
            configurable: !0, get: function () {
                return this.Ye._dataArray
            }
        }, destinationEdgesArrayAccess: {
            configurable: !0, get: function () {
                return this.Qe._dataArray
            }
        }, data: {
            configurable: !0, get: function () {
                return this.sb
            }, set: function (a) {
                this.sb = a;
                if (null !== a && a.bounds) {
                    var b = a.bounds;
                    a = b.x;
                    var c = b.y, d = b.width;
                    b = b.height;
                    this.w.h(d / 2, b / 2);
                    this.l.h(a, c, d, b)
                }
            }
        }, node: {
            configurable: !0, get: function () {
                return this.Vi
            },
            set: function (a) {
                if (this.Vi !== a) {
                    F && null !== a && w(a, V, Bq, "node");
                    this.Vi = a;
                    a.Ya();
                    var b = this.network.layout, c = L.alloc(), d = b.xj(a, c);
                    b = d.x;
                    var e = d.y, f = d.width;
                    d = d.height;
                    isNaN(b) && (b = 0);
                    isNaN(e) && (e = 0);
                    this.l.h(b, e, f, d);
                    L.free(c);
                    if (!(a instanceof Kf) && (a = a.locationObject.ja(Mc), a.o())) {
                        this.w.h(a.x - b, a.y - e);
                        return
                    }
                    this.w.h(f / 2, d / 2)
                }
            }
        }, bounds: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                this.l.A(a) || (F && w(a, L, Bq, "bounds"), this.l.assign(a))
            }
        }, focus: {
            configurable: !0,
            get: function () {
                return this.w
            }, set: function (a) {
                this.w.A(a) || (F && w(a, J, Bq, "focus"), this.w.assign(a))
            }
        }, centerX: {
            configurable: !0, get: function () {
                return this.l.x + this.w.x
            }, set: function (a) {
                var b = this.l;
                b.x + this.w.x !== a && (F && C(a, Bq, "centerX"), b.ka(), b.x = a - this.w.x, b.freeze())
            }
        }, centerY: {
            configurable: !0, get: function () {
                return this.l.y + this.w.y
            }, set: function (a) {
                var b = this.l;
                b.y + this.w.y !== a && (F && C(a, Bq, "centerY"), b.ka(), b.y = a - this.w.y, b.freeze())
            }
        }, focusX: {
            configurable: !0,
            get: function () {
                return this.w.x
            }, set: function (a) {
                var b = this.w;
                b.x !== a && (b.ka(), b.x = a, b.freeze())
            }
        }, focusY: {
            configurable: !0, get: function () {
                return this.w.y
            }, set: function (a) {
                var b = this.w;
                b.y !== a && (b.ka(), b.y = a, b.freeze())
            }
        }, x: {
            configurable: !0, get: function () {
                return this.l.x
            }, set: function (a) {
                var b = this.l;
                b.x !== a && (b.ka(), b.x = a, b.freeze())
            }
        }, y: {
            configurable: !0, get: function () {
                return this.l.y
            }, set: function (a) {
                var b = this.l;
                b.y !== a && (b.ka(), b.y = a, b.freeze())
            }
        }, width: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.l.width
            }, set: function (a) {
                var b = this.l;
                b.width !== a && (b.ka(), b.width = a, b.freeze())
            }
        }, height: {
            configurable: !0, get: function () {
                return this.l.height
            }, set: function (a) {
                var b = this.l;
                b.height !== a && (b.ka(), b.height = a, b.freeze())
            }
        }, network: {
            configurable: !0, get: function () {
                return this.$c
            }, set: function (a) {
                F && w(a, nq, Bq, "network");
                this.$c = a
            }
        }, sourceVertexes: {
            configurable: !0, get: function () {
                for (var a = new I, b = this.sourceEdges; b.next();) a.add(b.value.fromVertex);
                return a.iterator
            }
        }, destinationVertexes: {
            configurable: !0, get: function () {
                for (var a = new I, b = this.destinationEdges; b.next();) a.add(b.value.toVertex);
                return a.iterator
            }
        }, vertexes: {
            configurable: !0, get: function () {
                for (var a = new I, b = this.sourceEdges; b.next();) a.add(b.value.fromVertex);
                for (b = this.destinationEdges; b.next();) a.add(b.value.toVertex);
                return a.iterator
            }
        }, sourceEdges: {
            configurable: !0, get: function () {
                return this.Ye.iterator
            }
        }, destinationEdges: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Qe.iterator
            }
        }, edges: {
            configurable: !0, get: function () {
                for (var a = new H, b = this.sourceEdges; b.next();) a.add(b.value);
                for (b = this.destinationEdges; b.next();) a.add(b.value);
                return a.iterator
            }
        }, edgesCount: {
            configurable: !0, get: function () {
                return this.Ye.count + this.Qe.count
            }
        }
    });
    Bq.prototype.deleteDestinationEdge = Bq.prototype.Wv;
    Bq.prototype.addDestinationEdge = Bq.prototype.Nv;
    Bq.prototype.deleteSourceEdge = Bq.prototype.Xv;
    Bq.prototype.addSourceEdge = Bq.prototype.Pv;
    Bq.className = "LayoutVertex";
    Bq.standardComparer = Iq;
    Bq.smartComparer = function (a, b) {
        F && w(a, Bq, Bq, "smartComparer:m");
        F && w(b, Bq, Bq, "smartComparer:n");
        if (null !== a) {
            if (null !== b) {
                a = a.Vi;
                var c = b.Vi;
                if (null !== a) {
                    if (null !== c) {
                        b = a.text.toLocaleLowerCase().split(/([+\-]?[\.]?\d+(?:\.\d*)?(?:e[+\-]?\d+)?)/);
                        a = c.text.toLocaleLowerCase().split(/([+\-]?[\.]?\d+(?:\.\d*)?(?:e[+\-]?\d+)?)/);
                        for (c = 0; c < b.length; c++) if ("" !== a[c] && void 0 !== a[c]) {
                            var d = parseFloat(b[c]), e = parseFloat(a[c]);
                            if (isNaN(d)) if (isNaN(e)) {
                                if (0 !== b[c].localeCompare(a[c])) return b[c].localeCompare(a[c])
                            } else return 1;
                            else {
                                if (isNaN(e)) return -1;
                                if (0 !== d - e) return d - e
                            }
                        } else if ("" !== b[c]) return 1;
                        return "" !== a[c] && void 0 !== a[c] ? -1 : 0
                    }
                    return 1
                }
                return null !== c ? -1 : 0
            }
            return 1
        }
        return null !== b ? -1 : 0
    };

    function Cq(a) {
        gb(this);
        F && !a && v("LayoutEdge constructor requires non-null LayoutNetwork argument");
        this.Zc = a;
        this.Ig = this.ig = this.Zl = this.sb = null
    }

    Cq.prototype.clear = function () {
        this.Ig = this.ig = this.Zl = this.sb = null
    };
    Cq.prototype.serializeEdgeProperties = function (a) {
        a.id = rb(this);
        a.key = this.link ? this.link.key : this.data ? this.data.Mi : void 0;
        void 0 === a.key && (a.key = null);
        a.from = this.fromVertex ? rb(this.fromVertex) : null;
        a.uB = this.toVertex ? rb(this.toVertex) : null
    };
    Cq.prototype.deserializeEdgeProperties = function (a, b) {
        if (null !== a) {
            var c = b.get(a.from);
            c && (this.fromVertex = c);
            if (a = b.get(a.uB)) this.toVertex = a
        }
    };
    Cq.prototype.toString = function (a) {
        void 0 === a && (a = 0);
        var b = "LayoutEdge#" + rb(this);
        0 < a && (b += null !== this.Zl ? "(" + this.Zl.toString() + ")" : "", 1 < a && (b += " " + (this.ig ? this.ig.toString() : "null") + " --\x3e " + (this.Ig ? this.Ig.toString() : "null")));
        return b
    };
    Cq.prototype.cn = function () {
        var a = this.ig;
        this.ig = this.Ig;
        this.Ig = a
    };
    Cq.prototype.commit = function () {
    };
    Cq.prototype.Ny = function (a) {
        F && w(a, Bq, Cq, "getOtherVertex:v");
        return this.Ig === a ? this.ig : this.ig === a ? this.Ig : null
    };
    na.Object.defineProperties(Cq.prototype, {
        network: {
            configurable: !0, get: function () {
                return this.Zc
            }, set: function (a) {
                F && w(a, nq, Cq, "network");
                this.Zc = a
            }
        }, data: {
            configurable: !0, get: function () {
                return this.sb
            }, set: function (a) {
                this.sb !== a && (F && null !== a && A(a, "object", Cq, "data"), this.sb = a)
            }
        }, link: {
            configurable: !0, get: function () {
                return this.Zl
            }, set: function (a) {
                this.Zl !== a && (F && null !== a && w(a, S, Cq, "link"), this.Zl = a)
            }
        }, fromVertex: {
            configurable: !0, get: function () {
                return this.ig
            },
            set: function (a) {
                this.ig !== a && (F && null !== a && w(a, Bq, Cq, "network"), this.ig = a)
            }
        }, toVertex: {
            configurable: !0, get: function () {
                return this.Ig
            }, set: function (a) {
                this.Ig !== a && (F && null !== a && w(a, Bq, Cq, "network"), this.Ig = a)
            }
        }
    });
    Cq.prototype.getOtherVertex = Cq.prototype.Ny;
    Cq.className = "LayoutEdge";

    function dl() {
        0 < arguments.length && Ba(dl);
        Ni.call(this);
        this.isViewportSized = !0;
        this.Aq = this.Bq = NaN;
        this.dh = (new Hb(NaN, NaN)).freeze();
        this.xf = (new Hb(10, 10)).freeze();
        this.Eb = Jq;
        this.Lb = Kq;
        this.hd = Lq;
        this.cd = Mq
    }

    ma(dl, Ni);
    dl.prototype.cloneProtected = function (a) {
        Ni.prototype.cloneProtected.call(this, a);
        a.Bq = this.Bq;
        a.Aq = this.Aq;
        a.dh.assign(this.dh);
        a.xf.assign(this.xf);
        a.Eb = this.Eb;
        a.Lb = this.Lb;
        a.hd = this.hd;
        a.cd = this.cd
    };
    dl.prototype.pb = function (a) {
        a.classType === dl ? a === Lq || a === Nq || a === Oq || a === Pq ? this.sorting = a : a === Kq || a === Qq ? this.arrangement = a : a === Jq || a === Rq ? this.alignment = a : v("Unknown enum value: " + a) : Ni.prototype.pb.call(this, a)
    };
    dl.prototype.doLayout = function (a) {
        F && null === a && v("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts");
        this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
        var b = this.qy(a);
        a = this.diagram;
        for (var c = b.copy().iterator; c.next();) {
            var d = c.value;
            if (!d.Zh() || null === d.fromNode && null === d.toNode) {
                if (d.Ya(), d instanceof Kf) for (d = d.memberParts; d.next();) b.remove(d.value)
            } else b.remove(d)
        }
        var e = b.ta();
        if (0 !== e.length) {
            switch (this.sorting) {
                case Pq:
                    e.reverse();
                    break;
                case Lq:
                    e.sort(this.comparer);
                    break;
                case Nq:
                    e.sort(this.comparer), e.reverse()
            }
            var f = this.wrappingColumn;
            isNaN(f) && (f = 0);
            var g = this.wrappingWidth;
            isNaN(g) && null !== a ? (b = a.padding, g = Math.max(a.viewportBounds.width - b.left - b.right, 0)) : g = Math.max(this.wrappingWidth, 0);
            0 >= f && 0 >= g && (f = 1);
            b = this.spacing.width;
            isFinite(b) || (b = 0);
            c = this.spacing.height;
            isFinite(c) || (c = 0);
            null !== a && a.Ca("Layout");
            d = [];
            switch (this.alignment) {
                case Rq:
                    var h = b, k = c, l = L.alloc(), m = Math.max(this.cellSize.width, 1);
                    if (!isFinite(m)) for (var n =
                        m = 0; n < e.length; n++) {
                        var p = this.xj(e[n], l);
                        m = Math.max(m, p.width)
                    }
                    m = Math.max(m + h, 1);
                    n = Math.max(this.cellSize.height, 1);
                    if (!isFinite(n)) for (p = n = 0; p < e.length; p++) {
                        var r = this.xj(e[p], l);
                        n = Math.max(n, r.height)
                    }
                    n = Math.max(n + k, 1);
                    p = this.arrangement;
                    for (var q = r = this.arrangementOrigin.x, u = this.arrangementOrigin.y, x = 0, y = 0, z = 0; z < e.length; z++) {
                        var B = e[z], D = this.xj(B, l), G = Math.ceil((D.width + h) / m) * m,
                            O = Math.ceil((D.height + k) / n) * n;
                        switch (p) {
                            case Qq:
                                var U = Math.abs(q - D.width);
                                break;
                            default:
                                U = q + D.width
                        }
                        if (0 < f && x > f - 1 ||
                            0 < g && 0 < x && U - r > g) d.push(new L(0, u, g + h, y)), x = 0, q = r, u += y, y = 0;
                        y = Math.max(y, O);
                        switch (p) {
                            case Qq:
                                D = -D.width;
                                break;
                            default:
                                D = 0
                        }
                        B.moveTo(q + D, u);
                        switch (p) {
                            case Qq:
                                q -= G;
                                break;
                            default:
                                q += G
                        }
                        x++
                    }
                    d.push(new L(0, u, g + h, y));
                    L.free(l);
                    break;
                case Jq:
                    k = g;
                    m = f;
                    n = b;
                    p = c;
                    g = L.alloc();
                    r = Math.max(this.cellSize.width, 1);
                    f = u = l = 0;
                    h = J.alloc();
                    for (q = 0; q < e.length; q++) y = e[q], x = this.xj(y, g), y = y.Pf(y.locationObject, y.locationSpot, h), l = Math.max(l, y.x), u = Math.max(u, x.width - y.x), f = Math.max(f, y.y);
                    q = this.arrangement;
                    switch (q) {
                        case Qq:
                            l +=
                                n;
                            break;
                        default:
                            u += n
                    }
                    r = isFinite(r) ? Math.max(r + n, 1) : Math.max(l + u, 1);
                    var R = y = this.arrangementOrigin.x;
                    z = this.arrangementOrigin.y;
                    u = 0;
                    k >= l && (k -= l);
                    l = B = 0;
                    G = Math.max(this.cellSize.height, 1);
                    D = f = 0;
                    O = !0;
                    x = J.alloc();
                    for (U = 0; U < e.length; U++) {
                        var fa = e[U], Y = this.xj(fa, g), P = fa.Pf(fa.locationObject, fa.locationSpot, h);
                        if (0 < u) switch (q) {
                            case Qq:
                                R = (R - y - (Y.width - P.x)) / r;
                                R = K.da(Math.round(R), R) ? Math.round(R) : Math.floor(R);
                                R = R * r + y;
                                break;
                            default:
                                R = (R - y + P.x) / r, R = K.da(Math.round(R), R) ? Math.round(R) : Math.ceil(R), R = R * r + y
                        } else switch (q) {
                            case Qq:
                                B =
                                    R + P.x + Y.width;
                                break;
                            default:
                                B = R - P.x
                        }
                        switch (q) {
                            case Qq:
                                var ya = -(R + P.x) + B;
                                break;
                            default:
                                ya = R + Y.width - P.x - B
                        }
                        if (0 < m && u > m - 1 || 0 < k && 0 < u && ya > k) {
                            d.push(new L(0, O ? z - f : z, k + n, D + f + p));
                            for (R = 0; R < u && U !== u; R++) {
                                ya = e[U - u + R];
                                var ka = ya.Pf(ya.locationObject, ya.locationSpot, x);
                                ya.moveTo(ya.position.x, ya.position.y + f - ka.y)
                            }
                            D += p;
                            z = O ? z + D : z + (D + f);
                            u = D = f = 0;
                            R = y;
                            O = !1
                        }
                        R === y && (l = q === Qq ? Math.max(l, Y.width - P.x) : Math.min(l, -P.x));
                        f = Math.max(f, P.y);
                        D = Math.max(D, Y.height - P.y);
                        isFinite(G) && (D = Math.max(D, Math.max(Y.height, G) - P.y));
                        O ?
                            fa.moveTo(R - P.x, z - P.y) : fa.moveTo(R - P.x, z);
                        switch (q) {
                            case Qq:
                                R -= P.x + n;
                                break;
                            default:
                                R += Y.width - P.x + n
                        }
                        u++
                    }
                    d.push(new L(0, z, k + n, (O ? D : D + f) + p));
                    if (e.length !== u) for (k = 0; k < u; k++) m = e[e.length - u + k], n = m.Pf(m.locationObject, m.locationSpot, h), m.moveTo(m.position.x, m.position.y + f - n.y);
                    J.free(h);
                    J.free(x);
                    if (q === Qq) for (e = 0; e < d.length; e++) f = d[e], f.width += l, f.x -= l; else for (e = 0; e < d.length; e++) f = d[e], f.x > l && (f.width += f.x - l, f.x = l);
                    L.free(g)
            }
            for (h = f = g = e = 0; h < d.length; h++) k = d[h], e = Math.min(e, k.x), g = Math.min(g, k.y), f = Math.max(f,
                k.x + k.width);
            this.arrangement === Qq ? this.commitLayers(d, new J(e + b / 2 - (f + e), g - c / 2)) : this.commitLayers(d, new J(e - b / 2, g - c / 2));
            null !== a && a.bb("Layout");
            this.isValidLayout = !0
        }
    };
    dl.prototype.commitLayers = function () {
    };

    function Mq(a, b) {
        F && w(a, T, dl, "standardComparer:a");
        F && w(b, T, dl, "standardComparer:b");
        a = a.text;
        b = b.text;
        return a < b ? -1 : a > b ? 1 : 0
    }

    na.Object.defineProperties(dl.prototype, {
        wrappingWidth: {
            configurable: !0, get: function () {
                return this.Bq
            }, set: function (a) {
                this.Bq !== a && (A(a, "number", dl, "wrappingWidth"), 0 < a || isNaN(a)) && (this.Bq = a, this.isViewportSized = isNaN(a), this.D())
            }
        }, wrappingColumn: {
            configurable: !0, get: function () {
                return this.Aq
            }, set: function (a) {
                this.Aq !== a && (A(a, "number", dl, "wrappingColumn"), 0 < a || isNaN(a)) && (this.Aq = a, this.D())
            }
        }, cellSize: {
            configurable: !0, get: function () {
                return this.dh
            }, set: function (a) {
                w(a,
                    Hb, dl, "cellSize");
                this.dh.A(a) || (this.dh.assign(a), this.D())
            }
        }, spacing: {
            configurable: !0, get: function () {
                return this.xf
            }, set: function (a) {
                w(a, Hb, dl, "spacing");
                this.xf.A(a) || (this.xf.assign(a), this.D())
            }
        }, alignment: {
            configurable: !0, get: function () {
                return this.Eb
            }, set: function (a) {
                this.Eb !== a && (ib(a, dl, dl, "alignment"), a === Jq || a === Rq) && (this.Eb = a, this.D())
            }
        }, arrangement: {
            configurable: !0, get: function () {
                return this.Lb
            }, set: function (a) {
                this.Lb !== a && (ib(a, dl, dl, "arrangement"),
                a === Kq || a === Qq) && (this.Lb = a, this.D())
            }
        }, sorting: {
            configurable: !0, get: function () {
                return this.hd
            }, set: function (a) {
                this.hd !== a && (ib(a, dl, dl, "sorting"), a === Oq || a === Pq || a === Lq || a === Nq) && (this.hd = a, this.D())
            }
        }, comparer: {
            configurable: !0, get: function () {
                return this.cd
            }, set: function (a) {
                this.cd !== a && (A(a, "function", dl, "comparer"), this.cd = a, this.D())
            }
        }
    });
    var Rq = new E(dl, "Position", 0), Jq = new E(dl, "Location", 1), Kq = new E(dl, "LeftToRight", 2),
        Qq = new E(dl, "RightToLeft", 3), Oq = new E(dl, "Forward", 4), Pq = new E(dl, "Reverse", 5),
        Lq = new E(dl, "Ascending", 6), Nq = new E(dl, "Descending", 7);
    dl.className = "GridLayout";
    dl.standardComparer = Mq;
    dl.smartComparer = function (a, b) {
        F && w(a, T, dl, "standardComparer:a");
        F && w(b, T, dl, "standardComparer:b");
        if (null !== a) {
            if (null !== b) {
                a = a.text.toLocaleLowerCase().split(/([+\-]?[\.]?\d+(?:\.\d*)?(?:e[+\-]?\d+)?)/);
                b = b.text.toLocaleLowerCase().split(/([+\-]?[\.]?\d+(?:\.\d*)?(?:e[+\-]?\d+)?)/);
                for (var c = 0; c < a.length; c++) if ("" !== b[c] && void 0 !== b[c]) {
                    var d = parseFloat(a[c]), e = parseFloat(b[c]);
                    if (isNaN(d)) if (isNaN(e)) {
                        if (0 !== a[c].localeCompare(b[c])) return a[c].localeCompare(b[c])
                    } else return 1; else {
                        if (isNaN(e)) return -1;
                        if (0 !== d - e) return d - e
                    }
                } else if ("" !== a[c]) return 1;
                return "" !== b[c] && void 0 !== b[c] ? -1 : 0
            }
            return 1
        }
        return null !== b ? -1 : 0
    };
    dl.Position = Rq;
    dl.Location = Jq;
    dl.LeftToRight = Kq;
    dl.RightToLeft = Qq;
    dl.Forward = Oq;
    dl.Reverse = Pq;
    dl.Ascending = Lq;
    dl.Descending = Nq;

    function Ii() {
        this.sp = new I;
        this.Uo = new I;
        this.Ia = new I;
        this.ef = new Db;
        this.df = new Db;
        this.$j = new Db;
        this.B = null;
        this.Br = !1
    }

    t = Ii.prototype;
    t.clear = function () {
        this.sp.clear();
        this.Uo.clear();
        this.Ia.clear();
        this.ef.clear();
        this.df.clear();
        this.$j.clear()
    };
    t.ie = function (a) {
        F && null !== a && w(a, Q, Ii, "setDiagram");
        this.B = a
    };
    t.yj = function (a) {
        if (a instanceof V) {
            if (this.sp.add(a), a instanceof Kf) {
                var b = a.containingGroup;
                null === b ? this.B.Nh.add(a) : b.dm.add(a);
                b = a.layout;
                null !== b && (b.diagram = this.B)
            }
        } else a instanceof S ? this.Uo.add(a) : a instanceof Xe || this.Ia.add(a);
        b = a.data;
        null === b || a instanceof Xe || (a instanceof S ? this.df.add(b, a) : this.ef.add(b, a))
    };
    t.Rc = function (a) {
        a.yk();
        if (a instanceof V) {
            if (this.sp.remove(a), a instanceof Kf) {
                var b = a.containingGroup;
                null === b ? this.B.Nh.remove(a) : b.dm.remove(a);
                b = a.layout;
                null !== b && (b.diagram = null)
            }
        } else a instanceof S ? this.Uo.remove(a) : a instanceof Xe || this.Ia.remove(a);
        b = a.data;
        null === b || a instanceof Xe || (a instanceof S ? this.df.remove(b) : this.ef.remove(b))
    };
    t.Nd = function () {
        for (var a = this.B.nodeTemplateMap.iterator; a.next();) {
            var b = a.value, c = a.key;
            (!b.Tc() || b instanceof Kf) && v('Invalid node template in Diagram.nodeTemplateMap: template for "' + c + '" must be a Node or a simple Part, not a Group or Link: ' + b)
        }
        for (a = this.B.groupTemplateMap.iterator; a.next();) b = a.value, c = a.key, b instanceof Kf || v('Invalid group template in Diagram.groupTemplateMap: template for "' + c + '" must be a Group, not a normal Node or Link: ' + b);
        for (a = this.B.linkTemplateMap.iterator; a.next();) b =
            a.value, c = a.key, b instanceof S || v('Invalid link template in Diagram.linkTemplateMap: template for "' + c + '" must be a Link, not a normal Node or simple Part: ' + b);
        a = Ma();
        for (b = this.B.selection.iterator; b.next();) (c = b.value.data) && a.push(c);
        b = Ma();
        for (c = this.B.highlighteds.iterator; c.next();) {
            var d = c.value.data;
            d && b.push(d)
        }
        c = Ma();
        for (d = this.nodes.iterator; d.next();) {
            var e = d.value;
            null !== e.data && (c.push(e.data), c.push(e.location))
        }
        for (d = this.links.iterator; d.next();) e = d.value, null !== e.data && (c.push(e.data),
            c.push(e.location));
        for (d = this.parts.iterator; d.next();) e = d.value, null !== e.data && (c.push(e.data), c.push(e.location));
        this.removeAllModeledParts();
        this.addAllModeledParts();
        for (d = 0; d < a.length; d++) e = this.Fc(a[d]), null !== e && (e.isSelected = !0);
        for (d = 0; d < b.length; d++) e = this.Fc(b[d]), null !== e && (e.isHighlighted = !0);
        for (d = 0; d < c.length; d += 2) e = this.Fc(c[d]), null !== e && (e.location = c[d + 1]);
        Oa(a);
        Oa(b);
        Oa(c)
    };
    Ii.prototype.addAllModeledParts = function () {
        this.addModeledParts(this.diagram.model.nodeDataArray)
    };
    Ii.prototype.addModeledParts = function (a, b) {
        var c = this, d = this.diagram.model;
        a.forEach(function (a) {
            d.$a(a) && Sq(c, a, !1)
        });
        a.forEach(function (a) {
            d.$a(a) && c.resolveReferencesForData(a)
        });
        !1 !== b && rk(this.diagram, !1)
    };

    function Sq(a, b, c) {
        if (void 0 !== b && null !== b && !a.diagram.undoManager.isUndoingRedoing && !a.ef.contains(b)) {
            void 0 === c && (c = !0);
            a:{
                if (void 0 !== b && null !== b && !a.B.undoManager.isUndoingRedoing && !a.ef.contains(b)) {
                    var d = a.Rq(b);
                    var e = cp(a, b, d);
                    if (null !== e && (Ng(e), e = e.copy(), null !== e)) {
                        var f = a.diagram.skipsModelSourceBindings;
                        a.diagram.skipsModelSourceBindings = !0;
                        e.Zf = d;
                        e.sb = b;
                        a.Br && (e.uh = "Tool");
                        a.diagram.add(e);
                        e.sb = null;
                        e.data = b;
                        a.diagram.skipsModelSourceBindings = f;
                        d = e;
                        break a
                    }
                }
                d = null
            }
            null !== d && c && a.resolveReferencesForData(b)
        }
    }

    Ii.prototype.insertLink = function () {
        return null
    };
    Ii.prototype.resolveReferencesForData = function () {
    };
    Ii.prototype.Rq = function (a) {
        return this.B.model.Rq(a)
    };

    function cp(a, b, c) {
        a = a.B;
        var d = a.model;
        d.zj() && d.eu(b) ? (b = a.groupTemplateMap.K(c), null === b && (b = a.groupTemplateMap.K(""), null === b && (Tq || (Tq = !0, Ea('No Group template found for category "' + c + '"'), Ea("  Using default group template")), b = a.Ou))) : (b = a.nodeTemplateMap.K(c), null === b && (b = a.nodeTemplateMap.K(""), null === b && (Uq || (Uq = !0, Ea('No Node template found for category "' + c + '"'), Ea("  Using default node template")), b = a.Qu)));
        return b
    }

    Ii.prototype.getLinkCategoryForData = function () {
        return ""
    };
    Ii.prototype.setLinkCategoryForData = function () {
    };
    Ii.prototype.setFromNodeForLink = function () {
    };
    Ii.prototype.setToNodeForLink = function () {
    };
    Ii.prototype.findLinkTemplateForCategory = function (a) {
        var b = this.B.linkTemplateMap.K(a);
        null === b && (b = this.B.linkTemplateMap.K(""), null === b && (Vq || (Vq = !0, Ea('No Link template found for category "' + a + '"'), Ea("  Using default link template")), b = this.B.Pu));
        return b
    };
    Ii.prototype.removeAllModeledParts = function () {
        this.qu(this.diagram.model.nodeDataArray)
    };
    Ii.prototype.qu = function (a) {
        var b = this;
        a.forEach(function (a) {
            b.mr(a)
        })
    };
    Ii.prototype.mr = function (a) {
        a = this.Fc(a);
        null !== a && (ak(this.diagram, a, !1), this.unresolveReferencesForPart(a))
    };
    Ii.prototype.unresolveReferencesForPart = function () {
    };
    Ii.prototype.removeDataForLink = function () {
    };
    Ii.prototype.findPartForKey = function (a) {
        if (null === a || void 0 === a) return null;
        a = this.B.model.Rb(a);
        return null !== a ? this.ef.K(a) : null
    };
    Ii.prototype.Ib = function (a) {
        if (null === a || void 0 === a) return null;
        a = this.B.model.Rb(a);
        if (null === a) return null;
        a = this.ef.K(a);
        return a instanceof V ? a : null
    };
    Ii.prototype.findLinkForKey = function () {
        return null
    };
    t = Ii.prototype;
    t.Fc = function (a) {
        if (null === a) return null;
        var b = this.ef.K(a);
        return null !== b ? b : b = this.df.K(a)
    };
    t.qj = function (a) {
        if (null === a) return null;
        a = this.ef.K(a);
        return a instanceof V ? a : null
    };
    t.Ec = function (a) {
        return null === a ? null : this.df.K(a)
    };
    t.Ut = function (a) {
        for (var b = 0; b < arguments.length; ++b) ;
        b = new I;
        for (var c = this.sp.iterator; c.next();) {
            var d = c.value, e = d.data;
            if (null !== e) for (var f = 0; f < arguments.length; f++) {
                var g = arguments[f];
                if (Ga(g) && Wq(this, e, g)) {
                    b.add(d);
                    break
                }
            }
        }
        return b.iterator
    };
    t.Tt = function (a) {
        for (var b = 0; b < arguments.length; ++b) ;
        b = new I;
        for (var c = this.Uo.iterator; c.next();) {
            var d = c.value, e = d.data;
            if (null !== e) for (var f = 0; f < arguments.length; f++) {
                var g = arguments[f];
                if (Ga(g) && Wq(this, e, g)) {
                    b.add(d);
                    break
                }
            }
        }
        return b.iterator
    };

    function Wq(a, b, c) {
        for (var d in c) {
            var e = b[d], f = c[d];
            if (Ha(f)) {
                if (!Ha(e) || e.length < f.length) return !1;
                for (var g = 0; g < e.length; g++) {
                    var h = f[g];
                    if (void 0 !== h && !Xq(a, e[g], h)) return !1
                }
            } else if (!Xq(a, e, f)) return !1
        }
        return !0
    }

    function Xq(a, b, c) {
        if ("function" === typeof c) {
            if (!c(b)) return !1
        } else if (c instanceof RegExp) {
            if (!b || !c.test(b.toString())) return !1
        } else if (Ga(b) && Ga(c)) {
            if (!Wq(a, b, c)) return !1
        } else if (b !== c) return !1;
        return !0
    }

    Ii.prototype.doModelChanged = function (a) {
        if (this.B) {
            var b = this.B;
            if (a.model === b.model) {
                var c = a.change;
                b.doModelChanged(a);
                if (b.ba) {
                    b.ba = !1;
                    try {
                        var d = a.modelChange;
                        if ("" !== d) if (c === Le) {
                            if ("nodeCategory" === d) {
                                var e = this.Fc(a.object), f = a.newValue;
                                null !== e && "string" === typeof f && (e.category = f)
                            } else "nodeDataArray" === d && (this.qu(a.oldValue), this.addModeledParts(a.newValue));
                            b.isModified = !0
                        } else if (c === Ne) {
                            var g = a.newValue;
                            "nodeDataArray" === d && Ga(g) && Sq(this, g);
                            b.isModified = !0
                        } else if (c === Oe) {
                            var h = a.oldValue;
                            "nodeDataArray" === d && Ga(h) && this.mr(h);
                            b.isModified = !0
                        } else c === Me && ("SourceChanged" === d ? null !== a.object ? this.updateDataBindings(a.object, a.propertyName) : (this.xr(), this.updateAllTargetBindings()) : "ModelDisplaced" === d && this.Nd()); else if (c === Le) {
                            var k = a.propertyName, l = a.object;
                            if (l === b.model) {
                                if ("nodeKeyProperty" === k || "nodeCategoryProperty" === k) b.undoManager.isUndoingRedoing || this.Nd()
                            } else this.updateDataBindings(l, k);
                            b.isModified = !0
                        } else if (c === Ne || c === Oe) {
                            var m = a.change === Ne, n = m ? a.newParam : a.oldParam,
                                p = m ? a.newValue : a.oldValue, r = this.$j.K(a.object);
                            if (Array.isArray(r)) for (a = 0; a < r.length; a++) {
                                var q = r[a];
                                if (m) En(q, p, n); else if (!(0 > n)) {
                                    var u = n + wn(q);
                                    q.Rc(u, !0);
                                    In(q, u, n)
                                }
                            }
                            b.isModified = !0
                        }
                    } finally {
                        b.ba = !0
                    }
                }
            }
        }
    };
    Ii.prototype.updateAllTargetBindings = function (a) {
        void 0 === a && (a = "");
        for (var b = this.parts.iterator; b.next();) b.value.Ha(a);
        for (b = this.nodes.iterator; b.next();) b.value.Ha(a);
        for (b = this.links.iterator; b.next();) b.value.Ha(a)
    };
    Ii.prototype.xr = function () {
        for (var a = this.B.model, b = new I, c = a.nodeDataArray, d = 0; d < c.length; d++) b.add(c[d]);
        var e = [];
        this.nodes.each(function (a) {
            null === a.data || b.contains(a.data) || e.push(a.data)
        });
        this.parts.each(function (a) {
            null === a.data || b.contains(a.data) || e.push(a.data)
        });
        e.forEach(function (b) {
            Yq(a, b, !1)
        });
        for (d = 0; d < c.length; d++) {
            var f = c[d];
            null === this.Fc(f) && Zq(a, f, !1)
        }
        this.refreshDataBoundLinks();
        for (c = this.parts.iterator; c.next();) c.value.updateRelationshipsFromData();
        for (c = this.nodes.iterator; c.next();) c.value.updateRelationshipsFromData();
        for (c = this.links.iterator; c.next();) c.value.updateRelationshipsFromData()
    };
    Ii.prototype.refreshDataBoundLinks = function () {
    };
    Ii.prototype.updateRelationshipsFromData = function () {
    };
    Ii.prototype.updateDataBindings = function (a, b) {
        if ("string" === typeof b) {
            var c = this.Fc(a);
            if (null !== c) c.Ha(b); else {
                c = null;
                for (var d = this.$j.iterator; d.next();) {
                    for (var e = d.value, f = 0; f < e.length; f++) {
                        var g = e[f].Fy(a);
                        null !== g && (null === c && (c = Ma()), c.push(g))
                    }
                    if (null !== c) break
                }
                if (null !== c) {
                    for (d = 0; d < c.length; d++) c[d].Ha(b);
                    Oa(c)
                }
            }
            a === this.diagram.model.modelData && this.updateAllTargetBindings(b)
        }
    };

    function Wj(a, b) {
        var c = b.Li;
        if (Ha(c)) {
            var d = a.$j.K(c);
            if (null === d) d = [], d.push(b), a.$j.add(c, d); else {
                for (a = 0; a < d.length; a++) if (d[a] === b) return;
                d.push(b)
            }
        }
    }

    function Zj(a, b, c) {
        Uj(b, function (a) {
            a = a.$.j;
            for (var b = a.length, d = 0; d < b; d++) pk(c, a[d])
        });
        var d = b.Li;
        if (Ha(d)) {
            var e = a.$j.K(d);
            if (null !== e) for (var f = 0; f < e.length; f++) if (e[f] === b) {
                e.splice(f, 1);
                0 === e.length && a.$j.remove(d);
                break
            }
        }
    }

    Ii.prototype.Dk = function (a, b, c) {
        var d = new Db;
        if (Ha(a)) for (var e = 0; e < a.length; e++) $q(this, a[e], b, d, c); else for (a = a.iterator; a.next();) $q(this, a.value, b, d, c);
        if (null !== b) {
            c = b.model;
            a = b.toolManager.findTool("Dragging");
            a = null !== a ? a.dragOptions.dragsLink : b.ul.dragsLink;
            e = new I;
            for (var f = new Db, g = d.iterator; g.next();) {
                var h = g.value;
                if (h instanceof S) a || null !== h.fromNode && null !== h.toNode || e.add(h); else if (h instanceof V && null !== h.data && c.Qm()) {
                    var k = h;
                    h = g.key;
                    var l = h.Sg();
                    null !== l && (l = d.K(l), null !== l ? (c.je(k.data,
                        c.pa(l.data)), k = b.Ec(k.data), h = h.tj(), null !== h && null !== k && f.add(h, k)) : c.je(k.data, void 0))
                }
            }
            0 < e.count && b.ru(e, !1);
            if (0 < f.count) for (c = f.iterator; c.next();) d.add(c.key, c.value)
        }
        if (null !== b && null !== this.B && (b = b.model, c = b.afterCopyFunction, null !== c)) {
            var m = new Db;
            d.each(function (a) {
                null !== a.key.data && m.add(a.key.data, a.value.data)
            });
            c(m, b, this.B.model)
        }
        for (b = d.iterator; b.next();) b.value.Ha();
        return d
    };

    function $q(a, b, c, d, e) {
        if (null === b || e && !b.canCopy()) return null;
        if (d.contains(b)) return d.K(b);
        var f = a.copyPartData(b, c);
        if (!(f instanceof T)) return null;
        f.isSelected = !1;
        f.isHighlighted = !1;
        d.add(b, f);
        if (b instanceof V) {
            for (var g = b.linksConnected; g.next();) {
                var h = g.value;
                if (h.fromNode === b) {
                    var k = d.K(h);
                    null !== k && (k.fromNode = f)
                }
                h.toNode === b && (h = d.K(h), null !== h && (h.toNode = f))
            }
            if (b instanceof Kf && f instanceof Kf) for (b = b.memberParts; b.next();) g = $q(a, b.value, c, d, e), g instanceof S || null === g || (g.containingGroup =
                f)
        } else if (b instanceof S && f instanceof S) for (g = b.fromNode, null !== g && (g = d.K(g), null !== g && (f.fromNode = g)), g = b.toNode, null !== g && (g = d.K(g), null !== g && (f.toNode = g)), b = b.labelNodes; b.next();) g = $q(a, b.value, c, d, e), null !== g && g instanceof V && (g.labeledLink = f);
        return f
    }

    Ii.prototype.copyPartData = function (a, b) {
        var c = null, d = a.data;
        if (null !== d && null !== b) {
            var e = b.model;
            a instanceof S || (d = e.copyNodeData(d), Ga(d) && (e.Gf(d), c = b.Fc(d)))
        } else Ng(a), c = a.copy(), null !== c && (e = this.B, null !== b ? b.add(c) : null !== d && null !== e && null !== e.commandHandler && e.commandHandler.copiesClipboardData && (b = e.model, e = null, c instanceof S || (e = b.copyNodeData(d)), Ga(e) && (c.data = e)));
        return c
    };
    na.Object.defineProperties(Ii.prototype, {
        nodes: {
            configurable: !0, get: function () {
                return this.sp
            }
        }, links: {
            configurable: !0, get: function () {
                return this.Uo
            }
        }, parts: {
            configurable: !0, get: function () {
                return this.Ia
            }
        }, diagram: {
            configurable: !0, get: function () {
                return this.B
            }
        }, addsToTemporaryLayer: {
            configurable: !0, get: function () {
                return this.Br
            }, set: function (a) {
                A(a, "boolean", Ii, "addsToTemporaryLayer");
                this.Br = a
            }
        }
    });
    Ii.prototype.updateAllRelationshipsFromData = Ii.prototype.xr;
    Ii.prototype.findLinksByExample = Ii.prototype.Tt;
    Ii.prototype.findNodesByExample = Ii.prototype.Ut;
    Ii.prototype.findLinkForData = Ii.prototype.Ec;
    Ii.prototype.findNodeForData = Ii.prototype.qj;
    Ii.prototype.findPartForData = Ii.prototype.Fc;
    Ii.prototype.findNodeForKey = Ii.prototype.Ib;
    Ii.prototype.removeModeledPart = Ii.prototype.mr;
    Ii.prototype.removeModeledParts = Ii.prototype.qu;
    Ii.prototype.rebuildParts = Ii.prototype.Nd;
    var Uq = !1, Tq = !1, Vq = !1;
    Ii.className = "PartManager";

    function ar(a) {
        Ii.apply(this, arguments)
    }

    ma(ar, Ii);
    ar.prototype.addAllModeledParts = function () {
        var a = this.diagram.model;
        this.addModeledParts(a.nodeDataArray);
        br(this, a.linkDataArray)
    };
    ar.prototype.addModeledParts = function (a) {
        Ii.prototype.addModeledParts.call(this, a, !1);
        for (a = this.links.iterator; a.next();) dp(a.value);
        rk(this.diagram, !1)
    };

    function br(a, b) {
        b.forEach(function (b) {
            cr(a, b)
        });
        rk(a.diagram, !1)
    }

    function cr(a, b) {
        if (void 0 !== b && null !== b && !a.diagram.undoManager.isUndoingRedoing && !a.df.contains(b)) {
            var c = a.getLinkCategoryForData(b), d = a.findLinkTemplateForCategory(c);
            if (null !== d) {
                Ng(d);
                var e = d.copy();
                if (null !== e) {
                    d = a.diagram.skipsModelSourceBindings;
                    a.diagram.skipsModelSourceBindings = !0;
                    e.Zf = c;
                    e.sb = b;
                    c = a.diagram.model;
                    var f = dr(c, b, !0);
                    "" !== f && (e.fromPortId = f);
                    f = er(c, b, !0);
                    void 0 !== f && (f = a.Ib(f), f instanceof V && (e.fromNode = f));
                    f = dr(c, b, !1);
                    "" !== f && (e.toPortId = f);
                    f = er(c, b, !1);
                    void 0 !== f && (f = a.Ib(f),
                    f instanceof V && (e.toNode = f));
                    c = c.Nf(b);
                    Array.isArray(c) && c.forEach(function (b) {
                        b = a.Ib(b);
                        null !== b && (b.labeledLink = e)
                    });
                    a.Br && (e.uh = "Tool");
                    a.diagram.add(e);
                    e.sb = null;
                    e.data = b;
                    a.diagram.skipsModelSourceBindings = d
                }
            }
        }
    }

    ar.prototype.removeAllModeledParts = function () {
        var a = this.diagram.model;
        fr(this, a.linkDataArray);
        this.qu(a.nodeDataArray)
    };

    function fr(a, b) {
        b.forEach(function (b) {
            a.mr(b)
        })
    }

    ar.prototype.getLinkCategoryForData = function (a) {
        return this.diagram.model.Xt(a)
    };
    ar.prototype.setLinkCategoryForData = function (a, b) {
        return this.diagram.model.qr(a, b)
    };
    ar.prototype.setFromNodeForLink = function (a, b) {
        var c = this.diagram.model;
        c.Nw(a.data, c.pa(null !== b ? b.data : null))
    };
    ar.prototype.setToNodeForLink = function (a, b) {
        var c = this.diagram.model;
        c.Sw(a.data, c.pa(null !== b ? b.data : null))
    };
    ar.prototype.removeDataForLink = function (a) {
        this.diagram.model.Ym(a.data)
    };
    ar.prototype.findPartForKey = function (a) {
        var b = Ii.prototype.findPartForKey.call(this, a);
        return null === b && (a = this.diagram.model.Qg(a), null !== a) ? this.df.K(a) : b
    };
    ar.prototype.findLinkForKey = function (a) {
        if (null === a || void 0 === a) return null;
        a = this.diagram.model.Qg(a);
        return null !== a ? this.df.K(a) : null
    };
    ar.prototype.doModelChanged = function (a) {
        var b = this;
        Ii.prototype.doModelChanged.call(this, a);
        if (this.diagram) {
            var c = this.diagram;
            if (a.model === c.model) {
                var d = a.change;
                if (c.ba) {
                    c.ba = !1;
                    try {
                        var e = a.modelChange;
                        if ("" !== e) if (d === Le) {
                            if ("linkFromKey" === e) {
                                var f = this.Ec(a.object);
                                if (null !== f) {
                                    var g = this.Ib(a.newValue);
                                    f.fromNode = g
                                }
                            } else if ("linkToKey" === e) {
                                var h = this.Ec(a.object);
                                if (null !== h) {
                                    var k = this.Ib(a.newValue);
                                    h.toNode = k
                                }
                            } else if ("linkFromPortId" === e) {
                                var l = this.Ec(a.object);
                                if (null !== l) {
                                    var m = a.newValue;
                                    "string" === typeof m && (l.fromPortId = m)
                                }
                            } else if ("linkToPortId" === e) {
                                var n = this.Ec(a.object);
                                if (null !== n) {
                                    var p = a.newValue;
                                    "string" === typeof p && (n.toPortId = p)
                                }
                            } else if ("nodeGroupKey" === e) {
                                var r = this.Fc(a.object);
                                if (null !== r) {
                                    var q = a.newValue;
                                    if (void 0 !== q) {
                                        var u = this.Ib(q);
                                        u instanceof Kf ? r.containingGroup = u : r.containingGroup = null
                                    } else r.containingGroup = null
                                }
                            } else if ("linkLabelKeys" === e) {
                                var x = this.Ec(a.object);
                                if (null !== x) {
                                    var y = a.oldValue, z = a.newValue;
                                    Array.isArray(y) && y.forEach(function (a) {
                                        0 <= z.indexOf(a) ||
                                        (a = b.Ib(a), null !== a && (a.labeledLink = null))
                                    });
                                    Array.isArray(z) && z.forEach(function (a) {
                                        a = b.Ib(a);
                                        null !== a && (a.labeledLink = x)
                                    })
                                }
                            } else if ("linkCategory" === e) {
                                var B = this.Ec(a.object), D = a.newValue;
                                null !== B && "string" === typeof D && (B.category = D)
                            } else "linkDataArray" === e && (fr(this, a.oldValue), br(this, a.newValue));
                            c.isModified = !0
                        } else if (d === Ne) {
                            var G = a.newValue;
                            if ("linkDataArray" === e && "object" === typeof G && null !== G) cr(this, G); else if ("linkLabelKeys" === e && gr(G)) {
                                var O = this.Ec(a.object), U = this.Ib(G);
                                null !== O &&
                                null !== U && (U.labeledLink = O)
                            }
                            c.isModified = !0
                        } else {
                            if (d === Oe) {
                                var R = a.oldValue;
                                if ("linkDataArray" === e && "object" === typeof R && null !== R) this.mr(R); else if ("linkLabelKeys" === e && gr(R)) {
                                    var fa = this.Ib(R);
                                    null !== fa && (fa.labeledLink = null)
                                }
                                c.isModified = !0
                            }
                        } else if (d === Le) {
                            var Y = a.propertyName;
                            a.object !== c.model || "linkFromKeyProperty" !== Y && "linkToKeyProperty" !== Y && "linkFromPortIdProperty" !== Y && "linkToPortIdProperty" !== Y && "linkLabelKeysProperty" !== Y && "nodeIsGroupProperty" !== Y && "nodeGroupKeyProperty" !== Y && "linkCategoryProperty" !==
                            Y || c.undoManager.isUndoingRedoing || this.Nd();
                            c.isModified = !0
                        }
                    } finally {
                        c.ba = !0
                    }
                }
            }
        }
    };
    ar.prototype.refreshDataBoundLinks = function () {
        var a = this, b = this.diagram.model, c = new I, d = b.linkDataArray;
        d.forEach(function (a) {
            c.add(a)
        });
        var e = [];
        this.links.each(function (a) {
            null === a.data || c.contains(a.data) || e.push(a.data)
        });
        e.forEach(function (a) {
            hr(b, a, !1)
        });
        d.forEach(function (c) {
            null === a.Ec(c) && ir(b, c, !1)
        })
    };
    ar.prototype.updateRelationshipsFromData = function (a) {
        var b = a.data;
        if (null !== b) {
            var c = a.diagram;
            if (null !== c) {
                var d = c.model;
                if (a instanceof S) {
                    var e = er(d, b, !0);
                    e = c.Ib(e);
                    a.fromNode = e;
                    e = er(d, b, !1);
                    e = c.Ib(e);
                    a.toNode = e;
                    b = d.Nf(b);
                    if (0 < b.length || 0 < a.labelNodes.count) {
                        if (1 === b.length && 1 === a.labelNodes.count) {
                            e = b[0];
                            var f = a.labelNodes.first();
                            if (d.pa(f.data) === e) return
                        }
                        e = (new I).addAll(b);
                        var g = new I;
                        a.labelNodes.each(function (a) {
                            null !== a.data && (a = d.pa(a.data), void 0 !== a && g.add(a))
                        });
                        b = g.copy();
                        b.lr(e);
                        e =
                            e.copy();
                        e.lr(g);
                        if (0 < b.count || 0 < e.count) b.each(function (b) {
                            b = c.Ib(b);
                            null !== b && b.labeledLink === a && (b.labeledLink = null)
                        }), e.each(function (b) {
                            b = c.Ib(b);
                            null !== b && b.labeledLink !== a && (b.labeledLink = a)
                        })
                    }
                } else !(a instanceof Xe) && (b = d.Vh(b), b = c.findPartForKey(b), null === b || b instanceof Kf) && (a.containingGroup = b)
            }
        }
    };
    ar.prototype.resolveReferencesForData = function (a) {
        var b = this.diagram.model, c = b.pa(a);
        if (void 0 !== c) {
            var d = jr(b, c), e = this.Fc(a);
            if (null !== d && null !== e) {
                d = d.iterator;
                for (var f = {}; d.next();) {
                    var g = d.value;
                    b.$a(g) ? e instanceof Kf && b.Vh(g) === c && (g = this.Fc(g), null !== g && (g.containingGroup = e)) : (f.link = this.Ec(g), null !== f.link && e instanceof V && (er(b, g, !0) === c && (f.link.fromNode = e), er(b, g, !1) === c && (f.link.toNode = e), g = b.Nf(g), Array.isArray(g) && g.some(function (a) {
                        return function (b) {
                            return b === c ? (e.labeledLink =
                                a.link, !0) : !1
                        }
                    }(f))));
                    f = {link: f.link}
                }
                kr(b, c)
            }
            a = b.Vh(a);
            void 0 !== a && (a = this.Ib(a), a instanceof Kf && (e.containingGroup = a))
        }
    };
    ar.prototype.unresolveReferencesForPart = function (a) {
        var b = this.diagram.model;
        if (a instanceof V) {
            var c = b.pa(a.data);
            if (void 0 !== c) {
                for (var d = a.linksConnected; d.next();) lr(b, c, d.value.data);
                a.isLinkLabel && (d = a.labeledLink, null !== d && lr(b, c, d.data));
                if (a instanceof Kf) for (a = a.memberParts; a.next();) d = a.value.data, b.$a(d) && lr(b, c, d)
            }
        }
    };
    ar.prototype.copyPartData = function (a, b) {
        var c = Ii.prototype.copyPartData.call(this, a, b);
        if (a instanceof S) if (a = a.data, null !== a && null !== b) {
            var d = b.model;
            a = d.Jq(a);
            "object" === typeof a && null !== a && (d.lj(a), c = b.Ec(a))
        } else null !== c && (b = this.diagram, null !== a && null !== b && null !== b.commandHandler && b.commandHandler.copiesClipboardData && (b = b.model.Jq(a), "object" === typeof b && null !== b && (c.data = b)));
        return c
    };
    ar.prototype.insertLink = function (a, b, c, d) {
        var e = this.diagram, f = e.model, g = e.toolManager.findTool("Linking"), h = "";
        null !== a && (null === b && (b = a), h = b.portId, null === h && (h = ""));
        b = "";
        null !== c && (null === d && (d = c), b = d.portId, null === b && (b = ""));
        d = g.archetypeLinkData;
        if (d instanceof S) {
            if (Ng(d), f = d.copy(), null !== f) return f.fromNode = a, f.fromPortId = h, f.toNode = c, f.toPortId = b, e.add(f), a = g.archetypeLabelNodeData, a instanceof V && (Ng(a), a = a.copy(), null !== a && (a.labeledLink = f, e.add(a))), f
        } else if (null !== d && (d = f.Jq(d), "object" ===
        typeof d && null !== d)) return null !== a && mr(f, d, f.pa(a.data), !0), nr(f, d, h, !0), null !== c && mr(f, d, f.pa(c.data), !1), nr(f, d, b, !1), f.lj(d), a = g.archetypeLabelNodeData, null === a || a instanceof V || (a = f.copyNodeData(a), "object" === typeof a && null !== a && (f.Gf(a), a = f.pa(a), void 0 !== a && f.Ov(d, a))), e.Ec(d);
        return null
    };
    ar.prototype.findLinkForKey = ar.prototype.findLinkForKey;
    ar.prototype.findPartForKey = ar.prototype.findPartForKey;
    ar.prototype.removeAllModeledParts = ar.prototype.removeAllModeledParts;
    ar.prototype.addModeledParts = ar.prototype.addModeledParts;
    ar.prototype.addAllModeledParts = ar.prototype.addAllModeledParts;
    ar.className = "GraphLinksPartManager";

    function or() {
        Ii.apply(this, arguments);
        this.Ch = null
    }

    ma(or, Ii);

    function pr(a, b, c) {
        if (null !== b && null !== c) {
            var d = a.diagram.toolManager.findTool("Linking"), e = b, f = c;
            if (a.diagram.isTreePathToChildren) for (b = f.linksConnected; b.next();) {
                if (b.value.toNode === f) return
            } else for (e = c, f = b, b = e.linksConnected; b.next();) if (b.value.fromNode === e) return;
            if (null === d || !cg(d, e, f, null, !0)) if (d = a.getLinkCategoryForData(c.data), b = a.findLinkTemplateForCategory(d), null !== b && (Ng(b), b = b.copy(), null !== b)) {
                var g = a.diagram.skipsModelSourceBindings;
                a.diagram.skipsModelSourceBindings = !0;
                b.Zf = d;
                b.sb = c.data;
                b.fromNode = e;
                b.toNode = f;
                a.diagram.add(b);
                b.sb = null;
                b.data = c.data;
                a.diagram.skipsModelSourceBindings = g
            }
        }
    }

    or.prototype.getLinkCategoryForData = function (a) {
        return this.diagram.model.$t(a)
    };
    or.prototype.setLinkCategoryForData = function (a, b) {
        this.diagram.model.vu(a, b)
    };
    or.prototype.setFromNodeForLink = function (a, b, c) {
        var d = this.diagram.model;
        void 0 === c && (c = null);
        b = null !== b ? b.data : null;
        if (this.diagram.isTreePathToChildren) d.je(a.data, d.pa(b)); else {
            var e = this.Ch;
            this.Ch = a;
            null !== c && d.je(c.data, void 0);
            d.je(b, d.pa(null !== a.toNode ? a.toNode.data : null));
            this.Ch = e
        }
    };
    or.prototype.setToNodeForLink = function (a, b, c) {
        var d = this.diagram.model;
        void 0 === c && (c = null);
        b = null !== b ? b.data : null;
        if (this.diagram.isTreePathToChildren) {
            var e = this.Ch;
            this.Ch = a;
            null !== c && d.je(c.data, void 0);
            d.je(b, d.pa(null !== a.fromNode ? a.fromNode.data : null));
            this.Ch = e
        } else d.je(a.data, d.pa(b))
    };
    or.prototype.removeDataForLink = function (a) {
        this.diagram.model.je(a.data, void 0)
    };
    or.prototype.findLinkForKey = function (a) {
        if (null === a || void 0 === a) return null;
        a = this.diagram.model.Rb(a);
        return null !== a ? this.df.K(a) : null
    };
    or.prototype.doModelChanged = function (a) {
        Ii.prototype.doModelChanged.call(this, a);
        if (this.diagram) {
            var b = this.diagram;
            if (a.model === b.model) {
                var c = a.change;
                if (b.ba) {
                    b.ba = !1;
                    try {
                        var d = a.modelChange;
                        if ("" !== d) {
                            if (c === Le) {
                                if ("nodeParentKey" === d) {
                                    var e = a.object, f = this.Ib(a.newValue), g = this.qj(e);
                                    if (null !== this.Ch) null !== f && (this.Ch.data = e, this.Ch.category = this.getLinkCategoryForData(e)); else if (null !== g) {
                                        var h = g.tj();
                                        null !== h ? null === f ? b.remove(h) : b.isTreePathToChildren ? h.fromNode = f : h.toNode = f : pr(this, f,
                                            g)
                                    }
                                } else if ("parentLinkCategory" === d) {
                                    var k = this.qj(a.object), l = a.newValue;
                                    if (null !== k && "string" === typeof l) {
                                        var m = k.tj();
                                        null !== m && (m.category = l)
                                    }
                                }
                                b.isModified = !0
                            }
                        } else if (c === Le) {
                            var n = a.propertyName;
                            a.object === b.model && "nodeParentKeyProperty" === n && (b.undoManager.isUndoingRedoing || this.Nd());
                            b.isModified = !0
                        }
                    } finally {
                        b.ba = !0
                    }
                }
            }
        }
    };
    or.prototype.updateRelationshipsFromData = function (a) {
        var b = a.data;
        if (null !== b) {
            var c = a.diagram;
            if (null !== c) {
                var d = c.model;
                a instanceof V && (b = d.Wh(b), b = c.Ib(b), d = a.Sg(), b !== d && (d = a.tj(), null !== b ? null !== d ? c.isTreePathToChildren ? d.fromNode = b : d.toNode = b : pr(this, b, a) : null !== d && ak(c, d, !1)))
            }
        }
    };
    or.prototype.updateDataBindings = function (a, b) {
        Ii.prototype.updateDataBindings.call(this, a, b);
        "string" === typeof b && null !== this.Fc(a) && (a = this.Ec(a), null !== a && a.Ha(b))
    };
    or.prototype.resolveReferencesForData = function (a) {
        var b = this.diagram.model, c = b.pa(a);
        if (void 0 !== c) {
            var d = jr(b, c), e = this.Fc(a);
            if (null !== d && null !== e) {
                for (d = d.iterator; d.next();) {
                    var f = d.value;
                    b.$a(f) && e instanceof V && b.Wh(f) === c && pr(this, e, this.qj(f))
                }
                kr(b, c)
            }
            a = b.Wh(a);
            void 0 !== a && e instanceof V && (a = this.Ib(a), pr(this, a, e))
        }
    };
    or.prototype.unresolveReferencesForPart = function (a) {
        var b = this.diagram.model;
        if (a instanceof V) {
            var c = b.pa(a.data), d = this.Ec(a.data);
            if (null !== d) {
                d.isSelected = !1;
                d.isHighlighted = !1;
                var e = d.layer;
                if (null !== e) {
                    var f = e.Rc(-1, d, !1);
                    0 <= f && this.diagram.ib(Oe, "parts", e, d, null, f, null);
                    f = d.layerChanged;
                    null !== f && f(d, e, null)
                }
            }
            d = this.diagram.isTreePathToChildren;
            for (a = a.linksConnected; a.next();) e = a.value, e = (d ? e.toNode : e.fromNode).data, b.$a(e) && lr(b, c, e)
        }
    };
    or.prototype.insertLink = function (a, b, c) {
        b = this.diagram.model;
        var d = a, e = c;
        this.diagram.isTreePathToChildren || (d = c, e = a);
        return null !== d && null !== e ? (b.je(e.data, b.pa(d.data)), e.tj()) : null
    };
    or.prototype.findLinkForKey = or.prototype.findLinkForKey;
    or.className = "TreePartManager";

    function X(a) {
        this.Xi = new I;
        this.Ui = new I;
        this.Du = ',\n  "insertedNodeKeys": ';
        this.yx = ',\n  "modifiedNodeData": ';
        this.Fu = ',\n  "removedNodeKeys": ';
        this.hi = null;
        F && 1 < arguments.length && v("Model constructor can only take one optional argument, the Array of node data.");
        gb(this);
        this.Vn = this.Wa = "";
        this.mg = !1;
        this.l = {};
        this.xc = [];
        this.ab = new Db;
        this.Wi = "key";
        this.sl = this.am = null;
        this.Mn = this.Nn = !1;
        this.Pn = !0;
        this.un = null;
        this.hk = "category";
        this.eg = new Db;
        this.mv = new H;
        this.Hg = !1;
        this.w = null;
        this.undoManager =
            new Qe;
        void 0 !== a && (this.nodeDataArray = a)
    }

    X.prototype.cloneProtected = function (a) {
        a.Wa = this.Wa;
        a.Vn = this.Vn;
        a.mg = this.mg;
        a.Wi = this.Wi;
        a.am = this.am;
        a.sl = this.sl;
        a.Nn = this.Nn;
        a.Mn = this.Mn;
        a.Pn = this.Pn;
        a.un = this.un;
        a.hk = this.hk
    };
    X.prototype.copy = function () {
        var a = new this.constructor;
        this.cloneProtected(a);
        return a
    };
    X.prototype.clear = function () {
        this.xc = [];
        this.ab.clear();
        this.eg.clear();
        this.undoManager.clear()
    };
    X.prototype.toString = function (a) {
        void 0 === a && (a = 0);
        if (1 < a) return this.ur();
        var b = ("" !== this.name ? this.name : "") + " Model";
        if (0 < a) {
            b += "\n node data:";
            a = this.nodeDataArray;
            for (var c = a.length, d = 0; d < c; d++) {
                var e = a[d];
                b += " " + this.pa(e) + ":" + Qa(e)
            }
        }
        return b
    };
    X.prototype.vB = function (a) {
        w(a, Ke, X, "toIncrementalData:e");
        a.change !== Me && v("Model.toIncrementalData argument is not a Transaction ChangedEvent:" + a.toString());
        var b = a.object;
        if (!(a.isTransactionFinished && b instanceof Pe)) return null;
        qr(this, b);
        a = this.mx(b, "FinishedUndo" === a.propertyName);
        this.hi = null;
        return a
    };
    X.prototype.mx = function (a, b) {
        var c = this, d = !1, e = new I, f = new I, g = new I, h = this.hi;
        a.changes.each(function (a) {
            a.model === c && ("nodeDataArray" === a.modelChange ? a.change === Ne ? e.add(a.newValue) : a.change === Oe && g.add(a.oldValue) : c.$a(a.object) ? f.add(a.object) : a.change !== Le || c.modelData !== a.object && "modelData" !== a.propertyName ? null !== a.object && (h && h.contains(a.object) ? h.get(a.object).each(function (a) {
                c.$a(a) && f.add(a)
            }) : a.object instanceof X || c.Bj() && c.Dc(a.object) || rr(c, a.object).each(function (a) {
                f.add(a)
            })) :
                d = !0)
        });
        var k = this.Ui;
        k.clear();
        e.each(function (a) {
            k.add(c.pa(a));
            b || f.add(a)
        });
        var l = this.Xi;
        l.clear();
        g.each(function (a) {
            l.add(c.pa(a));
            b && f.add(a)
        });
        a = c.cloneDeep(f.ta());
        var m = null;
        d && (null === m && (m = {}), m.modelData = this.cloneDeep(this.modelData));
        0 < k.count && (null === m && (m = {}), b ? m.removedNodeKeys = k.ta() : m.insertedNodeKeys = k.ta());
        0 < a.length && (null === m && (m = {}), m.modifiedNodeData = a);
        0 < l.count && (null === m && (m = {}), b ? m.insertedNodeKeys = l.ta() : m.removedNodeKeys = l.ta());
        l.clear();
        k.clear();
        return m
    };
    X.prototype.cloneDeep = function (a) {
        return sr(this, a, !0)
    };

    function sr(a, b, c, d, e, f) {
        function g(a, c) {
            h ? (void 0 === a.__gohashid && f.push(a), d.set(a, c)) : (a = yb++, d.set(a, c), e.set(a, b))
        }

        if (!Ga(b)) return b;
        f || (f = []);
        var h = Object.isExtensible(b);
        d || (d = new Db);
        if (h) {
            var k = d.get(b);
            if (k) return k
        } else for (e || (e = new Db), k = e.iterator; k.next();) {
            var l = k.key;
            if (k.value === b && (l = d.get(l))) return l
        }
        if (Array.isArray(b)) {
            k = [];
            g(b, k);
            for (var m = 0; m < b.length; m++) k.push(sr(a, b[m], !1, d, e, f))
        } else if (b instanceof J || b instanceof Hb || b instanceof L || b instanceof jc || b instanceof M) k =
            b.copy(), g(b, k); else {
            if (b instanceof Ll || b instanceof Hd || b instanceof E) return b;
            if (b instanceof H) k = (new H).addAll(sr(a, b.ta(), !1, d, e, f)), g(b, k); else if (b instanceof I) k = (new I).addAll(sr(a, b.ta(), !1, d, e, f)), g(b, k); else if (b instanceof Db) k = (new Db).addAll(sr(a, b.ta(), !1, d, e, f)), g(b, k); else if (b instanceof Date) k = new Date(b.getTime()), g(b, k); else if (b instanceof RegExp) k = new RegExp(b), g(b, k), k.lastIndex = b.lastIndex; else if ("function" === typeof b.copy) k = b.copy(), g(b, k); else for (m in k = {}, g(b, k), b) "__gohashid" !==
            m && (k[m] = sr(a, b[m], !1, d, e, f))
        }
        c && f.forEach(function (a) {
            delete a.__gohashid
        });
        return k
    }

    t = X.prototype;
    t.dl = function () {
        var a = "";
        "" !== this.name && (a += ',\n  "name": ' + this.quote(this.name));
        "" !== this.dataFormat && (a += ',\n  "dataFormat": ' + this.quote(this.dataFormat));
        this.isReadOnly && (a += ',\n  "isReadOnly": ' + this.isReadOnly);
        "key" !== this.nodeKeyProperty && "string" === typeof this.nodeKeyProperty && (a += ',\n  "nodeKeyProperty": ' + this.quote(this.nodeKeyProperty));
        this.copiesArrays && (a += ',\n  "copiesArrays": true');
        this.copiesArrayObjects && (a += ',\n  "copiesArrayObjects": true');
        this.copiesKey || (a += ',\n  "copiesKey": false');
        "category" !== this.nodeCategoryProperty && "string" === typeof this.nodeCategoryProperty && (a += ',\n  "nodeCategoryProperty": ' + this.quote(this.nodeCategoryProperty));
        return a
    };
    t.jr = function (a) {
        a.name && (this.name = a.name);
        a.dataFormat && (this.dataFormat = a.dataFormat);
        a.isReadOnly && (this.isReadOnly = !0);
        a.nodeKeyProperty && (this.nodeKeyProperty = a.nodeKeyProperty);
        a.copiesArrays && (this.copiesArrays = !0);
        a.copiesArrayObjects && (this.copiesArrayObjects = !0);
        !1 === a.copiesKey && (this.copiesKey = !1);
        a.nodeCategoryProperty && (this.nodeCategoryProperty = a.nodeCategoryProperty)
    };

    function tr(a) {
        return ',\n  "modelData": ' + ur(a, a.modelData)
    }

    function vr(a, b) {
        b = b.modelData;
        Ga(b) && (a.$m(b), a.modelData = b)
    }

    t.nx = function () {
        var a = this.modelData, b = !1, c;
        for (c in a) if (!wr(c, a[c])) {
            b = !0;
            break
        }
        a = "";
        b && (a = tr(this));
        return a + ',\n  "nodeDataArray": ' + xr(this, this.nodeDataArray, !0)
    };
    t.Bw = function (a) {
        vr(this, a);
        a = a.nodeDataArray;
        Ha(a) && (this.$m(a), this.nodeDataArray = a)
    };

    function yr(a, b, c, d) {
        if (b === c) return !0;
        if (typeof b !== typeof c || "function" === typeof b || "function" === typeof c) return !1;
        if (Array.isArray(b) && Array.isArray(c)) {
            if (d.K(b) === c) return !0;
            d.add(b, c);
            if (b.length !== c.length) return !1;
            for (var e = 0; e < b.length; e++) if (!yr(a, b[e], c[e], d)) return !1;
            return !0
        }
        if (Ga(b) && Ga(c)) {
            if (d.K(b) === c) return !0;
            d.add(b, c);
            for (var f in b) {
                var g = b[f];
                if (!wr(f, g)) {
                    var h = c[f];
                    if (void 0 === h || !yr(a, g, h, d)) return !1
                }
            }
            for (e in c) if (f = c[e], !wr(e, f) && (g = b[e], void 0 === g || !yr(a, g, f, d))) return !1;
            return !0
        }
        return !1
    }

    function zr(a, b, c) {
        a[c] !== b[c] && v("Model.computeJsonDifference: Model." + c + ' is not the same in both models: "' + a[c] + '" and "' + b[c] + '"')
    }

    t.zr = function (a) {
        zr(this, a, "nodeKeyProperty");
        var b = this.Ui;
        b.clear();
        var c = new I, d = this.Xi;
        d.clear();
        d.addAll(this.ab.iteratorKeys);
        for (var e = new Db, f = a.nodeDataArray, g = f.length, h = 0; h < g; h++) {
            var k = f[h], l = a.pa(k);
            if (void 0 !== l) {
                d.remove(l);
                var m = this.Rb(l);
                null === m ? (b.add(l), c.add(k)) : yr(this, m, k, e) || c.add(k)
            } else this.ju(k), l = this.pa(k), b.add(l), c.add(k)
        }
        f = "";
        yr(this, this.modelData, a.modelData, e) || (f += tr(this));
        0 < b.count && (f += this.Du + xr(this, b.ta(), !0));
        0 < c.count && (f += this.yx + xr(this, c.ta(), !0));
        0 < d.count && (f += this.Fu + xr(this, d.ta(), !0));
        d.clear();
        b.clear();
        return f
    };
    t.Sz = function (a, b) {
        w(a, X, X, "computeJsonDifference:newmodel");
        void 0 === b && (b = Ar(this, this));
        return '{ "class": ' + this.quote(b) + ', "incremental": 1' + this.dl() + this.zr(a) + "}"
    };

    function qr(a, b) {
        function c(a, b) {
            if (b = b.part) if (b = b.data, a !== b) {
                var c = d.get(a);
                null === c ? (c = new I, c.add(b), d.add(a, c)) : c.add(b)
            }
        }

        var d = a.hi;
        null === d && (d = new Db, b.changes.each(function (a) {
            if (null !== a.diagram) {
                var b = a.change;
                if (b === Le) (a = a.object.panel) && (b = a.data) && c(b, a); else if (b === Ne || b === Oe) a = a.object, (b = a.itemArray) && c(b, a)
            }
        }), a.hi = d)
    }

    function rr(a, b) {
        for (var c = new I, d = 0; d < a.nodeDataArray.length; d++) {
            var e = a.nodeDataArray[d];
            Br(a, b, e, e, c)
        }
        return c
    }

    function Br(a, b, c, d, e) {
        if (Array.isArray(c)) for (var f = 0; f < c.length; f++) {
            var g = c[f];
            if (g === b) return e.add(d), !0;
            if (Br(a, b, g, d, e)) return !0
        } else if (Ga(c) && Object.getPrototypeOf(c) === Object.prototype) for (f in c) {
            g = c[f];
            if (g === b) return e.add(d), !0;
            if (Br(a, b, g, d, e)) return !0
        }
        return !1
    }

    t.lx = function (a, b) {
        var c = this, d = !1, e = new I, f = new I, g = new I, h = this.hi;
        a.changes.each(function (a) {
            a.model === c && ("nodeDataArray" === a.modelChange ? a.change === Ne ? e.add(a.newValue) : a.change === Oe && g.add(a.oldValue) : c.$a(a.object) ? f.add(a.object) : a.change !== Le || c.modelData !== a.object && "modelData" !== a.propertyName ? null !== a.object && (h && h.contains(a.object) ? h.get(a.object).each(function (a) {
                c.$a(a) && f.add(a)
            }) : a.object instanceof X || c.Bj() && c.Dc(a.object) || rr(c, a.object).each(function (a) {
                f.add(a)
            })) : d = !0)
        });
        var k =
            this.Ui;
        k.clear();
        e.each(function (a) {
            k.add(c.pa(a));
            b || f.add(a)
        });
        var l = this.Xi;
        l.clear();
        g.each(function (a) {
            l.add(c.pa(a));
            b && f.add(a)
        });
        a = "";
        d && (a += tr(this));
        0 < k.count && (a += (b ? this.Fu : this.Du) + xr(this, k.ta(), !0));
        0 < f.count && (a += this.yx + xr(this, f.ta(), !0));
        0 < l.count && (a += (b ? this.Du : this.Fu) + xr(this, l.ta(), !0));
        l.clear();
        k.clear();
        return a
    };
    t.ir = function (a) {
        (void 0 !== a.name && a.name !== this.name || void 0 !== a.dataFormat && a.dataFormat !== this.dataFormat || void 0 !== a.isReadOnly && a.isReadOnly !== this.isReadOnly || void 0 !== a.nodeKeyProperty && a.nodeKeyProperty !== this.nodeKeyProperty || void 0 !== a.copiesArrays && a.copiesArrays !== this.copiesArrays || void 0 !== a.copiesArrayObjects && a.copiesArrayObjects !== this.copiesArrayObjects || void 0 !== a.copiesKey && a.copiesKey !== this.copiesKey || void 0 !== a.nodeCategoryProperty && a.nodeCategoryProperty !== this.nodeCategoryProperty) &&
        v("applyIncrementalJson cannot change Model properties");
        vr(this, a);
        var b = a.insertedNodeKeys, c = a.modifiedNodeData, d = new Db;
        if (Array.isArray(c)) for (var e = 0; e < c.length; e++) {
            var f = c[e], g = this.pa(f);
            void 0 !== g && null !== g && d.set(g, f)
        }
        if (Array.isArray(b)) for (e = b.length, f = 0; f < e; f++) {
            g = b[f];
            var h = this.Rb(g);
            null === h && (h = (h = d.get(g)) ? h : this.copyNodeData({}), this.gn(h, g), this.Gf(h))
        }
        if (Array.isArray(c)) for (b = c.length, d = 0; d < b; d++) if (e = c[d], f = this.pa(e), f = this.Rb(f), null !== f) {
            for (var k in e) "__gohashid" === k ||
            k === this.nodeKeyProperty || this.Kk() && k === this.nodeIsGroupProperty || this.setDataProperty(f, k, e[k]);
            this.hn(e, f)
        }
        a = a.removedNodeKeys;
        if (Array.isArray(a)) for (c = a.length, k = 0; k < c; k++) b = this.Rb(a[k]), null !== b && this.Zm(b)
    };
    t.nz = function (a, b) {
        w(a, Ke, X, "toIncrementalJson:e");
        a.change !== Me && v("Model.toIncrementalJson argument is not a Transaction ChangedEvent:" + a.toString());
        var c = a.object;
        if (!(a.isTransactionFinished && c instanceof Pe)) return '{ "incremental": 0 }';
        void 0 === b && (b = Ar(this, this));
        qr(this, c);
        a = this.lx(c, "FinishedUndo" === a.propertyName);
        this.hi = null;
        return "2" === b ? '{ "incremental": 2' + a + "}" : '{ "class": ' + this.quote(b) + ', "incremental": 1' + this.dl() + a + "}"
    };
    t.wB = function (a, b) {
        return this.nz(a, b)
    };
    t.ur = function (a) {
        void 0 === a && (a = Ar(this, this));
        return '{ "class": ' + this.quote(a) + this.dl() + this.nx() + "}"
    };
    t.toJSON = function (a) {
        return this.ur(a)
    };
    t.ny = function (a) {
        var b = null;
        if ("string" === typeof a) try {
            b = qa.JSON.parse(a)
        } catch (d) {
            F && Ea("JSON.parse error: " + d.toString())
        } else "object" === typeof a ? b = a : v("Unable to modify a Model from: " + a);
        var c = b.incremental;
        "number" !== typeof c && v("Unable to apply non-incremental changes to Model: " + a);
        0 !== c && (this.Ca("applyIncrementalJson"), this.ir(b), this.bb("applyIncrementalJson"))
    };
    t.Jz = function (a) {
        return this.ny(a)
    };
    X.constructGraphLinksModel = function () {
        F && v("Unable to construct a Model. Provided JSON requires GraphLinksModel, which is not loaded.");
        return new X
    };
    t = X.prototype;
    t.$m = function (a) {
        if (Ha(a)) for (var b = a.length, c = 0; c < b; c++) {
            var d = a[c];
            if (Ga(d)) {
                var e = c;
                d = this.$m(d);
                Array.isArray(a) ? a[e] = d : v("Cannot replace an object in an HTMLCollection or NodeList at " + e)
            }
        } else if (Ga(a)) {
            for (c in a) if (e = a[c], Ga(e) && (e = this.$m(e), a[c] = e, "points" === c && Array.isArray(e))) {
                d = 0 === e.length % 2;
                for (var f = 0; f < e.length; f++) if ("number" !== typeof e[f]) {
                    d = !1;
                    break
                }
                if (d) {
                    d = new H;
                    for (f = 0; f < e.length / 2; f++) d.add(new J(e[2 * f], e[2 * f + 1]));
                    d.freeze();
                    a[c] = d
                }
            }
            if ("object" === typeof a) {
                c = a;
                e = a["class"] ||
                    "";
                0 === e.indexOf("go.") && (e = e.substr(3));
                if ("NaN" === e) c = NaN; else if ("Date" === e) c = new Date(a.value); else if ("Point" === e) c = new J(Cr(a.x), Cr(a.y)); else if ("Size" === e) c = new Hb(Cr(a.width), Cr(a.height)); else if ("Rect" === e) c = new L(Cr(a.x), Cr(a.y), Cr(a.width), Cr(a.height)); else if ("Margin" === e) c = new jc(Cr(a.top), Cr(a.right), Cr(a.bottom), Cr(a.left)); else if ("Spot" === e) "string" === typeof a["enum"] ? c = xd(a["enum"]) : c = new M(Cr(a.x), Cr(a.y), Cr(a.offsetX), Cr(a.offsetY)); else if ("Brush" === e) {
                    if (c = new Ll, c.type = hb(Ll,
                        a.type), "string" === typeof a.color && (c.color = a.color), a.start instanceof M && (c.start = a.start), a.end instanceof M && (c.end = a.end), "number" === typeof a.startRadius && (c.startRadius = Cr(a.startRadius)), "number" === typeof a.endRadius && (c.endRadius = Cr(a.endRadius)), a = a.colorStops, Ga(a)) for (b in a) c.addColorStop(parseFloat(b), a[b])
                } else "Geometry" === e ? (b = null, "string" === typeof a.path ? b = Qd(a.path) : b = new Hd, b.type = hb(Hd, a.type), "number" === typeof a.startX && (b.startX = Cr(a.startX)), "number" === typeof a.startY && (b.startY =
                    Cr(a.startY)), "number" === typeof a.endX && (b.endX = Cr(a.endX)), "number" === typeof a.endY && (b.endY = Cr(a.endY)), a.spot1 instanceof M && (b.spot1 = a.spot1), a.spot2 instanceof M && (b.spot2 = a.spot2), c = b) : "EnumValue" === e && (b = a.classType, 0 === b.indexOf("go.") && (b = b.substr(3)), b = Dr(b), "function" === typeof b && (c = hb(b, a.name)));
                a = c
            }
        }
        return a
    };
    t.quote = function (a) {
        for (var b = "", c = a.length, d = 0; d < c; d++) {
            var e = a[d];
            if ('"' === e || "\\" === e) b += "\\" + e; else if ("\b" === e) b += "\\b"; else if ("\f" === e) b += "\\f"; else if ("\n" === e) b += "\\n"; else if ("\r" === e) b += "\\r"; else if ("\t" === e) b += "\\t"; else {
                var f = a.charCodeAt(d);
                b = 16 > f ? b + ("\\u000" + a.charCodeAt(d).toString(16)) : 32 > f ? b + ("\\u00" + a.charCodeAt(d).toString(16)) : 8232 === f ? b + "\\u2028" : 8233 === f ? b + "\\u2029" : b + e
            }
        }
        return '"' + b + '"'
    };
    t.mn = function (a) {
        return void 0 === a ? "undefined" : null === a ? "null" : !0 === a ? "true" : !1 === a ? "false" : "string" === typeof a ? this.quote(a) : "number" === typeof a ? Infinity === a ? "9e9999" : -Infinity === a ? "-9e9999" : isNaN(a) ? '{"class":"NaN"}' : a.toString() : a instanceof Date ? '{"class":"Date", "value":"' + a.toJSON() + '"}' : a instanceof Number ? this.mn(a.valueOf()) : Ha(a) ? xr(this, a) : Ga(a) ? ur(this, a) : "function" === typeof a ? "null" : a.toString()
    };

    function xr(a, b, c) {
        void 0 === c && (c = !1);
        var d = b.length;
        if (0 >= d) return "[]";
        var e = new jb;
        e.add("[");
        c && 1 < d && e.add("\n");
        for (var f = 0; f < d; f++) {
            var g = b[f];
            void 0 !== g && (0 < f && (e.add(","), c && e.add("\n")), e.add(a.mn(g)))
        }
        c && 1 < d && e.add("\n");
        e.add("]");
        return e.toString()
    }

    function wr(a, b) {
        return void 0 === b || "__gohashid" === a || "_" === a[0] || "function" === typeof b ? !0 : !1
    }

    function Er(a) {
        return isNaN(a) ? "NaN" : Infinity === a ? "9e9999" : -Infinity === a ? "-9e9999" : a
    }

    function ur(a, b) {
        var c = b;
        if (c instanceof J) b = {
            "class": "go.Point",
            x: Er(c.x),
            y: Er(c.y)
        }; else if (c instanceof Hb) b = {
            "class": "go.Size",
            width: Er(c.width),
            height: Er(c.height)
        }; else if (c instanceof L) b = {
            "class": "go.Rect",
            x: Er(c.x),
            y: Er(c.y),
            width: Er(c.width),
            height: Er(c.height)
        }; else if (c instanceof jc) b = {
            "class": "go.Margin",
            top: Er(c.top),
            right: Er(c.right),
            bottom: Er(c.bottom),
            left: Er(c.left)
        }; else if (c instanceof M) c.cb() ? b = {
                "class": "go.Spot",
                x: Er(c.x),
                y: Er(c.y),
                offsetX: Er(c.offsetX),
                offsetY: Er(c.offsetY)
            } :
            b = {"class": "go.Spot", "enum": c.toString()}; else if (c instanceof Ll) {
            b = {"class": "go.Brush", type: c.type.name};
            if (c.type === Ol) b.color = c.color; else if (c.type === Rl || c.type === Ml) b.start = c.start, b.end = c.end, c.type === Ml && (0 !== c.startRadius && (b.startRadius = Er(c.startRadius)), isNaN(c.endRadius) || (b.endRadius = Er(c.endRadius)));
            if (null !== c.colorStops) {
                var d = {};
                for (c = c.colorStops.iterator; c.next();) d[c.key] = c.value;
                b.colorStops = d
            }
        } else if (c instanceof Hd) b = {"class": "go.Geometry", type: c.type.name}, 0 !== c.startX &&
        (b.startX = Er(c.startX)), 0 !== c.startY && (b.startY = Er(c.startY)), 0 !== c.endX && (b.endX = Er(c.endX)), 0 !== c.endY && (b.endY = Er(c.endY)), c.spot1.A(Fc) || (b.spot1 = c.spot1), c.spot2.A(Rc) || (b.spot2 = c.spot2), c.type === Id && (b.path = Nd(c)); else if (c instanceof E) b = {
            "class": "go.EnumValue",
            classType: Ar(a, c.classType),
            name: c.name
        }; else if (F && null !== Dr(Ar(a, c))) return Ea("ERROR: trying to convert a GraphObject or Diagram or Model or Tool or Layout or UndoManager or other unknown data into JSON text: " + c.toString()), "{}";
        d = "{";
        c = !0;
        for (var e in b) {
            var f = Jn(b, e);
            if (!wr(e, f)) if (c ? c = !1 : d += ",", d += '"' + e + '":', "points" === e && f instanceof H) {
                var g = "[";
                for (f = f.iterator; f.next();) {
                    var h = f.value;
                    1 < g.length && (g += ",");
                    g += a.mn(h.x);
                    g += ",";
                    g += a.mn(h.y)
                }
                g += "]";
                d += g
            } else d += a.mn(f)
        }
        return d + "}"
    }

    function Cr(a) {
        return "number" === typeof a ? a : "NaN" === a ? NaN : "9e9999" === a ? Infinity : "-9e9999" === a ? -Infinity : parseFloat(a)
    }

    t.Rh = function (a) {
        A(a, "function", X, "addChangedListener:listener");
        this.mv.add(a)
    };
    t.$k = function (a) {
        A(a, "function", X, "removeChangedListener:listener");
        this.mv.remove(a)
    };
    t.Kt = function (a) {
        this.skipsUndoManager || this.undoManager.mw(a);
        for (var b = this.mv, c = b.length, d = 0; d < c; d++) b.M(d)(a)
    };
    t.ib = function (a, b, c, d, e, f, g) {
        Gr(this, "", a, b, c, d, e, f, g)
    };
    t.g = function (a, b, c, d, e) {
        Gr(this, "", Le, a, this, b, c, d, e)
    };
    t.ou = function (a, b, c, d, e, f) {
        Gr(this, "", Le, b, a, c, d, e, f)
    };

    function Gr(a, b, c, d, e, f, g, h, k) {
        void 0 === h && (h = null);
        void 0 === k && (k = null);
        var l = new Ke;
        l.model = a;
        l.change = c;
        l.modelChange = b;
        l.propertyName = d;
        l.object = e;
        l.oldValue = f;
        l.oldParam = h;
        l.newValue = g;
        l.newParam = k;
        a.Kt(l)
    }

    X.prototype.changeState = function (a, b) {
        if (null !== a && a.model === this) if (a.change === Le) {
            var c = a.object, d = a.propertyName, e = a.K(b);
            d === this.nodeKeyProperty && this.$a(c) && (b = a.K(!b), void 0 !== b && this.ab.remove(b), void 0 !== e && this.ab.add(e, c));
            hk(c, d, e)
        } else a.change === Ne ? (c = a.newParam, "nodeDataArray" === a.modelChange ? (a = a.newValue, Ga(a) && "number" === typeof c && (d = this.pa(a), b ? (this.xc[c] === a && La(this.xc, c), void 0 !== d && this.ab.remove(d)) : (this.xc[c] !== a && Ka(this.xc, c, a), void 0 !== d && this.ab.add(d, a)))) : "" === a.modelChange ?
            ((d = a.object) && !Ha(d) && a.propertyName && (d = Jn(a.object, a.propertyName)), Ha(d) && "number" === typeof c && (a = a.newValue, b ? La(d, c) : Ka(d, c, a))) : v("unknown ChangedEvent.Insert modelChange: " + a.toString())) : a.change === Oe ? (c = a.oldParam, "nodeDataArray" === a.modelChange ? (a = a.oldValue, Ga(a) && "number" === typeof c && (d = this.pa(a), b ? (this.xc[c] !== a && Ka(this.xc, c, a), void 0 !== d && this.ab.add(d, a)) : (this.xc[c] === a && La(this.xc, c), void 0 !== d && this.ab.remove(d)))) : "" === a.modelChange ? ((d = a.object) && !Ha(d) && a.propertyName && (d =
            Jn(a.object, a.propertyName)), Ha(d) && "number" === typeof c && (a = a.oldValue, b ? Ka(d, c, a) : La(d, c))) : v("unknown ChangedEvent.Remove modelChange: " + a.toString())) : a.change !== Me && v("unknown ChangedEvent: " + a.toString())
    };
    X.prototype.Ca = function (a) {
        return this.undoManager.Ca(a)
    };
    X.prototype.bb = function (a) {
        return this.undoManager.bb(a)
    };
    X.prototype.Uf = function () {
        return this.undoManager.Uf()
    };
    X.prototype.commit = function (a, b) {
        void 0 === b && (b = "");
        var c = this.skipsUndoManager;
        null === b && (this.skipsUndoManager = !0, b = "");
        this.undoManager.Ca(b);
        var d = !1;
        try {
            a(this), d = !0
        } finally {
            d ? this.undoManager.bb(b) : this.undoManager.Uf(), this.skipsUndoManager = c
        }
    };
    t = X.prototype;
    t.Ha = function (a, b) {
        void 0 === b && (b = "");
        Gr(this, "SourceChanged", Me, b, a, null, null)
    };

    function Hr(a, b, c) {
        "string" !== typeof a && "function" !== typeof a && xa(a, "string or function", b, c)
    }

    t.pa = function (a) {
        if (null !== a) {
            var b = this.Wi;
            if ("" !== b && (b = Jn(a, b), void 0 !== b)) {
                if (gr(b)) return b;
                v("Key value for node data " + a + " is not a number or a string: " + b)
            }
        }
    };
    t.gn = function (a, b) {
        void 0 !== b && null !== b && gr(b) || xa(b, "number or string", X, "setKeyForNodeData:key");
        if (null !== a) {
            var c = this.Wi;
            if ("" !== c) if (this.$a(a)) {
                var d = Jn(a, c);
                d !== b && null === this.Rb(b) && (hk(a, c, b), void 0 !== d && this.ab.remove(d), this.ab.add(b, a), Gr(this, "nodeKey", Le, c, a, d, b), "string" === typeof c && this.Ha(a, c), this.nr(d, b))
            } else hk(a, c, b)
        }
    };

    function gr(a) {
        return "number" === typeof a || "string" === typeof a
    }

    t.$a = function (a) {
        var b = this.pa(a);
        return void 0 === b ? !1 : this.ab.K(b) === a
    };
    t.Rb = function (a) {
        null === a && v("Model.findNodeDataForKey:key must not be null");
        return void 0 !== a && gr(a) ? this.ab.K(a) : null
    };
    t.ju = function (a) {
        if (null !== a) {
            var b = this.Wi;
            if ("" !== b) {
                var c = this.pa(a);
                if (void 0 === c || this.ab.contains(c)) {
                    var d = this.am;
                    if (null !== d && (c = d(this, a), void 0 !== c && null !== c && !this.ab.contains(c))) {
                        hk(a, b, c);
                        return
                    }
                    if ("string" === typeof c) {
                        for (d = 2; this.ab.contains(c + d);) d++;
                        hk(a, b, c + d)
                    } else if (void 0 === c || "number" === typeof c) {
                        for (c = -this.ab.count - 1; this.ab.contains(c);) c--;
                        hk(a, b, c)
                    } else F && v("Model.getKeyForNodeData returned something other than a string or a number: " + c)
                }
            }
        }
    };
    t.Gf = function (a) {
        null !== a && (wb(a), this.$a(a) || Zq(this, a, !0))
    };

    function Zq(a, b, c) {
        var d = a.pa(b);
        if (void 0 === d || a.ab.K(d) !== b) a.ju(b), d = a.pa(b), void 0 === d ? v("Model.makeNodeDataKeyUnique failed on " + b + ".  Data not added to Model.") : (a.ab.add(d, b), d = null, c && (d = a.xc.length, Ka(a.xc, d, b)), Gr(a, "nodeDataArray", Ne, "nodeDataArray", a, null, b, null, d), a.bn(b), a.an(b))
    }

    t.Fz = function (a) {
        if (Ha(a)) for (var b = a.length, c = 0; c < b; c++) this.Gf(a[c]); else for (a = a.iterator; a.next();) this.Gf(a.value)
    };
    t.Zm = function (a) {
        null !== a && Yq(this, a, !0)
    };

    function Yq(a, b, c) {
        var d = a.pa(b);
        void 0 !== d && a.ab.remove(d);
        d = null;
        if (c) {
            a:if (c = a.xc, Array.isArray(c)) d = c.indexOf(b); else {
                d = c.length;
                for (var e = 0; e < d; e++) if (c[e] === b) {
                    d = e;
                    break a
                }
                d = -1
            }
            if (0 > d) return;
            La(a.xc, d)
        }
        Gr(a, "nodeDataArray", Oe, "nodeDataArray", a, b, null, d, null);
        a.wr(b)
    }

    t.lB = function (a) {
        if (Ha(a)) for (var b = a.length, c = 0; c < b; c++) this.Zm(a[c]); else for (a = a.iterator; a.next();) this.Zm(a.value)
    };
    t.bB = function (a) {
        if (a !== this.nodeDataArray && Ha(a)) {
            var b = this.Xi;
            b.clear();
            b.addAll(this.ab.iteratorKeys);
            var c = this.Ui;
            c.clear();
            for (var d = a.length, e = 0; e < d; e++) {
                var f = a[e], g = this.pa(f);
                if (void 0 !== g) {
                    c.add(g);
                    var h = this.Rb(g);
                    h !== f && (null !== h ? (this.Eq(h, f), this.hn(f, h)) : (f = this.cloneDeep(f), this.gn(f, g), this.Gf(f)))
                } else g = this.cloneDeep(f), this.Gf(g), c.add(this.pa(g))
            }
            for (a = b.iterator; a.next();) d = a.value, c.contains(d) || (d = this.Rb(d)) && this.Zm(d);
            b.clear();
            c.clear()
        }
    };
    t.nr = function (a, b) {
        void 0 !== b && (a = jr(this, a), a instanceof I && this.eg.add(b, a))
    };
    t.gx = function () {
    };
    t.bn = function () {
    };
    t.an = function () {
    };
    t.wr = function () {
    };

    function lr(a, b, c) {
        if (void 0 !== b) {
            var d = a.eg.K(b);
            null === d && (d = new I, a.eg.add(b, d));
            d.add(c)
        }
    }

    function kr(a, b, c) {
        if (void 0 !== b) {
            var d = a.eg.K(b);
            d instanceof I && (void 0 === c || null === c ? a.eg.remove(b) : (d.remove(c), 0 === d.count && a.eg.remove(b)))
        }
    }

    function jr(a, b) {
        if (void 0 === b) return null;
        a = a.eg.K(b);
        return a instanceof I ? a : null
    }

    t.Rz = function (a) {
        void 0 === a ? this.eg.clear() : this.eg.remove(a)
    };
    X.prototype.copyNodeData = function (a) {
        if (null === a) return null;
        var b = this.sl;
        a = null !== b ? b(a, this) : Ir(this, a, !0);
        Ga(a) && gb(a);
        return a
    };

    function Ir(a, b, c) {
        if (a.copiesArrays && Array.isArray(b)) {
            var d = [];
            for (c = 0; c < b.length; c++) {
                var e = Ir(a, b[c], a.copiesArrayObjects);
                d.push(e)
            }
            gb(d);
            return d
        }
        if (c && Ga(b)) {
            c = (c = b.constructor) ? new c : {};
            e = a.copiesKey || "string" !== typeof a.nodeKeyProperty ? null : a.nodeKeyProperty;
            for (d in b) if ("__gohashid" === d) c.__gohashid = void 0; else if (d === e) c[e] = void 0; else {
                var f = Jn(b, d);
                var g = Ar(a, f);
                "GraphObject" === g || "Diagram" === g || "Layer" === g || "RowColumnDefinition" === g || "AnimationManager" === g || "Tool" === g || "CommandHandler" ===
                g || "Layout" === g || "InputEvent" === g || "DiagramEvent" === g ? (F && "_" !== d[0] && Ea('Warning: found GraphObject or Diagram reference when copying model data on property "' + d + '" of data object: ' + b.toString() + "  \nModel data should not have any references to a Diagram or any part of a diagram, such as: " + f.toString()), g = !0) : g = f instanceof X || f instanceof Qe || f instanceof Pe || f instanceof Ke ? !0 : !1;
                g ? hk(c, d, f) : (f = Ir(a, f, !1), hk(c, d, f))
            }
            gb(c);
            return c
        }
        return b instanceof J ? b.copy() : b instanceof Hb ? b.copy() : b instanceof
        L ? b.copy() : b instanceof M ? b.copy() : b instanceof jc ? b.copy() : b
    }

    X.prototype.setDataProperty = function (a, b, c) {
        F && (A(a, "object", X, "setDataProperty:data"), A(b, "string", X, "setDataProperty:propname"), "" === b && v("Model.setDataProperty: property name must not be an empty string when setting " + a + " to " + c));
        if (this.$a(a)) {
            if (b === this.nodeKeyProperty) {
                this.gn(a, c);
                return
            }
            if (b === this.nodeCategoryProperty) {
                this.fn(a, c);
                return
            }
        } else !Jr && a instanceof N && (Jr = !0, Ea('Model.setDataProperty is modifying a GraphObject, "' + a.toString() + '"'), Ea("  Is that really your intent?"));
        var d =
            Jn(a, b);
        d !== c && (hk(a, b, c), this.ou(a, b, d, c))
    };
    t = X.prototype;
    t.set = function (a, b, c) {
        this.setDataProperty(a, b, c)
    };
    t.Eq = function (a, b) {
        if (b) {
            var c = this.$a(a), d;
            for (d in b) "__gohashid" === d || c && d === this.nodeKeyProperty || this.setDataProperty(a, d, b[d])
        }
    };
    t.Cz = function (a, b) {
        this.au(a, -1, b)
    };
    t.au = function (a, b, c) {
        F && (Ia(a, X, "insertArrayItem:arr"), C(b, X, "insertArrayItem:idx"), a === this.xc && v("Model.insertArrayItem or Model.addArrayItem should not be called on the Model.nodeDataArray"));
        0 > b && (b = a.length);
        Ka(a, b, c);
        Gr(this, "", Ne, "", a, null, c, null, b)
    };
    t.Dw = function (a, b) {
        void 0 === b && (b = -1);
        F && (Ia(a, X, "removeArrayItem:arr"), C(b, X, "removeArrayItem:idx"));
        a === this.xc && v("Model.removeArrayItem should not be called on the Model.nodeDataArray");
        -1 === b && (b = a.length - 1);
        var c = a[b];
        La(a, b);
        Gr(this, "", Oe, "", a, c, null, b, null)
    };
    t.Rq = function (a) {
        if (null === a) return "";
        var b = this.hk;
        if ("" === b) return "";
        b = Jn(a, b);
        if (void 0 === b) return "";
        if ("string" === typeof b) return b;
        v("getCategoryForNodeData found a non-string category for " + a + ": " + b);
        return ""
    };
    t.fn = function (a, b) {
        A(b, "string", X, "setCategoryForNodeData:cat");
        if (null !== a) {
            var c = this.hk;
            if ("" !== c) if (this.$a(a)) {
                var d = Jn(a, c);
                void 0 === d && (d = "");
                d !== b && (hk(a, c, b), Gr(this, "nodeCategory", Le, c, a, d, b))
            } else hk(a, c, b)
        }
    };
    t.hn = function (a, b) {
        this.fn(b, this.Rq(a))
    };
    t.Qm = function () {
        return !1
    };
    t.Kk = function () {
        return !1
    };
    t.Bj = function () {
        return !1
    };
    t.gu = function () {
        return !1
    };
    t.zj = function () {
        return !1
    };

    function Li() {
        return new X
    }

    function Ar(a, b) {
        if ("function" === typeof b) {
            if (b.className) return b.className;
            if (b.name) return b.name
        } else if ("object" === typeof b && null !== b && b.constructor) return Ar(a, b.constructor);
        return typeof b
    }

    function Dr(a) {
        return Kr[a] ? Kr[a] : void 0 !== qa.go && qa.go[a] ? qa.go[a] : null
    }

    function Jn(a, b) {
        if (!a || !b) return null;
        try {
            if ("function" === typeof b) var c = b(a); else "function" === typeof a.getAttribute ? (c = a.getAttribute(b), null === c && (c = void 0)) : c = a[b]
        } catch (d) {
            F && Ea("property get error: " + d.toString())
        }
        return c
    }

    function hk(a, b, c) {
        if (a && b) try {
            "function" === typeof b ? b(a, c) : "function" === typeof a.setAttribute ? a.setAttribute(b, c) : a[b] = c
        } catch (d) {
            F && Ea("property set error: " + d.toString())
        }
    }

    na.Object.defineProperties(X.prototype, {
        name: {
            configurable: !0, get: function () {
                return this.Wa
            }, set: function (a) {
                var b = this.Wa;
                b !== a && (A(a, "string", X, "name"), this.Wa = a, this.g("name", b, a))
            }
        }, dataFormat: {
            configurable: !0, get: function () {
                return this.Vn
            }, set: function (a) {
                var b = this.Vn;
                b !== a && (A(a, "string", X, "dataFormat"), this.Vn = a, this.g("dataFormat", b, a))
            }
        }, isReadOnly: {
            configurable: !0, get: function () {
                return this.mg
            }, set: function (a) {
                var b = this.mg;
                b !== a && (A(a, "boolean",
                    X, "isReadOnly"), this.mg = a, this.g("isReadOnly", b, a))
            }
        }, modelData: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                var b = this.l;
                b !== a && (A(a, "object", X, "modelData"), this.l = a, this.g("modelData", b, a), this.Ha(a))
            }
        }, undoManager: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                var b = this.w;
                b !== a && (w(a, Qe, X, "undoManager"), null !== b && b.ez(this), this.w = a, null !== a && a.ly(this))
            }
        }, skipsUndoManager: {
            configurable: !0, get: function () {
                return this.Hg
            },
            set: function (a) {
                A(a, "boolean", X, "skipsUndoManager");
                this.Hg = a
            }
        }, nodeKeyProperty: {
            configurable: !0, get: function () {
                return this.Wi
            }, set: function (a) {
                var b = this.Wi;
                b !== a && (Hr(a, X, "nodeKeyProperty"), "" === a && v("Model.nodeKeyProperty may not be the empty string"), 0 < this.ab.count && v("Cannot set Model.nodeKeyProperty when there is existing node data"), this.Wi = a, this.g("nodeKeyProperty", b, a))
            }
        }, makeUniqueKeyFunction: {
            configurable: !0, get: function () {
                return this.am
            }, set: function (a) {
                var b =
                    this.am;
                b !== a && (null !== a && A(a, "function", X, "makeUniqueKeyFunction"), this.am = a, this.g("makeUniqueKeyFunction", b, a))
            }
        }, nodeDataArray: {
            configurable: !0, get: function () {
                return this.xc
            }, set: function (a) {
                var b = this.xc;
                if (b !== a) {
                    Ia(a, X, "nodeDataArray");
                    this.ab.clear();
                    this.gx();
                    for (var c = a.length, d = 0; d < c; d++) {
                        var e = a[d];
                        if (!Ga(e)) {
                            v("Model.nodeDataArray must only contain Objects, not: " + e);
                            return
                        }
                        wb(e)
                    }
                    this.xc = a;
                    d = new H;
                    for (e = 0; e < c; e++) {
                        var f = a[e], g = this.pa(f);
                        void 0 === g ? d.add(f) : null !== this.ab.K(g) ?
                            d.add(f) : this.ab.add(g, f)
                    }
                    for (d = d.iterator; d.next();) e = d.value, this.ju(e), f = this.pa(e), void 0 !== f && this.ab.add(f, e);
                    Gr(this, "nodeDataArray", Le, "nodeDataArray", this, b, a);
                    for (b = 0; b < c; b++) d = a[b], this.bn(d), this.an(d);
                    Array.isArray(a) || (this.isReadOnly = !0)
                }
            }
        }, copyNodeDataFunction: {
            configurable: !0, get: function () {
                return this.sl
            }, set: function (a) {
                var b = this.sl;
                b !== a && (null !== a && A(a, "function", X, "copyNodeDataFunction"), this.sl = a, this.g("copyNodeDataFunction", b, a))
            }
        }, copiesArrays: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Nn
            }, set: function (a) {
                var b = this.Nn;
                b !== a && (null !== a && A(a, "boolean", X, "copiesArrays"), this.Nn = a, this.g("copiesArrays", b, a))
            }
        }, copiesArrayObjects: {
            configurable: !0, get: function () {
                return this.Mn
            }, set: function (a) {
                var b = this.Mn;
                b !== a && (null !== a && A(a, "boolean", X, "copiesArrayObjects"), this.Mn = a, this.g("copiesArrayObjects", b, a))
            }
        }, copiesKey: {
            configurable: !0, get: function () {
                return this.Pn
            }, set: function (a) {
                var b = this.Pn;
                b !== a && (null !== a && A(a,
                    "boolean", X, "copiesKey"), this.Pn = a, this.g("copiesKey", b, a))
            }
        }, afterCopyFunction: {
            configurable: !0, get: function () {
                return this.un
            }, set: function (a) {
                var b = this.un;
                b !== a && (null !== a && A(a, "function", X, "afterCopyFunction"), this.un = a, this.g("afterCopyFunction", b, a))
            }
        }, nodeCategoryProperty: {
            configurable: !0, get: function () {
                return this.hk
            }, set: function (a) {
                var b = this.hk;
                b !== a && (Hr(a, X, "nodeCategoryProperty"), this.hk = a, this.g("nodeCategoryProperty", b, a))
            }
        }, type: {
            configurable: !0,
            get: function () {
                return "Model"
            }
        }
    });
    X.prototype.setCategoryForNodeData = X.prototype.fn;
    X.prototype.getCategoryForNodeData = X.prototype.Rq;
    X.prototype.removeArrayItem = X.prototype.Dw;
    X.prototype.insertArrayItem = X.prototype.au;
    X.prototype.addArrayItem = X.prototype.Cz;
    X.prototype.assignAllDataProperties = X.prototype.Eq;
    X.prototype.set = X.prototype.set;
    X.prototype.clearUnresolvedReferences = X.prototype.Rz;
    X.prototype.mergeNodeDataArray = X.prototype.bB;
    X.prototype.removeNodeDataCollection = X.prototype.lB;
    X.prototype.removeNodeData = X.prototype.Zm;
    X.prototype.addNodeDataCollection = X.prototype.Fz;
    X.prototype.addNodeData = X.prototype.Gf;
    X.prototype.makeNodeDataKeyUnique = X.prototype.ju;
    X.prototype.findNodeDataForKey = X.prototype.Rb;
    X.prototype.containsNodeData = X.prototype.$a;
    X.prototype.setKeyForNodeData = X.prototype.gn;
    X.prototype.getKeyForNodeData = X.prototype.pa;
    X.prototype.updateTargetBindings = X.prototype.Ha;
    X.prototype.commit = X.prototype.commit;
    X.prototype.rollbackTransaction = X.prototype.Uf;
    X.prototype.commitTransaction = X.prototype.bb;
    X.prototype.startTransaction = X.prototype.Ca;
    X.prototype.raiseDataChanged = X.prototype.ou;
    X.prototype.raiseChanged = X.prototype.g;
    X.prototype.raiseChangedEvent = X.prototype.ib;
    X.prototype.removeChangedListener = X.prototype.$k;
    X.prototype.addChangedListener = X.prototype.Rh;
    X.prototype.writeJsonValue = X.prototype.mn;
    X.prototype.replaceJsonObjects = X.prototype.$m;
    X.prototype.applyIncrementalJSON = X.prototype.Jz;
    X.prototype.applyIncrementalJson = X.prototype.ny;
    X.prototype.toJSON = X.prototype.toJSON;
    X.prototype.toJson = X.prototype.ur;
    X.prototype.toIncrementalJSON = X.prototype.wB;
    X.prototype.toIncrementalJson = X.prototype.nz;
    X.prototype.computeJsonDifference = X.prototype.Sz;
    X.prototype.toIncrementalData = X.prototype.vB;
    X.prototype.clear = X.prototype.clear;
    var Jr = !1, Kr = {};
    X.className = "Model";
    X.fromJSON = X.fromJson = function (a, b) {
        void 0 === b && (b = null);
        null !== b && w(b, X, X, "fromJson:model");
        var c = null;
        if ("string" === typeof a) try {
            c = qa.JSON.parse(a)
        } catch (f) {
            F && Ea("JSON.parse error: " + f.toString())
        } else "object" === typeof a ? c = a : v("Unable to construct a Model from: " + a);
        if (null === b) {
            a = null;
            var d = c["class"];
            if ("string" === typeof d) try {
                var e = null;
                0 === d.indexOf("go.") ? (d = d.substr(3), e = Dr(d)) : (e = Dr(d), null === e && (e = qa[d]));
                "function" === typeof e && (a = new e)
            } catch (f) {
            }
            null === a || a instanceof X ? b = a : v("Unable to construct a Model of declared class: " +
                c["class"])
        }
        null === b && (b = X.constructGraphLinksModel());
        b.jr(c);
        b.Bw(c);
        return b
    };
    X.safePropertyValue = Jn;
    X.safePropertySet = hk;
    Kr.Brush = Ll;
    Kr.ChangedEvent = Ke;
    Kr.Geometry = Hd;
    Kr.Margin = jc;
    Kr.Panel = W;
    Kr.Point = J;
    Kr.Rect = L;
    Kr.Size = Hb;
    Kr.Spot = M;
    Kr.Transaction = Pe;
    Kr.UndoManager = Qe;

    function Ti(a, b, c) {
        gb(this);
        this.s = !1;
        void 0 === a ? a = "" : A(a, "string", Ti, "constructor:targetprop");
        void 0 === b ? b = a : A(b, "string", Ti, "constructor:sourceprop");
        void 0 === c ? c = null : null !== c && A(c, "function", Ti, "constructor:conv");
        this.l = -1;
        this.td = null;
        this.zm = a;
        this.ym = this.qq = 0;
        this.st = null;
        this.Ho = !1;
        this.rm = b;
        this.Ln = c;
        this.gp = Lr;
        this.En = null;
        this.Yu = new I
    }

    Ti.prototype.copy = function () {
        var a = new Ti;
        a.zm = this.zm;
        a.qq = this.qq;
        a.ym = this.ym;
        a.st = this.st;
        a.Ho = this.Ho;
        a.rm = this.rm;
        a.Ln = this.Ln;
        a.gp = this.gp;
        a.En = this.En;
        return a
    };
    t = Ti.prototype;
    t.pb = function (a) {
        a.classType === Ti ? this.mode = a : Da(this, a)
    };
    t.toString = function () {
        return "Binding(" + this.targetProperty + ":" + this.sourceProperty + (-1 !== this.Hj ? " " + this.Hj : "") + " " + this.mode.name + ")"
    };
    t.freeze = function () {
        this.s = !0;
        return this
    };
    t.ka = function () {
        this.s = !1;
        return this
    };
    t.Yy = function (a) {
        void 0 === a && (a = null);
        null !== a && A(a, "function", Ti, "makeTwoWay");
        this.mode = Bn;
        this.backConverter = a;
        return this
    };
    t.fr = function (a) {
        void 0 === a && (a = "");
        F && A(a, "string", Ti, "ofObject:srcname");
        this.sourceName = a;
        this.isToModel = !1;
        return this
    };
    t.dB = function () {
        this.sourceName = null;
        this.isToModel = !0;
        return this
    };

    function yl(a, b, c) {
        a = a.sourceName;
        return null === a || "" === a ? b : "/" === a ? c.part : "." === a ? c : ".." === a ? c.panel : b.hb(a)
    }

    t.hx = function (a, b, c) {
        var d = this.rm;
        if (void 0 === c || "" === d || d === c) {
            c = this.zm;
            var e = this.Ln;
            if (null === e && "" === c) Ea("Binding error: target property is the empty string: " + this.toString()); else {
                F && "string" === typeof c && ("function" !== typeof a.setAttribute && 0 < c.length && "_" !== c[0] && !Ra(a, c) ? Ea("Binding error: undefined target property: " + c + " on " + a.toString()) : "name" === c && a instanceof N && Ea("Binding error: cannot modify GraphObject.name on " + a.toString()));
                var f = b;
                "" !== d && (f = Jn(b, d));
                if (void 0 !== f) if (null ===
                    e) "" !== c && hk(a, c, f); else try {
                    if ("" !== c) {
                        var g = e(f, a);
                        F && void 0 === g && Ea('Binding warning: conversion function returned undefined when setting target property "' + c + '" on ' + a.toString() + ", function is: " + e);
                        hk(a, c, g)
                    } else e(f, a)
                } catch (h) {
                    F && Ea("Binding error: " + h.toString() + ' setting target property "' + c + '" on ' + a.toString() + " with conversion function: " + e)
                }
            }
        }
    };
    t.yr = function (a, b, c, d) {
        if (this.gp === Bn) {
            var e = this.zm;
            if (void 0 === c || e === c) {
                c = this.rm;
                var f = this.En, g = a;
                "" !== e && (g = Jn(a, e));
                if (void 0 !== g && !this.Yu.contains(a)) try {
                    this.Yu.add(a);
                    var h = null !== d ? d.diagram : null, k = null !== h ? h.model : null;
                    if (null === f) if ("" !== c) null !== k ? (F && k.nodeKeyProperty === c && k.$a(b) && Ea("Binding error: cannot have TwoWay Binding on node data key property: " + this.toString()), k.setDataProperty(b, c, g)) : hk(b, c, g); else {
                        if (null !== k && null !== d && 0 <= d.itemIndex && null !== d.panel && Array.isArray(d.panel.itemArray)) {
                            var l =
                                d.itemIndex, m = d.panel.itemArray;
                            k.Dw(m, l);
                            k.au(m, l, g)
                        }
                    } else try {
                        if ("" !== c) {
                            var n = f(g, b, k);
                            null !== k ? (F && (k.nodeKeyProperty === c && k.$a(b) && Ea("Binding error: cannot have TwoWay Binding on node data key property: " + this.toString()), void 0 === n && Ea('Binding warning: conversion function returned undefined when setting source property "' + c + '" on ' + b.toString() + ", function is: " + f)), k.setDataProperty(b, c, n)) : hk(b, c, n)
                        } else {
                            var p = f(g, b, k);
                            if (void 0 !== p && null !== k && null !== d && 0 <= d.itemIndex && null !== d.panel && Array.isArray(d.panel.itemArray)) {
                                var r =
                                    d.itemIndex, q = d.panel.itemArray;
                                k.Dw(q, r);
                                k.au(q, r, p)
                            }
                        }
                    } catch (u) {
                        F && Ea("Binding error: " + u.toString() + ' setting source property "' + c + '" on ' + b.toString() + " with conversion function: " + f)
                    }
                } finally {
                    this.Yu.remove(a)
                }
            }
        }
    };
    na.Object.defineProperties(Ti.prototype, {
        Hj: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                this.s && va(this);
                A(a, "number", Ti, "targetId");
                this.l = a
            }
        }, targetProperty: {
            configurable: !0, get: function () {
                return this.zm
            }, set: function (a) {
                this.s && va(this);
                A(a, "string", Ti, "targetProperty");
                this.zm = a
            }
        }, sourceName: {
            configurable: !0, get: function () {
                return this.st
            }, set: function (a) {
                this.s && va(this);
                null !== a && A(a, "string", Ti, "sourceName");
                this.st = a;
                null !== a && (this.Ho =
                    !1)
            }
        }, isToModel: {
            configurable: !0, get: function () {
                return this.Ho
            }, set: function (a) {
                this.s && va(this);
                A(a, "boolean", Ti, "isToModel");
                this.Ho = a
            }
        }, sourceProperty: {
            configurable: !0, get: function () {
                return this.rm
            }, set: function (a) {
                this.s && va(this);
                A(a, "string", Ti, "sourceProperty");
                this.rm = a
            }
        }, converter: {
            configurable: !0, get: function () {
                return this.Ln
            }, set: function (a) {
                this.s && va(this);
                null !== a && A(a, "function", Ti, "converter");
                this.Ln = a
            }
        }, backConverter: {
            configurable: !0,
            get: function () {
                return this.En
            }, set: function (a) {
                this.s && va(this);
                null !== a && A(a, "function", Ti, "backConverter");
                this.En = a
            }
        }, mode: {
            configurable: !0, get: function () {
                return this.gp
            }, set: function (a) {
                this.s && va(this);
                ib(a, Ti, Ti, "mode");
                this.gp = a
            }
        }
    });
    Ti.prototype.updateSource = Ti.prototype.yr;
    Ti.prototype.updateTarget = Ti.prototype.hx;
    Ti.prototype.ofModel = Ti.prototype.dB;
    Ti.prototype.ofObject = Ti.prototype.fr;
    Ti.prototype.makeTwoWay = Ti.prototype.Yy;
    var al = "Binding", Lr = new E(Ti, "OneWay", 1), Bn = new E(Ti, "TwoWay", 2);
    Ti.className = "Binding";
    Ti.parseEnum = function (a, b) {
        A(a, "function", Ti, "parseEnum:ctor");
        ib(b, a, Ti, "parseEnum:defval");
        return function (c) {
            c = hb(a, c);
            return null === c ? b : c
        }
    };
    Ti.toString = Qa;
    Ti.OneWay = Lr;
    Ti.TwoWay = Bn;

    function Mr(a, b) {
        X.call(this);
        this.Cu = ',\n  "insertedLinkKeys": ';
        this.xx = ',\n  "modifiedLinkData": ';
        this.Eu = ',\n  "removedLinkKeys": ';
        F && 2 < arguments.length && v("GraphLinksModel constructor can only take two optional arguments, the Array of node data and the Array of link data.");
        this.fd = [];
        this.ng = new I;
        this.mb = new Db;
        this.Qi = "";
        this.Kj = this.rl = this.bm = null;
        this.mf = "from";
        this.nf = "to";
        this.ek = this.dk = "";
        this.ck = "category";
        this.ae = "";
        this.fm = "isGroup";
        this.Ge = "group";
        this.On = !1;
        void 0 !== a && (this.nodeDataArray =
            a);
        void 0 !== b && (this.linkDataArray = b)
    }

    ma(Mr, X);
    Mr.constructGraphLinksModel = X.constructGraphLinksModel;
    Mr.prototype.cloneProtected = function (a) {
        X.prototype.cloneProtected.call(this, a);
        a.Qi = this.Qi;
        a.bm = this.bm;
        a.rl = this.rl;
        a.mf = this.mf;
        a.nf = this.nf;
        a.dk = this.dk;
        a.ek = this.ek;
        a.ck = this.ck;
        a.ae = this.ae;
        a.fm = this.fm;
        a.Ge = this.Ge;
        a.On = this.On
    };
    t = Mr.prototype;
    t.clear = function () {
        X.prototype.clear.call(this);
        this.fd = [];
        this.mb.clear();
        this.ng.clear()
    };
    t.toString = function (a) {
        void 0 === a && (a = 0);
        if (2 <= a) return this.ur();
        var b = ("" !== this.name ? this.name : "") + " GraphLinksModel";
        if (0 < a) {
            b += "\n node data:";
            a = this.nodeDataArray;
            var c = a.length, d;
            for (d = 0; d < c; d++) {
                var e = a[d];
                b += " " + this.pa(e) + ":" + Qa(e)
            }
            b += "\n link data:";
            a = this.linkDataArray;
            c = a.length;
            for (d = 0; d < c; d++) e = a[d], b += " " + er(this, e, !0) + "--\x3e" + er(this, e, !1)
        }
        return b
    };
    t.mx = function (a, b) {
        "" === this.linkKeyProperty && v("GraphLinksModel.linkKeyProperty must not be an empty string for .toIncrementalData() to succeed.");
        var c = X.prototype.mx.call(this, a, b), d = this, e = new I, f = new I, g = new I, h = this.hi;
        a.changes.each(function (a) {
            a.model === d && ("linkDataArray" === a.modelChange ? a.change === Ne ? e.add(a.newValue) : a.change === Oe && g.add(a.oldValue) : d.Dc(a.object) ? f.add(a.object) : null !== a.object && (null !== a.object && h && h.contains(a.object) ? h.get(a.object).each(function (a) {
                    d.Dc(a) && f.add(a)
                }) :
                a.object instanceof X || d.$a(a.object) || Nr(d, a.object).each(function (a) {
                    f.add(a)
                })))
        });
        var k = this.Ui;
        k.clear();
        e.each(function (a) {
            k.add(d.bc(a));
            b || f.add(a)
        });
        var l = this.Xi;
        l.clear();
        g.each(function (a) {
            l.add(d.bc(a));
            b && f.add(a)
        });
        a = d.cloneDeep(f.ta());
        0 < k.count && (null === c && (c = {}), b ? c.removedLinkKeys = k.ta() : c.insertedLinkKeys = k.ta());
        0 < a.length && (null === c && (c = {}), c.modifiedLinkData = a);
        0 < l.count && (null === c && (c = {}), b ? c.insertedLinkKeys = l.ta() : c.removedLinkKeys = l.ta());
        l.clear();
        k.clear();
        return c
    };
    t.dl = function () {
        var a = X.prototype.dl.call(this), b = "";
        "category" !== this.linkCategoryProperty && "string" === typeof this.linkCategoryProperty && (b += ',\n  "linkCategoryProperty": ' + this.quote(this.linkCategoryProperty));
        "" !== this.linkKeyProperty && "string" === typeof this.linkKeyProperty && (b += ',\n  "linkKeyProperty": ' + this.quote(this.linkKeyProperty));
        "from" !== this.linkFromKeyProperty && "string" === typeof this.linkFromKeyProperty && (b += ',\n  "linkFromKeyProperty": ' + this.quote(this.linkFromKeyProperty));
        "to" !==
        this.linkToKeyProperty && "string" === typeof this.linkToKeyProperty && (b += ',\n  "linkToKeyProperty": ' + this.quote(this.linkToKeyProperty));
        "" !== this.linkFromPortIdProperty && "string" === typeof this.linkFromPortIdProperty && (b += ',\n  "linkFromPortIdProperty": ' + this.quote(this.linkFromPortIdProperty));
        "" !== this.linkToPortIdProperty && "string" === typeof this.linkToPortIdProperty && (b += ',\n  "linkToPortIdProperty": ' + this.quote(this.linkToPortIdProperty));
        "" !== this.linkLabelKeysProperty && "string" === typeof this.linkLabelKeysProperty &&
        (b += ',\n  "linkLabelKeysProperty": ' + this.quote(this.linkLabelKeysProperty));
        "isGroup" !== this.nodeIsGroupProperty && "string" === typeof this.nodeIsGroupProperty && (b += ',\n  "nodeIsGroupProperty": ' + this.quote(this.nodeIsGroupProperty));
        "group" !== this.nodeGroupKeyProperty && "string" === typeof this.nodeGroupKeyProperty && (b += ',\n  "nodeGroupKeyProperty": ' + this.quote(this.nodeGroupKeyProperty));
        return a + b
    };
    t.jr = function (a) {
        X.prototype.jr.call(this, a);
        a.linkKeyProperty && (this.linkKeyProperty = a.linkKeyProperty);
        a.linkFromKeyProperty && (this.linkFromKeyProperty = a.linkFromKeyProperty);
        a.linkToKeyProperty && (this.linkToKeyProperty = a.linkToKeyProperty);
        a.linkFromPortIdProperty && (this.linkFromPortIdProperty = a.linkFromPortIdProperty);
        a.linkToPortIdProperty && (this.linkToPortIdProperty = a.linkToPortIdProperty);
        a.linkCategoryProperty && (this.linkCategoryProperty = a.linkCategoryProperty);
        a.linkLabelKeysProperty && (this.linkLabelKeysProperty =
            a.linkLabelKeysProperty);
        a.nodeIsGroupProperty && (this.nodeIsGroupProperty = a.nodeIsGroupProperty);
        a.nodeGroupKeyProperty && (this.nodeGroupKeyProperty = a.nodeGroupKeyProperty)
    };
    t.nx = function () {
        var a = X.prototype.nx.call(this), b = ',\n  "linkDataArray": ' + xr(this, this.linkDataArray, !0);
        return a + b
    };
    t.Bw = function (a) {
        X.prototype.Bw.call(this, a);
        a = a.linkDataArray;
        Array.isArray(a) && (this.$m(a), this.linkDataArray = a)
    };
    t.zr = function (a) {
        if (!(a instanceof Mr)) return v("Model.computeJsonDifference: newmodel must be a GraphLinksModel"), "";
        "" === this.linkKeyProperty && v("GraphLinksModel.linkKeyProperty must not be an empty string for .computeJsonDifference() to succeed.");
        var b = X.prototype.zr.call(this, a);
        zr(this, a, "linkKeyProperty");
        zr(this, a, "linkFromKeyProperty");
        zr(this, a, "linkToKeyProperty");
        zr(this, a, "linkLabelKeysProperty");
        zr(this, a, "nodeIsGroupProperty");
        zr(this, a, "nodeGroupKeyProperty");
        var c = this.Ui;
        c.clear();
        var d = new I, e = this.Xi;
        e.clear();
        e.addAll(this.mb.iteratorKeys);
        for (var f = new Db, g = a.linkDataArray, h = g.length, k = 0; k < h; k++) {
            var l = g[k], m = a.bc(l);
            if (void 0 !== m) {
                e.remove(m);
                var n = this.Qg(m);
                null === n ? (c.add(m), d.add(l)) : yr(this, n, l, f) || d.add(l)
            } else this.cr(l), m = this.bc(l), c.add(m), d.add(l)
        }
        a = b;
        0 < c.count && (a += this.Cu + xr(this, c.ta(), !0));
        0 < d.count && (a += this.xx + xr(this, d.ta(), !0));
        0 < e.count && (a += this.Eu + xr(this, e.ta(), !0));
        e.clear();
        c.clear();
        return a
    };

    function Nr(a, b) {
        for (var c = new I, d = 0; d < a.linkDataArray.length; d++) {
            var e = a.linkDataArray[d];
            Br(a, b, e, e, c)
        }
        return c
    }

    t.lx = function (a, b) {
        "" === this.linkKeyProperty && v("GraphLinksModel.linkKeyProperty must not be an empty string for .toIncrementalJson() to succeed.");
        var c = X.prototype.lx.call(this, a, b), d = this, e = new I, f = new I, g = new I, h = this.hi;
        a.changes.each(function (a) {
            a.model === d && ("linkDataArray" === a.modelChange ? a.change === Ne ? e.add(a.newValue) : a.change === Oe && g.add(a.oldValue) : d.Dc(a.object) ? f.add(a.object) : null !== a.object && (null !== a.object && h && h.contains(a.object) ? h.get(a.object).each(function (a) {
                    d.Dc(a) && f.add(a)
                }) :
                a.object instanceof X || d.$a(a.object) || Nr(d, a.object).each(function (a) {
                    f.add(a)
                })))
        });
        var k = this.Ui;
        k.clear();
        e.each(function (a) {
            k.add(d.bc(a));
            b || f.add(a)
        });
        var l = this.Xi;
        l.clear();
        g.each(function (a) {
            l.add(d.bc(a));
            b && f.add(a)
        });
        a = c;
        0 < k.count && (a += (b ? this.Eu : this.Cu) + xr(this, k.ta(), !0));
        0 < f.count && (a += this.xx + xr(this, f.ta(), !0));
        0 < l.count && (a += (b ? this.Cu : this.Eu) + xr(this, l.ta(), !0));
        l.clear();
        k.clear();
        return a
    };
    t.ir = function (a) {
        (void 0 !== a.linkCategoryProperty && a.linkCategoryProperty !== this.linkCategoryProperty || void 0 !== a.linkKeyProperty && a.linkKeyProperty !== this.linkKeyProperty || void 0 !== a.linkFromKeyProperty && a.linkFromKeyProperty !== this.linkFromKeyProperty || void 0 !== a.linkToKeyProperty && a.linkToKeyProperty !== this.linkToKeyProperty || void 0 !== a.linkFromPortIdProperty && a.linkFromPortIdProperty !== this.linkFromPortIdProperty || void 0 !== a.linkToPortIdProperty && a.linkToPortIdProperty !== this.linkToPortIdProperty ||
            void 0 !== a.linkLabelKeysProperty && a.linkLabelKeysProperty !== this.linkLabelKeysProperty || void 0 !== a.nodeIsGroupProperty && a.nodeIsGroupProperty !== this.nodeIsGroupProperty || void 0 !== a.nodeGroupKeyProperty && a.nodeGroupKeyProperty !== this.nodeGroupKeyProperty) && v("applyIncrementalJson cannot change Model properties");
        X.prototype.ir.call(this, a);
        var b = a.insertedLinkKeys;
        if (Array.isArray(b)) for (var c = b.length, d = 0; d < c; d++) {
            var e = b[d], f = this.Qg(e);
            null === f && (f = this.Jq({}), this.tu(f, e), this.lj(f))
        }
        b = a.modifiedLinkData;
        if (Array.isArray(b)) for (c = b.length, d = 0; d < c; d++) if (e = b[d], f = this.bc(e), f = this.Qg(f), null !== f) {
            for (var g in e) "__gohashid" !== g && g !== this.linkKeyProperty && this.setDataProperty(f, g, e[g]);
            Or(this, e, f)
        }
        a = a.removedLinkKeys;
        if (Array.isArray(a)) for (g = a.length, b = 0; b < g; b++) c = this.Qg(a[b]), null !== c && this.Ym(c)
    };
    Mr.prototype.changeState = function (a, b) {
        if (null !== a && a.model === this) {
            if (a.change === Le) {
                var c = a.object, d = a.propertyName;
                if (d === this.linkKeyProperty && this.Dc(c)) {
                    var e = a.K(b);
                    b = a.K(!b);
                    void 0 !== b && this.mb.remove(b);
                    void 0 !== e && this.mb.add(e, c);
                    hk(c, d, e);
                    return
                }
            } else if (a.change === Ne) {
                c = a.newParam;
                if ("linkDataArray" === a.modelChange) {
                    a = a.newValue;
                    Ga(a) && "number" === typeof c && (d = this.bc(a), b ? (this.ng.remove(a), this.fd[c] === a && this.fd.splice(c, 1), void 0 !== d && this.mb.remove(d)) : (this.ng.add(a), this.fd[c] !==
                    a && this.fd.splice(c, 0, a), void 0 !== d && this.mb.add(d, a)));
                    return
                }
                if ("linkLabelKeys" === a.modelChange) {
                    d = this.Nf(a.object);
                    Array.isArray(d) && "number" === typeof c && (b ? (c = d.indexOf(a.newValue), 0 <= c && d.splice(c, 1)) : 0 > d.indexOf(a.newValue) && d.splice(c, 0, a.newValue));
                    return
                }
            } else if (a.change === Oe) {
                c = a.oldParam;
                if ("linkDataArray" === a.modelChange) {
                    a = a.oldValue;
                    Ga(a) && "number" === typeof c && (d = this.bc(a), b ? (this.ng.add(a), this.fd[c] !== a && this.fd.splice(c, 0, a), void 0 !== d && this.mb.add(d, a)) : (this.ng.remove(a), this.fd[c] ===
                    a && this.fd.splice(c, 1), void 0 !== d && this.mb.remove(d)));
                    return
                }
                if ("linkLabelKeys" === a.modelChange) {
                    d = this.Nf(a.object);
                    Array.isArray(d) && "number" === typeof c && (b ? 0 > d.indexOf(a.newValue) && d.splice(c, 0, a.newValue) : (c = d.indexOf(a.newValue), 0 <= c && d.splice(c, 1)));
                    return
                }
            }
            X.prototype.changeState.call(this, a, b)
        }
    };
    t = Mr.prototype;
    t.Sm = function (a) {
        if (void 0 !== a) {
            var b = this.Kj;
            if (null !== b) {
                var c = this.Rb(a);
                null === c && (c = this.copyNodeData(b), hk(c, this.nodeKeyProperty, a), this.Gf(c))
            }
            return a
        }
    };
    t.Ly = function (a) {
        return er(this, a, !0)
    };
    t.Nw = function (a, b) {
        mr(this, a, b, !0)
    };
    t.Oy = function (a) {
        return er(this, a, !1)
    };
    t.Sw = function (a, b) {
        mr(this, a, b, !1)
    };

    function er(a, b, c) {
        if (null !== b && (a = c ? a.mf : a.nf, "" !== a && (a = Jn(b, a), void 0 !== a))) {
            if (gr(a)) return a;
            v((c ? "FromKey" : "ToKey") + " value for link data " + b + " is not a number or a string: " + a)
        }
    }

    function mr(a, b, c, d) {
        null === c && (c = void 0);
        void 0 === c || gr(c) || xa(c, "number or string", Mr, d ? "setFromKeyForLinkData:key" : "setToKeyForLinkData:key");
        if (null !== b) {
            var e = d ? a.mf : a.nf;
            if ("" !== e) if (c = a.Sm(c), a.Dc(b)) {
                var f = Jn(b, e);
                f !== c && (kr(a, f, b), hk(b, e, c), null === a.Rb(c) && lr(a, c, b), Gr(a, d ? "linkFromKey" : "linkToKey", Le, e, b, f, c), "string" === typeof e && a.Ha(b, e))
            } else hk(b, e, c)
        }
    }

    t.My = function (a) {
        return dr(this, a, !0)
    };
    t.Ow = function (a, b) {
        nr(this, a, b, !0)
    };
    t.Py = function (a) {
        return dr(this, a, !1)
    };
    t.Tw = function (a, b) {
        nr(this, a, b, !1)
    };

    function dr(a, b, c) {
        if (null === b) return "";
        a = c ? a.dk : a.ek;
        if ("" === a) return "";
        b = Jn(b, a);
        return void 0 === b ? "" : b
    }

    function nr(a, b, c, d) {
        A(c, "string", Mr, d ? "setFromPortIdForLinkData:portname" : "setToPortIdForLinkData:portname");
        if (null !== b) {
            var e = d ? a.dk : a.ek;
            if ("" !== e) if (a.Dc(b)) {
                var f = Jn(b, e);
                void 0 === f && (f = "");
                f !== c && (hk(b, e, c), Gr(a, d ? "linkFromPortId" : "linkToPortId", Le, e, b, f, c), "string" === typeof e && a.Ha(b, e))
            } else hk(b, e, c)
        }
    }

    t.Nf = function (a) {
        if (null === a) return Pr;
        var b = this.ae;
        if ("" === b) return Pr;
        a = Jn(a, b);
        return void 0 === a ? Pr : a
    };
    t.uu = function (a, b) {
        Ia(b, Mr, "setLabelKeysForLinkData:arr");
        if (null !== a) {
            var c = this.ae;
            if ("" !== c) if (this.Dc(a)) {
                var d = Jn(a, c);
                void 0 === d && (d = Pr);
                if (d !== b) {
                    if (Array.isArray(d)) for (var e = d.length, f = 0; f < e; f++) kr(this, d[f], a);
                    hk(a, c, b);
                    e = b.length;
                    for (f = 0; f < e; f++) {
                        var g = b[f];
                        null === this.Rb(g) && lr(this, g, a)
                    }
                    Gr(this, "linkLabelKeys", Le, c, a, d, b);
                    "string" === typeof c && this.Ha(a, c)
                }
            } else hk(a, c, b)
        }
    };
    t.Ov = function (a, b) {
        if (null !== b && void 0 !== b && (gr(b) || xa(b, "number or string", Mr, "addLabelKeyForLinkData:key"), null !== a)) {
            var c = this.ae;
            if ("" !== c) {
                var d = Jn(a, c);
                if (void 0 === d) c = [], c.push(b), this.uu(a, c); else if (Array.isArray(d)) {
                    var e = d.indexOf(b);
                    0 <= e || (e = d.length, d.push(b), this.Dc(a) && (null === this.Rb(b) && lr(this, b, a), Gr(this, "linkLabelKeys", Ne, c, a, null, b, null, e)))
                } else v(c + " property is not an Array; cannot addLabelKeyForLinkData: " + a)
            }
        }
    };
    t.dz = function (a, b) {
        if (null !== b && void 0 !== b && (gr(b) || xa(b, "number or string", Mr, "removeLabelKeyForLinkData:key"), null !== a)) {
            var c = this.ae;
            if ("" !== c) {
                var d = Jn(a, c);
                if (Array.isArray(d)) {
                    var e = d.indexOf(b);
                    0 > e || (d.splice(e, 1), this.Dc(a) && (kr(this, b, a), Gr(this, "linkLabelKeys", Oe, c, a, b, null, e, null)))
                } else void 0 !== d && v(c + " property is not an Array; cannot removeLabelKeyforLinkData: " + a)
            }
        }
    };
    t.bc = function (a) {
        if (null !== a) {
            var b = this.Qi;
            if ("" !== b && (b = Jn(a, b), void 0 !== b)) {
                if (gr(b)) return b;
                v("Key value for link data " + a + " is not a number or a string: " + b)
            }
        }
    };
    t.tu = function (a, b) {
        void 0 !== b && null !== b && gr(b) || xa(b, "number or string", Mr, "setKeyForLinkData:key");
        if (null !== a) {
            var c = this.Qi;
            if ("" !== c) if (this.Dc(a)) {
                var d = Jn(a, c);
                d !== b && null === this.Qg(b) && (hk(a, c, b), void 0 !== d && this.mb.remove(d), this.mb.add(b, a), Gr(this, "linkKey", Le, c, a, d, b), "string" === typeof c && this.Ha(a, c))
            } else hk(a, c, b)
        }
    };
    t.Qg = function (a) {
        null === a && v("GraphLinksModel.findLinkDataForKey:key must not be null");
        return void 0 !== a && gr(a) ? this.mb.K(a) : null
    };
    t.cr = function (a) {
        if (null !== a) {
            var b = this.Qi;
            if ("" !== b) {
                var c = this.bc(a);
                if (void 0 === c || this.mb.contains(c)) {
                    var d = this.bm;
                    if (null !== d && (c = d(this, a), void 0 !== c && null !== c && !this.mb.contains(c))) {
                        hk(a, b, c);
                        return
                    }
                    if ("string" === typeof c) {
                        for (d = 2; this.mb.contains(c + d);) d++;
                        hk(a, b, c + d)
                    } else if (void 0 === c || "number" === typeof c) {
                        for (c = -this.mb.count - 1; this.mb.contains(c);) c--;
                        hk(a, b, c)
                    } else F && v("GraphLinksModel.getKeyForLinkData returned something other than a string or a number: " + c)
                }
            }
        }
    };
    t.Dc = function (a) {
        return null === a ? !1 : this.ng.contains(a)
    };
    t.lj = function (a) {
        null !== a && (wb(a), this.Dc(a) || ir(this, a, !0))
    };

    function ir(a, b, c) {
        if ("" !== a.linkKeyProperty) {
            var d = a.bc(b);
            if (void 0 !== d && a.mb.K(d) === b) return;
            a.cr(b);
            d = a.bc(b);
            if (void 0 === d) {
                v("GraphLinksModel.makeLinkDataKeyUnique failed on " + b + ". Data not added to model.");
                return
            }
            a.mb.add(d, b)
        }
        a.ng.add(b);
        d = null;
        c && (d = a.fd.length, a.fd.splice(d, 0, b));
        Gr(a, "linkDataArray", Ne, "linkDataArray", a, null, b, null, d);
        Qr(a, b)
    }

    t.Ez = function (a) {
        if (Array.isArray(a)) for (var b = a.length, c = 0; c < b; c++) this.lj(a[c]); else for (a = a.iterator; a.next();) this.lj(a.value)
    };
    t.Ym = function (a) {
        null !== a && hr(this, a, !0)
    };

    function hr(a, b, c) {
        a.ng.remove(b);
        var d = a.bc(b);
        void 0 !== d && a.mb.remove(d);
        d = null;
        if (c) {
            d = a.fd.indexOf(b);
            if (0 > d) return;
            a.fd.splice(d, 1)
        }
        Gr(a, "linkDataArray", Oe, "linkDataArray", a, b, null, d, null);
        c = er(a, b, !0);
        kr(a, c, b);
        c = er(a, b, !1);
        kr(a, c, b);
        d = a.Nf(b);
        if (Array.isArray(d)) for (var e = d.length, f = 0; f < e; f++) c = d[f], kr(a, c, b)
    }

    t.jB = function (a) {
        if (Array.isArray(a)) for (var b = a.length, c = 0; c < b; c++) this.Ym(a[c]); else for (a = a.iterator; a.next();) this.Ym(a.value)
    };
    t.aB = function (a) {
        "" === this.linkKeyProperty && v("GraphLinksModel.linkKeyProperty must not be an empty string for .mergeLinkDataArray() to succeed.");
        if (a !== this.linkDataArray && Ha(a)) {
            var b = this.Xi;
            b.clear();
            b.addAll(this.mb.iteratorKeys);
            var c = this.Ui;
            c.clear();
            for (var d = a.length, e = 0; e < d; e++) {
                var f = a[e], g = this.bc(f);
                if (void 0 !== g) {
                    c.add(g);
                    var h = this.Qg(g);
                    h !== f && (null !== h ? (this.Eq(h, f), Or(this, f, h)) : (f = this.cloneDeep(f), this.tu(f, g), this.lj(f)))
                } else g = this.cloneDeep(f), this.lj(g), c.add(this.bc(g))
            }
            for (a =
                     b.iterator; a.next();) d = a.value, c.contains(d) || (d = this.Qg(d)) && this.Ym(d);
            b.clear();
            c.clear()
        }
    };

    function Qr(a, b) {
        var c = er(a, b, !0);
        c = a.Sm(c);
        null === a.Rb(c) && lr(a, c, b);
        c = er(a, b, !1);
        c = a.Sm(c);
        null === a.Rb(c) && lr(a, c, b);
        var d = a.Nf(b);
        if (Array.isArray(d)) for (var e = d.length, f = 0; f < e; f++) c = d[f], null === a.Rb(c) && lr(a, c, b)
    }

    t.Jq = function (a) {
        if (null === a) return null;
        var b = this.rl;
        a = null !== b ? b(a, this) : Ir(this, a, !0);
        Ga(a) && (gb(a), "" !== this.mf && hk(a, this.mf, void 0), "" !== this.nf && hk(a, this.nf, void 0), "" !== this.ae && hk(a, this.ae, []));
        return a
    };
    t.eu = function (a) {
        if (null === a) return !1;
        var b = this.fm;
        return "" === b ? !1 : Jn(a, b) ? !0 : !1
    };
    t.Vh = function (a) {
        if (null !== a) {
            var b = this.Ge;
            if ("" !== b && (b = Jn(a, b), void 0 !== b)) {
                if (gr(b)) return b;
                v("GroupKey value for node data " + a + " is not a number or a string: " + b)
            }
        }
    };
    t.rr = function (a, b) {
        null === b && (b = void 0);
        void 0 === b || gr(b) || xa(b, "number or string", Mr, "setGroupKeyForNodeData:key");
        if (null !== a) {
            var c = this.Ge;
            if ("" !== c) if (this.$a(a)) {
                var d = Jn(a, c);
                d !== b && (kr(this, d, a), hk(a, c, b), null === this.Rb(b) && lr(this, b, a), Gr(this, "nodeGroupKey", Le, c, a, d, b), "string" === typeof c && this.Ha(a, c))
            } else hk(a, c, b)
        }
    };
    Mr.prototype.copyNodeData = function (a) {
        if (null === a) return null;
        a = X.prototype.copyNodeData.call(this, a);
        this.Bk || "" === this.Ge || void 0 === Jn(a, this.Ge) || hk(a, this.Ge, void 0);
        return a
    };
    Mr.prototype.setDataProperty = function (a, b, c) {
        F && (A(a, "object", Mr, "setDataProperty:data"), A(b, "string", Mr, "setDataProperty:propname"), "" === b && v("GraphLinksModel.setDataProperty: property name must not be an empty string when setting " + a + " to " + c));
        if (this.$a(a)) {
            if (b === this.nodeKeyProperty) {
                this.gn(a, c);
                return
            }
            if (b === this.nodeCategoryProperty) {
                this.fn(a, c);
                return
            }
            if (b === this.nodeGroupKeyProperty) {
                this.rr(a, c);
                return
            }
            F && b === this.nodeIsGroupProperty && v("GraphLinksModel.setDataProperty: property name must not be the nodeIsGroupProperty: " +
                b)
        } else if (this.Dc(a)) {
            if (b === this.linkFromKeyProperty) {
                mr(this, a, c, !0);
                return
            }
            if (b === this.linkToKeyProperty) {
                mr(this, a, c, !1);
                return
            }
            if (b === this.linkFromPortIdProperty) {
                nr(this, a, c, !0);
                return
            }
            if (b === this.linkToPortIdProperty) {
                nr(this, a, c, !1);
                return
            }
            if (b === this.linkKeyProperty) {
                this.tu(a, c);
                return
            }
            if (b === this.linkCategoryProperty) {
                this.qr(a, c);
                return
            }
            if (b === this.linkLabelKeysProperty) {
                this.uu(a, c);
                return
            }
        }
        var d = Jn(a, b);
        d !== c && (hk(a, b, c), this.ou(a, b, d, c))
    };
    t = Mr.prototype;
    t.Eq = function (a, b) {
        if (b) {
            var c = this.$a(a), d = this.Dc(a), e;
            for (e in b) "__gohashid" === e || c && e === this.nodeKeyProperty || c && e === this.nodeIsGroupProperty && Jn(a, e) === b[e] || d && e === this.linkKeyProperty || this.setDataProperty(a, e, b[e])
        }
    };
    t.nr = function (a, b) {
        X.prototype.nr.call(this, a, b);
        for (var c = this.ab.iterator; c.next();) this.Hw(c.value, a, b);
        for (c = this.ng.iterator; c.next();) {
            var d = c.value, e = a, f = b;
            if (er(this, d, !0) === e) {
                var g = this.mf;
                hk(d, g, f);
                Gr(this, "linkFromKey", Le, g, d, e, f);
                "string" === typeof g && this.Ha(d, g)
            }
            er(this, d, !1) === e && (g = this.nf, hk(d, g, f), Gr(this, "linkToKey", Le, g, d, e, f), "string" === typeof g && this.Ha(d, g));
            g = this.Nf(d);
            if (Array.isArray(g)) for (var h = g.length, k = this.ae, l = 0; l < h; l++) g[l] === e && (g[l] = f, Gr(this, "linkLabelKeys", Ne,
                k, d, e, f, l, l))
        }
    };
    t.Hw = function (a, b, c) {
        if (this.Vh(a) === b) {
            var d = this.Ge;
            hk(a, d, c);
            Gr(this, "nodeGroupKey", Le, d, a, b, c);
            "string" === typeof d && this.Ha(a, d)
        }
    };
    t.gx = function () {
        X.prototype.gx.call(this);
        for (var a = this.linkDataArray, b = a.length, c = 0; c < b; c++) Qr(this, a[c])
    };
    t.bn = function (a) {
        X.prototype.bn.call(this, a);
        a = this.pa(a);
        var b = jr(this, a);
        if (null !== b) {
            var c = Ma();
            for (b = b.iterator; b.next();) {
                var d = b.value;
                if (this.$a(d)) {
                    if (this.Vh(d) === a) {
                        var e = this.Ge;
                        Gr(this, "nodeGroupKey", Le, e, d, a, a);
                        "string" === typeof e && this.Ha(d, e);
                        c.push(d)
                    }
                } else if (er(this, d, !0) === a && (e = this.mf, Gr(this, "linkFromKey", Le, e, d, a, a), "string" === typeof e && this.Ha(d, e), c.push(d)), er(this, d, !1) === a && (e = this.nf, Gr(this, "linkToKey", Le, e, d, a, a), "string" === typeof e && this.Ha(d, e), c.push(d)), e = this.Nf(d),
                    Array.isArray(e)) for (var f = e.length, g = this.ae, h = 0; h < f; h++) e[h] === a && (Gr(this, "linkLabelKeys", Ne, g, d, a, a, h, h), c.push(d))
            }
            for (b = 0; b < c.length; b++) kr(this, a, c[b]);
            Oa(c)
        }
    };
    t.an = function (a) {
        X.prototype.an.call(this, a);
        var b = this.Vh(a);
        null === this.Rb(b) && lr(this, b, a)
    };
    t.wr = function (a) {
        X.prototype.wr.call(this, a);
        var b = this.Vh(a);
        kr(this, b, a)
    };
    t.Xt = function (a) {
        if (null === a) return "";
        var b = this.ck;
        if ("" === b) return "";
        b = Jn(a, b);
        if (void 0 === b) return "";
        if ("string" === typeof b) return b;
        v("getCategoryForLinkData found a non-string category for " + a + ": " + b);
        return ""
    };
    Mr.prototype.getLinkCategoryForData = function (a) {
        return this.Xt(a)
    };
    Mr.prototype.qr = function (a, b) {
        A(b, "string", Mr, "setCategoryForLinkData:cat");
        if (null !== a) {
            var c = this.ck;
            if ("" !== c) if (this.Dc(a)) {
                var d = Jn(a, c);
                void 0 === d && (d = "");
                d !== b && (hk(a, c, b), Gr(this, "linkCategory", Le, c, a, d, b), "string" === typeof c && this.Ha(a, c))
            } else hk(a, c, b)
        }
    };
    Mr.prototype.setLinkCategoryForData = function (a, b) {
        this.qr(a, b)
    };
    t = Mr.prototype;
    t.hn = function (a, b) {
        X.prototype.hn.call(this, a, b);
        this.rr(b, this.Vh(a))
    };

    function Or(a, b, c) {
        a.qr(c, a.Xt(b));
        a.Nw(c, a.Ly(b));
        a.Sw(c, a.Oy(b));
        a.uu(c, a.Nf(b));
        a.Ow(c, a.My(b));
        a.Tw(c, a.Py(b))
    }

    t.Kk = function () {
        return !0
    };
    t.Bj = function () {
        return !0
    };
    t.gu = function () {
        return !0
    };
    t.zj = function () {
        return !0
    };
    na.Object.defineProperties(Mr.prototype, {
        archetypeNodeData: {
            configurable: !0, get: function () {
                return this.Kj
            }, set: function (a) {
                var b = this.Kj;
                b !== a && (null !== a && A(a, "object", Mr, "archetypeNodeData"), this.Kj = a, this.g("archetypeNodeData", b, a))
            }
        }, linkFromKeyProperty: {
            configurable: !0, get: function () {
                return this.mf
            }, set: function (a) {
                var b = this.mf;
                b !== a && (Hr(a, Mr, "linkFromKeyProperty"), this.mf = a, this.g("linkFromKeyProperty", b, a))
            }
        }, linkToKeyProperty: {
            configurable: !0, get: function () {
                return this.nf
            },
            set: function (a) {
                var b = this.nf;
                b !== a && (Hr(a, Mr, "linkToKeyProperty"), this.nf = a, this.g("linkToKeyProperty", b, a))
            }
        }, linkFromPortIdProperty: {
            configurable: !0, get: function () {
                return this.dk
            }, set: function (a) {
                var b = this.dk;
                b !== a && (Hr(a, Mr, "linkFromPortIdProperty"), !F || a !== this.linkFromKeyProperty && a !== this.linkToKeyProperty || v("linkFromPortIdProperty name must not be the same as the GraphLinksModel.linkFromKeyProperty or linkToKeyProperty: " + a), this.dk = a, this.g("linkFromPortIdProperty", b, a))
            }
        },
        linkToPortIdProperty: {
            configurable: !0, get: function () {
                return this.ek
            }, set: function (a) {
                var b = this.ek;
                b !== a && (Hr(a, Mr, "linkToPortIdProperty"), !F || a !== this.linkFromKeyProperty && a !== this.linkToKeyProperty || v("linkFromPortIdProperty name must not be the same as the GraphLinksModel.linkFromKeyProperty or linkToKeyProperty: " + a), this.ek = a, this.g("linkToPortIdProperty", b, a))
            }
        }, linkLabelKeysProperty: {
            configurable: !0, get: function () {
                return this.ae
            }, set: function (a) {
                var b = this.ae;
                b !==
                a && (Hr(a, Mr, "linkLabelKeysProperty"), this.ae = a, this.g("linkLabelKeysProperty", b, a))
            }
        }, linkDataArray: {
            configurable: !0, get: function () {
                return this.fd
            }, set: function (a) {
                var b = this.fd;
                if (b !== a) {
                    Ia(a, Mr, "linkDataArray");
                    this.mb.clear();
                    for (var c = a.length, d = 0; d < c; d++) {
                        var e = a[d];
                        if (!Ga(e)) {
                            v("GraphLinksModel.linkDataArray must only contain Objects, not: " + e);
                            return
                        }
                        wb(e)
                    }
                    this.fd = a;
                    if ("" !== this.linkKeyProperty) {
                        d = new H;
                        for (e = 0; e < c; e++) {
                            var f = a[e], g = this.bc(f);
                            void 0 === g ? d.add(f) : null !== this.mb.K(g) ?
                                d.add(f) : this.mb.add(g, f)
                        }
                        for (d = d.iterator; d.next();) e = d.value, this.cr(e), f = this.bc(e), void 0 !== f && this.mb.add(f, e)
                    }
                    d = new I;
                    for (e = 0; e < c; e++) d.add(a[e]);
                    this.ng = d;
                    Gr(this, "linkDataArray", Le, "linkDataArray", this, b, a);
                    for (b = 0; b < c; b++) Qr(this, a[b])
                }
            }
        }, linkKeyProperty: {
            configurable: !0, get: function () {
                return this.Qi
            }, set: function (a) {
                var b = this.Qi;
                if (b !== a) {
                    Hr(a, Mr, "linkKeyProperty");
                    this.Qi = a;
                    this.mb.clear();
                    for (var c = this.linkDataArray.length, d = 0; d < c; d++) {
                        var e = this.linkDataArray[d], f = this.bc(e);
                        void 0 === f && (this.cr(e), f = this.bc(e));
                        void 0 !== f && this.mb.add(f, e)
                    }
                    this.g("linkKeyProperty", b, a)
                }
            }
        }, makeUniqueLinkKeyFunction: {
            configurable: !0, get: function () {
                return this.bm
            }, set: function (a) {
                var b = this.bm;
                b !== a && (null !== a && A(a, "function", Mr, "makeUniqueLinkKeyFunction"), this.bm = a, this.g("makeUniqueLinkKeyFunction", b, a))
            }
        }, copyLinkDataFunction: {
            configurable: !0, get: function () {
                return this.rl
            }, set: function (a) {
                var b = this.rl;
                b !== a && (null !== a && A(a, "function", Mr, "copyLinkDataFunction"),
                    this.rl = a, this.g("copyLinkDataFunction", b, a))
            }
        }, nodeIsGroupProperty: {
            configurable: !0, get: function () {
                return this.fm
            }, set: function (a) {
                var b = this.fm;
                b !== a && (Hr(a, Mr, "nodeIsGroupProperty"), this.fm = a, this.g("nodeIsGroupProperty", b, a))
            }
        }, nodeGroupKeyProperty: {
            configurable: !0, get: function () {
                return this.Ge
            }, set: function (a) {
                var b = this.Ge;
                b !== a && (Hr(a, Mr, "nodeGroupKeyProperty"), this.Ge = a, this.g("nodeGroupKeyProperty", b, a))
            }
        }, Bk: {
            configurable: !0, get: function () {
                return this.On
            },
            set: function (a) {
                this.On !== a && (A(a, "boolean", Mr, "copiesGroupKeyOfNodeData"), this.On = a)
            }
        }, linkCategoryProperty: {
            configurable: !0, get: function () {
                return this.ck
            }, set: function (a) {
                var b = this.ck;
                b !== a && (Hr(a, Mr, "linkCategoryProperty"), this.ck = a, this.g("linkCategoryProperty", b, a))
            }
        }, type: {
            configurable: !0, get: function () {
                return "GraphLinksModel"
            }
        }
    });
    Mr.prototype.setCategoryForLinkData = Mr.prototype.qr;
    Mr.prototype.getCategoryForLinkData = Mr.prototype.Xt;
    Mr.prototype.assignAllDataProperties = Mr.prototype.Eq;
    Mr.prototype.setGroupKeyForNodeData = Mr.prototype.rr;
    Mr.prototype.getGroupKeyForNodeData = Mr.prototype.Vh;
    Mr.prototype.isGroupForNodeData = Mr.prototype.eu;
    Mr.prototype.copyLinkData = Mr.prototype.Jq;
    Mr.prototype.mergeLinkDataArray = Mr.prototype.aB;
    Mr.prototype.removeLinkDataCollection = Mr.prototype.jB;
    Mr.prototype.removeLinkData = Mr.prototype.Ym;
    Mr.prototype.addLinkDataCollection = Mr.prototype.Ez;
    Mr.prototype.addLinkData = Mr.prototype.lj;
    Mr.prototype.containsLinkData = Mr.prototype.Dc;
    Mr.prototype.makeLinkDataKeyUnique = Mr.prototype.cr;
    Mr.prototype.findLinkDataForKey = Mr.prototype.Qg;
    Mr.prototype.setKeyForLinkData = Mr.prototype.tu;
    Mr.prototype.getKeyForLinkData = Mr.prototype.bc;
    Mr.prototype.removeLabelKeyForLinkData = Mr.prototype.dz;
    Mr.prototype.addLabelKeyForLinkData = Mr.prototype.Ov;
    Mr.prototype.setLabelKeysForLinkData = Mr.prototype.uu;
    Mr.prototype.getLabelKeysForLinkData = Mr.prototype.Nf;
    Mr.prototype.setToPortIdForLinkData = Mr.prototype.Tw;
    Mr.prototype.getToPortIdForLinkData = Mr.prototype.Py;
    Mr.prototype.setFromPortIdForLinkData = Mr.prototype.Ow;
    Mr.prototype.getFromPortIdForLinkData = Mr.prototype.My;
    Mr.prototype.setToKeyForLinkData = Mr.prototype.Sw;
    Mr.prototype.getToKeyForLinkData = Mr.prototype.Oy;
    Mr.prototype.setFromKeyForLinkData = Mr.prototype.Nw;
    Mr.prototype.getFromKeyForLinkData = Mr.prototype.Ly;
    Mr.prototype.clear = Mr.prototype.clear;
    var Pr = Object.freeze([]);
    Mr.className = "GraphLinksModel";
    Kr.GraphLinksModel = Mr;
    X.constructGraphLinksModel = X.constructGraphLinksModel = function () {
        return new Mr
    };
    X.initDiagramModel = Li = function () {
        return new Mr
    };

    function Rr(a) {
        F && 1 < arguments.length && v("TreeModel constructor can only take one optional argument, the Array of node data.");
        X.call(this);
        this.He = "parent";
        this.Qn = !1;
        this.jk = "parentLinkCategory";
        void 0 !== a && (this.nodeDataArray = a)
    }

    ma(Rr, X);
    Rr.constructGraphLinksModel = X.constructGraphLinksModel;
    Rr.prototype.cloneProtected = function (a) {
        X.prototype.cloneProtected.call(this, a);
        a.He = this.He;
        a.Qn = this.Qn;
        a.jk = this.jk
    };
    t = Rr.prototype;
    t.toString = function (a) {
        void 0 === a && (a = 0);
        if (2 <= a) return this.ur();
        var b = ("" !== this.name ? this.name : "") + " TreeModel";
        if (0 < a) {
            b += "\n node data:";
            a = this.nodeDataArray;
            for (var c = a.length, d = 0; d < c; d++) {
                var e = a[d];
                b += " " + this.pa(e) + ":" + Qa(e)
            }
        }
        return b
    };
    t.dl = function () {
        var a = X.prototype.dl.call(this), b = "";
        "parent" !== this.nodeParentKeyProperty && "string" === typeof this.nodeParentKeyProperty && (b += ',\n  "nodeParentKeyProperty": ' + this.quote(this.nodeParentKeyProperty));
        return a + b
    };
    t.jr = function (a) {
        X.prototype.jr.call(this, a);
        a.nodeParentKeyProperty && (this.nodeParentKeyProperty = a.nodeParentKeyProperty)
    };
    t.zr = function (a) {
        zr(this, a, "nodeParentKeyProperty");
        return X.prototype.zr.call(this, a)
    };
    t.ir = function (a) {
        void 0 !== a.nodeParentKeyProperty && a.nodeParentKeyProperty !== this.nodeParentKeyProperty && v("applyIncrementalJson cannot change Model properties");
        X.prototype.ir.call(this, a)
    };
    t.Sm = function (a) {
        return a
    };
    t.Wh = function (a) {
        if (null !== a) {
            var b = this.He;
            if ("" !== b && (b = Jn(a, b), void 0 !== b)) {
                if (gr(b)) return b;
                v("ParentKey value for node data " + a + " is not a number or a string: " + b)
            }
        }
    };
    t.je = function (a, b) {
        null === b && (b = void 0);
        void 0 === b || gr(b) || xa(b, "number or string", Rr, "setParentKeyForNodeData:key");
        if (null !== a) {
            var c = this.He;
            if ("" !== c) if (b = this.Sm(b), this.$a(a)) {
                var d = Jn(a, c);
                d !== b && (kr(this, d, a), hk(a, c, b), null === this.Rb(b) && lr(this, b, a), Gr(this, "nodeParentKey", Le, c, a, d, b), "string" === typeof c && this.Ha(a, c))
            } else hk(a, c, b)
        }
    };
    t.$t = function (a) {
        if (null === a) return "";
        var b = this.jk;
        if ("" === b) return "";
        b = Jn(a, b);
        if (void 0 === b) return "";
        if ("string" === typeof b) return b;
        v("getParentLinkCategoryForNodeData found a non-string category for " + a + ": " + b);
        return ""
    };
    Rr.prototype.getLinkCategoryForData = function (a) {
        return this.$t(a)
    };
    Rr.prototype.vu = function (a, b) {
        A(b, "string", Rr, "setParentLinkCategoryForNodeData:cat");
        if (null !== a) {
            var c = this.jk;
            if ("" !== c) if (this.$a(a)) {
                var d = Jn(a, c);
                void 0 === d && (d = "");
                d !== b && (hk(a, c, b), Gr(this, "parentLinkCategory", Le, c, a, d, b), "string" === typeof c && this.Ha(a, c))
            } else hk(a, c, b)
        }
    };
    Rr.prototype.setLinkCategoryForData = function (a, b) {
        this.vu(a, b)
    };
    Rr.prototype.copyNodeData = function (a) {
        if (null === a) return null;
        a = X.prototype.copyNodeData.call(this, a);
        this.Ck || "" === this.He || void 0 === Jn(a, this.He) || hk(a, this.He, void 0);
        return a
    };
    Rr.prototype.setDataProperty = function (a, b, c) {
        F && (A(a, "object", Rr, "setDataProperty:data"), A(b, "string", Rr, "setDataProperty:propname"), "" === b && v("TreeModel.setDataProperty: property name must not be an empty string when setting " + a + " to " + c));
        if (this.$a(a)) {
            if (b === this.nodeKeyProperty) {
                this.gn(a, c);
                return
            }
            if (b === this.nodeCategoryProperty) {
                this.fn(a, c);
                return
            }
            if (b === this.nodeParentKeyProperty) {
                this.je(a, c);
                return
            }
        }
        var d = Jn(a, b);
        d !== c && (hk(a, b, c), this.ou(a, b, d, c))
    };
    t = Rr.prototype;
    t.nr = function (a, b) {
        X.prototype.nr.call(this, a, b);
        for (var c = this.ab.iterator; c.next();) this.Hw(c.value, a, b)
    };
    t.Hw = function (a, b, c) {
        if (this.Wh(a) === b) {
            var d = this.He;
            hk(a, d, c);
            Gr(this, "nodeParentKey", Le, d, a, b, c);
            "string" === typeof d && this.Ha(a, d)
        }
    };
    t.bn = function (a) {
        X.prototype.bn.call(this, a);
        a = this.pa(a);
        var b = jr(this, a);
        if (null !== b) {
            var c = Ma();
            for (b = b.iterator; b.next();) {
                var d = b.value;
                if (this.$a(d) && this.Wh(d) === a) {
                    var e = this.He;
                    Gr(this, "nodeParentKey", Le, e, d, a, a);
                    "string" === typeof e && this.Ha(d, e);
                    c.push(d)
                }
            }
            for (b = 0; b < c.length; b++) kr(this, a, c[b]);
            Oa(c)
        }
    };
    t.an = function (a) {
        X.prototype.an.call(this, a);
        var b = this.Wh(a);
        b = this.Sm(b);
        null === this.Rb(b) && lr(this, b, a)
    };
    t.wr = function (a) {
        X.prototype.wr.call(this, a);
        var b = this.Wh(a);
        kr(this, b, a)
    };
    t.hn = function (a, b) {
        X.prototype.hn.call(this, a, b);
        this.vu(b, this.$t(a));
        this.je(b, this.Wh(a))
    };
    t.Qm = function () {
        return !0
    };
    t.gu = function () {
        return !0
    };
    na.Object.defineProperties(Rr.prototype, {
        nodeParentKeyProperty: {
            configurable: !0, get: function () {
                return this.He
            }, set: function (a) {
                var b = this.He;
                b !== a && (Hr(a, Rr, "nodeParentKeyProperty"), this.He = a, this.g("nodeParentKeyProperty", b, a))
            }
        }, Ck: {
            configurable: !0, get: function () {
                return this.Qn
            }, set: function (a) {
                this.Qn !== a && (A(a, "boolean", Rr, "copiesParentKeyOfNodeData"), this.Qn = a)
            }
        }, parentLinkCategoryProperty: {
            configurable: !0, get: function () {
                return this.jk
            }, set: function (a) {
                var b =
                    this.jk;
                b !== a && (Hr(a, Rr, "parentLinkCategoryProperty"), this.jk = a, this.g("parentLinkCategoryProperty", b, a))
            }
        }, linkCategoryProperty: {
            configurable: !0, get: function () {
                return this.parentLinkCategoryProperty
            }, set: function (a) {
                this.parentLinkCategoryProperty = a
            }
        }, type: {
            configurable: !0, get: function () {
                return "TreeModel"
            }
        }
    });
    Rr.prototype.setParentLinkCategoryForNodeData = Rr.prototype.vu;
    Rr.prototype.getParentLinkCategoryForNodeData = Rr.prototype.$t;
    Rr.prototype.setParentKeyForNodeData = Rr.prototype.je;
    Rr.prototype.getParentKeyForNodeData = Rr.prototype.Wh;
    Rr.className = "TreeModel";
    Kr.TreeModel = Rr;

    function Sr() {
        0 < arguments.length && Ba(Sr);
        Ni.call(this);
        this.Jx = this.eo = this.fc = 0;
        this.js = 360;
        this.Ix = Tr;
        this.Sj = 0;
        this.zx = new J;
        this.Ur = this.ee = 0;
        this.Ft = new Ur;
        this.Lu = this.ik = 0;
        this.wz = 600;
        this.Hp = NaN;
        this.zn = 1;
        this.lq = 0;
        this.wm = 360;
        this.Lb = Tr;
        this.N = Vr;
        this.hd = Wr;
        this.cd = Iq;
        this.xf = 6;
        this.qp = Xr
    }

    ma(Sr, Ni);
    Sr.prototype.cloneProtected = function (a) {
        Ni.prototype.cloneProtected.call(this, a);
        a.Hp = this.Hp;
        a.zn = this.zn;
        a.lq = this.lq;
        a.wm = this.wm;
        a.Lb = this.Lb;
        a.N = this.N;
        a.hd = this.hd;
        a.cd = this.cd;
        a.xf = this.xf;
        a.qp = this.qp
    };
    Sr.prototype.pb = function (a) {
        if (a.classType === Sr) if (a === Yr || a === Zr || a === $r || a === as || a === Wr) this.sorting = a; else if (a === bs || a === cs || a === Vr || a === ds) this.direction = a; else if (a === es || a === fs || a === Tr || a === gs) this.arrangement = a; else {
            if (a === hs || a === Xr) this.nodeDiameterFormula = a
        } else Ni.prototype.pb.call(this, a)
    };
    Sr.prototype.createNetwork = function () {
        return new is(this)
    };
    Sr.prototype.doLayout = function (a) {
        F && null === a && v("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts");
        null === this.network && (this.network = this.makeNetwork(a));
        this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
        a = this.network.vertexes;
        if (1 >= a.count) 1 === a.count && (a = a.first(), a.centerX = 0, a.centerY = 0); else {
            var b = new H;
            b.addAll(a.iterator);
            a = new H;
            var c = new H;
            var d = this.sort(b);
            var e, f, g = this.Ur;
            var h = this.arrangement;
            var k = this.nodeDiameterFormula;
            var l = this.radius;
            if (!isFinite(l) || 0 >= l) l = NaN;
            var m = this.aspectRatio;
            if (!isFinite(m) || 0 >= m) m = 1;
            var n = this.startAngle;
            isFinite(n) || (n = 0);
            var p = this.sweepAngle;
            if (!isFinite(p) || 360 < p || 1 > p) p = 360;
            b = this.spacing;
            isFinite(b) || (b = NaN);
            h === gs && k === hs ? h = Tr : h === gs && k !== hs && (h = this.arrangement);
            if ((this.direction === bs || this.direction === cs) && this.sorting !== Wr) {
                for (k = 0; !(k >= d.length); k += 2) {
                    a.add(d.M(k));
                    if (k + 1 >= d.length) break;
                    c.add(d.M(k + 1))
                }
                this.direction === bs ? (this.arrangement === gs && a.reverse(), d = new H, d.addAll(a),
                    d.addAll(c)) : (this.arrangement === gs && c.reverse(), d = new H, d.addAll(c), d.addAll(a))
            }
            k = d.length;
            for (var r = f = e = 0; r < d.length; r++) {
                var q = n + p * f * (this.direction === Vr ? 1 : -1) / k, u = d.M(r).diameter;
                isNaN(u) && (u = js(d.M(r), q));
                360 > p && (0 === r || r === d.length - 1) && (u /= 2);
                e += u;
                f++
            }
            if (isNaN(l) || h === gs) {
                isNaN(b) && (b = 6);
                if (h !== Tr && h !== gs) {
                    f = -Infinity;
                    for (g = 0; g < k; g++) r = d.M(g), e = d.M(g === k - 1 ? 0 : g + 1), isNaN(r.diameter) && js(r, 0), isNaN(e.diameter) && js(e, 0), f = Math.max(f, (r.diameter + e.diameter) / 2);
                    g = f + b;
                    h === es ? l = (f + b) / (2 * Math.PI / k) :
                        l = ks(this, g * (360 <= p ? k : k - 1), m, n * Math.PI / 180, p * Math.PI / 180)
                } else l = ks(this, e + (360 <= p ? k : k - 1) * (h !== gs ? b : 1.6 * b), m, n * Math.PI / 180, p * Math.PI / 180);
                f = l * m
            } else if (f = l * m, r = ls(this, l, f, n * Math.PI / 180, p * Math.PI / 180), isNaN(b)) {
                if (h === Tr || h === gs) b = (r - e) / (360 <= p ? k : k - 1)
            } else if (h === Tr || h === gs) r = (r - e) / (360 <= p ? k : k - 1), r < b ? (l = ks(this, e + b * (360 <= p ? k : k - 1), m, n * Math.PI / 180, p * Math.PI / 180), f = l * m) : b = r; else {
                g = -Infinity;
                for (e = 0; e < k; e++) q = d.M(e), u = d.M(e === k - 1 ? 0 : e + 1), isNaN(q.diameter) && js(q, 0), isNaN(u.diameter) && js(u, 0), g = Math.max(g,
                    (q.diameter + u.diameter) / 2);
                g += b;
                e = ks(this, g * (360 <= p ? k : k - 1), m, n * Math.PI / 180, p * Math.PI / 180);
                e > l ? (l = e, f = l * m) : g = r / (360 <= p ? k : k - 1)
            }
            this.Ix = h;
            this.fc = l;
            this.eo = m;
            this.Jx = n;
            this.js = p;
            this.Sj = b;
            this.ee = f;
            this.Ur = g;
            b = d;
            d = this.Ix;
            h = this.fc;
            l = this.Jx;
            m = this.js;
            n = this.Sj;
            p = this.ee;
            k = this.Ur;
            if (this.direction !== bs && this.direction !== cs || d !== gs) if (this.direction === bs || this.direction === cs) {
                g = 0;
                switch (d) {
                    case fs:
                        g = 180 * ms(this, h, p, l, k) / Math.PI;
                        break;
                    case Tr:
                        k = b = 0;
                        g = a.first();
                        null !== g && (b = js(g, Math.PI / 2));
                        g = c.first();
                        null !== g && (k = js(g, Math.PI / 2));
                        g = 180 * ms(this, h, p, l, n + (b + k) / 2) / Math.PI;
                        break;
                    case es:
                        g = m / b.length
                }
                if (this.direction === bs) {
                    switch (d) {
                        case fs:
                            ns(this, a, l, ds);
                            break;
                        case Tr:
                            os(this, a, l, ds);
                            break;
                        case es:
                            ps(this, a, m / 2, l, ds)
                    }
                    switch (d) {
                        case fs:
                            ns(this, c, l + g, Vr);
                            break;
                        case Tr:
                            os(this, c, l + g, Vr);
                            break;
                        case es:
                            ps(this, c, m / 2, l + g, Vr)
                    }
                } else {
                    switch (d) {
                        case fs:
                            ns(this, c, l, ds);
                            break;
                        case Tr:
                            os(this, c, l, ds);
                            break;
                        case es:
                            ps(this, c, m / 2, l, ds)
                    }
                    switch (d) {
                        case fs:
                            ns(this, a, l + g, Vr);
                            break;
                        case Tr:
                            os(this, a, l + g, Vr);
                            break;
                        case es:
                            ps(this,
                                a, m / 2, l + g, Vr)
                    }
                }
            } else switch (d) {
                case fs:
                    ns(this, b, l, this.direction);
                    break;
                case Tr:
                    os(this, b, l, this.direction);
                    break;
                case es:
                    ps(this, b, m, l, this.direction);
                    break;
                case gs:
                    qs(this, b, m, l, this.direction)
            } else qs(this, b, m, l - m / 2, Vr)
        }
        this.updateParts();
        this.network = null;
        this.isValidLayout = !0
    };

    function ps(a, b, c, d, e) {
        var f = a.js, g = a.fc;
        a = a.ee;
        d = d * Math.PI / 180;
        c = c * Math.PI / 180;
        for (var h = b.length, k = 0; k < h; k++) {
            var l = d + (e === Vr ? k * c / (360 <= f ? h : h - 1) : -(k * c) / h), m = b.M(k), n = g * Math.tan(l) / a;
            n = Math.sqrt((g * g + a * a * n * n) / (1 + n * n));
            m.centerX = n * Math.cos(l);
            m.centerY = n * Math.sin(l);
            m.actualAngle = 180 * l / Math.PI
        }
    }

    function os(a, b, c, d) {
        var e = a.fc, f = a.ee, g = a.Sj;
        c = c * Math.PI / 180;
        for (var h = b.length, k = 0; k < h; k++) {
            var l = b.M(k), m = b.M(k === h - 1 ? 0 : k + 1), n = f * Math.sin(c);
            l.centerX = e * Math.cos(c);
            l.centerY = n;
            l.actualAngle = 180 * c / Math.PI;
            isNaN(l.diameter) && js(l, 0);
            isNaN(m.diameter) && js(m, 0);
            l = ms(a, e, f, d === Vr ? c : -c, (l.diameter + m.diameter) / 2 + g);
            c += d === Vr ? l : -l
        }
    }

    function ns(a, b, c, d) {
        var e = a.fc, f = a.ee, g = a.Ur;
        c = c * Math.PI / 180;
        for (var h = b.length, k = 0; k < h; k++) {
            var l = b.M(k);
            l.centerX = e * Math.cos(c);
            l.centerY = f * Math.sin(c);
            l.actualAngle = 180 * c / Math.PI;
            l = ms(a, e, f, d === Vr ? c : -c, g);
            c += d === Vr ? l : -l
        }
    }

    function qs(a, b, c, d, e) {
        var f = a.js;
        a.ik = 0;
        a.Ft = new Ur;
        if (360 > c) {
            for (f = d + (e === Vr ? f : -f); 0 > f;) f += 360;
            f %= 360;
            180 < f && (f -= 360);
            f *= Math.PI / 180;
            a.Lu = f;
            rs(a, b, c, d, e)
        } else ss(a, b, c, d, e);
        a.Ft.commit(b)
    }

    function ss(a, b, c, d, e) {
        var f = a.fc, g = a.Sj, h = a.eo, k = f * Math.cos(d * Math.PI / 180), l = a.ee * Math.sin(d * Math.PI / 180),
            m = b.ta();
        if (3 === m.length) m[0].centerX = f, m[0].centerY = 0, m[1].centerX = m[0].centerX - m[0].width / 2 - m[1].width / 2 - g, m[1].y = m[0].y, m[2].centerX = (m[0].centerX + m[1].centerX) / 2, m[2].y = m[0].y - m[2].height - g; else if (4 === m.length) m[0].centerX = f, m[0].centerY = 0, m[2].centerX = -m[0].centerX, m[2].centerY = m[0].centerY, m[1].centerX = 0, m[1].y = Math.min(m[0].y, m[2].y) - m[1].height - g, m[3].centerX = 0, m[3].y = Math.max(m[0].y +
            m[0].height + g, m[2].y + m[2].height + g); else {
            f = J.alloc();
            for (var n = 0; n < m.length; n++) {
                m[n].centerX = k;
                m[n].centerY = l;
                if (n >= m.length - 1) break;
                ts(a, k, l, m, n, e, f) || us(a, k, l, m, n, e, f);
                k = f.x;
                l = f.y
            }
            J.free(f);
            a.ik++;
            if (!(23 < a.ik)) {
                k = m[0].centerX;
                l = m[0].centerY;
                f = m[m.length - 1].centerX;
                n = m[m.length - 1].centerY;
                var p = Math.abs(k - f) - ((m[0].width + m[m.length - 1].width) / 2 + g),
                    r = Math.abs(l - n) - ((m[0].height + m[m.length - 1].height) / 2 + g);
                g = 0;
                1 > Math.abs(r) ? Math.abs(k - f) < (m[0].width + m[m.length - 1].width) / 2 && (g = 0) : g = 0 < r ? r : 1 > Math.abs(p) ?
                    0 : p;
                k = Math.abs(f) > Math.abs(n) ? 0 < f !== l > n : 0 < n !== k < f;
                if (k = e === Vr ? k : !k) g = -Math.abs(g), g = Math.min(g, -m[m.length - 1].width), g = Math.min(g, -m[m.length - 1].height);
                a.Ft.compare(g, m);
                1 < Math.abs(g) && (a.fc = 8 > a.ik ? a.fc - g / (2 * Math.PI) : 5 > m.length && 10 < g ? a.fc / 2 : a.fc - (0 < g ? 1.7 : -2.3), a.ee = a.fc * h, ss(a, b, c, d, e))
            }
        }
    }

    function rs(a, b, c, d, e) {
        for (var f = a.fc, g = a.ee, h = a.eo, k = f * Math.cos(d * Math.PI / 180), l = g * Math.sin(d * Math.PI / 180), m = J.alloc(), n = b.ta(), p = 0; p < n.length; p++) {
            n[p].centerX = k;
            n[p].centerY = l;
            if (p >= n.length - 1) break;
            ts(a, k, l, n, p, e, m) || us(a, k, l, n, p, e, m);
            k = m.x;
            l = m.y
        }
        J.free(m);
        a.ik++;
        if (!(23 < a.ik)) {
            k = Math.atan2(l, k);
            k = e === Vr ? a.Lu - k : k - a.Lu;
            k = Math.abs(k) < Math.abs(k - 2 * Math.PI) ? k : k - 2 * Math.PI;
            f = k * (f + g) / 2;
            g = a.Ft;
            if (Math.abs(f) < Math.abs(g.Mm)) for (g.Mm = f, g.el = [], g.nn = [], k = 0; k < n.length; k++) g.el[k] = n[k].bounds.x, g.nn[k] = n[k].bounds.y;
            1 < Math.abs(f) && (a.fc = 8 > a.ik ? a.fc - f / (2 * Math.PI) : a.fc - (0 < f ? 1.7 : -2.3), a.ee = a.fc * h, rs(a, b, c, d, e))
        }
    }

    function ts(a, b, c, d, e, f, g) {
        var h = a.fc, k = a.ee, l = 0;
        a = (d[e].width + d[e + 1].width) / 2 + a.Sj;
        var m = !1;
        if (0 <= c !== (f === Vr)) {
            if (f = b + a, f > h) {
                f = b - a;
                if (f < -h) return g.x = f, g.y = l, !1;
                m = !0
            }
        } else if (f = b - a, f < -h) {
            f = b + a;
            if (f > h) return g.x = f, g.y = l, !1;
            m = !0
        }
        l = Math.sqrt(1 - Math.min(1, f * f / (h * h))) * k;
        0 > c !== m && (l = -l);
        if (Math.abs(c - l) > (d[e].height + d[e + 1].height) / 2) return g.x = f, g.y = l, !1;
        g.x = f;
        g.y = l;
        return !0
    }

    function us(a, b, c, d, e, f, g) {
        var h = a.fc, k = a.ee, l = 0;
        a = (d[e].height + d[e + 1].height) / 2 + a.Sj;
        d = !1;
        if (0 <= b !== (f === Vr)) {
            if (f = c - a, f < -k) {
                f = c + a;
                if (f > k) {
                    g.x = l;
                    g.y = f;
                    return
                }
                d = !0
            }
        } else if (f = c + a, f > k) {
            f = c - a;
            if (f < -k) {
                g.x = l;
                g.y = f;
                return
            }
            d = !0
        }
        l = Math.sqrt(1 - Math.min(1, f * f / (k * k))) * h;
        0 > b !== d && (l = -l);
        g.x = l;
        g.y = f
    }

    Sr.prototype.commitLayout = function () {
        this.commitNodes();
        this.isRouting && this.commitLinks()
    };
    Sr.prototype.commitNodes = function () {
        var a = null !== this.group && null !== this.group.placeholder && this.group.isSubGraphExpanded,
            b = a ? this.group.location.copy() : null, c = this.actualCenter;
        a ? c = new J(0, 0) : (c.x = this.arrangementOrigin.x + this.fc, c.y = this.arrangementOrigin.y + this.ee);
        for (var d = this.network.vertexes.iterator; d.next();) {
            var e = d.value;
            e.x += c.x;
            e.y += c.y;
            e.commit()
        }
        a && (this.group.Ya(), a = this.group.position.copy(), c = this.group.location.copy(), b = b.ke(c.ke(a)), this.group.move(b), this.zx = b.ke(a))
    };
    Sr.prototype.commitLinks = function () {
        for (var a = this.network.edges.iterator; a.next();) a.value.commit()
    };

    function ls(a, b, c, d, e) {
        var f = a.wz;
        if (.001 > Math.abs(a.eo - 1)) return void 0 !== d && void 0 !== e ? e * b : 2 * Math.PI * b;
        a = b > c ? Math.sqrt(b * b - c * c) / b : Math.sqrt(c * c - b * b) / c;
        var g = 0;
        var h = void 0 !== d && void 0 !== e ? e / (f + 1) : Math.PI / (2 * (f + 1));
        for (var k = 0, l = 0; l <= f; l++) {
            void 0 !== d && void 0 !== e ? k = d + l * e / f : k = l * Math.PI / (2 * f);
            var m = Math.sin(k);
            g += Math.sqrt(1 - a * a * m * m) * h
        }
        return void 0 !== d && void 0 !== e ? (b > c ? b : c) * g : 4 * (b > c ? b : c) * g
    }

    function ks(a, b, c, d, e) {
        return b / (void 0 !== d && void 0 !== e ? ls(a, 1, c, d, e) : ls(a, 1, c))
    }

    function ms(a, b, c, d, e) {
        if (.001 > Math.abs(a.eo - 1)) return e / b;
        var f = b > c ? Math.sqrt(b * b - c * c) / b : Math.sqrt(c * c - b * b) / c, g = 0;
        a = 2 * Math.PI / (700 * a.network.vertexes.count);
        b > c && (d += Math.PI / 2);
        for (var h = 0; ; h++) {
            var k = Math.sin(d + h * a);
            g += (b > c ? b : c) * Math.sqrt(1 - f * f * k * k) * a;
            if (g >= e) return h * a
        }
    }

    Sr.prototype.sort = function (a) {
        switch (this.sorting) {
            case $r:
                break;
            case as:
                a.reverse();
                break;
            case Yr:
                a.sort(this.comparer);
                break;
            case Zr:
                a.sort(this.comparer);
                a.reverse();
                break;
            case Wr:
                return this.xw(vs(a));
            default:
                v("Invalid sorting type.")
        }
        return a
    };

    function vs(a) {
        for (var b = [], c = 0; c < a.length; c++) b.push(0);
        c = new H;
        for (var d = 0; d < a.length; d++) {
            var e = -1, f = -1;
            if (0 === d) for (var g = 0; g < a.length; g++) {
                var h = a.M(g).edgesCount;
                h > e && (e = h, f = g)
            } else for (g = 0; g < a.length; g++) h = b[g], h > e && (e = h, f = g);
            c.add(a.M(f));
            b[f] = -1;
            f = a.M(f);
            for (g = f.sourceEdges; g.next();) e = a.indexOf(g.value.fromVertex), 0 > e || 0 <= b[e] && b[e]++;
            for (f = f.destinationEdges; f.next();) e = a.indexOf(f.value.toVertex), 0 > e || 0 <= b[e] && b[e]++
        }
        return c
    }

    Sr.prototype.xw = function (a) {
        for (var b = [], c = 0; c < a.length; c++) {
            var d = a.M(c);
            b[c] = [];
            for (var e, f = d.destinationEdges; f.next();) e = a.indexOf(f.value.toVertex), e !== c && 0 > b[c].indexOf(e) && b[c].push(e);
            for (d = d.sourceEdges; d.next();) e = a.indexOf(d.value.fromVertex), e !== c && 0 > b[c].indexOf(e) && b[c].push(e)
        }
        f = [];
        for (c = 0; c < b.length; c++) f[c] = 0;
        c = [];
        var g = [], h = [];
        d = [];
        e = new H;
        for (var k = 0, l = 0; l < b.length; l++) {
            var m = b[l].length;
            if (1 === m) d.push(l); else if (0 === m) e.add(a.M(l)); else {
                if (0 === k) c.push(l); else {
                    for (var n = m = Infinity,
                             p = -1, r = [], q = 0; q < c.length; q++) 0 > b[c[q]].indexOf(c[q === c.length - 1 ? 0 : q + 1]) && r.push(q === c.length - 1 ? 0 : q + 1);
                    if (0 === r.length) for (q = 0; q < c.length; q++) r.push(q);
                    for (q = 0; q < r.length; q++) {
                        for (var u = r[q], x = b[l], y = 0, z = 0; z < g.length; z++) {
                            var B = f[g[z]], D = f[h[z]];
                            if (B < D) {
                                var G = B;
                                B = D
                            } else G = D;
                            if (G < u && u <= B) for (D = 0; D < x.length; D++) {
                                var O = x[D];
                                0 > c.indexOf(O) || G < f[O] && f[O] < B || G === f[O] || B === f[O] || y++
                            } else for (D = 0; D < x.length; D++) O = x[D], 0 > c.indexOf(O) || G < f[O] && f[O] < B && G !== f[O] && B !== f[O] && y++
                        }
                        x = y;
                        for (z = y = 0; z < b[l].length; z++) G =
                            c.indexOf(b[l][z]), 0 <= G && (G = Math.abs(u - (G >= u ? G + 1 : G)), y += G < c.length + 1 - G ? G : c.length + 1 - G);
                        for (z = 0; z < g.length; z++) G = f[g[z]], B = f[h[z]], G >= u && G++, B >= u && B++, G > B && (D = B, B = G, G = D), B - G < (c.length + 2) / 2 === (G < u && u <= B) && y++;
                        if (x < m || x === m && y < n) m = x, n = y, p = u
                    }
                    c.splice(p, 0, l);
                    for (m = 0; m < c.length; m++) f[c[m]] = m;
                    for (m = 0; m < b[l].length; m++) n = b[l][m], 0 <= c.indexOf(n) && (g.push(l), h.push(n))
                }
                k++
            }
        }
        for (g = c.length; ;) {
            f = !0;
            for (h = 0; h < d.length; h++) if (k = d[h], l = b[k][0], m = c.indexOf(l), 0 <= m) {
                for (p = n = 0; p < b[l].length; p++) r = c.indexOf(b[l][p]),
                0 > r || r === m || (q = r > m ? r - m : m - r, n += r < m !== q > g - q ? 1 : -1);
                c.splice(0 > n ? m : m + 1, 0, k);
                d.splice(h, 1);
                h--
            } else f = !1;
            if (f) break; else c.push(d[0]), d.splice(0, 1)
        }
        for (b = 0; b < c.length; b++) e.add(a.M(c[b]));
        return e
    };
    na.Object.defineProperties(Sr.prototype, {
        radius: {
            configurable: !0, get: function () {
                return this.Hp
            }, set: function (a) {
                this.Hp !== a && (A(a, "number", Sr, "radius"), 0 < a || isNaN(a)) && (this.Hp = a, this.D())
            }
        }, aspectRatio: {
            configurable: !0, get: function () {
                return this.zn
            }, set: function (a) {
                this.zn !== a && (A(a, "number", Sr, "aspectRatio"), 0 < a && (this.zn = a, this.D()))
            }
        }, startAngle: {
            configurable: !0, get: function () {
                return this.lq
            }, set: function (a) {
                this.lq !== a && (A(a, "number", Sr, "startAngle"),
                    this.lq = a, this.D())
            }
        }, sweepAngle: {
            configurable: !0, get: function () {
                return this.wm
            }, set: function (a) {
                this.wm !== a && (A(a, "number", Sr, "sweepAngle"), 0 < a && 360 >= a ? this.wm = a : this.wm = 360, this.D())
            }
        }, arrangement: {
            configurable: !0, get: function () {
                return this.Lb
            }, set: function (a) {
                this.Lb !== a && (ib(a, Sr, Sr, "arrangement"), a === gs || a === Tr || a === fs || a === es) && (this.Lb = a, this.D())
            }
        }, direction: {
            configurable: !0, get: function () {
                return this.N
            }, set: function (a) {
                this.N !== a && (ib(a, Sr, Sr, "direction"),
                a === Vr || a === ds || a === bs || a === cs) && (this.N = a, this.D())
            }
        }, sorting: {
            configurable: !0, get: function () {
                return this.hd
            }, set: function (a) {
                this.hd !== a && (ib(a, Sr, Sr, "sorting"), a === $r || a === as || a === Yr || Zr || a === Wr) && (this.hd = a, this.D())
            }
        }, comparer: {
            configurable: !0, get: function () {
                return this.cd
            }, set: function (a) {
                this.cd !== a && (A(a, "function", Sr, "comparer"), this.cd = a, this.D())
            }
        }, spacing: {
            configurable: !0, get: function () {
                return this.xf
            }, set: function (a) {
                this.xf !== a && (A(a, "number",
                    Sr, "spacing"), this.xf = a, this.D())
            }
        }, nodeDiameterFormula: {
            configurable: !0, get: function () {
                return this.qp
            }, set: function (a) {
                this.qp !== a && (ib(a, Sr, Sr, "nodeDiameterFormula"), a === Xr || a === hs) && (this.qp = a, this.D())
            }
        }, actualXRadius: {
            configurable: !0, get: function () {
                return this.fc
            }
        }, actualYRadius: {
            configurable: !0, get: function () {
                return this.ee
            }
        }, actualSpacing: {
            configurable: !0, get: function () {
                return this.Sj
            }
        }, actualCenter: {
            configurable: !0, get: function () {
                return this.zx
            }
        }
    });
    var Tr = new E(Sr, "ConstantSpacing", 0), fs = new E(Sr, "ConstantDistance", 1), es = new E(Sr, "ConstantAngle", 2),
        gs = new E(Sr, "Packed", 3), Vr = new E(Sr, "Clockwise", 4), ds = new E(Sr, "Counterclockwise", 5),
        bs = new E(Sr, "BidirectionalLeft", 6), cs = new E(Sr, "BidirectionalRight", 7), $r = new E(Sr, "Forwards", 8),
        as = new E(Sr, "Reverse", 9), Yr = new E(Sr, "Ascending", 10), Zr = new E(Sr, "Descending", 11),
        Wr = new E(Sr, "Optimized", 12), Xr = new E(Sr, "Pythagorean", 13), hs = new E(Sr, "Circular", 14);
    Sr.className = "CircularLayout";
    Sr.ConstantSpacing = Tr;
    Sr.ConstantDistance = fs;
    Sr.ConstantAngle = es;
    Sr.Packed = gs;
    Sr.Clockwise = Vr;
    Sr.Counterclockwise = ds;
    Sr.BidirectionalLeft = bs;
    Sr.BidirectionalRight = cs;
    Sr.Forwards = $r;
    Sr.Reverse = as;
    Sr.Ascending = Yr;
    Sr.Descending = Zr;
    Sr.Optimized = Wr;
    Sr.Pythagorean = Xr;
    Sr.Circular = hs;

    function Ur() {
        this.Mm = -Infinity;
        this.nn = this.el = null
    }

    Ur.prototype.compare = function (a, b) {
        if (0 < a && 0 > this.Mm || Math.abs(a) < Math.abs(this.Mm) && !(0 > a && 0 < this.Mm)) for (this.Mm = a, this.el = [], this.nn = [], a = 0; a < b.length; a++) this.el[a] = b[a].bounds.x, this.nn[a] = b[a].bounds.y
    };
    Ur.prototype.commit = function (a) {
        if (null !== this.el && null !== this.nn) for (var b = 0; b < this.el.length; b++) {
            var c = a.M(b);
            c.x = this.el[b];
            c.y = this.nn[b]
        }
    };
    Ur.className = "VertexArrangement";

    function is(a) {
        nq.call(this, a)
    }

    ma(is, nq);
    is.prototype.createVertex = function () {
        return new ws(this)
    };
    is.prototype.createEdge = function () {
        return new xs(this)
    };
    is.className = "CircularNetwork";

    function ws(a) {
        Bq.call(this, a);
        this.L = this.Qj = NaN
    }

    ma(ws, Bq);

    function js(a, b) {
        var c = a.network;
        if (null === c) return NaN;
        c = c.layout;
        if (null === c) return NaN;
        if (c.arrangement === gs) if (c.nodeDiameterFormula === hs) a.Qj = Math.max(a.width, a.height); else {
            c = Math.abs(Math.sin(b));
            b = Math.abs(Math.cos(b));
            if (0 === c) return a.width;
            if (0 === b) return a.height;
            a.Qj = Math.min(a.height / c, a.width / b)
        } else a.Qj = c.nodeDiameterFormula === hs ? Math.max(a.width, a.height) : Math.sqrt(a.width * a.width + a.height * a.height);
        return a.Qj
    }

    na.Object.defineProperties(ws.prototype, {
        diameter: {
            configurable: !0, get: function () {
                return this.Qj
            }, set: function (a) {
                this.Qj !== a && (A(a, "number", ws, "diameter"), this.Qj = a)
            }
        }, actualAngle: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                this.L !== a && (A(a, "number", ws, "actualAngle"), this.L = a)
            }
        }
    });
    ws.className = "CircularVertex";

    function xs(a) {
        Cq.call(this, a)
    }

    ma(xs, Cq);
    xs.className = "CircularEdge";

    function ys() {
        0 < arguments.length && Ba(ys);
        Ni.call(this);
        this.Ph = null;
        this.Lo = 0;
        this.Qd = (new Hb(100, 100)).freeze();
        this.yn = !1;
        this.vf = !0;
        this.od = !1;
        this.cm = 100;
        this.io = 1;
        this.jg = 1E3;
        this.jp = 10;
        this.Ip = Math;
        this.yl = .05;
        this.xl = 50;
        this.vl = 150;
        this.wl = 0;
        this.Yn = 10;
        this.Xn = 5
    }

    ma(ys, Ni);
    ys.prototype.cloneProtected = function (a) {
        Ni.prototype.cloneProtected.call(this, a);
        a.Qd.assign(this.Qd);
        a.yn = this.yn;
        a.vf = this.vf;
        a.od = this.od;
        a.cm = this.cm;
        a.io = this.io;
        a.jg = this.jg;
        a.jp = this.jp;
        a.Ip = this.Ip;
        a.yl = this.yl;
        a.xl = this.xl;
        a.vl = this.vl;
        a.wl = this.wl;
        a.Yn = this.Yn;
        a.Xn = this.Xn
    };
    ys.prototype.serializeLayoutProperties = function (a, b) {
        Ni.prototype.serializeLayoutProperties.call(this, a, b);
        a.arrangementSpacing = {width: this.arrangementSpacing.width, height: this.arrangementSpacing.height};
        a.arrangesToOrigin = this.arrangesToOrigin;
        a.setsPortSpots = this.setsPortSpots;
        a.comments = this.comments;
        a.maxIterations = this.maxIterations;
        a.epsilonDistance = this.epsilonDistance;
        a.infinityDistance = this.infinityDistance;
        a.moveLimit = this.moveLimit;
        a.defaultSpringStiffness = this.defaultSpringStiffness;
        a.defaultSpringLength =
            this.defaultSpringLength;
        a.defaultElectricalCharge = this.defaultElectricalCharge;
        a.defaultGravitationalMass = this.defaultGravitationalMass;
        a.defaultCommentSpringLength = this.defaultCommentSpringLength;
        a.defaultCommentElectricalCharge = this.defaultCommentElectricalCharge
    };
    ys.prototype.deserializeLayoutProperties = function (a, b, c, d) {
        Ni.prototype.deserializeLayoutProperties.call(this, a, b, c, d);
        this.arrangementSpacing = new Hb(a.arrangementSpacing.width, a.arrangementSpacing.height);
        this.arrangesToOrigin = a.arrangesToOrigin;
        this.setsPortSpots = a.setsPortSpots;
        this.comments = a.comments;
        this.maxIterations = a.maxIterations;
        this.epsilonDistance = a.epsilonDistance;
        this.infinityDistance = a.infinityDistance;
        this.moveLimit = a.moveLimit;
        this.defaultSpringStiffness = a.defaultSpringStiffness;
        this.defaultSpringLength = a.defaultSpringLength;
        this.defaultElectricalCharge = a.defaultElectricalCharge;
        this.defaultGravitationalMass = a.defaultGravitationalMass;
        this.defaultCommentSpringLength = a.defaultCommentSpringLength;
        this.defaultCommentElectricalCharge = a.defaultCommentElectricalCharge
    };
    ys.prototype.createNetwork = function () {
        return new zs(this)
    };
    ys.prototype.doLayout = function (a) {
        F && null === a && v("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts");
        null === this.network && (this.network = this.makeNetwork(a));
        if (!this.ix()) {
            a = this.maxIterations;
            if (0 < this.network.vertexes.count) {
                this.network.Kq();
                for (var b = this.network.vertexes.iterator; b.next();) {
                    var c = b.value;
                    c.charge = this.electricalCharge(c);
                    c.mass = this.gravitationalMass(c)
                }
                for (b = this.network.edges.iterator; b.next();) c = b.value, c.stiffness = this.springStiffness(c),
                    c.length = this.springLength(c);
                this.Qv();
                this.Lo = 0;
                if (this.needsClusterLayout()) {
                    b = this.network;
                    c = b.mz();
                    for (var d = c.iterator; d.next();) {
                        this.network = d.value;
                        for (var e = this.network.vertexes.iterator; e.next();) {
                            var f = e.value;
                            f.Md = f.vertexes.count;
                            f.bi = 1;
                            f.Ak = null;
                            f.Xe = null
                        }
                        As(this, 0, a)
                    }
                    this.network = b;
                    var g = d = c.iterator;
                    F && w(b, zs, ys, "arrangeConnectedGraphs:singletons");
                    d = this.arrangementSpacing;
                    var h = g.count, k = !0;
                    f = e = 0;
                    for (var l = Ma(), m = 0; m < h + b.vertexes.count + 2; m++) l[m] = null;
                    h = 0;
                    g.reset();
                    for (var n = L.alloc(); g.next();) if (m =
                        g.value, this.computeBounds(m, n), k) k = !1, e = n.x + n.width / 2, f = n.y + n.height / 2, l[0] = new J(n.x + n.width + d.width, n.y), l[1] = new J(n.x, n.y + n.height + d.height), h = 2; else {
                        var p = Bs(l, h, e, f, n.width, n.height, d), r = l[p], q = new J(r.x + n.width + d.width, r.y),
                            u = new J(r.x, r.y + n.height + d.height);
                        p + 1 < h && l.splice(p + 1, 0, null);
                        l[p] = q;
                        l[p + 1] = u;
                        h++;
                        p = r.x - n.x;
                        r = r.y - n.y;
                        for (m = m.vertexes.iterator; m.next();) q = m.value, q.centerX += p, q.centerY += r
                    }
                    L.free(n);
                    for (m = b.vertexes.iterator; m.next();) g = m.value, p = g.bounds, 2 > h ? (e = p.x + p.width / 2, f = p.y +
                        p.height / 2, l[0] = new J(p.x + p.width + d.width, p.y), l[1] = new J(p.x, p.y + p.height + d.height), h = 2) : (k = Bs(l, h, e, f, p.width, p.height, d), n = l[k], r = new J(n.x + p.width + d.width, n.y), p = new J(n.x, n.y + p.height + d.height), k + 1 < h && l.splice(k + 1, 0, null), l[k] = r, l[k + 1] = p, h++, g.centerX = n.x + g.width / 2, g.centerY = n.y + g.height / 2);
                    Oa(l);
                    for (d = c.iterator; d.next();) {
                        c = d.value;
                        for (e = c.vertexes.iterator; e.next();) b.Og(e.value);
                        for (c = c.edges.iterator; c.next();) b.Dm(c.value)
                    }
                }
                Cs(this, a);
                this.updateParts()
            }
            this.cm = a;
            this.network = null;
            this.isValidLayout =
                !0
        }
    };
    ys.prototype.needsClusterLayout = function () {
        if (3 > this.network.vertexes.count) return !1;
        for (var a = 0, b = 0, c = this.network.vertexes.first().bounds, d = this.network.vertexes.iterator; d.next();) {
            if (d.value.bounds.Sc(c) && (a++, 2 < a)) return !0;
            if (10 < b) break;
            b++
        }
        return !1
    };
    ys.prototype.computeBounds = function (a, b) {
        var c = !0;
        for (a = a.vertexes.iterator; a.next();) {
            var d = a.value;
            c ? (c = !1, b.set(d.bounds)) : b.Yc(d.bounds)
        }
        return b
    };

    function Ds(a, b, c) {
        F && (C(b, ys, "computeClusterLayoutIterations:level"), C(c, ys, "computeClusterLayoutIterations:maxiter"));
        return Math.max(Math.min(a.network.vertexes.count, c * (b + 1) / 11), 10)
    }

    function As(a, b, c) {
        F && (C(b, ys, "layoutClusters:level"), C(c, ys, "layoutClusters:maxiter"));
        if (Es(a, b)) {
            var d = a.jg;
            a.jg *= 1 + 1 / (b + 1);
            var e = Fs(a, b), f = Math.max(0, Ds(a, b, c));
            a.maxIterations += f;
            As(a, b + 1, c);
            Cs(a, f);
            Gs(a, e, b);
            c = e.vertexes.ta();
            c.sort(function (a, b) {
                return null === a || null === b || a === b ? 0 : b.Md - a.Md
            });
            for (e = 0; e < c.length; e++) Hs(a, c[e], b);
            a.jg = d
        }
    }

    function Es(a, b) {
        F && C(b, ys, "hasClusters:level");
        if (10 < b || 3 > a.network.vertexes.count) return !1;
        a.Ph = a.network.vertexes.ta();
        a = a.Ph;
        a.sort(function (a, b) {
            return null === a || null === b || a === b ? 0 : b.Md - a.Md
        });
        for (b = a.length - 1; 0 <= b && 1 >= a[b].Md;) b--;
        return 1 < a.length - b
    }

    function Fs(a, b) {
        F && C(b, ys, "pushSubNetwork:level");
        for (var c = a.network, d = new zs(a), e = 0; e < a.Ph.length; e++) {
            var f = a.Ph[e];
            if (1 < f.Md) {
                d.Og(f);
                var g = new Is;
                g.Au = f.Md;
                g.Bu = f.width;
                g.zu = f.height;
                g.ox = f.focus.x;
                g.px = f.focus.y;
                null === f.Xe && (f.Xe = new H);
                f.Xe.add(g);
                f.Lw = f.Xe.count - 1
            } else break
        }
        for (f = c.edges.iterator; f.next();) {
            var h = f.value;
            e = h.fromVertex;
            g = h.toVertex;
            e.network === d && g.network === d ? d.Dm(h) : e.network === d ? (h = e.Ak, null === h && (h = new H, e.Ak = h), h.add(g), e.Md--, e.bi += g.bi) : g.network === d && (h = g.Ak, null ===
            h && (h = new H, g.Ak = h), h.add(e), g.Md--, g.bi += e.bi)
        }
        for (e = d.edges.iterator; e.next();) f = e.value, f.length *= Math.max(1, K.sqrt((f.fromVertex.bi + f.toVertex.bi) / (4 * b + 1)));
        for (b = d.vertexes.iterator; b.next();) {
            e = b.value;
            var k = e.Ak;
            if (null !== k && 0 < k.count && (g = e.Xe.M(e.Xe.count - 1).Au - e.Md, !(0 >= g))) {
                for (var l = h = 0, m = k.count - g; m < k.count; m++) {
                    var n = k.M(m), p = null;
                    for (f = n.edges.iterator; f.next();) {
                        var r = f.value;
                        if (r.Ny(n) === e) {
                            p = r;
                            break
                        }
                    }
                    null !== p && (l += p.length, h += n.width * n.height)
                }
                f = e.centerX;
                k = e.centerY;
                m = e.width;
                n =
                    e.height;
                p = e.focus;
                r = m * n;
                1 > r && (r = 1);
                h = K.sqrt((h + r + l * l * 4 / (g * g)) / r);
                g = (h - 1) * m / 2;
                h = (h - 1) * n / 2;
                e.bounds = new L(f - p.x - g, k - p.y - h, m + 2 * g, n + 2 * h);
                e.focus = new J(p.x + g, p.y + h)
            }
        }
        a.network = d;
        return c
    }

    function Gs(a, b, c) {
        F && (w(b, zs, ys, "popNetwork:oldnet"), C(c, ys, "popNetwork:level"));
        for (c = a.network.vertexes.iterator; c.next();) {
            var d = c.value;
            d.network = b;
            if (null !== d.Xe) {
                var e = d.Xe.M(d.Lw);
                d.Md = e.Au;
                var f = e.ox, g = e.px;
                d.bounds = new L(d.centerX - f, d.centerY - g, e.Bu, e.zu);
                d.focus = new J(f, g);
                d.Lw--
            }
        }
        for (c = a.network.edges.iterator; c.next();) c.value.network = b;
        a.network = b
    }

    function Hs(a, b, c) {
        F && (w(b, Js, ys, "surroundNode:oldnet"), C(c, ys, "surroundNode:level"));
        var d = b.Ak;
        if (null !== d && 0 !== d.count) {
            c = b.centerX;
            var e = b.centerY, f = b.width, g = b.height;
            null !== b.Xe && 0 < b.Xe.count && (g = b.Xe.M(0), f = g.Bu, g = g.zu);
            f = K.sqrt(f * f + g * g) / 2;
            for (var h = !1, k = g = 0, l = 0, m = b.vertexes.iterator; m.next();) {
                var n = m.value;
                1 >= n.Md ? k++ : (h = !0, l++, g += Math.atan2(b.centerY - n.centerY, b.centerX - n.centerX))
            }
            if (0 !== k) for (0 < l && (g /= l), l = b = 0, b = h ? 2 * Math.PI / (k + 1) : 2 * Math.PI / k, 0 === k % 2 && (l = b / 2), 1 < d.count && d.sort(function (a,
                                                                                                                                                                         b) {
                return null === a || null === b || a === b ? 0 : b.width * b.height - a.width * a.height
            }), h = 0 === k % 2 ? 0 : 1, d = d.iterator; d.next();) if (k = d.value, !(1 < k.Md || a.isFixed(k))) {
                m = null;
                for (n = k.edges.iterator; n.next();) {
                    m = n.value;
                    break
                }
                n = k.width;
                var p = k.height;
                n = K.sqrt(n * n + p * p) / 2;
                m = f + m.length + n;
                n = g + (b * (h / 2 >> 1) + l) * (0 === h % 2 ? 1 : -1);
                k.centerX = c + m * Math.cos(n);
                k.centerY = e + m * Math.sin(n);
                h++
            }
        }
    }

    function Bs(a, b, c, d, e, f, g) {
        var h = 9E19, k = -1, l = 0;
        a:for (; l < b; l++) {
            var m = a[l], n = m.x - c, p = m.y - d;
            n = n * n + p * p;
            if (n < h) {
                for (p = l - 1; 0 <= p; p--) if (a[p].y > m.y && a[p].x - m.x < e + g.width) continue a;
                for (p = l + 1; p < b; p++) if (a[p].x > m.x && a[p].y - m.y < f + g.height) continue a;
                k = l;
                h = n
            }
        }
        return k
    }

    ys.prototype.Qv = function () {
        if (this.comments) for (var a = this.network.vertexes.iterator; a.next();) this.addComments(a.value)
    };
    ys.prototype.addComments = function (a) {
        var b = a.node;
        if (null !== b) for (b = b.dw(); b.next();) {
            var c = b.value;
            if ("Comment" === c.category && c.isVisible()) {
                var d = this.network.uj(c);
                null === d && (d = this.network.xk(c));
                d.charge = this.defaultCommentElectricalCharge;
                c = null;
                for (var e = d.destinationEdges; e.next();) {
                    var f = e.value;
                    if (f.toVertex === a) {
                        c = f;
                        break
                    }
                }
                if (null === c) for (e = d.sourceEdges; e.next();) if (f = e.value, f.fromVertex === a) {
                    c = f;
                    break
                }
                null === c && (c = this.network.Mk(a, d, null));
                c.length = this.defaultCommentSpringLength
            }
        }
    };

    function Ks(a, b) {
        F && (w(a, Js, ys, "getNodeDistance:vertexA"), w(b, Js, ys, "getNodeDistance:vertexB"));
        var c = a.bounds, d = c.x;
        a = c.y;
        var e = c.width;
        c = c.height;
        var f = b.bounds, g = f.x;
        b = f.y;
        var h = f.width;
        f = f.height;
        return d + e < g ? a > b + f ? (c = d + e - g, a = a - b - f, K.sqrt(c * c + a * a)) : a + c < b ? (d = d + e - g, a = a + c - b, K.sqrt(d * d + a * a)) : g - (d + e) : d > g + h ? a > b + f ? (c = d - g - h, a = a - b - f, K.sqrt(c * c + a * a)) : a + c < b ? (d = d - g - h, a = a + c - b, K.sqrt(d * d + a * a)) : d - (g + h) : a > b + f ? a - (b + f) : a + c < b ? b - (a + c) : .1
    }

    function Cs(a, b) {
        F && C(b, ys, "performIterations:num");
        a.Ph = null;
        for (b = a.Lo + b; a.Lo < b && (a.Lo++, Ls(a));) ;
        a.Ph = null
    }

    function Ls(a) {
        null === a.Ph && (a.Ph = a.network.vertexes.ta());
        var b = a.Ph;
        if (0 >= b.length) return !1;
        var c = b[0];
        c.forceX = 0;
        c.forceY = 0;
        for (var d = c.centerX, e = d, f = c = c.centerY, g = 1; g < b.length; g++) {
            var h = b[g];
            h.forceX = 0;
            h.forceY = 0;
            var k = h.centerX;
            h = h.centerY;
            d = Math.min(d, k);
            e = Math.max(e, k);
            c = Math.min(c, h);
            f = Math.max(f, h)
        }
        (e = e - d > f - c) ? b.sort(function (a, b) {
            return null === a || null === b || a === b ? 0 : a.centerX - b.centerX
        }) : b.sort(function (a, b) {
            return null === a || null === b || a === b ? 0 : a.centerY - b.centerY
        });
        c = a.jg;
        var l = d = h = 0;
        for (f =
                 0; f < b.length; f++) {
            g = b[f];
            d = g.bounds;
            h = g.focus;
            k = d.x + h.x;
            var m = d.y + h.y;
            d = g.charge * a.electricalFieldX(k, m);
            l = g.charge * a.electricalFieldY(k, m);
            d += g.mass * a.gravitationalFieldX(k, m);
            l += g.mass * a.gravitationalFieldY(k, m);
            g.forceX += d;
            g.forceY += l;
            for (var n = f + 1; n < b.length; n++) {
                var p = b[n];
                if (p !== g) {
                    d = p.bounds;
                    h = p.focus;
                    l = d.x + h.x;
                    var r = d.y + h.y;
                    if (k - l > c || l - k > c) {
                        if (e) break
                    } else if (m - r > c || r - m > c) {
                        if (!e) break
                    } else {
                        var q = Ks(g, p);
                        1 > q ? (d = a.randomNumberGenerator, null === d && (a.randomNumberGenerator = d = new Ms), q = d.random(),
                            h = d.random(), k > l ? (d = Math.abs(p.bounds.right - g.bounds.x), d = (1 + d) * q) : k < l ? (d = Math.abs(p.bounds.x - g.bounds.right), d = -(1 + d) * q) : (d = Math.max(p.width, g.width), d = (1 + d) * q - d / 2), m > r ? (l = Math.abs(p.bounds.bottom - g.bounds.y), l = (1 + l) * h) : k < l ? (l = Math.abs(p.bounds.y - g.bounds.bottom), l = -(1 + l) * h) : (l = Math.max(p.height, g.height), l = (1 + l) * h - l / 2)) : (h = -(g.charge * p.charge) / (q * q), d = (l - k) / q * h, l = (r - m) / q * h);
                        g.forceX += d;
                        g.forceY += l;
                        p.forceX -= d;
                        p.forceY -= l
                    }
                }
            }
        }
        for (e = a.network.edges.iterator; e.next();) h = e.value, c = h.fromVertex, f = h.toVertex,
            g = c.bounds, k = c.focus, d = g.x + k.x, g = g.y + k.y, m = f.bounds, n = f.focus, k = m.x + n.x, m = m.y + n.y, n = Ks(c, f), 1 > n ? (n = a.randomNumberGenerator, null === n && (a.randomNumberGenerator = n = new Ms), h = n.random(), n = n.random(), d = (d > k ? 1 : -1) * (1 + (f.width > c.width ? f.width : c.width)) * h, l = (g > m ? 1 : -1) * (1 + (f.height > c.height ? f.height : c.height)) * n) : (h = h.stiffness * (n - h.length), d = (k - d) / n * h, l = (m - g) / n * h), c.forceX += d, c.forceY += l, f.forceX -= d, f.forceY -= l;
        for (e = d = 0; e < b.length; e++) c = b[e], a.isFixed(c) ? a.moveFixedVertex(c) : d = Math.max(d, a.moveVertex(c) ||
            0);
        return d > a.epsilonDistance * a.epsilonDistance
    }

    ys.prototype.moveVertex = function (a) {
        var b = a.forceX, c = a.forceY, d = this.moveLimit;
        b < -d ? b = -d : b > d && (b = d);
        c < -d ? c = -d : c > d && (c = d);
        a.centerX += b;
        a.centerY += c;
        return b * b + c * c
    };
    ys.prototype.moveFixedVertex = function () {
    };
    ys.prototype.commitLayout = function () {
        this.Pw();
        this.commitNodes();
        this.isRouting && this.commitLinks()
    };
    ys.prototype.Pw = function () {
        if (this.setsPortSpots) for (var a = this.network.edges.iterator; a.next();) {
            var b = a.value.link;
            null !== b && (b.fromSpot = jd, b.toSpot = jd)
        }
    };
    ys.prototype.commitNodes = function () {
        var a = 0, b = 0;
        if (this.arrangesToOrigin) {
            var c = L.alloc();
            this.computeBounds(this.network, c);
            b = this.arrangementOrigin;
            a = b.x - c.x;
            b = b.y - c.y;
            L.free(c)
        }
        c = L.alloc();
        for (var d = this.network.vertexes.iterator; d.next();) {
            var e = d.value;
            if (0 !== a || 0 !== b) c.assign(e.bounds), c.x += a, c.y += b, e.bounds = c;
            e.commit()
        }
        L.free(c)
    };
    ys.prototype.commitLinks = function () {
        for (var a = this.network.edges.iterator; a.next();) a.value.commit()
    };
    ys.prototype.springStiffness = function (a) {
        a = a.stiffness;
        return isNaN(a) ? this.yl : a
    };
    ys.prototype.springLength = function (a) {
        a = a.length;
        return isNaN(a) ? this.xl : a
    };
    ys.prototype.electricalCharge = function (a) {
        a = a.charge;
        return isNaN(a) ? this.vl : a
    };
    ys.prototype.electricalFieldX = function () {
        return 0
    };
    ys.prototype.electricalFieldY = function () {
        return 0
    };
    ys.prototype.gravitationalMass = function (a) {
        a = a.mass;
        return isNaN(a) ? this.wl : a
    };
    ys.prototype.gravitationalFieldX = function () {
        return 0
    };
    ys.prototype.gravitationalFieldY = function () {
        return 0
    };
    ys.prototype.isFixed = function (a) {
        return a.isFixed
    };
    na.Object.defineProperties(ys.prototype, {
        currentIteration: {
            configurable: !0, get: function () {
                return this.Lo
            }
        }, arrangementSpacing: {
            configurable: !0, get: function () {
                return this.Qd
            }, set: function (a) {
                w(a, Hb, ys, "arrangementSpacing");
                this.Qd.A(a) || (this.Qd.assign(a), this.D())
            }
        }, arrangesToOrigin: {
            configurable: !0, get: function () {
                return this.yn
            }, set: function (a) {
                this.yn !== a && (A(a, "boolean", ys, "arrangesToOrigin"), this.yn = a, this.D())
            }
        }, setsPortSpots: {
            configurable: !0,
            get: function () {
                return this.vf
            }, set: function (a) {
                this.vf !== a && (A(a, "boolean", ys, "setsPortSpots"), this.vf = a, this.D())
            }
        }, comments: {
            configurable: !0, get: function () {
                return this.od
            }, set: function (a) {
                this.od !== a && (A(a, "boolean", ys, "comments"), this.od = a, this.D())
            }
        }, maxIterations: {
            configurable: !0, get: function () {
                return this.cm
            }, set: function (a) {
                this.cm !== a && (A(a, "number", ys, "maxIterations"), 0 <= a && (this.cm = a, this.D()))
            }
        }, epsilonDistance: {
            configurable: !0, get: function () {
                return this.io
            },
            set: function (a) {
                this.io !== a && (A(a, "number", ys, "epsilonDistance"), 0 < a && (this.io = a, this.D()))
            }
        }, infinityDistance: {
            configurable: !0, get: function () {
                return this.jg
            }, set: function (a) {
                this.jg !== a && (A(a, "number", ys, "infinityDistance"), 1 < a && (this.jg = a, this.D()))
            }
        }, moveLimit: {
            configurable: !0, get: function () {
                return this.jp
            }, set: function (a) {
                this.jp !== a && (A(a, "number", ys, "moveLimit"), 1 < a && (this.jp = a, this.D()))
            }
        }, randomNumberGenerator: {
            configurable: !0, get: function () {
                return this.Ip
            },
            set: function (a) {
                this.Ip !== a && (null !== a && "function" !== typeof a.random && v('ForceDirectedLayout.randomNumberGenerator must have a "random()" function on it: ' + a), this.Ip = a)
            }
        }, defaultSpringStiffness: {
            configurable: !0, get: function () {
                return this.yl
            }, set: function (a) {
                this.yl !== a && (A(a, "number", ys, "defaultSpringStiffness"), this.yl = a, this.D())
            }
        }, defaultSpringLength: {
            configurable: !0, get: function () {
                return this.xl
            }, set: function (a) {
                this.xl !== a && (A(a, "number", ys, "defaultSpringLength"),
                    this.xl = a, this.D())
            }
        }, defaultElectricalCharge: {
            configurable: !0, get: function () {
                return this.vl
            }, set: function (a) {
                this.vl !== a && (A(a, "number", ys, "defaultElectricalCharge"), this.vl = a, this.D())
            }
        }, defaultGravitationalMass: {
            configurable: !0, get: function () {
                return this.wl
            }, set: function (a) {
                this.wl !== a && (A(a, "number", ys, "defaultGravitationalMass"), this.wl = a, this.D())
            }
        }, defaultCommentSpringLength: {
            configurable: !0, get: function () {
                return this.Yn
            }, set: function (a) {
                this.Yn !==
                a && (A(a, "number", ys, "defaultCommentSpringLength"), this.Yn = a, this.D())
            }
        }, defaultCommentElectricalCharge: {
            configurable: !0, get: function () {
                return this.Xn
            }, set: function (a) {
                this.Xn !== a && (A(a, "number", ys, "defaultCommentElectricalCharge"), this.Xn = a, this.D())
            }
        }
    });
    ys.className = "ForceDirectedLayout";

    function Is() {
        this.px = this.ox = this.zu = this.Bu = this.Au = 0
    }

    Is.className = "ForceDirectedSubnet";

    function zs(a) {
        nq.call(this, a)
    }

    ma(zs, nq);
    zs.prototype.createVertex = function () {
        return new Js(this)
    };
    zs.prototype.createEdge = function () {
        return new Ns(this)
    };
    zs.className = "ForceDirectedNetwork";

    function Js(a) {
        Bq.call(this, a);
        this.Pa = !1;
        this.kb = this.L = NaN;
        this.bi = this.Md = this.Oa = this.W = 0;
        this.Xe = this.Ak = null;
        this.Lw = 0
    }

    ma(Js, Bq);
    Js.prototype.serializeVertexProperties = function (a, b) {
        Bq.prototype.serializeVertexProperties.call(this, a, b);
        a.isFixed = this.isFixed;
        a.charge = this.charge;
        a.mass = this.mass
    };
    Js.prototype.Lq = function (a, b, c, d) {
        Bq.prototype.Lq.call(this, a, b, c, d);
        this.isFixed = a.isFixed;
        this.charge = a.charge;
        this.mass = a.mass
    };
    na.Object.defineProperties(Js.prototype, {
        isFixed: {
            configurable: !0, get: function () {
                return this.Pa
            }, set: function (a) {
                this.Pa !== a && (A(a, "boolean", Js, "isFixed"), this.Pa = a)
            }
        }, charge: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                this.L !== a && (A(a, "number", Js, "charge"), this.L = a)
            }
        }, mass: {
            configurable: !0, get: function () {
                return this.kb
            }, set: function (a) {
                this.kb !== a && (A(a, "number", Js, "mass"), this.kb = a)
            }
        }, forceX: {
            configurable: !0, get: function () {
                return this.W
            },
            set: function (a) {
                this.W !== a && (A(a, "number", Js, "forceX"), this.W = a)
            }
        }, forceY: {
            configurable: !0, get: function () {
                return this.Oa
            }, set: function (a) {
                this.Oa !== a && (A(a, "number", Js, "forceY"), this.Oa = a)
            }
        }
    });
    Js.className = "ForceDirectedVertex";

    function Ns(a) {
        Cq.call(this, a);
        this.l = this.w = NaN
    }

    ma(Ns, Cq);
    Ns.prototype.serializeEdgeProperties = function (a, b) {
        Cq.prototype.serializeEdgeProperties.call(this, a, b);
        a.stiffness = this.stiffness;
        a.length = this.length
    };
    Ns.prototype.deserializeEdgeProperties = function (a, b, c, d) {
        Cq.prototype.deserializeEdgeProperties.call(this, a, b, c, d);
        this.stiffness = a.stiffness;
        this.length = a.length
    };
    na.Object.defineProperties(Ns.prototype, {
        stiffness: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                this.w !== a && (A(a, "number", Ns, "stiffness"), this.w = a)
            }
        }, length: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                this.l !== a && (A(a, "number", Ns, "length"), this.l = a)
            }
        }
    });
    Ns.className = "ForceDirectedEdge";

    function Ms() {
        var a = 0;
        void 0 === a && (a = 42);
        this.seed = a;
        this.oz = 48271;
        this.qz = 2147483647;
        this.Q = 44488.07041494893;
        this.rz = 3399;
        this.pz = 1 / 2147483647;
        this.random()
    }

    Ms.prototype.random = function () {
        var a = this.seed % this.Q * this.oz - this.seed / this.Q * this.rz;
        0 < a ? this.seed = a : this.seed = a + this.qz;
        return this.seed * this.pz
    };
    Ms.className = "RandomNumberGenerator";

    function Os() {
        0 < arguments.length && Ba(Os);
        Ni.call(this);
        this.ec = this.Ae = 25;
        this.N = 0;
        this.tl = Ps;
        this.Yl = Qs;
        this.Nl = Rs;
        this.ak = 4;
        this.il = Ss;
        this.Ag = 7;
        this.vf = !0;
        this.To = 4;
        this.Ga = this.Si = this.xa = -1;
        this.uc = this.yh = 0;
        this.Na = this.Ad = this.Bd = this.$d = this.Fb = null;
        this.Ah = 0;
        this.mp = this.fk = null;
        this.Lc = 0;
        this.np = null;
        this.bd = new J;
        this.Ee = [];
        this.Ee.length = 100
    }

    ma(Os, Ni);
    Os.prototype.cloneProtected = function (a) {
        Ni.prototype.cloneProtected.call(this, a);
        a.Ae = this.Ae;
        a.ec = this.ec;
        a.N = this.N;
        a.tl = this.tl;
        a.Yl = this.Yl;
        a.Nl = this.Nl;
        a.ak = this.ak;
        a.il = this.il;
        a.Ag = this.Ag;
        a.vf = this.vf;
        a.To = this.To
    };
    Os.prototype.serializeLayoutProperties = function (a, b) {
        Ni.prototype.serializeLayoutProperties.call(this, a, b);
        a.layerSpacing = this.layerSpacing;
        a.columnSpacing = this.columnSpacing;
        a.direction = this.direction;
        a.cycleRemoveOption = this.cycleRemoveOption.name;
        a.layeringOption = this.layeringOption.name;
        a.initializeOption = this.initializeOption.name;
        a.iterations = this.iterations;
        a.aggressiveOption = this.aggressiveOption.name;
        a.packOption = this.packOption;
        a.setsPortSpots = this.setsPortSpots;
        a.linkSpacing = this.linkSpacing;
        a.xa = this.xa;
        a.Si = this.Si;
        a.Ga = this.Ga;
        a.yh = this.yh;
        a.uc = this.uc;
        a.Fb = this.Fb;
        a.Ah = this.Ah;
        a.Lc = this.Lc;
        a.bd = {x: this.bd.x, y: this.bd.y}
    };
    Os.prototype.deserializeLayoutProperties = function (a, b, c, d) {
        Ni.prototype.deserializeLayoutProperties.call(this, a, b, c, d);
        this.layerSpacing = a.layerSpacing;
        this.columnSpacing = a.columnSpacing;
        this.direction = a.direction;
        this.cycleRemoveOption = hb(Os, a.cycleRemoveOption);
        this.layeringOption = hb(Os, a.layeringOption);
        this.initializeOption = hb(Os, a.initializeOption);
        this.iterations = a.iterations;
        this.aggressiveOption = hb(Os, a.aggressiveOption);
        this.packOption = a.packOption;
        this.setsPortSpots = a.setsPortSpots;
        this.linkSpacing =
            a.linkSpacing;
        this.xa = a.xa;
        this.Si = a.Si;
        this.Ga = a.Ga;
        this.yh = a.yh;
        this.uc = a.uc;
        this.Fb = a.Fb;
        this.Ah = a.Ah;
        this.Lc = a.Lc;
        this.bd = new J(this.bd.x, this.bd.y)
    };
    Os.prototype.pb = function (a) {
        a.classType === Os ? 0 === a.name.indexOf("Aggressive") ? this.aggressiveOption = a : 0 === a.name.indexOf("Cycle") ? this.cycleRemoveOption = a : 0 === a.name.indexOf("Init") ? this.initializeOption = a : 0 === a.name.indexOf("Layer") ? this.layeringOption = a : v("Unknown enum value: " + a) : Ni.prototype.pb.call(this, a)
    };
    Os.prototype.createNetwork = function () {
        return new Ts(this)
    };
    Os.prototype.doLayout = function (a) {
        F && null === a && v("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts");
        null === this.network && (this.network = this.makeNetwork(a));
        this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
        this.Si = -1;
        this.uc = this.yh = 0;
        this.np = this.mp = this.fk = null;
        for (a = 0; a < this.Ee.length; a++) this.Ee[a] = null;
        if (0 < this.network.vertexes.count) {
            this.network.Kq();
            if (this.ix()) return;
            this.cycleRemoveOption !== Us && this.removeCycles();
            for (a =
                     this.network.vertexes.iterator; a.next();) a.value.layer = -1;
            this.xa = -1;
            this.assignLayers();
            for (a.reset(); a.next();) this.xa = Math.max(this.xa, a.value.layer);
            this.cycleRemoveOption === Us && this.removeCycles();
            a = this.network;
            for (var b = [], c = a.edges.iterator; c.next();) {
                var d = c.value;
                d.valid = !1;
                b.push(d)
            }
            for (c = 0; c < b.length; c++) {
                d = b[c];
                var e = d.fromVertex, f = d.toVertex;
                if (!(d.valid || (null === e.node && null === e.data || null === f.node && null === f.data) && e.layer === f.layer)) {
                    var g = 0, h = 0, k = 0, l = 0;
                    if (null !== d.link) {
                        h = d.link;
                        if (null === h) continue;
                        var m = e.node;
                        g = f.node;
                        if (null === m || null === g) continue;
                        var n = h.fromNode;
                        k = h.toNode;
                        var p = h.fromPort;
                        h = h.toPort;
                        if (d.rev) {
                            l = n;
                            var r = p;
                            n = k;
                            p = h;
                            k = l;
                            h = r
                        }
                        var q = e.focus;
                        l = f.focus;
                        var u = d.rev ? f.bounds : e.bounds;
                        r = J.alloc();
                        m !== n ? u.o() && n.isVisible() ? n.actualBounds.o() ? (n.Pf(p, Mc, r), r.x += n.actualBounds.x - u.x, r.y += n.actualBounds.y - u.y) : (n.Pf(p, Mc, r), r.o() || r.assign(q)) : r.assign(q) : u.o() ? (n.Pf(p, Mc, r), r.o() || r.assign(q)) : r.assign(q);
                        n = d.rev ? e.bounds : f.bounds;
                        m = J.alloc();
                        g !== k ? n.o() && k.isVisible() ?
                            k.actualBounds.o() ? (k.Pf(h, Mc, m), m.x += k.actualBounds.x - n.x, m.y += k.actualBounds.y - n.y) : (k.Pf(h, Mc, m), m.o() || m.assign(l)) : m.assign(l) : n.o() ? (k.Pf(h, Mc, m), m.o() || m.assign(l)) : m.assign(l);
                        90 === this.N || 270 === this.N ? (g = Math.round((r.x - q.x) / this.ec), k = r.x, h = Math.round((m.x - l.x) / this.ec), l = m.x) : (g = Math.round((r.y - q.y) / this.ec), k = r.y, h = Math.round((m.y - l.y) / this.ec), l = m.y);
                        J.free(r);
                        J.free(m);
                        d.portFromColOffset = g;
                        d.portFromPos = k;
                        d.portToColOffset = h;
                        d.portToPos = l
                    } else d.portFromColOffset = 0, d.portFromPos = 0,
                        d.portToColOffset = 0, d.portToPos = 0;
                    r = e.layer;
                    m = f.layer;
                    n = 0;
                    u = d.link;
                    if (null !== u) {
                        var x = u.fromPort, y = u.toPort;
                        if (null !== x && null !== y) {
                            var z = u.fromNode;
                            p = u.toNode;
                            if (null !== z && null !== p) {
                                var B = Vs(this, !0), D = Vs(this, !1),
                                    G = this.setsPortSpots ? B : u.computeSpot(!0, x);
                                q = this.setsPortSpots ? D : u.computeSpot(!1, y);
                                var O = u.isOrthogonal;
                                G.Uc() && G.Qf(D) && q.Uc() && q.Qf(B) ? n = 0 : (B = u.getLinkPoint(z, x, G, !0, O, p, y, J.alloc()), D = u.getLinkDirection(z, x, B, G, !0, O, p, y), J.free(B), G.Zq() || D !== Ws(this, d, !0) ? this.setsPortSpots && null !==
                                    z && 1 === z.ports.count && d.rev && (n += 1) : n += 1, G = u.getLinkPoint(p, y, q, !1, O, z, x, J.alloc()), u = u.getLinkDirection(p, y, G, q, !1, O, z, x), J.free(G), q.Zq() || u !== Ws(this, d, !1) ? this.setsPortSpots && null !== p && 1 === p.ports.count && d.rev && (n += 2) : n += 2)
                            }
                        }
                    }
                    p = n;
                    n = 1 === p || 3 === p ? !0 : !1;
                    if (p = 2 === p || 3 === p ? !0 : !1) q = a.createVertex(), q.node = null, q.If = 1, q.layer = r, q.near = e, a.Og(q), e = a.Mk(e, q, d.link), e.valid = !1, e.rev = d.rev, e.portFromColOffset = g, e.portToColOffset = 0, e.portFromPos = k, e.portToPos = 0, e = q;
                    u = 1;
                    n && u--;
                    if (r - m > u && 0 < r) {
                        d.valid = !1;
                        q =
                            a.createVertex();
                        q.node = null;
                        q.If = 2;
                        q.layer = r - 1;
                        a.Og(q);
                        e = a.Mk(e, q, d.link);
                        e.valid = !0;
                        e.rev = d.rev;
                        e.portFromColOffset = p ? 0 : g;
                        e.portToColOffset = 0;
                        e.portFromPos = p ? 0 : k;
                        e.portToPos = 0;
                        e = q;
                        for (r--; r - m > u && 0 < r;) q = a.createVertex(), q.node = null, q.If = 3, q.layer = r - 1, a.Og(q), e = a.Mk(e, q, d.link), e.valid = !0, e.rev = d.rev, e.portFromColOffset = 0, e.portToColOffset = 0, e.portFromPos = 0, e.portToPos = 0, e = q, r--;
                        e = a.Mk(q, f, d.link);
                        e.valid = !n;
                        n && (q.near = f);
                        e.rev = d.rev;
                        e.portFromColOffset = 0;
                        e.portToColOffset = h;
                        e.portFromPos = 0;
                        e.portToPos =
                            l
                    } else d.valid = !0
                }
            }
            a = this.Fb = [];
            for (b = 0; b <= this.xa; b++) a[b] = 0;
            for (b = this.network.vertexes.iterator; b.next();) b.value.index = -1;
            this.initializeIndices();
            this.Si = -1;
            for (c = this.uc = this.yh = 0; c <= this.xa; c++) a[c] > a[this.uc] && (this.Si = a[c] - 1, this.uc = c), a[c] < a[this.yh] && (this.yh = c);
            this.np = [];
            for (c = 0; c < a.length; c++) this.np[c] = [];
            for (b.reset(); b.next();) a = b.value, this.np[a.layer][a.index] = a;
            this.Ga = -1;
            for (a = 0; a <= this.xa; a++) {
                b = Xs(this, a);
                c = 0;
                d = this.Fb[a];
                for (f = 0; f < d; f++) e = b[f], c += this.nodeMinColumnSpace(e,
                    !0), e.column = c, c += 1, c += this.nodeMinColumnSpace(e, !1);
                this.Ga = Math.max(this.Ga, c - 1);
                Ys(this, a, b)
            }
            this.reduceCrossings();
            this.straightenAndPack();
            this.updateParts()
        }
        this.network = null;
        this.isValidLayout = !0
    };
    Os.prototype.linkMinLength = function () {
        return 1
    };

    function Zs(a) {
        var b = a.fromVertex.node || a.fromVertex.data;
        a = a.toVertex.node || a.toVertex.data;
        return null === b && null === a ? 8 : null === b || null === a ? 4 : 1
    }

    Os.prototype.nodeMinLayerSpace = function (a, b) {
        return null === a.node && null === a.data ? 0 : 90 === this.N || 270 === this.N ? b ? a.focus.y + 10 : a.bounds.height - a.focus.y + 10 : b ? a.focus.x + 10 : a.bounds.width - a.focus.x + 10
    };
    Os.prototype.nodeMinColumnSpace = function (a, b) {
        if (null === a.node && null === a.data) return 0;
        var c = b ? a.Uk : a.Tk;
        if (null !== c) return c;
        c = this.N;
        return 90 === c || 270 === c ? b ? a.Uk = a.focus.x / this.ec + 1 | 0 : a.Tk = (a.bounds.width - a.focus.x) / this.ec + 1 | 0 : b ? a.Uk = a.focus.y / this.ec + 1 | 0 : a.Tk = (a.bounds.height - a.focus.y) / this.ec + 1 | 0
    };

    function $s(a) {
        null === a.fk && (a.fk = []);
        for (var b = 0, c = a.network.vertexes.iterator; c.next();) {
            var d = c.value;
            a.fk[b] = d.layer;
            b++;
            a.fk[b] = d.column;
            b++;
            a.fk[b] = d.index;
            b++
        }
        return a.fk
    }

    function at(a, b) {
        var c = 0;
        for (a = a.network.vertexes.iterator; a.next();) {
            var d = a.value;
            d.layer = b[c];
            c++;
            d.column = b[c];
            c++;
            d.index = b[c];
            c++
        }
    }

    function bt(a, b, c) {
        F && (C(b, Os, "crossingMatrix:unfixedLayer"), C(c, Os, "crossingMatrix:direction"));
        var d = Xs(a, b), e = a.Fb[b];
        if (null === a.mp || a.mp.length < e * e) a.mp = [];
        for (var f = a.mp, g = 0; g < e; g++) {
            var h = 0, k = d[g], l = k.near;
            if (null !== l && l.layer === k.layer) if (k = l.index, k > g) for (var m = g + 1; m < k; m++) {
                var n = d[m];
                n.near === l && n.If === l.If || h++
            } else for (m = g - 1; m > k; m--) n = d[m], n.near === l && n.If === l.If || h++;
            var p;
            if (0 <= c) for (k = d[g].sourceEdgesArrayAccess, l = 0; l < k.length; l++) {
                var r = k[l];
                if (r.valid && r.fromVertex.layer !== b) for (n =
                                                                  r.fromVertex.index, m = r.portToPos, r = r.portFromPos, p = l + 1; p < k.length; p++) {
                    var q = k[p];
                    if (q.valid && q.fromVertex.layer !== b) {
                        var u = q.fromVertex.index;
                        var x = q.portToPos;
                        q = q.portFromPos;
                        m < x && (n > u || n === u && r > q) && h++;
                        x < m && (u > n || u === n && q > r) && h++
                    }
                }
            }
            if (0 >= c) for (k = d[g].destinationEdgesArrayAccess, l = 0; l < k.length; l++) if (r = k[l], r.valid && r.toVertex.layer !== b) for (n = r.toVertex.index, m = r.portToPos, r = r.portFromPos, p = l + 1; p < k.length; p++) q = k[p], q.valid && q.toVertex.layer !== b && (u = q.toVertex.index, x = q.portToPos, q = q.portFromPos,
            r < q && (n > u || n === u && m > x) && h++, q < r && (u > n || u === n && x > m) && h++);
            f[g * e + g] = h;
            for (k = g + 1; k < e; k++) {
                var y = 0, z = 0;
                if (0 <= c) {
                    h = d[g].sourceEdgesArrayAccess;
                    var B = d[k].sourceEdgesArrayAccess;
                    for (l = 0; l < h.length; l++) if (r = h[l], r.valid && r.fromVertex.layer !== b) for (n = r.fromVertex.index, r = r.portFromPos, p = 0; p < B.length; p++) q = B[p], q.valid && q.fromVertex.layer !== b && (u = q.fromVertex.index, q = q.portFromPos, (n < u || n === u && r < q) && z++, (u < n || u === n && q < r) && y++)
                }
                if (0 >= c) for (h = d[g].destinationEdgesArrayAccess, B = d[k].destinationEdgesArrayAccess,
                                     l = 0; l < h.length; l++) if (r = h[l], r.valid && r.toVertex.layer !== b) for (n = r.toVertex.index, m = r.portToPos, p = 0; p < B.length; p++) q = B[p], q.valid && q.toVertex.layer !== b && (u = q.toVertex.index, x = q.portToPos, (n < u || n === u && m < x) && z++, (u < n || u === n && x < m) && y++);
                f[g * e + k] = y;
                f[k * e + g] = z
            }
        }
        Ys(a, b, d);
        return f
    }

    Os.prototype.countCrossings = function () {
        for (var a = 0, b = 0; b <= this.xa; b++) for (var c = bt(this, b, 1), d = this.Fb[b], e = 0; e < d; e++) for (var f = e; f < d; f++) a += c[e * d + f];
        return a
    };

    function ct(a) {
        for (var b = 0, c = 0; c <= a.xa; c++) {
            for (var d = a, e = c, f = Xs(d, e), g = d.Fb[e], h = 0, k = 0; k < g; k++) {
                var l = f[k].destinationEdgesArrayAccess;
                if (null !== l) for (var m = 0; m < l.length; m++) {
                    var n = l[m];
                    if (n.valid && n.toVertex.layer !== e) {
                        var p = n.fromVertex.column + n.portFromColOffset;
                        var r = n.toVertex.column + n.portToColOffset;
                        h += (Math.abs(p - r) + 1) * Zs(n)
                    }
                }
            }
            Ys(d, e, f);
            b += h
        }
        return b
    }

    Os.prototype.normalize = function () {
        var a = Infinity;
        this.Ga = -1;
        for (var b = this.network.vertexes.iterator; b.next();) {
            var c = b.value;
            a = Math.min(a, c.column - this.nodeMinColumnSpace(c, !0));
            this.Ga = Math.max(this.Ga, c.column + this.nodeMinColumnSpace(c, !1))
        }
        for (b.reset(); b.next();) b.value.column -= a;
        this.Ga -= a
    };

    function dt(a, b, c) {
        F && (C(b, Os, "barycenters:unfixedLayer"), C(c, Os, "barycenters:direction"));
        for (var d = Xs(a, b), e = a.Fb[b], f = [], g = 0; g < e; g++) {
            var h = d[g], k = null;
            0 >= c && (k = h.sourceEdgesArrayAccess);
            var l = null;
            0 <= c && (l = h.destinationEdgesArrayAccess);
            var m = 0, n = 0, p = h.near;
            null !== p && p.layer === h.layer && (m += p.column - 1, n++);
            if (null !== k) for (p = 0; p < k.length; p++) {
                h = k[p];
                var r = h.fromVertex;
                h.valid && !h.rev && r.layer !== b && (m += r.column, n++)
            }
            if (null !== l) for (k = 0; k < l.length; k++) h = l[k], p = h.toVertex, h.valid && !h.rev && p.layer !==
            b && (m += p.column, n++);
            f[g] = 0 === n ? -1 : m / n
        }
        Ys(a, b, d);
        return f
    }

    function et(a, b, c) {
        F && (C(b, Os, "medians:unfixedLayer"), C(c, Os, "medians:direction"));
        for (var d = Xs(a, b), e = a.Fb[b], f = [], g = 0; g < e; g++) {
            var h = d[g], k = null;
            0 >= c && (k = h.sourceEdgesArrayAccess);
            var l = null;
            0 <= c && (l = h.destinationEdgesArrayAccess);
            var m = 0, n = [], p = h.near;
            null !== p && p.layer === h.layer && (n[m] = p.column - 1, m++);
            h = void 0;
            if (null !== k) for (p = 0; p < k.length; p++) {
                h = k[p];
                var r = h.fromVertex;
                h.valid && !h.rev && r.layer !== b && (n[m] = r.column + h.portFromColOffset, m++)
            }
            if (null !== l) for (k = 0; k < l.length; k++) h = l[k], p = h.toVertex,
            h.valid && !h.rev && p.layer !== b && (n[m] = p.column + h.portToColOffset, m++);
            0 === m ? f[g] = -1 : (n.sort(function (a, b) {
                return a - b
            }), l = m >> 1, f[g] = 0 !== (m & 1) ? n[l] : n[l - 1] + n[l] >> 1)
        }
        Ys(a, b, d);
        return f
    }

    function ft(a, b, c, d, e, f) {
        if (b.component === d) {
            b.component = c;
            if (e) for (var g = b.destinationEdges; g.next();) {
                var h = g.value;
                var k = h.toVertex;
                var l = b.layer - k.layer;
                h = a.linkMinLength(h);
                l === h && ft(a, k, c, d, e, f)
            }
            if (f) for (g = b.sourceEdges; g.next();) h = g.value, k = h.fromVertex, l = k.layer - b.layer, h = a.linkMinLength(h), l === h && ft(a, k, c, d, e, f)
        }
    }

    function gt(a, b, c, d, e, f) {
        if (b.component === d) {
            b.component = c;
            if (e) for (var g = b.destinationEdges; g.next();) gt(a, g.value.toVertex, c, d, e, f);
            if (f) for (b = b.sourceEdges; b.next();) gt(a, b.value.fromVertex, c, d, e, f)
        }
    }

    Os.prototype.removeCycles = function () {
        for (var a = this.network.edges.iterator; a.next();) a.value.rev = !1;
        switch (this.tl) {
            default:
            case ht:
                a = this.network;
                var b = 0, c = a.vertexes.count - 1, d = [];
                d.length = c + 1;
                for (var e = a.vertexes.iterator; e.next();) e.value.valid = !0;
                for (; null !== it(a);) {
                    for (e = jt(a); null !== e;) d[c] = e, c--, e.valid = !1, e = jt(a);
                    for (e = kt(a); null !== e;) d[b] = e, b++, e.valid = !1, e = kt(a);
                    e = null;
                    for (var f = 0, g = this.network.vertexes.iterator; g.next();) {
                        var h = g.value;
                        if (h.valid) {
                            for (var k = 0, l = h.destinationEdges; l.next();) l.value.toVertex.valid &&
                            k++;
                            l = 0;
                            for (var m = h.sourceEdges; m.next();) m.value.fromVertex.valid && l++;
                            if (null === e || f < k - l) e = h, f = k - l
                        }
                    }
                    null !== e && (d[b] = e, b++, e.valid = !1)
                }
                for (b = 0; b < a.vertexes.count; b++) d[b].index = b;
                for (d = a.edges.iterator; d.next();) b = d.value, b.fromVertex.index > b.toVertex.index && (a.cn(b), b.rev = !0);
                break;
            case Ps:
                for (d = this.network.vertexes.iterator; d.next();) a = d.value, a.Pg = -1, a.finish = -1;
                for (a = this.network.edges.iterator; a.next();) a.value.forest = !1;
                this.Ah = 0;
                for (d.reset(); d.next();) b = d.value, 0 === b.sourceEdges.count &&
                lt(this, b);
                for (d.reset(); d.next();) b = d.value, -1 === b.Pg && lt(this, b);
                for (a.reset(); a.next();) d = a.value, d.forest || (b = d.fromVertex, c = b.finish, e = d.toVertex, f = e.finish, e.Pg < b.Pg && c < f && (this.network.cn(d), d.rev = !0));
                break;
            case Us:
                a = this.network;
                b = a.vertexes.iterator;
                for (d = Infinity; b.next();) d = Math.min(d, b.value.layer);
                if (Infinity > d) {
                    if (0 > d) for (b.reset(); b.next();) b.value.layer -= d;
                    d = [];
                    for (b.reset(); b.next();) c = b.value, e = d[c.layer], void 0 === e ? d[c.layer] = [c] : e.push(c);
                    for (c = b = 0; c < d.length; c++) if (e = d[c], !e ||
                    0 === e.length) b++; else if (0 < c) for (f = 0; f < e.length; f++) e[f].layer -= b;
                    for (d = a.edges.iterator; d.next();) b = d.value, b.fromVertex.layer < b.toVertex.layer && (a.cn(b), b.rev = !0)
                }
        }
    };

    function it(a) {
        for (a = a.vertexes.iterator; a.next();) {
            var b = a.value;
            if (b.valid) return b
        }
        return null
    }

    function jt(a) {
        for (a = a.vertexes.iterator; a.next();) {
            var b = a.value;
            if (b.valid) {
                for (var c = !0, d = b.destinationEdges; d.next();) if (d.value.toVertex.valid) {
                    c = !1;
                    break
                }
                if (c) return b
            }
        }
        return null
    }

    function kt(a) {
        for (a = a.vertexes.iterator; a.next();) {
            var b = a.value;
            if (b.valid) {
                for (var c = !0, d = b.sourceEdges; d.next();) if (d.value.fromVertex.valid) {
                    c = !1;
                    break
                }
                if (c) return b
            }
        }
        return null
    }

    function lt(a, b) {
        b.Pg = a.Ah;
        a.Ah++;
        for (var c = b.destinationEdges; c.next();) {
            var d = c.value, e = d.toVertex;
            -1 === e.Pg && (d.forest = !0, lt(a, e))
        }
        b.finish = a.Ah;
        a.Ah++
    }

    Os.prototype.assignLayers = function () {
        switch (this.Yl) {
            case mt:
                nt(this);
                break;
            case ot:
                for (var a, b = this.network.vertexes.iterator; b.next();) a = pt(this, b.value), this.xa = Math.max(a, this.xa);
                for (b.reset(); b.next();) a = b.value, a.layer = this.xa - a.layer;
                break;
            default:
            case Qs:
                nt(this);
                for (b = this.network.vertexes.iterator; b.next();) b.value.valid = !1;
                for (b.reset(); b.next();) a = b.value, 0 === a.sourceEdges.count && qt(this, a);
                a = Infinity;
                for (b.reset(); b.next();) a = Math.min(a, b.value.layer);
                this.xa = -1;
                for (b.reset(); b.next();) {
                    var c =
                        b.value;
                    c.layer -= a;
                    this.xa = Math.max(this.xa, c.layer)
                }
        }
    };

    function nt(a) {
        for (var b = a.network.vertexes.iterator; b.next();) {
            var c = rt(a, b.value);
            a.xa = Math.max(c, a.xa)
        }
    }

    function rt(a, b) {
        var c = 0;
        if (-1 === b.layer) {
            for (var d = b.destinationEdges; d.next();) {
                var e = d.value, f = e.toVertex;
                e = a.linkMinLength(e);
                c = Math.max(c, rt(a, f) + e)
            }
            b.layer = c
        } else c = b.layer;
        return c
    }

    function pt(a, b) {
        var c = 0;
        if (-1 === b.layer) {
            for (var d = b.sourceEdges; d.next();) {
                var e = d.value, f = e.fromVertex;
                e = a.linkMinLength(e);
                c = Math.max(c, pt(a, f) + e)
            }
            b.layer = c
        } else c = b.layer;
        return c
    }

    function qt(a, b) {
        if (!b.valid) {
            b.valid = !0;
            for (var c = b.destinationEdges; c.next();) qt(a, c.value.toVertex);
            for (c = a.network.vertexes.iterator; c.next();) c.value.component = -1;
            for (var d = b.sourceEdgesArrayAccess, e = d.length, f = 0; f < e; f++) {
                var g = d[f], h = g.fromVertex, k = g.toVertex;
                g = a.linkMinLength(g);
                h.layer - k.layer > g && ft(a, h, 0, -1, !0, !1)
            }
            for (ft(a, b, 1, -1, !0, !0); 0 !== b.component;) {
                f = 0;
                d = Infinity;
                h = 0;
                k = null;
                for (g = a.network.vertexes.iterator; g.next();) {
                    var l = g.value;
                    if (1 === l.component) {
                        var m = 0, n = !1, p = l.sourceEdgesArrayAccess;
                        e = p.length;
                        for (var r = 0; r < e; r++) {
                            var q = p[r], u = q.fromVertex;
                            m += 1;
                            1 !== u.component && (f += 1, u = u.layer - l.layer, q = a.linkMinLength(q), d = Math.min(d, u - q))
                        }
                        p = l.destinationEdgesArrayAccess;
                        e = p.length;
                        for (r = 0; r < e; r++) q = p[r].toVertex, --m, 1 !== q.component ? --f : n = !0;
                        (null === k || m < h) && !n && (k = l, h = m)
                    }
                }
                if (0 < f) {
                    for (c.reset(); c.next();) e = c.value, 1 === e.component && (e.layer += d);
                    b.component = 0
                } else k.component = 0
            }
            for (c = a.network.vertexes.iterator; c.next();) c.value.component = -1;
            for (ft(a, b, 1, -1, !0, !1); 0 !== b.component;) {
                d = 0;
                e = Infinity;
                f = 0;
                h = null;
                for (k = a.network.vertexes.iterator; k.next();) if (g = k.value, 1 === g.component) {
                    l = 0;
                    m = !1;
                    p = g.sourceEdgesArrayAccess;
                    n = p.length;
                    for (r = 0; r < n; r++) q = p[r].fromVertex, l += 1, 1 !== q.component ? d += 1 : m = !0;
                    p = g.destinationEdgesArrayAccess;
                    n = p.length;
                    for (r = 0; r < n; r++) q = p[r], u = q.toVertex, --l, 1 !== u.component && (--d, u = g.layer - u.layer, q = a.linkMinLength(q), e = Math.min(e, u - q));
                    (null === h || l > f) && !m && (h = g, f = l)
                }
                if (0 > d) {
                    for (c.reset(); c.next();) d = c.value, 1 === d.component && (d.layer -= e);
                    b.component = 0
                } else h.component = 0
            }
        }
    }

    function Ws(a, b, c) {
        return 90 === a.N ? c && !b.rev || !c && b.rev ? 270 : 90 : 180 === a.N ? c && !b.rev || !c && b.rev ? 0 : 180 : 270 === a.N ? c && !b.rev || !c && b.rev ? 90 : 270 : c && !b.rev || !c && b.rev ? 180 : 0
    }

    Os.prototype.initializeIndices = function () {
        switch (this.Nl) {
            default:
            case st:
                for (var a = this.network.vertexes.iterator; a.next();) {
                    var b = a.value, c = b.layer;
                    b.index = this.Fb[c];
                    this.Fb[c]++
                }
                break;
            case Rs:
                a = this.network.vertexes.iterator;
                for (b = this.xa; 0 <= b; b--) for (a.reset(); a.next();) c = a.value, c.layer === b && -1 === c.index && tt(this, c);
                break;
            case ut:
                for (a = this.network.vertexes.iterator, b = 0; b <= this.xa; b++) for (a.reset(); a.next();) c = a.value, c.layer === b && -1 === c.index && vt(this, c)
        }
    };

    function tt(a, b) {
        var c = b.layer;
        b.index = a.Fb[c];
        a.Fb[c]++;
        b = b.destinationEdgesArrayAccess;
        for (c = !0; c;) {
            c = !1;
            for (var d = 0; d < b.length - 1; d++) {
                var e = b[d], f = b[d + 1];
                e.portFromColOffset > f.portFromColOffset && (c = !0, b[d] = f, b[d + 1] = e)
            }
        }
        for (c = 0; c < b.length; c++) d = b[c], d.valid && (d = d.toVertex, -1 === d.index && tt(a, d))
    }

    function vt(a, b) {
        var c = b.layer;
        b.index = a.Fb[c];
        a.Fb[c]++;
        b = b.sourceEdgesArrayAccess;
        for (var d = !0; d;) for (d = !1, c = 0; c < b.length - 1; c++) {
            var e = b[c], f = b[c + 1];
            e.portToColOffset > f.portToColOffset && (d = !0, b[c] = f, b[c + 1] = e)
        }
        for (c = 0; c < b.length; c++) d = b[c], d.valid && (d = d.fromVertex, -1 === d.index && vt(a, d))
    }

    Os.prototype.reduceCrossings = function () {
        var a = this.countCrossings(), b = $s(this), c, d;
        for (c = 0; c < this.ak; c++) {
            for (d = 0; d <= this.xa; d++) wt(this, d, 1), xt(this, d, 1);
            var e = this.countCrossings();
            e < a && (a = e, b = $s(this));
            for (d = this.xa; 0 <= d; d--) wt(this, d, -1), xt(this, d, -1);
            e = this.countCrossings();
            e < a && (a = e, b = $s(this))
        }
        at(this, b);
        for (c = 0; c < this.ak; c++) {
            for (d = 0; d <= this.xa; d++) wt(this, d, 0), xt(this, d, 0);
            e = this.countCrossings();
            e < a && (a = e, b = $s(this));
            for (d = this.xa; 0 <= d; d--) wt(this, d, 0), xt(this, d, 0);
            e = this.countCrossings();
            e < a && (a = e, b = $s(this))
        }
        at(this, b);
        var f, g, h;
        switch (this.il) {
            case yt:
                break;
            case zt:
                for (h = a + 1; (d = this.countCrossings()) < h;) for (h = d, c = this.xa; 0 <= c; c--) for (g = 0; g <= c; g++) {
                    for (f = !0; f;) for (f = !1, d = c; d >= g; d--) f = xt(this, d, -1) || f;
                    e = this.countCrossings();
                    e >= a ? at(this, b) : (a = e, b = $s(this));
                    for (f = !0; f;) for (f = !1, d = c; d >= g; d--) f = xt(this, d, 1) || f;
                    e = this.countCrossings();
                    e >= a ? at(this, b) : (a = e, b = $s(this));
                    for (f = !0; f;) for (f = !1, d = g; d <= c; d++) f = xt(this, d, 1) || f;
                    e >= a ? at(this, b) : (a = e, b = $s(this));
                    for (f = !0; f;) for (f = !1, d = g; d <= c; d++) f =
                        xt(this, d, -1) || f;
                    e >= a ? at(this, b) : (a = e, b = $s(this));
                    for (f = !0; f;) for (f = !1, d = c; d >= g; d--) f = xt(this, d, 0) || f;
                    e >= a ? at(this, b) : (a = e, b = $s(this));
                    for (f = !0; f;) for (f = !1, d = g; d <= c; d++) f = xt(this, d, 0) || f;
                    e >= a ? at(this, b) : (a = e, b = $s(this))
                }
                break;
            default:
            case Ss:
                for (c = this.xa, g = 0, h = a + 1; (d = this.countCrossings()) < h;) {
                    h = d;
                    for (f = !0; f;) for (f = !1, d = c; d >= g; d--) f = xt(this, d, -1) || f;
                    e = this.countCrossings();
                    e >= a ? at(this, b) : (a = e, b = $s(this));
                    for (f = !0; f;) for (f = !1, d = c; d >= g; d--) f = xt(this, d, 1) || f;
                    e = this.countCrossings();
                    e >= a ? at(this, b) :
                        (a = e, b = $s(this));
                    for (f = !0; f;) for (f = !1, d = g; d <= c; d++) f = xt(this, d, 1) || f;
                    e >= a ? at(this, b) : (a = e, b = $s(this));
                    for (f = !0; f;) for (f = !1, d = g; d <= c; d++) f = xt(this, d, -1) || f;
                    e >= a ? at(this, b) : (a = e, b = $s(this));
                    for (f = !0; f;) for (f = !1, d = c; d >= g; d--) f = xt(this, d, 0) || f;
                    e >= a ? at(this, b) : (a = e, b = $s(this));
                    for (f = !0; f;) for (f = !1, d = g; d <= c; d++) f = xt(this, d, 0) || f;
                    e >= a ? at(this, b) : (a = e, b = $s(this))
                }
        }
        at(this, b)
    };

    function wt(a, b, c) {
        F && (C(b, Os, "medianBarycenterCrossingReduction:unfixedLayer"), C(c, Os, "medianBarycenterCrossingReduction:direction"));
        var d = Xs(a, b), e = a.Fb[b], f = et(a, b, c), g = dt(a, b, c);
        for (c = 0; c < e; c++) -1 === g[c] && (g[c] = d[c].column), -1 === f[c] && (f[c] = d[c].column);
        for (var h = !0, k; h;) for (h = !1, c = 0; c < e - 1; c++) if (f[c + 1] < f[c] || f[c + 1] === f[c] && g[c + 1] < g[c]) h = !0, k = f[c], f[c] = f[c + 1], f[c + 1] = k, k = g[c], g[c] = g[c + 1], g[c + 1] = k, k = d[c], d[c] = d[c + 1], d[c + 1] = k;
        for (c = f = 0; c < e; c++) k = d[c], k.index = c, f += a.nodeMinColumnSpace(k, !0), k.column =
            f, f += 1, f += a.nodeMinColumnSpace(k, !1);
        Ys(a, b, d)
    }

    function xt(a, b, c) {
        var d = Xs(a, b), e = a.Fb[b];
        c = bt(a, b, c);
        var f;
        var g = [];
        for (f = 0; f < e; f++) g[f] = -1;
        var h = [];
        for (f = 0; f < e; f++) h[f] = -1;
        for (var k = !1, l = !0; l;) for (l = !1, f = 0; f < e - 1; f++) {
            var m = c[d[f].index * e + d[f + 1].index], n = c[d[f + 1].index * e + d[f].index], p = 0, r = 0,
                q = d[f].column, u = d[f + 1].column, x = a.nodeMinColumnSpace(d[f], !0),
                y = a.nodeMinColumnSpace(d[f], !1), z = a.nodeMinColumnSpace(d[f + 1], !0),
                B = a.nodeMinColumnSpace(d[f + 1], !1);
            x = q - x + z;
            y = u - y + B;
            var D = d[f].sourceEdges.iterator;
            for (D.reset(); D.next();) if (z = D.value, B = z.fromVertex,
            z.valid && B.layer === b) {
                for (z = 0; d[z] !== B;) z++;
                z < f && (p += 2 * (f - z), r += 2 * (f + 1 - z));
                z === f + 1 && (p += 1);
                z > f + 1 && (p += 4 * (z - f), r += 4 * (z - (f + 1)))
            }
            D = d[f].destinationEdges.iterator;
            for (D.reset(); D.next();) if (z = D.value, B = z.toVertex, z.valid && B.layer === b) {
                for (z = 0; d[z] !== B;) z++;
                z === f + 1 && (r += 1)
            }
            D = d[f + 1].sourceEdges.iterator;
            for (D.reset(); D.next();) if (z = D.value, B = z.fromVertex, z.valid && B.layer === b) {
                for (z = 0; d[z] !== B;) z++;
                z < f && (p += 2 * (f + 1 - z), r += 2 * (f - z));
                z === f && (r += 1);
                z > f + 1 && (p += 4 * (z - (f + 1)), r += 4 * (z - f))
            }
            D = d[f + 1].destinationEdges.iterator;
            for (D.reset(); D.next();) if (z = D.value, B = z.toVertex, z.valid && B.layer === b) {
                for (z = 0; d[z] !== B;) z++;
                z === f && (p += 1)
            }
            z = B = 0;
            D = g[d[f].index];
            var G = h[d[f].index], O = g[d[f + 1].index], U = h[d[f + 1].index];
            -1 !== D && (B += Math.abs(D - q), z += Math.abs(D - y));
            -1 !== G && (B += Math.abs(G - q), z += Math.abs(G - y));
            -1 !== O && (B += Math.abs(O - u), z += Math.abs(O - x));
            -1 !== U && (B += Math.abs(U - u), z += Math.abs(U - x));
            if (r < p - .5 || r === p && n < m - .5 || r === p && n === m && z < B - .5) l = k = !0, d[f].column = y, d[f + 1].column = x, m = d[f], d[f] = d[f + 1], d[f + 1] = m
        }
        for (f = 0; f < e; f++) d[f].index =
            f;
        Ys(a, b, d);
        return k
    }

    Os.prototype.straightenAndPack = function () {
        var a = 0 !== (this.Ag & 1);
        var b = 7 === this.Ag;
        1E3 < this.network.edges.count && !b && (a = !1);
        if (a) {
            var c = [];
            for (b = 0; b <= this.xa; b++) c[b] = 0;
            for (var d, e = this.network.vertexes.iterator; e.next();) {
                var f = e.value;
                b = f.layer;
                d = f.column;
                f = this.nodeMinColumnSpace(f, !1);
                c[b] = Math.max(c[b], d + f)
            }
            for (e.reset(); e.next();) f = e.value, b = f.layer, d = f.column, f.column = (8 * (this.Ga - c[b]) >> 1) + 8 * d;
            this.Ga *= 8
        }
        if (0 !== (this.Ag & 2)) for (c = !0; c;) {
            c = !1;
            for (b = this.uc + 1; b <= this.xa; b++) c = At(this, b, 1) || c;
            for (b =
                     this.uc - 1; 0 <= b; b--) c = At(this, b, -1) || c;
            c = At(this, this.uc, 0) || c
        }
        if (0 !== (this.Ag & 4)) {
            for (b = this.uc + 1; b <= this.xa; b++) Bt(this, b, 1);
            for (b = this.uc - 1; 0 <= b; b--) Bt(this, b, -1);
            Bt(this, this.uc, 0)
        }
        a && (Ct(this, -1), Ct(this, 1));
        if (0 !== (this.Ag & 2)) for (c = !0; c;) {
            c = !1;
            c = At(this, this.uc, 0) || c;
            for (b = this.uc + 1; b <= this.xa; b++) c = At(this, b, 0) || c;
            for (b = this.uc - 1; 0 <= b; b--) c = At(this, b, 0) || c
        }
    };

    function At(a, b, c) {
        F && (C(b, Os, "bendStraighten:unfixedLayer"), C(c, Os, "bendStraighten:direction"));
        for (var d = !1; Dt(a, b, c);) d = !0;
        return d
    }

    function Dt(a, b, c) {
        F && (C(b, Os, "shiftbendStraighten:unfixedLayer"), C(c, Os, "shiftbendStraighten:direction"));
        var d, e = Xs(a, b), f = a.Fb[b], g = dt(a, b, -1);
        if (0 < c) for (d = 0; d < f; d++) g[d] = -1;
        var h = dt(a, b, 1);
        if (0 > c) for (d = 0; d < f; d++) h[d] = -1;
        for (var k = !1, l = !0; l;) for (l = !1, d = 0; d < f; d++) {
            var m = e[d].column, n = a.nodeMinColumnSpace(e[d], !0), p = a.nodeMinColumnSpace(e[d], !1), r = 0;
            0 > d - 1 || m - e[d - 1].column - 1 > n + a.nodeMinColumnSpace(e[d - 1], !1) ? r = m - 1 : r = m;
            n = d + 1 >= f || e[d + 1].column - m - 1 > p + a.nodeMinColumnSpace(e[d + 1], !0) ? m + 1 : m;
            var q = p = 0, u =
                0;
            if (0 >= c) for (var x = e[d].sourceEdges.iterator; x.next();) {
                var y = x.value;
                var z = y.fromVertex;
                if (y.valid && z.layer !== b) {
                    var B = Zs(y);
                    var D = y.portFromColOffset;
                    y = y.portToColOffset;
                    z = z.column;
                    p += (Math.abs(m + y - (z + D)) + 1) * B;
                    q += (Math.abs(r + y - (z + D)) + 1) * B;
                    u += (Math.abs(n + y - (z + D)) + 1) * B
                }
            }
            if (0 <= c) for (x = e[d].destinationEdges.iterator; x.next();) y = x.value, z = y.toVertex, y.valid && z.layer !== b && (B = Zs(y), D = y.portFromColOffset, y = y.portToColOffset, z = z.column, p += (Math.abs(m + D - (z + y)) + 1) * B, q += (Math.abs(r + D - (z + y)) + 1) * B, u += (Math.abs(n +
                D - (z + y)) + 1) * B);
            y = D = B = 0;
            x = g[e[d].index];
            z = h[e[d].index];
            -1 !== x && (B += Math.abs(x - m), D += Math.abs(x - r), y += Math.abs(x - n));
            -1 !== z && (B += Math.abs(z - m), D += Math.abs(z - r), y += Math.abs(z - n));
            if (q < p || q === p && D < B) l = k = !0, e[d].column = r; else if (u < p || u === p && y < B) l = k = !0, e[d].column = n
        }
        Ys(a, b, e);
        a.normalize();
        return k
    }

    function Bt(a, b, c) {
        F && (C(b, Os, "medianStraighten:unfixedLayer"), C(c, Os, "medianStraighten:direction"));
        var d = Xs(a, b), e = a.Fb[b], f = et(a, b, c), g = [];
        for (c = 0; c < e; c++) g[c] = f[c];
        for (f = !0; f;) for (f = !1, c = 0; c < e; c++) {
            var h = d[c].column, k = a.nodeMinColumnSpace(d[c], !0), l = a.nodeMinColumnSpace(d[c], !1), m = 0;
            if (-1 === g[c]) if (0 === c && c === e - 1) m = h; else if (0 === c) {
                var n = d[c + 1].column;
                n - h === l + a.nodeMinColumnSpace(d[c + 1], !0) ? m = h - 1 : m = h
            } else c === e - 1 ? (n = d[c - 1].column, m = h - n === k + a.nodeMinColumnSpace(d[c - 1], !1) ? h + 1 : h) : (n = d[c - 1].column,
                k = n + a.nodeMinColumnSpace(d[c - 1], !1) + k + 1, n = d[c + 1].column, l = n - a.nodeMinColumnSpace(d[c + 1], !0) - l - 1, m = (k + l) / 2 | 0); else 0 === c && c === e - 1 ? m = g[c] : 0 === c ? (n = d[c + 1].column, l = n - a.nodeMinColumnSpace(d[c + 1], !0) - l - 1, m = Math.min(g[c], l)) : c === e - 1 ? (n = d[c - 1].column, k = n + a.nodeMinColumnSpace(d[c - 1], !1) + k + 1, m = Math.max(g[c], k)) : (n = d[c - 1].column, k = n + a.nodeMinColumnSpace(d[c - 1], !1) + k + 1, n = d[c + 1].column, l = n - a.nodeMinColumnSpace(d[c + 1], !0) - l - 1, k < g[c] && g[c] < l ? m = g[c] : k >= g[c] ? m = k : l <= g[c] && (m = l));
            m !== h && (f = !0, d[c].column = m)
        }
        Ys(a, b,
            d);
        a.normalize()
    }

    function Et(a, b) {
        F && (C(b, Os, "packAux:column"), C(1, Os, "packAux:direction"));
        for (var c = !0, d = a.network.vertexes.iterator; d.next();) {
            var e = d.value, f = a.nodeMinColumnSpace(e, !0), g = a.nodeMinColumnSpace(e, !1);
            if (e.column - f <= b && e.column + g >= b) {
                c = !1;
                break
            }
        }
        a = !1;
        if (c) for (d.reset(); d.next();) c = d.value, c.column > b && (--c.column, a = !0);
        return a
    }

    function Ft(a, b) {
        F && (C(b, Os, "tightPackAux:column"), C(1, Os, "tightPackAux:direction"));
        var c = b + 1;
        var d, e = [], f = [];
        for (d = 0; d <= a.xa; d++) e[d] = !1, f[d] = !1;
        for (var g = a.network.vertexes.iterator; g.next();) {
            d = g.value;
            var h = d.column - a.nodeMinColumnSpace(d, !0), k = d.column + a.nodeMinColumnSpace(d, !1);
            h <= b && k >= b && (e[d.layer] = !0);
            h <= c && k >= c && (f[d.layer] = !0)
        }
        h = !0;
        c = !1;
        for (d = 0; d <= a.xa; d++) h = h && !(e[d] && f[d]);
        if (h) for (g.reset(); g.next();) a = g.value, a.column > b && (--a.column, c = !0);
        return c
    }

    function Ct(a, b) {
        F && C(b, Os, "componentPack:direction");
        for (var c = 0; c <= a.Ga; c++) for (; Et(a, c);) ;
        a.normalize();
        for (c = 0; c < a.Ga; c++) for (; Ft(a, c);) ;
        a.normalize();
        var d;
        if (0 < b) for (c = 0; c <= a.Ga; c++) {
            var e = $s(a);
            var f = ct(a);
            for (d = f + 1; f < d;) {
                d = f;
                Gt(a, c, 1);
                var g = ct(a);
                g > f ? at(a, e) : g < f && (f = g, e = $s(a))
            }
        }
        if (0 > b) for (c = a.Ga; 0 <= c; c--) for (e = $s(a), f = ct(a), d = f + 1; f < d;) d = f, Gt(a, c, -1), g = ct(a), g > f ? at(a, e) : g < f && (f = g, e = $s(a));
        a.normalize()
    }

    function Gt(a, b, c) {
        a.Lc = 0;
        for (var d = a.network.vertexes.iterator; d.next();) d.value.component = -1;
        if (0 < c) for (d.reset(); d.next();) {
            var e = d.value;
            e.column - a.nodeMinColumnSpace(e, !0) <= b && (e.component = a.Lc)
        }
        if (0 > c) for (d.reset(); d.next();) e = d.value, e.column + a.nodeMinColumnSpace(e, !1) >= b && (e.component = a.Lc);
        a.Lc++;
        for (d.reset(); d.next();) b = d.value, -1 === b.component && (gt(a, b, a.Lc, -1, !0, !0), a.Lc++);
        var f;
        b = [];
        for (f = 0; f < a.Lc * a.Lc; f++) b[f] = !1;
        e = [];
        for (f = 0; f < (a.xa + 1) * (a.Ga + 1); f++) e[f] = -1;
        for (d.reset(); d.next();) {
            f =
                d.value;
            for (var g = f.layer, h = Math.max(0, f.column - a.nodeMinColumnSpace(f, !0)), k = Math.min(a.Ga, f.column + a.nodeMinColumnSpace(f, !1)); h <= k; h++) e[g * (a.Ga + 1) + h] = f.component
        }
        for (f = 0; f <= a.xa; f++) {
            if (0 < c) for (g = 0; g < a.Ga; g++) -1 !== e[f * (a.Ga + 1) + g] && -1 !== e[f * (a.Ga + 1) + g + 1] && e[f * (a.Ga + 1) + g] !== e[f * (a.Ga + 1) + g + 1] && (b[e[f * (a.Ga + 1) + g] * a.Lc + e[f * (a.Ga + 1) + g + 1]] = !0);
            if (0 > c) for (g = a.Ga; 0 < g; g--) -1 !== e[f * (a.Ga + 1) + g] && -1 !== e[f * (a.Ga + 1) + g - 1] && e[f * (a.Ga + 1) + g] !== e[f * (a.Ga + 1) + g - 1] && (b[e[f * (a.Ga + 1) + g] * a.Lc + e[f * (a.Ga + 1) + g - 1]] = !0)
        }
        e =
            [];
        for (f = 0; f < a.Lc; f++) e[f] = !0;
        g = [];
        for (g.push(0); 0 !== g.length;) if (k = g[g.length - 1], g.pop(), e[k]) for (e[k] = !1, f = 0; f < a.Lc; f++) b[k * a.Lc + f] && g.splice(0, 0, f);
        if (0 < c) for (d.reset(); d.next();) a = d.value, e[a.component] && --a.column;
        if (0 > c) for (d.reset(); d.next();) c = d.value, e[c.component] && (c.column += 1)
    }

    Os.prototype.commitLayout = function () {
        if (this.setsPortSpots) for (var a = Vs(this, !0), b = Vs(this, !1), c = this.network.edges.iterator; c.next();) {
            var d = c.value.link;
            null !== d && (d.fromSpot = a, d.toSpot = b)
        }
        this.commitNodes();
        this.Sv();
        this.isRouting && this.commitLinks()
    };

    function Vs(a, b) {
        return 270 === a.N ? b ? od : rd : 90 === a.N ? b ? rd : od : 180 === a.N ? b ? pd : qd : b ? qd : pd
    }

    Os.prototype.commitNodes = function () {
        this.$d = [];
        this.Bd = [];
        this.Ad = [];
        this.Na = [];
        for (var a = 0; a <= this.xa; a++) this.$d[a] = 0, this.Bd[a] = 0, this.Ad[a] = 0, this.Na[a] = 0;
        for (a = this.network.vertexes.iterator; a.next();) {
            var b = a.value, c = b.layer;
            this.$d[c] = Math.max(this.$d[c], this.nodeMinLayerSpace(b, !0));
            this.Bd[c] = Math.max(this.Bd[c], this.nodeMinLayerSpace(b, !1))
        }
        b = 0;
        c = this.Ae;
        for (var d = 0; d <= this.xa; d++) {
            var e = c;
            0 >= this.$d[d] + this.Bd[d] && (e = 0);
            0 < d && (b += e / 2);
            90 === this.N || 0 === this.N ? (b += this.Bd[d], this.Ad[d] = b,
                b += this.$d[d]) : (b += this.$d[d], this.Ad[d] = b, b += this.Bd[d]);
            d < this.xa && (b += e / 2);
            this.Na[d] = b
        }
        c = b;
        b = this.arrangementOrigin;
        for (d = 0; d <= this.xa; d++) 270 === this.N ? this.Ad[d] = b.y + this.Ad[d] : 90 === this.N ? (this.Ad[d] = b.y + c - this.Ad[d], this.Na[d] = c - this.Na[d]) : 180 === this.N ? this.Ad[d] = b.x + this.Ad[d] : (this.Ad[d] = b.x + c - this.Ad[d], this.Na[d] = c - this.Na[d]);
        a.reset();
        for (c = d = Infinity; a.next();) {
            e = a.value;
            var f = e.layer, g = e.column | 0;
            if (270 === this.N || 90 === this.N) {
                var h = b.x + this.ec * g;
                f = this.Ad[f]
            } else h = this.Ad[f], f = b.y +
                this.ec * g;
            e.centerX = h;
            e.centerY = f;
            d = Math.min(e.x, d);
            c = Math.min(e.y, c)
        }
        d = b.x - d;
        b = b.y - c;
        this.bd = new J(d, b);
        for (a.reset(); a.next();) c = a.value, c.x += d, c.y += b, c.commit()
    };
    Os.prototype.Sv = function () {
        for (var a = 0, b = this.Ae, c = 0; c <= this.xa; c++) a += this.$d[c], a += this.Bd[c];
        a += this.xa * b;
        b = [];
        c = this.ec * this.Ga;
        for (var d = this.maxLayer; 0 <= d; d--) 270 === this.N ? 0 === d ? b.push(new L(0, 0, c, Math.abs(this.Na[0]))) : b.push(new L(0, this.Na[d - 1], c, Math.abs(this.Na[d - 1] - this.Na[d]))) : 90 === this.N ? 0 === d ? b.push(new L(0, this.Na[0], c, Math.abs(this.Na[0] - a))) : b.push(new L(0, this.Na[d], c, Math.abs(this.Na[d - 1] - this.Na[d]))) : 180 === this.N ? 0 === d ? b.push(new L(0, 0, Math.abs(this.Na[0]), c)) : b.push(new L(this.Na[d -
        1], 0, Math.abs(this.Na[d - 1] - this.Na[d]), c)) : 0 === d ? b.push(new L(this.Na[0], 0, Math.abs(this.Na[0] - a), c)) : b.push(new L(this.Na[d], 0, Math.abs(this.Na[d - 1] - this.Na[d]), c));
        this.commitLayers(b, this.bd)
    };
    Os.prototype.commitLayers = function () {
    };
    Os.prototype.commitLinks = function () {
        for (var a = this.network.edges.iterator, b; a.next();) b = a.value.link, null !== b && (b.ci(), b.zk(), b.Jf());
        for (a.reset(); a.next();) b = a.value.link, null !== b && b.Ij();
        for (a.reset(); a.next();) {
            var c = a.value;
            b = c.link;
            if (null !== b) {
                b.ci();
                var d = b, e = d.fromNode, f = d.toNode, g = d.fromPort, h = d.toPort;
                if (null !== e) {
                    var k = e.findVisibleNode();
                    null !== k && k !== e && (e = k, g = k.port)
                }
                null !== f && (k = f.findVisibleNode(), null !== k && k !== f && (f = k, h = k.port));
                var l = b.computeSpot(!0, g);
                k = b.computeSpot(!1, h);
                var m =
                    c.fromVertex, n = c.toVertex;
                if (c.valid) {
                    if (b.curve === sg && 4 === b.pointsCount) if (m.column === n.column) c = b.getLinkPoint(e, g, l, !0, !1, f, h), g = b.getLinkPoint(f, h, k, !1, !1, e, g), c.o() || c.set(e.actualBounds.center), g.o() || g.set(f.actualBounds.center), b.zk(), b.Hf(c.x, c.y), b.Hf((2 * c.x + g.x) / 3, (2 * c.y + g.y) / 3), b.Hf((c.x + 2 * g.x) / 3, (c.y + 2 * g.y) / 3), b.Hf(g.x, g.y); else {
                        var p = !1, r = !1;
                        null !== g && l === Ec && (p = !0);
                        null !== h && k === Ec && (r = !0);
                        if (p || r) {
                            var q = b.i(0).x;
                            c = b.i(0).y;
                            m = b.i(3).x;
                            d = b.i(3).y;
                            p && (90 === this.N || 270 === this.N ? (p = q, n =
                                (c + d) / 2) : (p = (q + m) / 2, n = c), b.O(1, p, n), l = b.getLinkPoint(e, g, l, !0, !1, f, h), l.o() || l.set(e.actualBounds.center), b.O(0, l.x, l.y));
                            r && (90 === this.N || 270 === this.N ? (l = m, c = (c + d) / 2) : (l = (q + m) / 2, c = d), b.O(2, l, c), e = b.getLinkPoint(f, h, k, !1, !1, e, g), e.o() || e.set(f.actualBounds.center), b.O(3, e.x, e.y))
                        }
                    }
                    b.Jf()
                } else if (m.layer === n.layer) b.Jf(); else {
                    p = r = !1;
                    q = b.firstPickIndex + 1;
                    if (b.isOrthogonal) {
                        p = !0;
                        var u = b.pointsCount;
                        4 < u && b.points.removeRange(2, u - 3)
                    } else if (b.curve === sg) r = !0, u = b.pointsCount, 4 < u && b.points.removeRange(2,
                        u - 3), 4 === u && (q = 2); else {
                        u = b.pointsCount;
                        var x = l === Ec, y = k === Ec;
                        2 < u && x && y ? b.points.removeRange(1, u - 2) : 3 < u && x && !y ? b.points.removeRange(1, u - 3) : 3 < u && !x && y ? b.points.removeRange(2, u - 2) : 4 < u && !x && !y && b.points.removeRange(2, u - 3)
                    }
                    if (c.rev) {
                        for (; null !== n && m !== n;) {
                            var z = u = null;
                            for (x = n.sourceEdges.iterator; x.next() && (y = x.value, y.link !== c.link || (u = y.fromVertex, z = y.toVertex, null !== u.node));) ;
                            if (u !== m) {
                                x = b.i(q - 1).x;
                                y = b.i(q - 1).y;
                                var B = u.centerX;
                                var D = u.centerY;
                                if (p) 180 === this.N || 0 === this.N ? q === b.firstPickIndex + 1 ? (b.m(q++,
                                    x, y), b.m(q++, x, D)) : (null !== z ? z.centerY : y) !== D && (z = this.Na[u.layer - 1] + this.bd.x, b.m(q++, z, y), b.m(q++, z, D)) : q === b.firstPickIndex + 1 ? (b.m(q++, x, y), b.m(q++, B, y)) : (null !== z ? z.centerX : x) !== B && (z = this.Na[u.layer - 1] + this.bd.y, b.m(q++, x, z), b.m(q++, B, z)); else if (q === b.firstPickIndex + 1) {
                                    z = Math.max(10, this.$d[n.layer]);
                                    var G = Math.max(10, this.Bd[n.layer]);
                                    if (r) 180 === this.N ? B <= n.bounds.x ? (n = n.bounds.x, b.m(q++, n - z, D), b.m(q++, n, D), b.m(q++, n + G, D)) : (b.m(q++, B - z, D), b.m(q++, B, D), b.m(q++, B + G, D)) : 90 === this.N ? D >= n.bounds.bottom ?
                                        (n = n.bounds.y + n.bounds.height, b.m(q++, B, n + G), b.m(q++, B, n), b.m(q++, B, n - z)) : (b.m(q++, B, D + G), b.m(q++, B, D), b.m(q++, B, D - z)) : 270 === this.N ? D <= n.bounds.y ? (n = n.bounds.y, b.m(q++, B, n - z), b.m(q++, B, n), b.m(q++, B, n + G)) : (b.m(q++, B, D - z), b.m(q++, B, D), b.m(q++, B, D + G)) : 0 === this.N && (B >= n.bounds.right ? (n = n.bounds.x + n.bounds.width, b.m(q++, n + G, D), b.m(q++, n, D), b.m(q++, n - z, D)) : (b.m(q++, B + G, D), b.m(q++, B, D), b.m(q++, B - z, D))); else {
                                        b.m(q++, x, y);
                                        var O = 0;
                                        if (180 === this.N || 0 === this.N) {
                                            if (180 === this.N ? B >= n.bounds.right : B <= n.bounds.x) O =
                                                (0 === this.N ? -z : G) / 2;
                                            b.m(q++, x + O, D)
                                        } else {
                                            if (270 === this.N ? D >= n.bounds.bottom : D <= n.bounds.y) O = (90 === this.N ? -z : G) / 2;
                                            b.m(q++, B, y + O)
                                        }
                                        b.m(q++, B, D)
                                    }
                                } else z = Math.max(10, this.$d[u.layer]), G = Math.max(10, this.Bd[u.layer]), 180 === this.N ? (r && b.m(q++, B - z, D), b.m(q++, B, D), r && b.m(q++, B + G, D)) : 90 === this.N ? (r && b.m(q++, B, D + G), b.m(q++, B, D), r && b.m(q++, B, D - z)) : 270 === this.N ? (r && b.m(q++, B, D - z), b.m(q++, B, D), r && b.m(q++, B, D + G)) : (r && b.m(q++, B + G, D), b.m(q++, B, D), r && b.m(q++, B - z, D))
                            }
                            n = u
                        }
                        if (null === h || l !== Ec || p) if (x = b.i(q - 1).x, y = b.i(q -
                            1).y, B = b.i(q).x, D = b.i(q).y, p) n = this.Bd[m.layer], 180 === this.N || 0 === this.N ? (p = y, p >= m.bounds.y && p <= m.bounds.bottom && (180 === this.N ? B >= m.bounds.x : B <= m.bounds.right) && (n = m.centerX + (180 === this.N ? -n : n), p < m.bounds.y + m.bounds.height / 2 ? p = m.bounds.y - this.ec / 2 : p = m.bounds.bottom + this.ec / 2, b.m(q++, n, y), b.m(q++, n, p)), b.m(q++, B, p)) : (p = x, p >= m.bounds.x && p <= m.bounds.right && (270 === this.N ? D >= m.bounds.y : D <= m.bounds.bottom) && (n = m.centerY + (270 === this.N ? -n : n), p < m.bounds.x + m.bounds.width / 2 ? p = m.bounds.x - this.ec / 2 : p = m.bounds.right +
                            this.ec / 2, b.m(q++, x, n), b.m(q++, p, n)), b.m(q++, p, D)), b.m(q++, B, D); else if (r) z = Math.max(10, this.$d[m.layer]), G = Math.max(10, this.Bd[m.layer]), 180 === this.N && B >= m.bounds.x ? (n = m.bounds.x + m.bounds.width, b.O(q - 2, n, y), b.O(q - 1, n + G, y)) : 90 === this.N && D <= m.bounds.bottom ? (n = m.bounds.y, b.O(q - 2, x, n), b.O(q - 1, x, n - z)) : 270 === this.N && D >= m.bounds.y ? (n = m.bounds.y + m.bounds.height, b.O(q - 2, x, n), b.O(q - 1, x, n + G)) : 0 === this.N && B <= m.bounds.right && (n = m.bounds.x, b.O(q - 2, n, y), b.O(q - 1, n - z, y)); else {
                            z = Math.max(10, this.$d[m.layer]);
                            G = Math.max(10,
                                this.Bd[m.layer]);
                            p = 0;
                            if (180 === this.N || 0 === this.N) {
                                if (180 === this.N ? B <= m.bounds.x : B >= m.bounds.right) p = (0 === this.N ? G : -z) / 2;
                                b.m(q++, B + p, y)
                            } else {
                                if (270 === this.N ? D <= m.bounds.y : D >= m.bounds.bottom) p = (90 === this.N ? G : -z) / 2;
                                b.m(q++, x, D + p)
                            }
                            b.m(q++, B, D)
                        }
                    } else {
                        for (; null !== m && m !== n;) {
                            z = u = null;
                            for (m = m.destinationEdges.iterator; m.next() && (x = m.value, x.link !== c.link || (u = x.toVertex, z = x.fromVertex, null !== z.node && (z = null), null !== u.node));) ;
                            u !== n && (x = b.i(q - 1).x, y = b.i(q - 1).y, B = u.centerX, D = u.centerY, p ? 180 === this.N || 0 === this.N ?
                                (null !== z ? z.centerY : y) !== D && (z = this.Na[u.layer] + this.bd.x, q === b.firstPickIndex + 1 && (z = 0 === this.N ? Math.max(z, x) : Math.min(z, x)), b.m(q++, z, y), b.m(q++, z, D)) : (null !== z ? z.centerX : x) !== B && (z = this.Na[u.layer] + this.bd.y, q === b.firstPickIndex + 1 && (z = 90 === this.N ? Math.max(z, y) : Math.min(z, y)), b.m(q++, x, z), b.m(q++, B, z)) : (z = Math.max(10, this.$d[u.layer]), G = Math.max(10, this.Bd[u.layer]), 180 === this.N ? (b.m(q++, B + G, D), r && b.m(q++, B, D), b.m(q++, B - z, D)) : 90 === this.N ? (b.m(q++, B, D - z), r && b.m(q++, B, D), b.m(q++, B, D + G)) : 270 === this.N ?
                                (b.m(q++, B, D + G), r && b.m(q++, B, D), b.m(q++, B, D - z)) : (b.m(q++, B - z, D), r && b.m(q++, B, D), b.m(q++, B + G, D))));
                            m = u
                        }
                        p && (x = b.i(q - 1).x, y = b.i(q - 1).y, B = b.i(q).x, D = b.i(q).y, 180 === this.N || 0 === this.N ? y !== D && (z = 0 === this.N ? Math.min(Math.max((B + x) / 2, this.Na[n.layer] + this.bd.x), B) : Math.max(Math.min((B + x) / 2, this.Na[n.layer] + this.bd.x), B), b.m(q++, z, y), b.m(q++, z, D)) : x !== B && (z = 90 === this.N ? Math.min(Math.max((D + y) / 2, this.Na[n.layer] + this.bd.y), D) : Math.max(Math.min((D + y) / 2, this.Na[n.layer] + this.bd.y), D), b.m(q++, x, z), b.m(q++, B, z)))
                    }
                    null !==
                    d && r && (null !== g && (l === Ec && (l = b.i(0), d = b.i(2), l.A(d) || b.O(1, (l.x + d.x) / 2, (l.y + d.y) / 2)), l = b.getLinkPoint(e, g, Ec, !0, !1, f, h), l.o() || l.set(e.actualBounds.center), b.O(0, l.x, l.y)), null !== h && (k === Ec && (k = b.i(b.pointsCount - 1), l = b.i(b.pointsCount - 3), k.A(l) || b.O(b.pointsCount - 2, (k.x + l.x) / 2, (k.y + l.y) / 2)), e = b.getLinkPoint(f, h, Ec, !1, !1, e, g), e.o() || e.set(f.actualBounds.center), b.O(b.pointsCount - 1, e.x, e.y)));
                    b.Jf();
                    c.commit()
                }
            }
        }
        this.avoidOrthogonalOverlaps()
    };
    Os.prototype.avoidOrthogonalOverlaps = function () {
        if (!(0 >= this.linkSpacing)) {
            for (var a = new H, b = this.network.edges.iterator; b.next();) {
                var c = b.value.link;
                null !== c && c.isOrthogonal && !a.contains(c) && a.add(c)
            }
            if (0 < a.count) if (90 === this.N || 270 === this.N) {
                b = 0;
                c = [];
                for (a = a.iterator; a.next();) {
                    var d = a.value;
                    if (null !== d && d.isOrthogonal) for (var e = 2; e < d.pointsCount - 3; e++) {
                        var f = d.i(e);
                        var g = d.i(e + 1);
                        if (this.C(f.y, g.y) && !this.C(f.x, g.x)) {
                            var h = new Ht;
                            h.layer = Math.floor(f.y / 2);
                            var k = d.i(0), l = d.i(d.pointsCount - 1);
                            h.first =
                                k.x * k.x + k.y;
                            h.cc = l.x * l.x + l.y;
                            h.ld = Math.min(f.x, g.x);
                            h.Bc = Math.max(f.x, g.x);
                            h.index = e;
                            h.link = d;
                            if (e + 2 < d.pointsCount) {
                                k = d.i(e - 1);
                                l = d.i(e + 2);
                                var m = 0;
                                k.y < f.y ? m = l.y < f.y ? 3 : f.x < g.x ? 2 : 1 : k.y > f.y && (m = l.y > f.y ? 0 : g.x < f.x ? 2 : 1);
                                h.l = m
                            }
                            c.push(h)
                        }
                    }
                }
                if (1 < c.length) for (c.sort(this.gz), a = 0; a < c.length;) {
                    f = c[a].layer;
                    for (d = a + 1; d < c.length && c[d].layer === f;) d++;
                    if (1 < d - a) for (f = a; f < d;) {
                        g = c[f].Bc;
                        for (e = a + 1; e < d && c[e].ld < g;) g = Math.max(g, c[e].Bc), e++;
                        g = e - f;
                        if (1 < g) {
                            this.Fj(c, this.su, f, f + g);
                            m = 1;
                            h = c[f].cc;
                            for (k = f; k < e; k++) l = c[k], l.cc !==
                            h && (m++, h = l.cc);
                            this.Fj(c, this.fz, f, f + g);
                            var n = 1;
                            h = c[f].first;
                            for (k = f; k < e; k++) l = c[k], l.first !== h && (n++, h = l.first);
                            k = !0;
                            l = n;
                            m < n ? (k = !1, l = m, h = c[f].cc, this.Fj(c, this.su, f, f + g)) : h = c[f].first;
                            m = 0;
                            for (n = f; n < e; n++) {
                                var p = c[n];
                                (k ? p.first : p.cc) !== h && (m++, h = k ? p.first : p.cc);
                                var r = p.link;
                                f = r.i(p.index);
                                g = r.i(p.index + 1);
                                var q = this.linkSpacing * (m - (l - 1) / 2);
                                if (!r.isAvoiding || It(f.x, f.y + q, g.x, g.y + q)) b++, r.ci(), r.O(p.index, f.x, f.y + q), r.O(p.index + 1, g.x, g.y + q), r.Jf()
                            }
                        }
                        f = e
                    }
                    a = d
                }
            } else {
                b = 0;
                c = [];
                for (a = a.iterator; a.next();) if (d =
                    a.value, null !== d && d.isOrthogonal) for (e = 2; e < d.pointsCount - 3; e++) f = d.i(e), g = d.i(e + 1), this.C(f.x, g.x) && !this.C(f.y, g.y) && (h = new Ht, h.layer = Math.floor(f.x / 2), k = d.i(0), l = d.i(d.pointsCount - 1), h.first = k.x + k.y * k.y, h.cc = l.x + l.y * l.y, h.ld = Math.min(f.y, g.y), h.Bc = Math.max(f.y, g.y), h.index = e, h.link = d, e + 2 < d.pointsCount && (k = d.i(e - 1), l = d.i(e + 2), m = 0, k.x < f.x ? m = l.x < f.x ? 3 : f.y < g.y ? 2 : 1 : k.x > f.x && (m = l.x > f.x ? 0 : g.y < f.y ? 2 : 1), h.l = m), c.push(h));
                if (1 < c.length) for (c.sort(this.gz), a = 0; a < c.length;) {
                    f = c[a].layer;
                    for (d = a + 1; d < c.length &&
                    c[d].layer === f;) d++;
                    if (1 < d - a) for (f = a; f < d;) {
                        g = c[f].Bc;
                        for (e = a + 1; e < d && c[e].ld < g;) g = Math.max(g, c[e].Bc), e++;
                        g = e - f;
                        if (1 < g) {
                            this.Fj(c, this.su, f, f + g);
                            m = 1;
                            h = c[f].cc;
                            for (k = f; k < e; k++) l = c[k], l.cc !== h && (m++, h = l.cc);
                            this.Fj(c, this.fz, f, f + g);
                            n = 1;
                            h = c[f].first;
                            for (k = f; k < e; k++) l = c[k], l.first !== h && (n++, h = l.first);
                            k = !0;
                            l = n;
                            m < n ? (k = !1, l = m, h = c[f].cc, this.Fj(c, this.su, f, f + g)) : h = c[f].first;
                            m = 0;
                            for (n = f; n < e; n++) if (p = c[n], (k ? p.first : p.cc) !== h && (m++, h = k ? p.first : p.cc), r = p.link, f = r.i(p.index), g = r.i(p.index + 1), q = this.linkSpacing *
                                (m - (l - 1) / 2), !r.isAvoiding || It(f.x + q, f.y, g.x + q, g.y)) b++, r.ci(), r.O(p.index, f.x + q, f.y), r.O(p.index + 1, g.x + q, g.y), r.Jf()
                        }
                        f = e
                    }
                    a = d
                }
            }
        }
    };
    t = Os.prototype;
    t.gz = function (a, b) {
        return a instanceof Ht && b instanceof Ht && a !== b ? a.layer < b.layer ? -1 : a.layer > b.layer ? 1 : a.ld < b.ld ? -1 : a.ld > b.ld ? 1 : a.Bc < b.Bc ? -1 : a.Bc > b.Bc ? 1 : 0 : 0
    };
    t.fz = function (a, b) {
        return a instanceof Ht && b instanceof Ht && a !== b ? a.first < b.first ? -1 : a.first > b.first || a.l < b.l ? 1 : a.l > b.l || a.ld < b.ld ? -1 : a.ld > b.ld ? 1 : a.Bc < b.Bc ? -1 : a.Bc > b.Bc ? 1 : 0 : 0
    };
    t.su = function (a, b) {
        return a instanceof Ht && b instanceof Ht && a !== b ? a.cc < b.cc ? -1 : a.cc > b.cc || a.l < b.l ? 1 : a.l > b.l || a.ld < b.ld ? -1 : a.ld > b.ld ? 1 : a.Bc < b.Bc ? -1 : a.Bc > b.Bc ? 1 : 0 : 0
    };
    t.C = function (a, b) {
        F && (C(a, Os, "isApprox:a"), C(b, Os, "isApprox:b"));
        a -= b;
        return -1 < a && 1 > a
    };
    t.Fj = function (a, b, c, d) {
        var e = a.length, f = d - c;
        if (!(1 >= f)) if ((0 > c || c >= e - 1) && v("not in range 0 <= from < length: " + c), 2 === f) d = a[c], e = a[c + 1], 0 < b(d, e) && (a[c] = e, a[c + 1] = d); else if (0 === c) if (d >= e) a.sort(b); else for (c = a.slice(0, d), c.sort(b), b = 0; b < d; b++) a[b] = c[b]; else if (d >= e) for (d = a.slice(c), d.sort(b), b = c; b < e; b++) a[b] = d[b - c]; else for (e = a.slice(c, d), e.sort(b), b = c; b < d; b++) a[b] = e[b - c]
    };

    function It(a, b, c, d) {
        F && (C(a, Os, "isUnoccupied2:px"), C(b, Os, "isUnoccupied2:py"), C(c, Os, "isUnoccupied2:qx"), C(d, Os, "isUnoccupied2:qy"));
        return !0
    }

    function Xs(a, b) {
        var c = a.Fb[b];
        if (c >= a.Ee.length) {
            var d = [];
            for (var e = 0; e < a.Ee.length; e++) d[e] = a.Ee[e];
            a.Ee = d
        }
        void 0 === a.Ee[c] || null === a.Ee[c] ? d = [] : (d = a.Ee[c], a.Ee[c] = null);
        a = a.np[b];
        for (b = 0; b < a.length; b++) c = a[b], d[c.index] = c;
        return d
    }

    function Ys(a, b, c) {
        a.Ee[a.Fb[b]] = c
    }

    na.Object.defineProperties(Os.prototype, {
        layerSpacing: {
            configurable: !0, get: function () {
                return this.Ae
            }, set: function (a) {
                this.Ae !== a && (A(a, "number", Os, "layerSpacing"), 0 <= a && (this.Ae = a, this.D()))
            }
        }, columnSpacing: {
            configurable: !0, get: function () {
                return this.ec
            }, set: function (a) {
                this.ec !== a && (A(a, "number", Os, "columnSpacing"), 0 < a && (this.ec = a, this.D()))
            }
        }, direction: {
            configurable: !0, get: function () {
                return this.N
            }, set: function (a) {
                this.N !== a && (A(a, "number", Os, "direction"),
                    0 === a || 90 === a || 180 === a || 270 === a ? (this.N = a, this.D()) : v("LayeredDigraphLayout.direction must be 0, 90, 180, or 270"))
            }
        }, cycleRemoveOption: {
            configurable: !0, get: function () {
                return this.tl
            }, set: function (a) {
                this.tl !== a && (ib(a, Os, Os, "cycleRemoveOption"), a === ht || a === Ps || a === Us) && (this.tl = a, this.D())
            }
        }, layeringOption: {
            configurable: !0, get: function () {
                return this.Yl
            }, set: function (a) {
                this.Yl !== a && (ib(a, Os, Os, "layeringOption"), a === Qs || a === mt || a === ot) && (this.Yl = a, this.D())
            }
        }, initializeOption: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Nl
            }, set: function (a) {
                this.Nl !== a && (ib(a, Os, Os, "initializeOption"), a === Rs || a === ut || a === st) && (this.Nl = a, this.D())
            }
        }, iterations: {
            configurable: !0, get: function () {
                return this.ak
            }, set: function (a) {
                this.ak !== a && (C(a, Ts, "iterations"), 0 <= a && (this.ak = a, this.D()))
            }
        }, aggressiveOption: {
            configurable: !0, get: function () {
                return this.il
            }, set: function (a) {
                this.il !== a && (ib(a, Os, Os, "aggressiveOption"), a === yt || a === Ss || a === zt) && (this.il = a, this.D())
            }
        }, packOption: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Ag
            }, set: function (a) {
                this.Ag !== a && (A(a, "number", Os, "packOption"), 0 <= a && 8 > a && (this.Ag = a, this.D()))
            }
        }, setsPortSpots: {
            configurable: !0, get: function () {
                return this.vf
            }, set: function (a) {
                this.vf !== a && (A(a, "boolean", Os, "setsPortSpots"), this.vf = a, this.D())
            }
        }, linkSpacing: {
            configurable: !0, get: function () {
                return this.To
            }, set: function (a) {
                this.To !== a && (A(a, "number", Os, "linkSpacing"), 0 <= a && (this.To = a, this.D()))
            }
        }, maxLayer: {
            configurable: !0,
            get: function () {
                return this.xa
            }
        }, maxIndex: {
            configurable: !0, get: function () {
                return this.Si
            }
        }, maxColumn: {
            configurable: !0, get: function () {
                return this.Ga
            }
        }, minIndexLayer: {
            configurable: !0, get: function () {
                return this.yh
            }
        }, maxIndexLayer: {
            configurable: !0, get: function () {
                return this.uc
            }
        }
    });
    var Ps = new E(Os, "CycleDepthFirst", 0), ht = new E(Os, "CycleGreedy", 1), Us = new E(Os, "CycleFromLayers", 2),
        Qs = new E(Os, "LayerOptimalLinkLength", 0), mt = new E(Os, "LayerLongestPathSink", 1),
        ot = new E(Os, "LayerLongestPathSource", 2), Rs = new E(Os, "InitDepthFirstOut", 0),
        ut = new E(Os, "InitDepthFirstIn", 1), st = new E(Os, "InitNaive", 2), yt = new E(Os, "AggressiveNone", 0),
        Ss = new E(Os, "AggressiveLess", 1), zt = new E(Os, "AggressiveMore", 2);
    Os.className = "LayeredDigraphLayout";
    Os.CycleDepthFirst = Ps;
    Os.CycleGreedy = ht;
    Os.CycleFromLayers = Us;
    Os.LayerOptimalLinkLength = Qs;
    Os.LayerLongestPathSink = mt;
    Os.LayerLongestPathSource = ot;
    Os.InitDepthFirstOut = Rs;
    Os.InitDepthFirstIn = ut;
    Os.InitNaive = st;
    Os.AggressiveNone = yt;
    Os.AggressiveLess = Ss;
    Os.AggressiveMore = zt;
    Os.PackNone = 0;
    Os.PackExpand = 1;
    Os.PackStraighten = 2;
    Os.PackMedian = 4;
    Os.PackAll = 7;

    function Ht() {
        this.index = this.Bc = this.ld = this.cc = this.first = this.layer = 0;
        this.link = null;
        this.l = 0
    }

    Ht.className = "SegInfo";

    function Ts(a) {
        nq.call(this, a)
    }

    ma(Ts, nq);
    Ts.prototype.createVertex = function () {
        return new Jt(this)
    };
    Ts.prototype.createEdge = function () {
        return new Kt(this)
    };
    Ts.className = "LayeredDigraphNetwork";

    function Jt(a) {
        Bq.call(this, a);
        this.Va = this.eh = this.Oi = -1;
        this.L = NaN;
        this.W = null;
        this.valid = !1;
        this.finish = this.Pg = NaN;
        this.If = 0;
        this.Tk = this.Uk = null
    }

    ma(Jt, Bq);
    Jt.prototype.serializeVertexProperties = function (a, b) {
        Bq.prototype.serializeVertexProperties.call(this, a, b);
        a.layer = this.layer;
        a.column = this.column;
        a.index = this.index;
        a.component = this.component;
        a.near = this.near ? rb(this.near) : null;
        a.valid = this.valid;
        a.Pg = this.Pg;
        a.finish = this.finish;
        a.If = this.If;
        a.Uk = this.Uk;
        a.Tk = this.Tk
    };
    Jt.prototype.Lq = function (a, b, c, d) {
        Bq.prototype.Lq.call(this, a, b, c, d);
        this.layer = a.layer;
        this.column = a.column;
        this.index = a.index;
        this.component = a.component;
        if (b = b.get(a.near)) this.near = b;
        this.valid = a.valid;
        this.Pg = a.Pg;
        this.finish = a.finish;
        this.If = a.If;
        this.Uk = a.Uk;
        this.Tk = a.Tk
    };
    na.Object.defineProperties(Jt.prototype, {
        layer: {
            configurable: !0, get: function () {
                return this.Oi
            }, set: function (a) {
                this.Oi !== a && (A(a, "number", Jt, "layer"), this.Oi = a)
            }
        }, column: {
            configurable: !0, get: function () {
                return this.eh
            }, set: function (a) {
                this.eh !== a && (A(a, "number", Jt, "column"), this.eh = a)
            }
        }, index: {
            configurable: !0, get: function () {
                return this.Va
            }, set: function (a) {
                this.Va !== a && (A(a, "number", Jt, "index"), this.Va = a)
            }
        }, component: {
            configurable: !0, get: function () {
                return this.L
            },
            set: function (a) {
                this.L !== a && (A(a, "number", Jt, "component"), this.L = a)
            }
        }, near: {
            configurable: !0, get: function () {
                return this.W
            }, set: function (a) {
                this.W !== a && (F && null !== a && w(a, Jt, Jt, "near"), this.W = a)
            }
        }
    });
    Jt.className = "LayeredDigraphVertex";

    function Kt(a) {
        Cq.call(this, a);
        this.l = this.Pa = this.kb = !1;
        this.Oa = this.L = NaN;
        this.W = this.w = 0
    }

    ma(Kt, Cq);
    Kt.prototype.serializeEdgeProperties = function (a, b) {
        Cq.prototype.serializeEdgeProperties.call(this, a, b);
        a.valid = this.valid;
        a.rev = this.rev;
        a.forest = this.forest;
        a.portFromPos = this.portFromPos;
        a.portToPos = this.portToPos;
        a.portFromColOffset = this.portFromColOffset;
        a.portToColOffset = this.portToColOffset
    };
    Kt.prototype.deserializeEdgeProperties = function (a, b, c, d) {
        Cq.prototype.deserializeEdgeProperties.call(this, a, b, c, d);
        this.valid = a.valid;
        this.rev = a.rev;
        this.forest = a.forest;
        this.portFromPos = a.portFromPos;
        this.portToPos = a.portToPos;
        this.portFromColOffset = a.portFromColOffset;
        this.portToColOffset = a.portToColOffset
    };
    na.Object.defineProperties(Kt.prototype, {
        valid: {
            configurable: !0, get: function () {
                return this.kb
            }, set: function (a) {
                this.kb !== a && (A(a, "boolean", Kt, "valid"), this.kb = a)
            }
        }, rev: {
            configurable: !0, get: function () {
                return this.Pa
            }, set: function (a) {
                this.Pa !== a && (A(a, "boolean", Kt, "rev"), this.Pa = a)
            }
        }, forest: {
            configurable: !0, get: function () {
                return this.l
            }, set: function (a) {
                this.l !== a && (A(a, "boolean", Kt, "forest"), this.l = a)
            }
        }, portFromPos: {
            configurable: !0, get: function () {
                return this.L
            },
            set: function (a) {
                this.L !== a && (A(a, "number", Kt, "portFromPos"), this.L = a)
            }
        }, portToPos: {
            configurable: !0, get: function () {
                return this.Oa
            }, set: function (a) {
                this.Oa !== a && (A(a, "number", Kt, "portToPos"), this.Oa = a)
            }
        }, portFromColOffset: {
            configurable: !0, get: function () {
                return this.w
            }, set: function (a) {
                this.w !== a && (A(a, "number", Kt, "portFromColOffset"), this.w = a)
            }
        }, portToColOffset: {
            configurable: !0, get: function () {
                return this.W
            }, set: function (a) {
                this.W !== a && (A(a, "number", Kt, "portToColOffset"),
                    this.W = a)
            }
        }
    });
    Kt.className = "LayeredDigraphEdge";

    function Z() {
        0 < arguments.length && Ba(Z);
        Ni.call(this);
        this.Qb = new I;
        this.Cp = Lt;
        this.pd = Mt;
        this.xq = Nt;
        this.Gs = Ot;
        this.Ax = [];
        this.od = !0;
        this.Lb = Pt;
        this.Qd = (new Hb(10, 10)).freeze();
        var a = new Qt(this);
        this.Y = new Rt(a);
        this.Z = new Rt(a);
        this.Fv = []
    }

    ma(Z, Ni);
    Z.prototype.cloneProtected = function (a) {
        Ni.prototype.cloneProtected.call(this, a);
        a.Cp = this.Cp;
        a.xq = this.xq;
        a.Gs = this.Gs;
        a.od = this.od;
        a.Lb = this.Lb;
        a.Qd.assign(this.Qd);
        a.Y.copyInheritedPropertiesFrom(this.Y);
        a.Z.copyInheritedPropertiesFrom(this.Z)
    };
    Z.prototype.pb = function (a) {
        a.classType === Z ? 0 === a.name.indexOf("Alignment") ? this.alignment = a : 0 === a.name.indexOf("Arrangement") ? this.arrangement = a : 0 === a.name.indexOf("Compaction") ? this.compaction = a : 0 === a.name.indexOf("Path") ? this.path = a : 0 === a.name.indexOf("Sorting") ? this.sorting = a : 0 === a.name.indexOf("Style") ? this.treeStyle = a : v("Unknown enum value: " + a) : Ni.prototype.pb.call(this, a)
    };
    Z.prototype.createNetwork = function () {
        return new Qt(this)
    };
    Z.prototype.makeNetwork = function (a) {
        function b(a) {
            if (a instanceof V) return !a.isLinkLabel && "Comment" !== a.category;
            if (a instanceof S) {
                var b = a.fromNode;
                if (null === b || b.isLinkLabel || "Comment" === b.category) return !1;
                a = a.toNode;
                return null === a || a.isLinkLabel || "Comment" === a.category ? !1 : !0
            }
            return !1
        }

        var c = this.createNetwork();
        a instanceof Q ? (c.Ng(a.nodes, !0, b), c.Ng(a.links, !0, b)) : a instanceof Kf ? c.Ng(a.memberParts, !1, b) : c.Ng(a.iterator, !1, b);
        return c
    };
    Z.prototype.doLayout = function (a) {
        F && null === a && v("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts");
        null === this.network && (this.network = this.makeNetwork(a));
        this.arrangement !== St && (this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin));
        var b = this.diagram;
        null === b && a instanceof Q && (b = a);
        this.path === Lt && null !== b ? this.pd = b.isTreePathToChildren ? Mt : Tt : this.pd = this.path === Lt ? Mt : this.path;
        if (0 < this.network.vertexes.count) {
            this.network.Kq();
            for (a = this.network.vertexes.iterator; a.next();) b = a.value, b.initialized = !1, b.level = 0, b.parent = null, b.children = [];
            if (0 < this.Qb.count) {
                a = new I;
                for (b = this.Qb.iterator; b.next();) {
                    var c = b.value;
                    c instanceof V ? (c = this.network.uj(c), null !== c && a.add(c)) : c instanceof Rt && a.add(c)
                }
                this.Qb = a
            }
            0 === this.Qb.count && this.findRoots();
            for (a = this.Qb.copy().iterator; a.next();) b = a.value, b.initialized || (b.initialized = !0, Ut(this, b));
            b = this.network.vertexes;
            for (a = null; a = Vt(b), 0 < a.count;) b = Wt(this, a), null !== b && this.Qb.add(b),
                b.initialized = !0, Ut(this, b), b = a;
            for (a = this.Qb.iterator; a.next();) b = a.value, b instanceof Rt && Xt(this, b);
            for (a = this.Qb.iterator; a.next();) b = a.value, b instanceof Rt && Yt(this, b);
            for (a = this.Qb.iterator; a.next();) b = a.value, b instanceof Rt && Zt(this, b);
            this.Qv();
            if (this.layerStyle === $t) {
                a = [];
                for (b = this.network.vertexes.iterator; b.next();) {
                    c = b.value;
                    var d = c.parent;
                    null === d && (d = c);
                    d = 0 === d.angle || 180 === d.angle;
                    var e = a[c.level];
                    void 0 === e && (e = 0);
                    a[c.level] = Math.max(e, d ? c.width : c.height)
                }
                for (b = 0; b < a.length; b++) void 0 ===
                a[b] && (a[b] = 0);
                this.Ax = a;
                for (b = this.network.vertexes.iterator; b.next();) c = b.value, d = c.parent, null === d && (d = c), 0 === d.angle || 180 === d.angle ? (180 === d.angle && (c.focusX += a[c.level] - c.width), c.width = a[c.level]) : (270 === d.angle && (c.focusY += a[c.level] - c.height), c.height = a[c.level])
            } else if (this.layerStyle === au) for (a = this.network.vertexes.iterator; a.next();) {
                b = a.value;
                c = 0 === b.angle || 180 === b.angle;
                d = -1;
                for (e = 0; e < b.children.length; e++) {
                    var f = b.children[e];
                    d = Math.max(d, c ? f.width : f.height)
                }
                if (0 <= d) for (e = 0; e < b.children.length; e++) f =
                    b.children[e], c ? (180 === b.angle && (f.focusX += d - f.width), f.width = d) : (270 === b.angle && (f.focusY += d - f.height), f.height = d)
            }
            for (a = this.Qb.iterator; a.next();) b = a.value, b instanceof Rt && this.layoutTree(b);
            this.arrangeTrees();
            this.updateParts()
        }
        this.network = null;
        this.Qb = new I;
        this.isValidLayout = !0
    };

    function Vt(a) {
        var b = new I;
        for (a = a.iterator; a.next();) {
            var c = a.value;
            c.initialized || b.add(c)
        }
        return b
    }

    Z.prototype.findRoots = function () {
        for (var a = this.network.vertexes, b = a.iterator; b.next();) {
            var c = b.value;
            switch (this.pd) {
                case Mt:
                    0 === c.sourceEdges.count && this.Qb.add(c);
                    break;
                case Tt:
                    0 === c.destinationEdges.count && this.Qb.add(c);
                    break;
                default:
                    v("Unhandled path value " + this.pd.toString())
            }
        }
        0 === this.Qb.count && (a = Wt(this, a), null !== a && this.Qb.add(a))
    };

    function Wt(a, b) {
        var c = 999999, d = null;
        for (b = b.iterator; b.next();) {
            var e = b.value;
            switch (a.pd) {
                case Mt:
                    e.sourceEdges.count < c && (c = e.sourceEdges.count, d = e);
                    break;
                case Tt:
                    e.destinationEdges.count < c && (c = e.destinationEdges.count, d = e);
                    break;
                default:
                    v("Unhandled path value " + a.pd.toString())
            }
        }
        return d
    }

    function Ut(a, b) {
        if (null !== b) {
            F && w(b, Rt, Z, "walkTree:v");
            switch (a.pd) {
                case Mt:
                    if (0 < b.destinationEdges.count) {
                        for (var c = new H, d = b.destinationVertexes; d.next();) {
                            var e = d.value;
                            bu(a, b, e) && c.add(e)
                        }
                        0 < c.count && (b.children = c.ta())
                    }
                    break;
                case Tt:
                    if (0 < b.sourceEdges.count) {
                        c = new H;
                        for (d = b.sourceVertexes; d.next();) e = d.value, bu(a, b, e) && c.add(e);
                        0 < c.count && (b.children = c.ta())
                    }
                    break;
                default:
                    v("Unhandled path value" + a.pd.toString())
            }
            c = b.children;
            d = c.length;
            for (e = 0; e < d; e++) {
                var f = c[e];
                f.initialized = !0;
                f.level = b.level +
                    1;
                f.parent = b;
                a.Qb.remove(f)
            }
            for (b = 0; b < d; b++) Ut(a, c[b])
        }
    }

    function bu(a, b, c) {
        F && w(b, Rt, Z, "walkOK:v");
        F && w(c, Rt, Z, "walkOK:c");
        if (c.initialized) {
            if (null === b) var d = !1; else {
                F && w(c, Rt, Z, "isAncestor:a");
                F && w(b, Rt, Z, "isAncestor:b");
                for (d = b.parent; null !== d && d !== c;) d = d.parent;
                d = d === c
            }
            if (d || c.level > b.level) return !1;
            a.removeChild(c.parent, c)
        }
        return !0
    }

    Z.prototype.removeChild = function (a, b) {
        if (null !== a && null !== b) {
            F && w(a, Rt, Z, "removeChild:p");
            F && w(b, Rt, Z, "removeChild:c");
            for (var c = a.children, d = 0, e = 0; e < c.length; e++) c[e] === b && d++;
            if (0 < d) {
                d = Array(c.length - d);
                for (var f = e = 0; f < c.length; f++) c[f] !== b && (d[e++] = c[f]);
                a.children = d
            }
        }
    };

    function Xt(a, b) {
        if (null !== b) {
            F && w(b, Rt, Z, "initializeTree:v");
            a.initializeTreeVertexValues(b);
            b.alignment === cu && a.sortTreeVertexChildren(b);
            for (var c = 0, d = b.childrenCount, e = 0, f = b.children, g = f.length, h = 0; h < g; h++) {
                var k = f[h];
                Xt(a, k);
                c += k.descendantCount + 1;
                d = Math.max(d, k.maxChildrenCount);
                e = Math.max(e, k.maxGenerationCount)
            }
            b.descendantCount = c;
            b.maxChildrenCount = d;
            b.maxGenerationCount = 0 < d ? e + 1 : 0
        }
    }

    function du(a, b) {
        F && w(b, Rt, Z, "mom:v");
        switch (a.xq) {
            default:
            case Nt:
                return null !== b.parent ? b.parent : a.Y;
            case eu:
                return null === b.parent ? a.Y : null === b.parent.parent ? a.Z : b.parent;
            case fu:
                return null !== b.parent ? null !== b.parent.parent ? b.parent.parent : a.Z : a.Y;
            case gu:
                var c = !0;
                if (0 === b.childrenCount) c = !1; else for (var d = b.children, e = d.length, f = 0; f < e; f++) if (0 < d[f].childrenCount) {
                    c = !1;
                    break
                }
                return c && null !== b.parent ? a.Z : null !== b.parent ? b.parent : a.Y
        }
    }

    Z.prototype.initializeTreeVertexValues = function (a) {
        F && w(a, Rt, Z, "initializeTreeVertexValues:v");
        var b = du(this, a);
        a.copyInheritedPropertiesFrom(b);
        if (null !== a.parent && a.parent.alignment === cu) {
            b = a.angle;
            for (var c = a.parent.children, d = 0; d < c.length && a !== c[d];) d++;
            0 === d % 2 ? d !== c.length - 1 && (b = 90 === b ? 180 : 180 === b ? 270 : 270 === b ? 180 : 270) : b = 90 === b ? 0 : 180 === b ? 90 : 270 === b ? 0 : 90;
            a.angle = b
        }
        a.initialized = !0
    };

    function Yt(a, b) {
        if (null !== b) {
            F && w(b, Rt, Z, "assignTree:v");
            a.assignTreeVertexValues(b);
            b = b.children;
            for (var c = b.length, d = 0; d < c; d++) Yt(a, b[d])
        }
    }

    Z.prototype.assignTreeVertexValues = function () {
    };

    function Zt(a, b) {
        if (null !== b) {
            F && w(b, Rt, Z, "sortTree:v");
            b.alignment !== cu && a.sortTreeVertexChildren(b);
            b = b.children;
            for (var c = b.length, d = 0; d < c; d++) Zt(a, b[d])
        }
    }

    Z.prototype.sortTreeVertexChildren = function (a) {
        F && w(a, Rt, Z, "sortTreeVertexChildren:v");
        switch (a.sorting) {
            case hu:
                break;
            case iu:
                a.children.reverse();
                break;
            case ju:
                a.children.sort(a.comparer);
                break;
            case ku:
                a.children.sort(a.comparer);
                a.children.reverse();
                break;
            default:
                v("Unhandled sorting value " + a.sorting.toString())
        }
    };
    Z.prototype.Qv = function () {
        if (this.comments) for (var a = this.network.vertexes.iterator; a.next();) this.addComments(a.value)
    };
    Z.prototype.addComments = function (a) {
        F && w(a, Rt, Z, "addComments:v");
        var b = a.angle, c = a.parent, d = 0;
        var e = !1;
        null !== c && (d = c.angle, e = c.alignment, e = lu(e));
        b = 90 === b || 270 === b;
        d = 90 === d || 270 === d;
        c = 0 === a.childrenCount;
        var f = 0, g = 0, h = 0, k = a.commentSpacing;
        if (null !== a.node) for (var l = a.node.dw(); l.next();) {
            var m = l.value;
            "Comment" === m.category && m.canLayout() && (null === a.comments && (a.comments = []), a.comments.push(m), m.Ya(), m = m.measuredBounds, b && !c || !e && !d && c || e && d && c ? (f = Math.max(f, m.width), g += m.height + Math.abs(h)) : (f +=
                m.width + Math.abs(h), g = Math.max(g, m.height)), h = k)
        }
        null !== a.comments && (b && !c || !e && !d && c || e && d && c ? (f += Math.abs(a.commentMargin), g = Math.max(0, g - a.height)) : (g += Math.abs(a.commentMargin), f = Math.max(0, f - a.width)), e = L.allocAt(0, 0, a.bounds.width + f, a.bounds.height + g), a.bounds = e, L.free(e))
    };

    function lu(a) {
        return a === mu || a === cu || a === nu || a === ou
    }

    function pu(a) {
        return a === mu || a === cu
    }

    function qu(a) {
        F && w(a, Rt, Z, "isLeftSideBus:v");
        var b = a.parent;
        if (null !== b) {
            var c = b.alignment;
            if (lu(c)) {
                if (pu(c)) {
                    b = b.children;
                    for (c = 0; c < b.length && a !== b[c];) c++;
                    return 0 === c % 2
                }
                if (c === nu) return !0
            }
        }
        return !1
    }

    Z.prototype.layoutComments = function (a) {
        F && w(a, Rt, Z, "layoutComments:v");
        if (null !== a.comments) {
            var b = a.node.measuredBounds, c = a.parent, d = a.angle, e = 0;
            var f = !1;
            null !== c && (e = c.angle, f = c.alignment, f = lu(f));
            d = 90 === d || 270 === d;
            c = 90 === e || 270 === e;
            for (var g = 0 === a.childrenCount, h = qu(a), k = 0, l = a.comments, m = l.length, n = J.alloc(), p = 0; p < m; p++) {
                var r = l[p], q = r.measuredBounds;
                if (d && !g || !f && !c && g || f && c && g) {
                    if (135 < e && !f || c && h) if (0 <= a.commentMargin) for (n.h(a.bounds.x - a.commentMargin - q.width, a.bounds.y + k), r.move(n), r = r.Jd(); r.next();) {
                        var u =
                            r.value;
                        u.fromSpot = pd;
                        u.toSpot = qd
                    } else for (n.h(a.bounds.x + 2 * a.focus.x - a.commentMargin, a.bounds.y + k), r.move(n), r = r.Jd(); r.next();) u = r.value, u.fromSpot = qd, u.toSpot = pd; else if (0 <= a.commentMargin) for (n.h(a.bounds.x + 2 * a.focus.x + a.commentMargin, a.bounds.y + k), r.move(n), r = r.Jd(); r.next();) u = r.value, u.fromSpot = qd, u.toSpot = pd; else for (n.h(a.bounds.x + a.commentMargin - q.width, a.bounds.y + k), r.move(n), r = r.Jd(); r.next();) u = r.value, u.fromSpot = pd, u.toSpot = qd;
                    k = 0 <= a.commentSpacing ? k + (q.height + a.commentSpacing) : k + (a.commentSpacing -
                        q.height)
                } else {
                    if (135 < e && !f || !c && h) if (0 <= a.commentMargin) for (n.h(a.bounds.x + k, a.bounds.y - a.commentMargin - q.height), r.move(n), r = r.Jd(); r.next();) u = r.value, u.fromSpot = od, u.toSpot = rd; else for (n.h(a.bounds.x + k, a.bounds.y + 2 * a.focus.y - a.commentMargin), r.move(n), r = r.Jd(); r.next();) u = r.value, u.fromSpot = rd, u.toSpot = od; else if (0 <= a.commentMargin) for (n.h(a.bounds.x + k, a.bounds.y + 2 * a.focus.y + a.commentMargin), r.move(n), r = r.Jd(); r.next();) u = r.value, u.fromSpot = rd, u.toSpot = od; else for (n.h(a.bounds.x + k, a.bounds.y +
                        a.commentMargin - q.height), r.move(n), r = r.Jd(); r.next();) u = r.value, u.fromSpot = od, u.toSpot = rd;
                    k = 0 <= a.commentSpacing ? k + (q.width + a.commentSpacing) : k + (a.commentSpacing - q.width)
                }
            }
            J.free(n);
            b = k - a.commentSpacing - (d ? b.height : b.width);
            if (this.pd === Mt) for (a = a.destinationEdges; a.next();) e = a.value.link, null === e || e.isAvoiding || (e.fromEndSegmentLength = 0 < b ? b : NaN); else for (a = a.sourceEdges; a.next();) e = a.value.link, null === e || e.isAvoiding || (e.toEndSegmentLength = 0 < b ? b : NaN)
        }
    };
    Z.prototype.layoutTree = function (a) {
        if (null !== a) {
            F && w(a, Rt, Z, "layoutTree:v");
            for (var b = a.children, c = b.length, d = 0; d < c; d++) this.layoutTree(b[d]);
            switch (a.compaction) {
                case ru:
                    su(this, a);
                    break;
                case tu:
                    if (a.alignment === cu) su(this, a); else if (F && w(a, Rt, Z, "layoutTreeBlock:v"), 0 === a.childrenCount) d = a.parent, c = !1, b = 0, null !== d && (b = d.angle, c = d.alignment, c = lu(c)), d = qu(a), a.V.h(0, 0), a.Ba.h(a.width, a.height), null === a.parent || null === a.comments || (180 !== b && 270 !== b || c) && !d ? a.la.h(0, 0) : 180 === b && !c || (90 === b || 270 === b) &&
                    d ? a.la.h(a.width - 2 * a.focus.x, 0) : a.la.h(0, a.height - 2 * a.focus.y), a.ar = null, a.pr = null; else {
                        var e = uu(a);
                        b = 90 === e || 270 === e;
                        var f = 0, g = a.children, h = g.length;
                        for (c = 0; c < h; c++) d = g[c], f = Math.max(f, b ? d.Ba.width : d.Ba.height);
                        var k = a.alignment;
                        d = k === vu;
                        var l = k === wu, m = lu(k), n = Math.max(0, a.breadthLimit);
                        c = xu(a);
                        var p = a.nodeSpacing, r = Cu(a), q = a.rowSpacing, u = 0;
                        if (d || l || a.dn || a.en && 1 === a.maxGenerationCount) u = Math.max(0, a.rowIndent);
                        d = a.width;
                        var x = a.height, y = 0, z = 0, B = 0, D = null, G = null, O = 0, U = 0, R = 0, fa = 0, Y = 0,
                            P = 0, ya = 0, ka = 0;
                        m && !pu(k) && 135 < e && g.reverse();
                        if (pu(k)) if (1 < h) for (var Aa = 0; Aa < h; Aa++) 0 === Aa % 2 && Aa !== h - 1 && (ka = Math.max(ka, b ? g[Aa].Ba.width : g[Aa].Ba.height)); else 1 === h && (ka = b ? g[0].Ba.width : g[0].Ba.height);
                        if (m) {
                            switch (k) {
                                case mu:
                                    z = 135 > e ? Du(a, g, ka, y, z) : Eu(a, g, ka, y, z);
                                    ka = z.x;
                                    y = z.width;
                                    z = z.height;
                                    break;
                                case nu:
                                    for (D = 0; D < h; D++) G = g[D], n = G.Ba, B = 0 === P ? 0 : q, b ? (G.V.h(f - n.width, fa + B), y = Math.max(y, n.width), z = Math.max(z, fa + B + n.height), fa += B + n.height) : (G.V.h(R + B, f - n.height), y = Math.max(y, R + B + n.width), z = Math.max(z, n.height), R += B +
                                        n.width), P++;
                                    break;
                                case ou:
                                    for (D = 0; D < h; D++) G = g[D], f = G.Ba, n = 0 === P ? 0 : q, b ? (G.V.h(p / 2 + a.focus.x, fa + n), y = Math.max(y, f.width), z = Math.max(z, fa + n + f.height), fa += n + f.height) : (G.V.h(R + n, p / 2 + a.focus.y), y = Math.max(y, R + n + f.width), z = Math.max(z, f.height), R += n + f.width), P++
                            }
                            D = Fu(this, 2);
                            G = Fu(this, 2);
                            b ? (D[0].h(0, 0), D[1].h(0, z), G[0].h(y, 0)) : (D[0].h(0, 0), D[1].h(y, 0), G[0].h(0, z));
                            G[1].h(y, z)
                        } else for (Aa = 0; Aa < h; Aa++) {
                            var Ta = g[Aa], sb = Ta.Ba;
                            if (b) {
                                0 < n && 0 < P && R + p + sb.width > n && (R < f && Gu(a, k, f - R, 0, ya, Aa - 1), Y++, P = 0, ya = Aa, B = z, R = 0,
                                    fa = 135 < e ? -z - q : z + q);
                                Hu(this, Ta, 0, fa);
                                var Xa = 0;
                                if (0 === P) {
                                    if (D = Ta.ar, G = Ta.pr, O = sb.width, U = sb.height, null === D || null === G || e !== uu(Ta)) D = Fu(this, 2), G = Fu(this, 2), D[0].h(0, 0), D[1].h(0, U), G[0].h(O, 0), G[1].h(O, U)
                                } else {
                                    var ab = Ma();
                                    U = Iu(this, a, Ta, D, G, O, U, ab);
                                    Xa = U.x;
                                    D = ab[0];
                                    G = ab[1];
                                    O = U.width;
                                    U = U.height;
                                    Oa(ab);
                                    R < sb.width && 0 > Xa && (Ju(a, -Xa, 0, ya, Aa - 1), Ku(D, -Xa, 0), Ku(G, -Xa, 0), Xa = 0)
                                }
                                Ta.V.h(Xa, fa);
                                y = Math.max(y, O);
                                z = Math.max(z, B + (0 === Y ? 0 : q) + sb.height);
                                R = O
                            } else {
                                0 < n && 0 < P && fa + p + sb.height > n && (fa < f && Gu(a, k, 0, f - fa, ya, Aa - 1),
                                    Y++, P = 0, ya = Aa, B = y, fa = 0, R = 135 < e ? -y - q : y + q);
                                Hu(this, Ta, R, 0);
                                Xa = 0;
                                if (0 === P) {
                                    if (D = Ta.ar, G = Ta.pr, O = sb.width, U = sb.height, null === D || null === G || e !== uu(Ta)) D = Fu(this, 2), G = Fu(this, 2), D[0].h(0, 0), D[1].h(O, 0), G[0].h(0, U), G[1].h(O, U)
                                } else ab = Ma(), U = Iu(this, a, Ta, D, G, O, U, ab), Xa = U.x, D = ab[0], G = ab[1], O = U.width, U = U.height, Oa(ab), fa < sb.height && 0 > Xa && (Ju(a, 0, -Xa, ya, Aa - 1), Ku(D, 0, -Xa), Ku(G, 0, -Xa), Xa = 0);
                                Ta.V.h(R, Xa);
                                z = Math.max(z, U);
                                y = Math.max(y, B + (0 === Y ? 0 : q) + sb.width);
                                fa = U
                            }
                            P++
                        }
                        0 < Y && (b ? (z += Math.max(0, c), R < y && Gu(a, k, y - R, 0, ya,
                            h - 1), 0 < u && (l || Ju(a, u, 0, 0, h - 1), y += u)) : (y += Math.max(0, c), fa < z && Gu(a, k, 0, z - fa, ya, h - 1), 0 < u && (l || Ju(a, 0, u, 0, h - 1), z += u)));
                        u = l = 0;
                        switch (k) {
                            case Lu:
                                b ? l += y / 2 - a.focus.x - r / 2 : u += z / 2 - a.focus.y - r / 2;
                                break;
                            case Mu:
                                0 < Y ? b ? l += y / 2 - a.focus.x - r / 2 : u += z / 2 - a.focus.y - r / 2 : b ? (ka = g[0].V.x + g[0].la.x, l += ka + (g[h - 1].V.x + g[h - 1].la.x + 2 * g[h - 1].focus.x - ka) / 2 - a.focus.x - r / 2) : (ka = g[0].V.y + g[0].la.y, u += ka + (g[h - 1].V.y + g[h - 1].la.y + 2 * g[h - 1].focus.y - ka) / 2 - a.focus.y - r / 2);
                                break;
                            case vu:
                                b ? (l -= r, y += r) : (u -= r, z += r);
                                break;
                            case wu:
                                b ? (l += y - a.width + r,
                                    y += r) : (u += z - a.height + r, z += r);
                                break;
                            case mu:
                                b ? 1 < h ? l += ka + p / 2 - a.focus.x : l += g[0].focus.x - a.focus.x + g[0].la.x : 1 < h ? u += ka + p / 2 - a.focus.y : u += g[0].focus.y - a.focus.y + g[0].la.y;
                                break;
                            case nu:
                                b ? l += y + p / 2 - a.focus.x : u += z + p / 2 - a.focus.y;
                                break;
                            case ou:
                                break;
                            default:
                                v("Unhandled alignment value " + k.toString())
                        }
                        for (r = 0; r < h; r++) ka = g[r], b ? ka.V.h(ka.V.x + ka.la.x - l, ka.V.y + (135 < e ? (m ? -z : -ka.Ba.height) + ka.la.y - c : x + c + ka.la.y)) : ka.V.h(ka.V.x + (135 < e ? (m ? -y : -ka.Ba.width) + ka.la.x - c : d + c + ka.la.x), ka.V.y + ka.la.y - u);
                        h = g = 0;
                        m ? b ? (y = Nu(a,
                            y, l), 0 > l && (l = 0), 135 < e && (u += z + c), z += x + c, k === ou && (g += p / 2 + a.focus.x), h += x + c) : (135 < e && (l += y + c), y += d + c, z = Ou(a, z, u), 0 > u && (u = 0), k === ou && (h += p / 2 + a.focus.y), g += d + c) : b ? (null === a.comments ? d > y && (y = Pu(k, d - y, 0), g = y.x, h = y.y, y = d, l = 0) : y = Nu(a, y, l), 0 > l && (g -= l, l = 0), 135 < e && (u += z + c), z = Math.max(Math.max(z, x), z + x + c), h += x + c) : (135 < e && (l += y + c), y = Math.max(Math.max(y, d), y + d + c), null === a.comments ? x > z && (z = Pu(k, 0, x - z), g = z.x, h = z.y, z = x, u = 0) : z = Ou(a, z, u), 0 > u && (h -= u, u = 0), g += d + c);
                        if (0 < Y) e = Fu(this, 4), Y = Fu(this, 4), b ? (e[2].h(0, x + c), e[3].h(e[2].x,
                            z), Y[2].h(y, e[2].y), Y[3].h(Y[2].x, e[3].y)) : (e[2].h(d + c, 0), e[3].h(y, e[2].y), Y[2].h(e[2].x, z), Y[3].h(e[3].x, Y[2].y)); else {
                            e = Fu(this, D.length + 2);
                            Y = Fu(this, G.length + 2);
                            for (k = 0; k < D.length; k++) m = D[k], e[k + 2].h(m.x + g, m.y + h);
                            for (k = 0; k < G.length; k++) m = G[k], Y[k + 2].h(m.x + g, m.y + h)
                        }
                        b ? (e[0].h(l, 0), e[1].h(e[0].x, x), e[2].y < e[1].y && (e[2].x > e[0].x ? e[2].assign(e[1]) : e[1].assign(e[2])), e[3].y < e[2].y && (e[3].x > e[0].x ? e[3].assign(e[2]) : e[2].assign(e[3])), Y[0].h(l + d, 0), Y[1].h(Y[0].x, x), Y[2].y < Y[1].y && (Y[2].x < Y[0].x ? Y[2].assign(Y[1]) :
                            Y[1].assign(Y[2])), Y[3].y < Y[2].y && (Y[3].x < Y[0].x ? Y[3].assign(Y[2]) : Y[2].assign(Y[3])), e[2].y -= c / 2, Y[2].y -= c / 2) : (e[0].h(0, u), e[1].h(d, e[0].y), e[2].x < e[1].x && (e[2].y > e[0].y ? e[2].assign(e[1]) : e[1].assign(e[2])), e[3].x < e[2].x && (e[3].y > e[0].y ? e[3].assign(e[2]) : e[2].assign(e[3])), Y[0].h(0, u + x), Y[1].h(d, Y[0].y), Y[2].x < Y[1].x && (Y[2].y < Y[0].y ? Y[2].assign(Y[1]) : Y[1].assign(Y[2])), Y[3].x < Y[2].x && (Y[3].y < Y[0].y ? Y[3].assign(Y[2]) : Y[2].assign(Y[3])), e[2].x -= c / 2, Y[2].x -= c / 2);
                        Qu(this, D);
                        Qu(this, G);
                        a.ar = e;
                        a.pr = Y;
                        a.la.h(l, u);
                        a.Ba.h(y, z)
                    }
                    break;
                default:
                    v("Unhandled compaction value " + a.compaction.toString())
            }
        }
    };

    function su(a, b) {
        F && w(b, Rt, Z, "layoutTreeNone:v");
        if (0 === b.childrenCount) {
            var c = !1, d = 0;
            null !== b.parent && (d = b.parent.angle, c = b.parent.alignment, c = lu(c));
            var e = qu(b);
            b.V.h(0, 0);
            b.Ba.h(b.width, b.height);
            null === b.parent || null === b.comments || (180 !== d && 270 !== d || c) && !e ? b.la.h(0, 0) : 180 === d && !c || (90 === d || 270 === d) && e ? b.la.h(b.width - 2 * b.focus.x, 0) : b.la.h(0, b.height - 2 * b.focus.y)
        } else {
            d = uu(b);
            c = 90 === d || 270 === d;
            var f = 0;
            e = b.children;
            for (var g = e.length, h = 0; h < g; h++) {
                var k = e[h];
                f = Math.max(f, c ? k.Ba.width : k.Ba.height)
            }
            var l =
                b.alignment, m = l === vu, n = l === wu;
            h = lu(l);
            var p = Math.max(0, b.breadthLimit);
            k = xu(b);
            var r = b.nodeSpacing, q = Cu(b), u = m || n ? 0 : q / 2, x = b.rowSpacing, y = 0;
            if (m || n || b.dn || b.en && 1 === b.maxGenerationCount) y = Math.max(0, b.rowIndent);
            m = b.width;
            var z = b.height, B = 0, D = 0, G = 0, O = 0, U = 0, R = 0, fa = 0, Y = 0, P = 0, ya = 0;
            h && !pu(l) && 135 < d && e.reverse();
            if (pu(l)) if (1 < g) for (var ka = 0; ka < g; ka++) {
                var Aa = e[ka], Ta = Aa.Ba;
                0 === ka % 2 && ka !== g - 1 ? P = Math.max(P, (c ? Ta.width : Ta.height) + Ru(Aa) - r) : 0 !== ka % 2 && (ya = Math.max(ya, (c ? Ta.width : Ta.height) + Ru(Aa) - r))
            } else 1 ===
            g && (P = c ? e[0].Ba.width : e[0].Ba.height);
            if (h) switch (l) {
                case mu:
                case cu:
                    D = 135 > d ? Du(b, e, P, B, D) : Eu(b, e, P, B, D);
                    P = D.x;
                    B = D.width;
                    D = D.height;
                    break;
                case nu:
                    for (a = 0; a < g; a++) p = e[a], u = p.Ba, G = 0 === fa ? 0 : x, c ? (p.V.h(f - u.width, U + G), B = Math.max(B, u.width), D = Math.max(D, U + G + u.height), U += G + u.height) : (p.V.h(O + G, f - u.height), B = Math.max(B, O + G + u.width), D = Math.max(D, u.height), O += G + u.width), fa++;
                    break;
                case ou:
                    for (f = 0; f < g; f++) a = e[f], p = a.Ba, u = 0 === fa ? 0 : x, c ? (a.V.h(r / 2 + b.focus.x, U + u), B = Math.max(B, p.width), D = Math.max(D, U + u + p.height),
                        U += u + p.height) : (a.V.h(O + u, r / 2 + b.focus.y), B = Math.max(B, O + u + p.width), D = Math.max(D, p.height), O += u + p.width), fa++
            } else for (ya = 0; ya < g; ya++) ka = e[ya], Aa = ka.Ba, c ? (0 < p && 0 < fa && O + r + Aa.width > p && (O < f && Gu(b, l, f - O, 0, Y, ya - 1), R++, fa = 0, Y = ya, G = D, O = 0, U = 135 < d ? -D - x : D + x), Ta = 0 === fa ? u : r, Hu(a, ka, 0, U), ka.V.h(O + Ta, U), B = Math.max(B, O + Ta + Aa.width), D = Math.max(D, G + (0 === R ? 0 : x) + Aa.height), O += Ta + Aa.width) : (0 < p && 0 < fa && U + r + Aa.height > p && (U < f && Gu(b, l, 0, f - U, Y, ya - 1), R++, fa = 0, Y = ya, G = B, U = 0, O = 135 < d ? -B - x : B + x), Ta = 0 === fa ? u : r, Hu(a, ka, O, 0), ka.V.h(O,
                U + Ta), D = Math.max(D, U + Ta + Aa.height), B = Math.max(B, G + (0 === R ? 0 : x) + Aa.width), U += Ta + Aa.height), fa++;
            0 < R && (c ? (D += Math.max(0, k), O < B && Gu(b, l, B - O, 0, Y, g - 1), 0 < y && (n || Ju(b, y, 0, 0, g - 1), B += y)) : (B += Math.max(0, k), U < D && Gu(b, l, 0, D - U, Y, g - 1), 0 < y && (n || Ju(b, 0, y, 0, g - 1), D += y)));
            y = n = 0;
            switch (l) {
                case Lu:
                    c ? n += B / 2 - b.focus.x - q / 2 : y += D / 2 - b.focus.y - q / 2;
                    break;
                case Mu:
                    0 < R ? c ? n += B / 2 - b.focus.x - q / 2 : y += D / 2 - b.focus.y - q / 2 : c ? (l = e[0].V.x + e[0].la.x, n += l + (e[g - 1].V.x + e[g - 1].la.x + 2 * e[g - 1].focus.x - l) / 2 - b.focus.x - q / 2) : (l = e[0].V.y + e[0].la.y, y += l + (e[g -
                    1].V.y + e[g - 1].la.y + 2 * e[g - 1].focus.y - l) / 2 - b.focus.y - q / 2);
                    break;
                case vu:
                    c ? (n -= q, B += q) : (y -= q, D += q);
                    break;
                case wu:
                    c ? (n += B - b.width + q, B += q) : (y += D - b.height + q, D += q);
                    break;
                case mu:
                case cu:
                    c ? 1 < g ? n += P + r / 2 - b.focus.x : n += e[0].focus.x - b.focus.x + e[0].la.x : 1 < g ? y += P + r / 2 - b.focus.y : y += e[0].focus.y - b.focus.y + e[0].la.y;
                    break;
                case nu:
                    c ? n += B + r / 2 - b.focus.x : y += D + r / 2 - b.focus.y;
                    break;
                case ou:
                    break;
                default:
                    v("Unhandled alignment value " + l.toString())
            }
            for (q = 0; q < g; q++) l = e[q], c ? l.V.h(l.V.x + l.la.x - n, l.V.y + (135 < d ? (h ? -D : -l.Ba.height) +
                l.la.y - k : z + k + l.la.y)) : l.V.h(l.V.x + (135 < d ? (h ? -B : -l.Ba.width) + l.la.x - k : m + k + l.la.x), l.V.y + l.la.y - y);
            c ? (B = Nu(b, B, n), 0 > n && (n = 0), 135 < d && (y += D + k), D = Math.max(Math.max(D, z), D + z + k)) : (135 < d && (n += B + k), B = Math.max(Math.max(B, m), B + m + k), D = Ou(b, D, y), 0 > y && (y = 0));
            b.la.h(n, y);
            b.Ba.h(B, D)
        }
    }

    function Du(a, b, c, d, e) {
        F && w(a, Rt, Z, "layoutBusChildrenPosDir:v");
        var f = b.length;
        if (0 === f) return new L(c, 0, d, e);
        if (1 === f) return a = b[0], d = a.Ba.width, e = a.Ba.height, new L(c, 0, d, e);
        for (var g = a.nodeSpacing, h = a.rowSpacing, k = 90 === uu(a), l = 0, m = 0, n = 0, p = 0; p < f; p++) if (!(0 !== p % 2 || 1 < f && p === f - 1)) {
            var r = b[p], q = r.Ba, u = 0 === l ? 0 : h;
            if (k) {
                var x = Ru(r) - g;
                r.V.h(c - (q.width + x), n + u);
                d = Math.max(d, q.width + x);
                e = Math.max(e, n + u + q.height);
                n += u + q.height
            } else x = Ru(r) - g, r.V.h(m + u, c - (q.height + x)), e = Math.max(e, q.height + x), d = Math.max(d, m +
                u + q.width), m += u + q.width;
            l++
        }
        l = 0;
        r = m;
        p = n;
        k ? (m = c + g, n = 0) : (m = 0, n = c + g);
        for (q = 0; q < f; q++) if (0 !== q % 2) {
            u = b[q];
            x = u.Ba;
            var y = 0 === l ? 0 : h;
            if (k) {
                var z = Ru(u) - g;
                u.V.h(m + z, n + y);
                d = Math.max(d, m + x.width + z);
                e = Math.max(e, n + y + x.height);
                n += y + x.height
            } else z = Ru(u) - g, u.V.h(m + y, n + z), d = Math.max(d, m + y + x.width), e = Math.max(e, n + x.height + z), m += y + x.width;
            l++
        }
        1 < f && 1 === f % 2 && (b = b[f - 1], f = b.Ba, h = Su(b), k ? (b.V.h(c + g / 2 - b.focus.x - b.la.x, e + h), k = c + g / 2 - b.focus.x - b.la.x, d = Math.max(d, k + f.width), 0 > k && (d -= k), e = Math.max(e, Math.max(p, n) + h + f.height),
        0 > b.V.x && (c = Tu(a, b.V.x, !1, c, g))) : (b.V.h(d + h, c + g / 2 - b.focus.y - b.la.y), d = Math.max(d, Math.max(r, m) + h + f.width), n = c + g / 2 - b.focus.y - b.la.y, e = Math.max(e, n + f.height), 0 > n && (e -= n), 0 > b.V.y && (c = Tu(a, b.V.y, !0, c, g))));
        return new L(c, 0, d, e)
    }

    function Eu(a, b, c, d, e) {
        F && w(a, Rt, Z, "layoutBusChildrenNegDir:v");
        var f = b.length;
        if (0 === f) return new L(c, 0, d, e);
        if (1 === f) return b = b[0], d = b.Ba.width, e = b.Ba.height, new L(c, 0, d, e);
        for (var g = a.nodeSpacing, h = a.rowSpacing, k = 270 === uu(a), l = 0, m = 0, n = 0, p = 0; p < f; p++) if (!(0 !== p % 2 || 1 < f && p === f - 1)) {
            var r = b[p], q = r.Ba, u = 0 === l ? 0 : h;
            if (k) {
                var x = Ru(r) - g;
                n -= u + q.height;
                r.V.h(c - (q.width + x), n);
                d = Math.max(d, q.width + x);
                e = Math.max(e, Math.abs(n))
            } else x = Ru(r) - g, m -= u + q.width, r.V.h(m, c - (q.height + x)), e = Math.max(e, q.height + x), d = Math.max(d,
                Math.abs(m));
            l++
        }
        l = 0;
        r = m;
        p = n;
        k ? (m = c + g, n = 0) : (m = 0, n = c + g);
        for (q = 0; q < f; q++) if (0 !== q % 2) {
            u = b[q];
            x = u.Ba;
            var y = 0 === l ? 0 : h;
            if (k) {
                var z = Ru(u) - g;
                n -= y + x.height;
                u.V.h(m + z, n);
                d = Math.max(d, m + x.width + z);
                e = Math.max(e, Math.abs(n))
            } else z = Ru(u) - g, m -= y + x.width, u.V.h(m, n + z), e = Math.max(e, n + x.height + z), d = Math.max(d, Math.abs(m));
            l++
        }
        1 < f && 1 === f % 2 && (h = b[f - 1], l = h.Ba, q = Su(h), k ? (h.V.h(c + g / 2 - h.focus.x - h.la.x, -e - l.height - q), m = c + g / 2 - h.focus.x - h.la.x, d = Math.max(d, m + l.width), 0 > m && (d -= m), e = Math.max(e, Math.abs(Math.min(p, n)) + q + l.height),
        0 > h.V.x && (c = Tu(a, h.V.x, !1, c, g))) : (h.V.h(-d - l.width - q, c + g / 2 - h.focus.y - h.la.y), d = Math.max(d, Math.abs(Math.min(r, m)) + q + l.width), n = c + g / 2 - h.focus.y - h.la.y, e = Math.max(e, n + l.height), 0 > n && (e -= n), 0 > h.V.y && (c = Tu(a, h.V.y, !0, c, g))));
        for (a = 0; a < f; a++) g = b[a], k ? g.V.h(g.V.x, g.V.y + e) : g.V.h(g.V.x + d, g.V.y);
        return new L(c, 0, d, e)
    }

    function Ru(a) {
        F && w(a, Rt, Z, "fixRelativePostions:child");
        return null === a.parent ? 0 : a.parent.nodeSpacing
    }

    function Su(a) {
        F && w(a, Rt, Z, "fixRelativePostions:lastchild");
        return null === a.parent ? 0 : a.parent.rowSpacing
    }

    function Tu(a, b, c, d, e) {
        F && w(a, Rt, Z, "fixRelativePostions:v");
        a = a.children;
        for (var f = a.length, g = 0; g < f; g++) c ? a[g].V.h(a[g].V.x, a[g].V.y - b) : a[g].V.h(a[g].V.x - b, a[g].V.y);
        b = a[f - 1];
        return Math.max(d, c ? b.la.y + b.focus.y - e / 2 : b.la.x + b.focus.x - e / 2)
    }

    function Nu(a, b, c) {
        F && w(a, Rt, Z, "calculateSubwidth:v");
        switch (a.alignment) {
            case Mu:
            case Lu:
                return c + a.width > b && (b = c + a.width), 0 > c && (b -= c), b;
            case vu:
                return a.width > b ? a.width : b;
            case wu:
                return 2 * a.focus.x > b ? a.width : b + a.width - 2 * a.focus.x;
            case mu:
            case cu:
                return Math.max(a.width, Math.max(b, c + a.width) - Math.min(0, c));
            case nu:
                return a.width - a.focus.x + a.nodeSpacing / 2 + b;
            case ou:
                return Math.max(a.width, a.focus.x + a.nodeSpacing / 2 + b);
            default:
                return b
        }
    }

    function Ou(a, b, c) {
        F && w(a, Rt, Z, "calculateSubheight:v");
        switch (a.alignment) {
            case Mu:
            case Lu:
                return c + a.height > b && (b = c + a.height), 0 > c && (b -= c), b;
            case vu:
                return a.height > b ? a.height : b;
            case wu:
                return 2 * a.focus.y > b ? a.height : b + a.height - 2 * a.focus.y;
            case mu:
            case cu:
                return Math.max(a.height, Math.max(b, c + a.height) - Math.min(0, c));
            case nu:
                return a.height - a.focus.y + a.nodeSpacing / 2 + b;
            case ou:
                return Math.max(a.height, a.focus.y + a.nodeSpacing / 2 + b);
            default:
                return b
        }
    }

    function Pu(a, b, c) {
        F && w(a, E, Z, "alignOffset:align");
        switch (a) {
            case Lu:
                b /= 2;
                c /= 2;
                break;
            case Mu:
                b /= 2;
                c /= 2;
                break;
            case vu:
                c = b = 0;
                break;
            case wu:
                break;
            default:
                v("Unhandled alignment value " + a.toString())
        }
        return new J(b, c)
    }

    function Gu(a, b, c, d, e, f) {
        F && w(a, Rt, Z, "shiftRelPosAlign:v");
        F && w(b, E, Z, "shiftRelPosAlign:align");
        b = Pu(b, c, d);
        Ju(a, b.x, b.y, e, f)
    }

    function Ju(a, b, c, d, e) {
        F && w(a, Rt, Z, "shiftRelPos:v");
        if (0 !== b || 0 !== c) for (a = a.children; d <= e; d++) {
            var f = a[d].V;
            f.x += b;
            f.y += c
        }
    }

    function Hu(a, b, c, d) {
        F && (w(b, Rt, Z, "recordMidPoints:v"), A(c, "number", Z, "recordMidPoints:x"), A(d, "number", Z, "recordMidPoints:y"));
        var e = b.parent;
        switch (a.pd) {
            case Mt:
                for (a = b.sourceEdges; a.next();) b = a.value, b.fromVertex === e && b.relativePoint.h(c, d);
                break;
            case Tt:
                for (a = b.destinationEdges; a.next();) b = a.value, b.toVertex === e && b.relativePoint.h(c, d);
                break;
            default:
                v("Unhandled path value " + a.pd.toString())
        }
    }

    function Ku(a, b, c) {
        for (var d = 0; d < a.length; d++) {
            var e = a[d];
            e.x += b;
            e.y += c
        }
    }

    function Iu(a, b, c, d, e, f, g, h) {
        F && w(b, Rt, Z, "mergeFringes:parent");
        F && w(c, Rt, Z, "mergeFringes:child");
        var k = uu(b), l = 90 === k || 270 === k, m = b.nodeSpacing;
        b = d;
        var n = e;
        d = f;
        var p = g, r = c.ar, q = c.pr;
        g = c.Ba;
        var u = l ? Math.max(p, g.height) : Math.max(d, g.width);
        if (null === r || k !== uu(c)) r = Fu(a, 2), q = Fu(a, 2), l ? (r[0].h(0, 0), r[1].h(0, g.height), q[0].h(g.width, 0), q[1].h(q[0].x, r[1].y)) : (r[0].h(0, 0), r[1].h(g.width, 0), q[0].h(0, g.height), q[1].h(r[1].x, q[0].y));
        if (l) {
            p = 9999999;
            if (!(null === n || 2 > n.length || null === r || 2 > r.length)) for (e = c =
                0; c < n.length && e < r.length;) {
                f = n[c];
                var x = r[e];
                k = x.x;
                l = x.y;
                k += d;
                var y = f;
                c + 1 < n.length && (y = n[c + 1]);
                var z = x;
                x = z.x;
                z = z.y;
                e + 1 < r.length && (z = r[e + 1], x = z.x, z = z.y, x += d);
                var B = p;
                f.y === l ? B = k - f.x : f.y > l && f.y < z ? B = k + (f.y - l) / (z - l) * (x - k) - f.x : l > f.y && l < y.y && (B = k - (f.x + (l - f.y) / (y.y - f.y) * (y.x - f.x)));
                B < p && (p = B);
                y.y <= f.y ? c++ : z <= l ? e++ : (y.y <= z && c++, z <= y.y && e++)
            }
            p = d - p;
            p += m;
            c = r;
            e = p;
            if (null === b || 2 > b.length || null === c || 2 > c.length) d = null; else {
                m = Fu(a, b.length + c.length);
                for (d = f = k = 0; f < c.length && c[f].y < b[0].y;) l = c[f++], m[d++].h(l.x + e,
                    l.y);
                for (; k < b.length;) l = b[k++], m[d++].h(l.x, l.y);
                for (k = b[b.length - 1].y; f < c.length && c[f].y <= k;) f++;
                for (; f < c.length && c[f].y > k;) l = c[f++], m[d++].h(l.x + e, l.y);
                c = Fu(a, d);
                for (k = 0; k < d; k++) c[k].assign(m[k]);
                Qu(a, m);
                d = c
            }
            f = q;
            k = p;
            if (null === n || 2 > n.length || null === f || 2 > f.length) e = null; else {
                m = Fu(a, n.length + f.length);
                for (e = l = c = 0; c < n.length && n[c].y < f[0].y;) y = n[c++], m[e++].h(y.x, y.y);
                for (; l < f.length;) y = f[l++], m[e++].h(y.x + k, y.y);
                for (f = f[f.length - 1].y; c < n.length && n[c].y <= f;) c++;
                for (; c < n.length && n[c].y > f;) k = n[c++], m[e++].h(k.x,
                    k.y);
                f = Fu(a, e);
                for (c = 0; c < e; c++) f[c].assign(m[c]);
                Qu(a, m);
                e = f
            }
            f = Math.max(0, p) + g.width;
            g = u;
            Qu(a, b);
            Qu(a, r);
            Qu(a, n);
            Qu(a, q);
            h[0] = d;
            h[1] = e;
            return new L(p, 0, f, g)
        }
        d = 9999999;
        if (!(null === n || 2 > n.length || null === r || 2 > r.length)) for (e = c = 0; c < n.length && e < r.length;) f = n[c], x = r[e], k = x.x, l = x.y, l += p, y = f, c + 1 < n.length && (y = n[c + 1]), z = x, x = z.x, z = z.y, e + 1 < r.length && (z = r[e + 1], x = z.x, z = z.y, z += p), B = d, f.x === k ? B = l - f.y : f.x > k && f.x < x ? B = l + (f.x - k) / (x - k) * (z - l) - f.y : k > f.x && k < y.x && (B = l - (f.y + (k - f.x) / (y.x - f.x) * (y.y - f.y))), B < d && (d = B), y.x <= f.x ?
            c++ : x <= k ? e++ : (y.x <= x && c++, x <= y.x && e++);
        p -= d;
        p += m;
        c = r;
        e = p;
        if (null === b || 2 > b.length || null === c || 2 > c.length) d = null; else {
            m = Fu(a, b.length + c.length);
            for (d = f = k = 0; f < c.length && c[f].x < b[0].x;) l = c[f++], m[d++].h(l.x, l.y + e);
            for (; k < b.length;) l = b[k++], m[d++].h(l.x, l.y);
            for (k = b[b.length - 1].x; f < c.length && c[f].x <= k;) f++;
            for (; f < c.length && c[f].x > k;) l = c[f++], m[d++].h(l.x, l.y + e);
            c = Fu(a, d);
            for (k = 0; k < d; k++) c[k].assign(m[k]);
            Qu(a, m);
            d = c
        }
        f = q;
        k = p;
        if (null === n || 2 > n.length || null === f || 2 > f.length) e = null; else {
            m = Fu(a, n.length + f.length);
            for (e = l = c = 0; c < n.length && n[c].x < f[0].x;) y = n[c++], m[e++].h(y.x, y.y);
            for (; l < f.length;) y = f[l++], m[e++].h(y.x, y.y + k);
            for (f = f[f.length - 1].x; c < n.length && n[c].x <= f;) c++;
            for (; c < n.length && n[c].x > f;) k = n[c++], m[e++].h(k.x, k.y);
            f = Fu(a, e);
            for (c = 0; c < e; c++) f[c].assign(m[c]);
            Qu(a, m);
            e = f
        }
        f = u;
        g = Math.max(0, p) + g.height;
        Qu(a, b);
        Qu(a, r);
        Qu(a, n);
        Qu(a, q);
        h[0] = d;
        h[1] = e;
        return new L(p, 0, f, g)
    }

    function Fu(a, b) {
        a = a.Fv[b];
        if (void 0 !== a && (a = a.pop(), void 0 !== a)) return a;
        a = [];
        for (var c = 0; c < b; c++) a[c] = new J;
        return a
    }

    function Qu(a, b) {
        var c = b.length, d = a.Fv[c];
        void 0 === d && (d = [], a.Fv[c] = d);
        d.push(b)
    }

    Z.prototype.arrangeTrees = function () {
        if (this.Lb === St) for (var a = this.Qb.iterator; a.next();) {
            var b = a.value;
            if (b instanceof Rt) {
                var c = b.node;
                if (null !== c) {
                    var d = c.position;
                    c = d.x;
                    d = d.y;
                    isFinite(c) || (c = 0);
                    isFinite(d) || (d = 0);
                    Uu(this, b, c, d)
                }
            }
        } else {
            a = [];
            for (b = this.Qb.iterator; b.next();) c = b.value, c instanceof Rt && a.push(c);
            switch (this.sorting) {
                case hu:
                    break;
                case iu:
                    a.reverse();
                    break;
                case ju:
                    a.sort(this.comparer);
                    break;
                case ku:
                    a.sort(this.comparer);
                    a.reverse();
                    break;
                default:
                    v("Unhandled sorting value " + this.sorting.toString())
            }
            c =
                this.arrangementOrigin;
            b = c.x;
            c = c.y;
            for (d = 0; d < a.length; d++) {
                var e = a[d];
                Uu(this, e, b + e.la.x, c + e.la.y);
                switch (this.Lb) {
                    case Pt:
                        c += e.Ba.height + this.Qd.height;
                        break;
                    case Vu:
                        b += e.Ba.width + this.Qd.width;
                        break;
                    default:
                        v("Unhandled arrangement value " + this.Lb.toString())
                }
            }
        }
    };

    function Uu(a, b, c, d) {
        if (null !== b) {
            F && w(b, Rt, Z, "assignAbsolutePositions:v");
            b.x = c;
            b.y = d;
            b = b.children;
            for (var e = b.length, f = 0; f < e; f++) {
                var g = b[f];
                Uu(a, g, c + g.V.x, d + g.V.y)
            }
        }
    }

    Z.prototype.commitLayout = function () {
        this.Pw();
        this.commitNodes();
        this.Sv();
        this.isRouting && this.commitLinks()
    };
    Z.prototype.commitNodes = function () {
        for (var a = this.network.vertexes.iterator; a.next();) a.value.commit();
        for (a.reset(); a.next();) this.layoutComments(a.value)
    };
    Z.prototype.Sv = function () {
        if (this.layerStyle === $t) {
            for (var a = this.Ax, b = [], c = null, d = this.network.vertexes.iterator; d.next();) {
                var e = d.value;
                null === c ? c = e.bounds.copy() : c.Yc(e.bounds);
                var f = b[e.level];
                void 0 === f ? f = xu(e) : f = Math.max(f, xu(e));
                b[e.level] = f
            }
            for (d = 0; d < b.length; d++) void 0 === b[d] && (b[d] = 0);
            90 === this.angle || 270 === this.angle ? (c.Pc(this.nodeSpacing / 2, this.layerSpacing), d = new J(-this.nodeSpacing / 2, -this.layerSpacing / 2)) : (c.Pc(this.layerSpacing, this.nodeSpacing / 2), d = new J(-this.layerSpacing / 2, -this.nodeSpacing /
                2));
            e = [];
            c = 90 === this.angle || 270 === this.angle ? c.width : c.height;
            f = 0;
            if (180 === this.angle || 270 === this.angle) for (var g = 0; g < a.length; g++) f += a[g] + b[g];
            for (g = 0; g < a.length; g++) {
                var h = a[g] + b[g];
                270 === this.angle ? (f -= h, e.push(new L(0, f, c, h))) : 90 === this.angle ? (e.push(new L(0, f, c, h)), f += h) : 180 === this.angle ? (f -= h, e.push(new L(f, 0, h, c))) : (e.push(new L(f, 0, h, c)), f += h)
            }
            this.commitLayers(e, d)
        }
    };
    Z.prototype.commitLayers = function () {
    };
    Z.prototype.commitLinks = function () {
        for (var a = this.network.edges.iterator; a.next();) a.value.commit()
    };
    Z.prototype.Pw = function () {
        for (var a = this.Qb.iterator; a.next();) {
            var b = a.value;
            b instanceof Rt && Wu(this, b)
        }
    };

    function Wu(a, b) {
        if (null !== b) {
            F && w(b, Rt, Z, "setPortSpotsTree:v");
            a.setPortSpots(b);
            b = b.children;
            for (var c = b.length, d = 0; d < c; d++) Wu(a, b[d])
        }
    }

    Z.prototype.setPortSpots = function (a) {
        F && w(a, Rt, Z, "setPortSpots:v");
        var b = a.alignment;
        if (lu(b)) {
            F && w(a, Rt, Z, "setPortSpotsBus:v");
            F && w(b, E, Z, "setPortSpots:align");
            var c = this.pd === Mt, d = uu(a);
            switch (d) {
                case 0:
                    var e = qd;
                    break;
                case 90:
                    e = rd;
                    break;
                case 180:
                    e = pd;
                    break;
                default:
                    e = od
            }
            var f = a.children, g = f.length;
            switch (b) {
                case mu:
                case cu:
                    for (b = 0; b < g; b++) {
                        var h = f[b];
                        h = (c ? h.sourceEdges : h.destinationEdges).first();
                        if (null !== h && (h = h.link, null !== h)) {
                            var k = 90 === d || 270 === d ? pd : od;
                            if (1 === g || b === g - 1 && 1 === g % 2) switch (d) {
                                case 0:
                                    k =
                                        pd;
                                    break;
                                case 90:
                                    k = od;
                                    break;
                                case 180:
                                    k = qd;
                                    break;
                                default:
                                    k = rd
                            } else 0 === b % 2 && (k = 90 === d || 270 === d ? qd : rd);
                            c ? (a.setsPortSpot && (h.fromSpot = e), a.setsChildPortSpot && (h.toSpot = k)) : (a.setsPortSpot && (h.fromSpot = k), a.setsChildPortSpot && (h.toSpot = e))
                        }
                    }
                    break;
                case nu:
                    d = 90 === d || 270 === d ? qd : rd;
                    for (f = c ? a.destinationEdges : a.sourceEdges; f.next();) g = f.value.link, null !== g && (c ? (a.setsPortSpot && (g.fromSpot = e), a.setsChildPortSpot && (g.toSpot = d)) : (a.setsPortSpot && (g.fromSpot = d), a.setsChildPortSpot && (g.toSpot = e)));
                    break;
                case ou:
                    for (d =
                             90 === d || 270 === d ? pd : od, f = c ? a.destinationEdges : a.sourceEdges; f.next();) g = f.value.link, null !== g && (c ? (a.setsPortSpot && (g.fromSpot = e), a.setsChildPortSpot && (g.toSpot = d)) : (a.setsPortSpot && (g.fromSpot = d), a.setsChildPortSpot && (g.toSpot = e)))
            }
        } else if (c = uu(a), this.pd === Mt) for (e = a.destinationEdges; e.next();) {
            if (d = e.value.link, null !== d) {
                if (a.setsPortSpot) if (a.portSpot.Jb()) switch (c) {
                    case 0:
                        d.fromSpot = qd;
                        break;
                    case 90:
                        d.fromSpot = rd;
                        break;
                    case 180:
                        d.fromSpot = pd;
                        break;
                    default:
                        d.fromSpot = od
                } else d.fromSpot = a.portSpot;
                if (a.setsChildPortSpot) if (a.childPortSpot.Jb()) switch (c) {
                    case 0:
                        d.toSpot = pd;
                        break;
                    case 90:
                        d.toSpot = od;
                        break;
                    case 180:
                        d.toSpot = qd;
                        break;
                    default:
                        d.toSpot = rd
                } else d.toSpot = a.childPortSpot
            }
        } else for (e = a.sourceEdges; e.next();) if (d = e.value.link, null !== d) {
            if (a.setsPortSpot) if (a.portSpot.Jb()) switch (c) {
                case 0:
                    d.toSpot = qd;
                    break;
                case 90:
                    d.toSpot = rd;
                    break;
                case 180:
                    d.toSpot = pd;
                    break;
                default:
                    d.toSpot = od
            } else d.toSpot = a.portSpot;
            if (a.setsChildPortSpot) if (a.childPortSpot.Jb()) switch (c) {
                case 0:
                    d.fromSpot = pd;
                    break;
                case 90:
                    d.fromSpot = od;
                    break;
                case 180:
                    d.fromSpot = qd;
                    break;
                default:
                    d.fromSpot = rd
            } else d.fromSpot = a.childPortSpot
        }
    };

    function uu(a) {
        a = a.angle;
        return 45 >= a ? 0 : 135 >= a ? 90 : 225 >= a ? 180 : 315 >= a ? 270 : 0
    }

    function xu(a) {
        F && w(a, Rt, Z, "computeLayerSpacing:v");
        var b = uu(a);
        b = 90 === b || 270 === b;
        var c = a.layerSpacing;
        if (0 < a.layerSpacingParentOverlap) {
            var d = Math.min(1, a.layerSpacingParentOverlap);
            c -= b ? a.height * d : a.width * d
        }
        c < (b ? -a.height : -a.width) && (c = b ? -a.height : -a.width);
        return c
    }

    function Cu(a) {
        F && w(a, Rt, Z, "computeNodeIndent:v");
        var b = uu(a), c = a.nodeIndent;
        if (0 < a.nodeIndentPastParent) {
            var d = Math.min(1, a.nodeIndentPastParent);
            c += 90 === b || 270 === b ? a.width * d : a.height * d
        }
        return c = Math.max(0, c)
    }

    na.Object.defineProperties(Z.prototype, {
        roots: {
            configurable: !0, get: function () {
                return this.Qb
            }, set: function (a) {
                this.Qb !== a && (w(a, I, Z, "roots"), this.Qb = a, this.D())
            }
        }, path: {
            configurable: !0, get: function () {
                return this.Cp
            }, set: function (a) {
                this.Cp !== a && (ib(a, Z, Z, "path"), this.Cp = a, this.D())
            }
        }, treeStyle: {
            configurable: !0, get: function () {
                return this.xq
            }, set: function (a) {
                this.Lb !== a && (ib(a, Z, Z, "treeStyle"), a === Nt || a === fu || a === gu || a === eu) && (this.xq = a, this.D())
            }
        }, layerStyle: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Gs
            }, set: function (a) {
                this.Lb !== a && (ib(a, Z, Z, "layerStyle"), a === Ot || a === au || a === $t) && (this.Gs = a, this.D())
            }
        }, comments: {
            configurable: !0, get: function () {
                return this.od
            }, set: function (a) {
                this.od !== a && (A(a, "boolean", Z, "comments"), this.od = a, this.D())
            }
        }, arrangement: {
            configurable: !0, get: function () {
                return this.Lb
            }, set: function (a) {
                this.Lb !== a && (ib(a, Z, Z, "arrangement"), a === Pt || a === Vu || a === St) && (this.Lb = a, this.D())
            }
        }, arrangementSpacing: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Qd
            }, set: function (a) {
                w(a, Hb, Z, "arrangementSpacing");
                this.Qd.A(a) || (this.Qd.assign(a), this.D())
            }
        }, rootDefaults: {
            configurable: !0, get: function () {
                return this.Y
            }, set: function (a) {
                this.Y !== a && (w(a, Rt, Z, "rootDefaults"), this.Y = a, this.D())
            }
        }, alternateDefaults: {
            configurable: !0, get: function () {
                return this.Z
            }, set: function (a) {
                this.Z !== a && (w(a, Rt, Z, "alternateDefaults"), this.Z = a, this.D())
            }
        }, sorting: {
            configurable: !0, get: function () {
                return this.Y.sorting
            },
            set: function (a) {
                this.Y.sorting !== a && (ib(a, Z, Z, "sorting"), a === hu || a === iu || a === ju || ku) && (this.Y.sorting = a, this.D())
            }
        }, comparer: {
            configurable: !0, get: function () {
                return this.Y.comparer
            }, set: function (a) {
                this.Y.comparer !== a && (A(a, "function", Z, "comparer"), this.Y.comparer = a, this.D())
            }
        }, angle: {
            configurable: !0, get: function () {
                return this.Y.angle
            }, set: function (a) {
                this.Y.angle !== a && (A(a, "number", Z, "angle"), 0 === a || 90 === a || 180 === a || 270 === a ? (this.Y.angle = a, this.D()) : v("TreeLayout.angle must be 0, 90, 180, or 270"))
            }
        },
        alignment: {
            configurable: !0, get: function () {
                return this.Y.alignment
            }, set: function (a) {
                this.Y.alignment !== a && (ib(a, Z, Z, "alignment"), this.Y.alignment = a, this.D())
            }
        }, nodeIndent: {
            configurable: !0, get: function () {
                return this.Y.nodeIndent
            }, set: function (a) {
                this.Y.nodeIndent !== a && (A(a, "number", Z, "nodeIndent"), 0 <= a && (this.Y.nodeIndent = a, this.D()))
            }
        }, nodeIndentPastParent: {
            configurable: !0, get: function () {
                return this.Y.nodeIndentPastParent
            }, set: function (a) {
                this.Y.nodeIndentPastParent !==
                a && (A(a, "number", Z, "nodeIndentPastParent"), 0 <= a && 1 >= a && (this.Y.nodeIndentPastParent = a, this.D()))
            }
        }, nodeSpacing: {
            configurable: !0, get: function () {
                return this.Y.nodeSpacing
            }, set: function (a) {
                this.Y.nodeSpacing !== a && (A(a, "number", Z, "nodeSpacing"), this.Y.nodeSpacing = a, this.D())
            }
        }, layerSpacing: {
            configurable: !0, get: function () {
                return this.Y.layerSpacing
            }, set: function (a) {
                this.Y.layerSpacing !== a && (A(a, "number", Z, "layerSpacing"), this.Y.layerSpacing = a, this.D())
            }
        }, layerSpacingParentOverlap: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Y.layerSpacingParentOverlap
            }, set: function (a) {
                this.Y.layerSpacingParentOverlap !== a && (A(a, "number", Z, "layerSpacingParentOverlap"), 0 <= a && 1 >= a && (this.Y.layerSpacingParentOverlap = a, this.D()))
            }
        }, compaction: {
            configurable: !0, get: function () {
                return this.Y.compaction
            }, set: function (a) {
                this.Y.compaction !== a && (ib(a, Z, Z, "compaction"), a === ru || a === tu) && (this.Y.compaction = a, this.D())
            }
        }, breadthLimit: {
            configurable: !0, get: function () {
                return this.Y.breadthLimit
            },
            set: function (a) {
                this.Y.breadthLimit !== a && (A(a, "number", Z, "breadthLimit"), 0 <= a && (this.Y.breadthLimit = a, this.D()))
            }
        }, rowSpacing: {
            configurable: !0, get: function () {
                return this.Y.rowSpacing
            }, set: function (a) {
                this.Y.rowSpacing !== a && (A(a, "number", Z, "rowSpacing"), this.Y.rowSpacing = a, this.D())
            }
        }, rowIndent: {
            configurable: !0, get: function () {
                return this.Y.rowIndent
            }, set: function (a) {
                this.Y.rowIndent !== a && (A(a, "number", Z, "rowIndent"), 0 <= a && (this.Y.rowIndent = a, this.D()))
            }
        }, commentSpacing: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Y.commentSpacing
            }, set: function (a) {
                this.Y.commentSpacing !== a && (A(a, "number", Z, "commentSpacing"), this.Y.commentSpacing = a, this.D())
            }
        }, commentMargin: {
            configurable: !0, get: function () {
                return this.Y.commentMargin
            }, set: function (a) {
                this.Y.commentMargin !== a && (A(a, "number", Z, "commentMargin"), this.Y.commentMargin = a, this.D())
            }
        }, setsPortSpot: {
            configurable: !0, get: function () {
                return this.Y.setsPortSpot
            }, set: function (a) {
                this.Y.setsPortSpot !== a && (A(a,
                    "boolean", Z, "setsPortSpot"), this.Y.setsPortSpot = a, this.D())
            }
        }, portSpot: {
            configurable: !0, get: function () {
                return this.Y.portSpot
            }, set: function (a) {
                w(a, M, Z, "portSpot");
                this.Y.portSpot.A(a) || (this.Y.portSpot = a, this.D())
            }
        }, setsChildPortSpot: {
            configurable: !0, get: function () {
                return this.Y.setsChildPortSpot
            }, set: function (a) {
                this.Y.setsChildPortSpot !== a && (A(a, "boolean", Z, "setsChildPortSpot"), this.Y.setsChildPortSpot = a, this.D())
            }
        }, childPortSpot: {
            configurable: !0, get: function () {
                return this.Y.childPortSpot
            },
            set: function (a) {
                w(a, M, Z, "childPortSpot");
                this.Y.childPortSpot.A(a) || (this.Y.childPortSpot = a, this.D())
            }
        }, alternateSorting: {
            configurable: !0, get: function () {
                return this.Z.sorting
            }, set: function (a) {
                this.Z.sorting !== a && (ib(a, Z, Z, "alternateSorting"), a === hu || a === iu || a === ju || ku) && (this.Z.sorting = a, this.D())
            }
        }, alternateComparer: {
            configurable: !0, get: function () {
                return this.Z.comparer
            }, set: function (a) {
                this.Z.comparer !== a && (A(a, "function", Z, "alternateComparer"), this.Z.comparer = a, this.D())
            }
        },
        alternateAngle: {
            configurable: !0, get: function () {
                return this.Z.angle
            }, set: function (a) {
                this.Z.angle !== a && (A(a, "number", Z, "alternateAngle"), 0 === a || 90 === a || 180 === a || 270 === a) && (this.Z.angle = a, this.D())
            }
        }, alternateAlignment: {
            configurable: !0, get: function () {
                return this.Z.alignment
            }, set: function (a) {
                this.Z.alignment !== a && (ib(a, Z, Z, "alternateAlignment"), this.Z.alignment = a, this.D())
            }
        }, alternateNodeIndent: {
            configurable: !0, get: function () {
                return this.Z.nodeIndent
            }, set: function (a) {
                this.Z.nodeIndent !==
                a && (A(a, "number", Z, "alternateNodeIndent"), 0 <= a && (this.Z.nodeIndent = a, this.D()))
            }
        }, alternateNodeIndentPastParent: {
            configurable: !0, get: function () {
                return this.Z.nodeIndentPastParent
            }, set: function (a) {
                this.Z.nodeIndentPastParent !== a && (A(a, "number", Z, "alternateNodeIndentPastParent"), 0 <= a && 1 >= a && (this.Z.nodeIndentPastParent = a, this.D()))
            }
        }, alternateNodeSpacing: {
            configurable: !0, get: function () {
                return this.Z.nodeSpacing
            }, set: function (a) {
                this.Z.nodeSpacing !== a && (A(a, "number", Z, "alternateNodeSpacing"),
                    this.Z.nodeSpacing = a, this.D())
            }
        }, alternateLayerSpacing: {
            configurable: !0, get: function () {
                return this.Z.layerSpacing
            }, set: function (a) {
                this.Z.layerSpacing !== a && (A(a, "number", Z, "alternateLayerSpacing"), this.Z.layerSpacing = a, this.D())
            }
        }, alternateLayerSpacingParentOverlap: {
            configurable: !0, get: function () {
                return this.Z.layerSpacingParentOverlap
            }, set: function (a) {
                this.Z.layerSpacingParentOverlap !== a && (A(a, "number", Z, "alternateLayerSpacingParentOverlap"), 0 <= a && 1 >= a && (this.Z.layerSpacingParentOverlap =
                    a, this.D()))
            }
        }, alternateCompaction: {
            configurable: !0, get: function () {
                return this.Z.compaction
            }, set: function (a) {
                this.Z.compaction !== a && (ib(a, Z, Z, "alternateCompaction"), a === ru || a === tu) && (this.Z.compaction = a, this.D())
            }
        }, alternateBreadthLimit: {
            configurable: !0, get: function () {
                return this.Z.breadthLimit
            }, set: function (a) {
                this.Z.breadthLimit !== a && (A(a, "number", Z, "alternateBreadthLimit"), 0 <= a && (this.Z.breadthLimit = a, this.D()))
            }
        }, alternateRowSpacing: {
            configurable: !0, get: function () {
                return this.Z.rowSpacing
            },
            set: function (a) {
                this.Z.rowSpacing !== a && (A(a, "number", Z, "alternateRowSpacing"), this.Z.rowSpacing = a, this.D())
            }
        }, alternateRowIndent: {
            configurable: !0, get: function () {
                return this.Z.rowIndent
            }, set: function (a) {
                this.Z.rowIndent !== a && (A(a, "number", Z, "alternateRowIndent"), 0 <= a && (this.Z.rowIndent = a, this.D()))
            }
        }, alternateCommentSpacing: {
            configurable: !0, get: function () {
                return this.Z.commentSpacing
            }, set: function (a) {
                this.Z.commentSpacing !== a && (A(a, "number", Z, "alternateCommentSpacing"),
                    this.Z.commentSpacing = a, this.D())
            }
        }, alternateCommentMargin: {
            configurable: !0, get: function () {
                return this.Z.commentMargin
            }, set: function (a) {
                this.Z.commentMargin !== a && (A(a, "number", Z, "alternateCommentMargin"), this.Z.commentMargin = a, this.D())
            }
        }, alternateSetsPortSpot: {
            configurable: !0, get: function () {
                return this.Z.setsPortSpot
            }, set: function (a) {
                this.Z.setsPortSpot !== a && (A(a, "boolean", Z, "alternateSetsPortSpot"), this.Z.setsPortSpot = a, this.D())
            }
        }, alternatePortSpot: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Z.portSpot
            }, set: function (a) {
                w(a, M, Z, "alternatePortSpot");
                this.Z.portSpot.A(a) || (this.Z.portSpot = a, this.D())
            }
        }, alternateSetsChildPortSpot: {
            configurable: !0, get: function () {
                return this.Z.setsChildPortSpot
            }, set: function (a) {
                this.Z.setsChildPortSpot !== a && (A(a, "boolean", Z, "alternateSetsChildPortSpot"), this.Z.setsChildPortSpot = a, this.D())
            }
        }, alternateChildPortSpot: {
            configurable: !0, get: function () {
                return this.Z.childPortSpot
            }, set: function (a) {
                w(a,
                    M, Z, "alternateChildPortSpot");
                this.Z.childPortSpot.A(a) || (this.Z.childPortSpot = a, this.D())
            }
        }
    });
    var Lt = new E(Z, "PathDefault", -1), Mt = new E(Z, "PathDestination", 0), Tt = new E(Z, "PathSource", 1),
        hu = new E(Z, "SortingForwards", 10), iu = new E(Z, "SortingReverse", 11),
        ju = new E(Z, "SortingAscending", 12), ku = new E(Z, "SortingDescending", 13),
        Lu = new E(Z, "AlignmentCenterSubtrees", 20), Mu = new E(Z, "AlignmentCenterChildren", 21),
        vu = new E(Z, "AlignmentStart", 22), wu = new E(Z, "AlignmentEnd", 23), mu = new E(Z, "AlignmentBus", 24),
        cu = new E(Z, "AlignmentBusBranching", 25), nu = new E(Z, "AlignmentTopLeftBus", 26),
        ou = new E(Z, "AlignmentBottomRightBus",
            27), ru = new E(Z, "CompactionNone", 30), tu = new E(Z, "CompactionBlock", 31),
        Nt = new E(Z, "StyleLayered", 40), gu = new E(Z, "StyleLastParents", 41), fu = new E(Z, "StyleAlternating", 42),
        eu = new E(Z, "StyleRootOnly", 43), Pt = new E(Z, "ArrangementVertical", 50),
        Vu = new E(Z, "ArrangementHorizontal", 51), St = new E(Z, "ArrangementFixedRoots", 52),
        Ot = new E(Z, "LayerIndividual", 60), au = new E(Z, "LayerSiblings", 61), $t = new E(Z, "LayerUniform", 62);
    Z.className = "TreeLayout";
    Z.PathDefault = Lt;
    Z.PathDestination = Mt;
    Z.PathSource = Tt;
    Z.SortingForwards = hu;
    Z.SortingReverse = iu;
    Z.SortingAscending = ju;
    Z.SortingDescending = ku;
    Z.AlignmentCenterSubtrees = Lu;
    Z.AlignmentCenterChildren = Mu;
    Z.AlignmentStart = vu;
    Z.AlignmentEnd = wu;
    Z.AlignmentBus = mu;
    Z.AlignmentBusBranching = cu;
    Z.AlignmentTopLeftBus = nu;
    Z.AlignmentBottomRightBus = ou;
    Z.CompactionNone = ru;
    Z.CompactionBlock = tu;
    Z.StyleLayered = Nt;
    Z.StyleLastParents = gu;
    Z.StyleAlternating = fu;
    Z.StyleRootOnly = eu;
    Z.ArrangementVertical = Pt;
    Z.ArrangementHorizontal = Vu;
    Z.ArrangementFixedRoots = St;
    Z.LayerIndividual = Ot;
    Z.LayerSiblings = au;
    Z.LayerUniform = $t;

    function Qt(a) {
        nq.call(this, a)
    }

    ma(Qt, nq);
    Qt.prototype.createVertex = function () {
        return new Rt(this)
    };
    Qt.prototype.createEdge = function () {
        return new Xu(this)
    };
    Qt.className = "TreeNetwork";

    function Rt(a) {
        Bq.call(this, a);
        this.Oa = !1;
        this.Ic = null;
        this.L = [];
        this.Zc = this.kb = this.W = this.Pa = 0;
        this.od = null;
        this.V = new J(0, 0);
        this.Ba = new Hb(0, 0);
        this.la = new J(0, 0);
        this.en = this.dn = this.nB = !1;
        this.pr = this.ar = null;
        this.hd = hu;
        this.cd = Iq;
        this.dc = 0;
        this.Eb = Mu;
        this.Qs = this.Ps = 0;
        this.Rs = 20;
        this.Ae = 50;
        this.Fs = 0;
        this.Sr = tu;
        this.Kr = 0;
        this.dt = 25;
        this.Rr = this.ct = 10;
        this.Qr = 20;
        this.qt = !0;
        this.$s = jd;
        this.pt = !0;
        this.Nr = jd
    }

    ma(Rt, Bq);
    Rt.prototype.copyInheritedPropertiesFrom = function (a) {
        null !== a && (this.hd = a.sorting, this.cd = a.comparer, this.dc = a.angle, this.Eb = a.alignment, this.Ps = a.nodeIndent, this.Qs = a.nodeIndentPastParent, this.Rs = a.nodeSpacing, this.Ae = a.layerSpacing, this.Fs = a.layerSpacingParentOverlap, this.Sr = a.compaction, this.Kr = a.breadthLimit, this.dt = a.rowSpacing, this.ct = a.rowIndent, this.Rr = a.commentSpacing, this.Qr = a.commentMargin, this.qt = a.setsPortSpot, this.$s = a.portSpot, this.pt = a.setsChildPortSpot, this.Nr = a.childPortSpot)
    };
    na.Object.defineProperties(Rt.prototype, {
        initialized: {
            configurable: !0, get: function () {
                return this.Oa
            }, set: function (a) {
                this.Oa !== a && (A(a, "boolean", Rt, "initialized"), this.Oa = a)
            }
        }, parent: {
            configurable: !0, get: function () {
                return this.Ic
            }, set: function (a) {
                this.Ic !== a && (F && null !== a && w(a, Rt, Rt, "parent"), this.Ic = a)
            }
        }, children: {
            configurable: !0, get: function () {
                return this.L
            }, set: function (a) {
                if (this.L !== a) {
                    null === a || Array.isArray(a) || xa(a, "Array", Rt, "children:value");
                    if (null !==
                        a) for (var b = a.length, c = 0; c < b; c++) {
                        var d = a[c];
                        F && w(d, Rt, Rt, "children")
                    }
                    this.L = a
                }
            }
        }, level: {
            configurable: !0, get: function () {
                return this.Pa
            }, set: function (a) {
                this.Pa !== a && (A(a, "number", Rt, "level"), this.Pa = a)
            }
        }, descendantCount: {
            configurable: !0, get: function () {
                return this.W
            }, set: function (a) {
                this.W !== a && (A(a, "number", Rt, "descendantCount"), this.W = a)
            }
        }, maxChildrenCount: {
            configurable: !0, get: function () {
                return this.kb
            }, set: function (a) {
                this.kb !== a && (A(a, "number", Rt, "maxChildrenCount"),
                    this.kb = a)
            }
        }, maxGenerationCount: {
            configurable: !0, get: function () {
                return this.Zc
            }, set: function (a) {
                this.Zc !== a && (A(a, "number", Rt, "maxGenerationCount"), this.Zc = a)
            }
        }, comments: {
            configurable: !0, get: function () {
                return this.od
            }, set: function (a) {
                if (this.od !== a) {
                    null === a || Array.isArray(a) || xa(a, "Array", Rt, "comments:value");
                    if (null !== a) for (var b = a.length, c = 0; c < b; c++) {
                        var d = a[c];
                        F && w(d, V, Rt, "comments")
                    }
                    this.od = a
                }
            }
        }, sorting: {
            configurable: !0, get: function () {
                return this.hd
            },
            set: function (a) {
                this.hd !== a && (ib(a, Z, Rt, "sorting"), this.hd = a)
            }
        }, comparer: {
            configurable: !0, get: function () {
                return this.cd
            }, set: function (a) {
                this.cd !== a && (A(a, "function", Rt, "comparer"), this.cd = a)
            }
        }, angle: {
            configurable: !0, get: function () {
                return this.dc
            }, set: function (a) {
                this.dc !== a && (A(a, "number", Rt, "angle"), this.dc = a)
            }
        }, alignment: {
            configurable: !0, get: function () {
                return this.Eb
            }, set: function (a) {
                this.Eb !== a && (ib(a, Z, Rt, "alignment"), this.Eb = a)
            }
        }, nodeIndent: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Ps
            }, set: function (a) {
                this.Ps !== a && (A(a, "number", Rt, "nodeIndent"), this.Ps = a)
            }
        }, nodeIndentPastParent: {
            configurable: !0, get: function () {
                return this.Qs
            }, set: function (a) {
                this.Qs !== a && (A(a, "number", Rt, "nodeIndentPastParent"), this.Qs = a)
            }
        }, nodeSpacing: {
            configurable: !0, get: function () {
                return this.Rs
            }, set: function (a) {
                this.Rs !== a && (A(a, "number", Rt, "nodeSpacing"), this.Rs = a)
            }
        }, layerSpacing: {
            configurable: !0, get: function () {
                return this.Ae
            },
            set: function (a) {
                this.Ae !== a && (A(a, "number", Rt, "layerSpacing"), this.Ae = a)
            }
        }, layerSpacingParentOverlap: {
            configurable: !0, get: function () {
                return this.Fs
            }, set: function (a) {
                this.Fs !== a && (A(a, "number", Rt, "layerSpacingParentOverlap"), this.Fs = a)
            }
        }, compaction: {
            configurable: !0, get: function () {
                return this.Sr
            }, set: function (a) {
                this.Sr !== a && (ib(a, Z, Rt, "compaction"), this.Sr = a)
            }
        }, breadthLimit: {
            configurable: !0, get: function () {
                return this.Kr
            }, set: function (a) {
                this.Kr !== a && (A(a, "number",
                    Rt, "breadthLimit"), this.Kr = a)
            }
        }, rowSpacing: {
            configurable: !0, get: function () {
                return this.dt
            }, set: function (a) {
                this.dt !== a && (A(a, "number", Rt, "rowSpacing"), this.dt = a)
            }
        }, rowIndent: {
            configurable: !0, get: function () {
                return this.ct
            }, set: function (a) {
                this.ct !== a && (A(a, "number", Rt, "rowIndent"), this.ct = a)
            }
        }, commentSpacing: {
            configurable: !0, get: function () {
                return this.Rr
            }, set: function (a) {
                this.Rr !== a && (A(a, "number", Rt, "commentSpacing"), this.Rr = a)
            }
        }, commentMargin: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this.Qr
            }, set: function (a) {
                this.Qr !== a && (A(a, "number", Rt, "commentMargin"), this.Qr = a)
            }
        }, setsPortSpot: {
            configurable: !0, get: function () {
                return this.qt
            }, set: function (a) {
                this.qt !== a && (A(a, "boolean", Rt, "setsPortSpot"), this.qt = a)
            }
        }, portSpot: {
            configurable: !0, get: function () {
                return this.$s
            }, set: function (a) {
                w(a, M, Rt, "portSpot");
                this.$s.A(a) || (this.$s = a)
            }
        }, setsChildPortSpot: {
            configurable: !0, get: function () {
                return this.pt
            }, set: function (a) {
                this.pt !==
                a && (A(a, "boolean", Rt, "setsChildPortSpot"), this.pt = a)
            }
        }, childPortSpot: {
            configurable: !0, get: function () {
                return this.Nr
            }, set: function (a) {
                w(a, M, Rt, "childPortSpot");
                this.Nr.A(a) || (this.Nr = a)
            }
        }, childrenCount: {
            configurable: !0, get: function () {
                return this.children.length
            }
        }, relativePosition: {
            configurable: !0, get: function () {
                return this.V
            }, set: function (a) {
                this.V.set(a)
            }
        }, subtreeSize: {
            configurable: !0, get: function () {
                return this.Ba
            }, set: function (a) {
                this.Ba.set(a)
            }
        },
        subtreeOffset: {
            configurable: !0, get: function () {
                return this.la
            }, set: function (a) {
                this.la.set(a)
            }
        }
    });
    Rt.className = "TreeVertex";

    function Xu(a) {
        Cq.call(this, a);
        this.vv = new J(0, 0)
    }

    ma(Xu, Cq);
    Xu.prototype.commit = function () {
        var a = this.link;
        if (null !== a && !a.isAvoiding) {
            var b = this.network.layout, c = null, d = null;
            switch (b.pd) {
                case Mt:
                    c = this.fromVertex;
                    d = this.toVertex;
                    break;
                case Tt:
                    c = this.toVertex;
                    d = this.fromVertex;
                    break;
                default:
                    v("Unhandled path value " + b.pd.toString())
            }
            if (null !== c && null !== d) if (b = this.vv, 0 !== b.x || 0 !== b.y || c.nB) {
                d = c.bounds;
                var e = uu(c), f = xu(c), g = c.rowSpacing;
                a.Ij();
                var h = a.curve === sg, k = a.isOrthogonal, l;
                a.ci();
                if (k || h) {
                    for (l = 2; 4 < a.pointsCount;) a.Fw(2);
                    var m = a.i(1);
                    var n = a.i(2)
                } else {
                    for (l =
                             1; 3 < a.pointsCount;) a.Fw(1);
                    m = a.i(0);
                    n = a.i(a.pointsCount - 1)
                }
                var p = a.i(a.pointsCount - 1);
                0 === e ? (c.alignment === wu ? (e = d.bottom + b.y, 0 === b.y && m.y > p.y + c.rowIndent && (e = Math.min(e, Math.max(m.y, e - Cu(c))))) : c.alignment === vu ? (e = d.top + b.y, 0 === b.y && m.y < p.y - c.rowIndent && (e = Math.max(e, Math.min(m.y, e + Cu(c))))) : e = c.dn || c.en && 1 === c.maxGenerationCount ? d.top - c.la.y + b.y : d.y + d.height / 2 + b.y, h ? (a.m(l, m.x, e), l++, a.m(l, d.right + f, e), l++, a.m(l, d.right + f + (b.x - g) / 3, e), l++, a.m(l, d.right + f + 2 * (b.x - g) / 3, e), l++, a.m(l, d.right + f + (b.x -
                    g), e), l++, a.m(l, n.x, e)) : (k && (a.m(l, d.right + f / 2, m.y), l++), a.m(l, d.right + f / 2, e), l++, a.m(l, d.right + f + b.x - (k ? g / 2 : g), e), l++, k && a.m(l, a.i(l - 1).x, n.y))) : 90 === e ? (c.alignment === wu ? (e = d.right + b.x, 0 === b.x && m.x > p.x + c.rowIndent && (e = Math.min(e, Math.max(m.x, e - Cu(c))))) : c.alignment === vu ? (e = d.left + b.x, 0 === b.x && m.x < p.x - c.rowIndent && (e = Math.max(e, Math.min(m.x, e + Cu(c))))) : e = c.dn || c.en && 1 === c.maxGenerationCount ? d.left - c.la.x + b.x : d.x + d.width / 2 + b.x, h ? (a.m(l, e, m.y), l++, a.m(l, e, d.bottom + f), l++, a.m(l, e, d.bottom + f + (b.y - g) /
                    3), l++, a.m(l, e, d.bottom + f + 2 * (b.y - g) / 3), l++, a.m(l, e, d.bottom + f + (b.y - g)), l++, a.m(l, e, n.y)) : (k && (a.m(l, m.x, d.bottom + f / 2), l++), a.m(l, e, d.bottom + f / 2), l++, a.m(l, e, d.bottom + f + b.y - (k ? g / 2 : g)), l++, k && a.m(l, n.x, a.i(l - 1).y))) : 180 === e ? (c.alignment === wu ? (e = d.bottom + b.y, 0 === b.y && m.y > p.y + c.rowIndent && (e = Math.min(e, Math.max(m.y, e - Cu(c))))) : c.alignment === vu ? (e = d.top + b.y, 0 === b.y && m.y < p.y - c.rowIndent && (e = Math.max(e, Math.min(m.y, e + Cu(c))))) : e = c.dn || c.en && 1 === c.maxGenerationCount ? d.top - c.la.y + b.y : d.y + d.height / 2 + b.y, h ?
                    (a.m(l, m.x, e), l++, a.m(l, d.left - f, e), l++, a.m(l, d.left - f + (b.x + g) / 3, e), l++, a.m(l, d.left - f + 2 * (b.x + g) / 3, e), l++, a.m(l, d.left - f + (b.x + g), e), l++, a.m(l, n.x, e)) : (k && (a.m(l, d.left - f / 2, m.y), l++), a.m(l, d.left - f / 2, e), l++, a.m(l, d.left - f + b.x + (k ? g / 2 : g), e), l++, k && a.m(l, a.i(l - 1).x, n.y))) : 270 === e ? (c.alignment === wu ? (e = d.right + b.x, 0 === b.x && m.x > p.x + c.rowIndent && (e = Math.min(e, Math.max(m.x, e - Cu(c))))) : c.alignment === vu ? (e = d.left + b.x, 0 === b.x && m.x < p.x - c.rowIndent && (e = Math.max(e, Math.min(m.x, e + Cu(c))))) : e = c.dn || c.en && 1 === c.maxGenerationCount ?
                    d.left - c.la.x + b.x : d.x + d.width / 2 + b.x, h ? (a.m(l, e, m.y), l++, a.m(l, e, d.top - f), l++, a.m(l, e, d.top - f + (b.y + g) / 3), l++, a.m(l, e, d.top - f + 2 * (b.y + g) / 3), l++, a.m(l, e, d.top - f + (b.y + g)), l++, a.m(l, e, n.y)) : (k && (a.m(l, m.x, d.top - f / 2), l++), a.m(l, e, d.top - f / 2), l++, a.m(l, e, d.top - f + b.y + (k ? g / 2 : g)), l++, k && a.m(l, n.x, a.i(l - 1).y))) : v("Invalid angle " + e);
                a.Jf()
            } else b = d, F && w(c, Rt, Xu, "adjustRouteForAngleChange:parent"), F && w(b, Rt, Xu, "adjustRouteForAngleChange:child"), a = this.link, f = uu(c), f !== uu(b) && (g = xu(c), h = c.bounds, c = b.bounds, 0 ===
            f && c.left - h.right < g + 1 || 90 === f && c.top - h.bottom < g + 1 || 180 === f && h.left - c.right < g + 1 || 270 === f && h.top - c.bottom < g + 1 || (a.Ij(), c = a.curve === sg, b = a.isOrthogonal, d = lu(this.fromVertex.alignment), a.ci(), 0 === f ? (f = h.right + g / 2, c ? 4 === a.pointsCount && (c = a.i(3).y, a.O(1, f - 20, a.i(1).y), a.m(2, f - 20, c), a.m(3, f, c), a.m(4, f + 20, c), a.O(5, a.i(5).x, c)) : b ? d ? a.O(3, a.i(2).x, a.i(4).y) : 6 === a.pointsCount && (a.O(2, f, a.i(2).y), a.O(3, f, a.i(3).y)) : 4 === a.pointsCount ? a.m(2, f, a.i(2).y) : 3 === a.pointsCount ? a.O(1, f, a.i(2).y) : 2 === a.pointsCount && a.m(1,
                f, a.i(1).y)) : 90 === f ? (f = h.bottom + g / 2, c ? 4 === a.pointsCount && (c = a.i(3).x, a.O(1, a.i(1).x, f - 20), a.m(2, c, f - 20), a.m(3, c, f), a.m(4, c, f + 20), a.O(5, c, a.i(5).y)) : b ? d ? a.O(3, a.i(2).x, a.i(4).y) : 6 === a.pointsCount && (a.O(2, a.i(2).x, f), a.O(3, a.i(3).x, f)) : 4 === a.pointsCount ? a.m(2, a.i(2).x, f) : 3 === a.pointsCount ? a.O(1, a.i(2).x, f) : 2 === a.pointsCount && a.m(1, a.i(1).x, f)) : 180 === f ? (f = h.left - g / 2, c ? 4 === a.pointsCount && (c = a.i(3).y, a.O(1, f + 20, a.i(1).y), a.m(2, f + 20, c), a.m(3, f, c), a.m(4, f - 20, c), a.O(5, a.i(5).x, c)) : b ? d ? a.O(3, a.i(2).x, a.i(4).y) :
                6 === a.pointsCount && (a.O(2, f, a.i(2).y), a.O(3, f, a.i(3).y)) : 4 === a.pointsCount ? a.m(2, f, a.i(2).y) : 3 === a.pointsCount ? a.O(1, f, a.i(2).y) : 2 === a.pointsCount && a.m(1, f, a.i(1).y)) : 270 === f && (f = h.top - g / 2, c ? 4 === a.pointsCount && (c = a.i(3).x, a.O(1, a.i(1).x, f + 20), a.m(2, c, f + 20), a.m(3, c, f), a.m(4, c, f - 20), a.O(5, c, a.i(5).y)) : b ? d ? a.O(3, a.i(2).x, a.i(4).y) : 6 === a.pointsCount && (a.O(2, a.i(2).x, f), a.O(3, a.i(3).x, f)) : 4 === a.pointsCount ? a.m(2, a.i(2).x, f) : 3 === a.pointsCount ? a.O(1, a.i(2).x, f) : 2 === a.pointsCount && a.m(1, a.i(1).x, f)), a.Jf()))
        }
    };
    na.Object.defineProperties(Xu.prototype, {
        relativePoint: {
            configurable: !0, get: function () {
                return this.vv
            }, set: function (a) {
                this.vv.set(a)
            }
        }
    });
    Xu.className = "TreeEdge";
    Ua.prototype.initializeStandardTools = function () {
        this.eb("Action", new Tg, this.mouseDownTools);
        this.eb("Relinking", new qf, this.mouseDownTools);
        this.eb("LinkReshaping", new qg, this.mouseDownTools);
        this.eb("Rotating", new Rg, this.mouseDownTools);
        this.eb("Resizing", new xg, this.mouseDownTools);
        this.eb("Linking", new jg, this.mouseMoveTools);
        this.eb("Dragging", new jf, this.mouseMoveTools);
        this.eb("DragSelecting", new Wg, this.mouseMoveTools);
        this.eb("Panning", new Xg, this.mouseMoveTools);
        this.eb("ContextMenu", new Zg,
            this.mouseUpTools);
        this.eb("TextEditing", new jh, this.mouseUpTools);
        this.eb("ClickCreating", new Ug, this.mouseUpTools);
        this.eb("ClickSelecting", new Sg, this.mouseUpTools)
    };
    Kn("Horizontal", new Pm);
    Kn("Spot", new Rm);
    Kn("Table", new Vm);
    Kn("Viewbox", new $m);
    Kn("TableRow", new Ym);
    Kn("TableColumn", new Zm);
    Kn("Graduated", new kn);
    Kn("Grid", new an);
    Hi.add("GraphLinksModel", ar);
    Hi.add("TreeModel", or);
    tq(ys, null);
    tq(Os, null);
    var Yu = qa.go, Zu = {
        get licenseKey() {
            return Q.licenseKey
        },
        set licenseKey(a) {
            Q.licenseKey = a
        },
        get version() {
            return Q.version
        },
        Group: Kf,
        EnumValue: E,
        List: H,
        Set: I,
        Map: Db,
        Point: J,
        Size: Hb,
        Rect: L,
        Margin: jc,
        Spot: M,
        Geometry: Hd,
        PathFigure: xe,
        PathSegment: ye,
        InputEvent: Ae,
        DiagramEvent: Ce,
        ChangedEvent: Ke,
        Model: X,
        GraphLinksModel: Mr,
        TreeModel: Rr,
        Binding: Ti,
        Transaction: Pe,
        UndoManager: Qe,
        CommandHandler: il,
        Tool: Se,
        DraggingTool: jf,
        DraggingInfo: rf,
        DraggingOptions: kf,
        LinkingBaseTool: Yf,
        LinkingTool: jg,
        RelinkingTool: qf,
        LinkReshapingTool: qg,
        ResizingTool: xg,
        RotatingTool: Rg,
        ClickSelectingTool: Sg,
        ActionTool: Tg,
        ClickCreatingTool: Ug,
        HTMLInfo: gf,
        ContextMenuTool: Zg,
        DragSelectingTool: Wg,
        PanningTool: Xg,
        TextEditingTool: jh,
        ToolManager: Ua,
        Animation: Fh,
        AnimationManager: Bh,
        AnimationTrigger: si,
        Layer: xi,
        Diagram: Q,
        Palette: bl,
        Overview: el,
        Brush: Ll,
        GraphObject: N,
        Panel: W,
        RowColumnDefinition: ik,
        Shape: Zf,
        TextBlock: kh,
        TextBlockMetrics: Co,
        Picture: ok,
        Part: T,
        Adornment: Xe,
        Node: V,
        Link: S,
        Placeholder: Mg,
        Layout: Ni,
        LayoutNetwork: nq,
        LayoutVertex: Bq,
        LayoutEdge: Cq,
        GridLayout: dl,
        PanelLayout: em,
        CircularLayout: Sr,
        CircularNetwork: is,
        CircularVertex: ws,
        CircularEdge: xs,
        ForceDirectedLayout: ys,
        ForceDirectedNetwork: zs,
        ForceDirectedVertex: Js,
        ForceDirectedEdge: Ns,
        LayeredDigraphLayout: Os,
        LayeredDigraphNetwork: Ts,
        LayeredDigraphVertex: Jt,
        LayeredDigraphEdge: Kt,
        TreeLayout: Z,
        TreeNetwork: Qt,
        TreeVertex: Rt,
        TreeEdge: Xu
    };
    "object" === typeof Yu && Yu.version && v("WARNING: a `go` object on the root object is already defined.  " + ("Debug" in Yu ? "debug " : "") + "version: " + Yu.version + ", replaced with version: " + Zu.version);
    Q.prototype.go = Zu;
    qa.go = Zu;
    ("undefined" === typeof qa || "undefined" === typeof qa.module || "object" !== typeof qa.module.exports) && qa.define && "function" === typeof qa.define && qa.define.amd && qa.define(Zu);
    Zu.Debug = F;
    F.Lz(Zu);
    'undefined' !== typeof module && 'object' === typeof module.exports && (module.exports = 'undefined' !== typeof global ? global.go : self.go);
})();
